<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/trigger.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * trigger.c
 *	  PostgreSQL TRIGGERs support code.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/commands/trigger.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplestore.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>SessionReplicationRole</name> <init>= <expr><name>SESSION_REPLICATION_ROLE_ORIGIN</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* How many levels deep into trigger execution are we? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>MyTriggerDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetTriggerFlags</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>, <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetTupleForTrigger</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
							   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
							   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
							   <parameter><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>newSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TriggerEnabled</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
						   <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>TriggerEvent</name></type> <name>event</name></decl></parameter>,
						   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>ExecCallTriggerFunc</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>tgindx</name></decl></parameter>,
									 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>,
									 <parameter><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>,
									 <parameter><decl><type><name>MemoryContext</name></type> <name>per_tuple_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AfterTriggerSaveEvent</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>row_trigger</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldtup</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newtup</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
								  <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AfterTriggerEnlargeQueryState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>before_stmt_triggers_fired</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Create a trigger.  Returns the address of the created trigger.
 *
 * queryString is the source text of the CREATE TRIGGER command.
 * This must be supplied if a whenClause is specified, else it can be NULL.
 *
 * relOid, if nonzero, is the relation on which the trigger should be
 * created.  If zero, the name provided in the statement will be looked up.
 *
 * refRelOid, if nonzero, is the relation to which the constraint trigger
 * refers.  If zero, the constraint relation name provided in the statement
 * will be looked up as needed.
 *
 * constraintOid, if nonzero, says that this trigger is being created
 * internally to implement that constraint.  A suitable pg_depend entry will
 * be made to link the trigger to that constraint.  constraintOid is zero when
 * executing a user-entered CREATE TRIGGER command.  (For CREATE CONSTRAINT
 * TRIGGER, we build a pg_constraint entry internally.)
 *
 * indexOid, if nonzero, is the OID of an index associated with the constraint.
 * We do nothing with this except store it into pg_trigger.tgconstrindid;
 * but when creating a trigger for a deferrable unique constraint on a
 * partitioned table, its children are looked up.  Note we don't cope with
 * invalid indexes in that case.
 *
 * funcoid, if nonzero, is the OID of the function to invoke.  When this is
 * given, stmt-&gt;funcname is ignored.
 *
 * parentTriggerOid, if nonzero, is a trigger that begets this one; so that
 * if that trigger is dropped, this one should be too.  (This is passed as
 * Invalid by most callers; it's set here when recursing on a partition.)
 *
 * If whenClause is passed, it is an already-transformed expression for
 * WHEN.  In this case, we ignore any that may come in stmt-&gt;whenClause.
 *
 * If isInternal is true then this is an internally-generated trigger.
 * This argument sets the tgisinternal field of the pg_trigger entry, and
 * if true causes us to modify the given trigger name to ensure uniqueness.
 *
 * When isInternal is not true we require ACL_TRIGGER permissions on the
 * relation, as well as ACL_EXECUTE on the trigger function.  For internal
 * triggers the caller must apply any required permission checks.
 *
 * When called on partitioned tables, this function recurses to create the
 * trigger on all the partitions, except if isInternal is true, in which
 * case caller is expected to execute recursion on its own.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateTrigger</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>,
			  <parameter><decl><type><name>Oid</name></type> <name>funcoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentTriggerOid</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>whenClause</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>isInternal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return
		<expr><call><name>CreateTriggerFiringOn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>,
							  <argument><expr><name>constraintOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>,
							  <argument><expr><name>parentTriggerOid</name></expr></argument>, <argument><expr><name>whenClause</name></expr></argument>, <argument><expr><name>isInternal</name></expr></argument>,
							  <argument><expr><name>in_partition</name></expr></argument>, <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like the above; additionally the firing condition
 * (always/origin/replica/disabled) can be specified.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateTriggerFiringOn</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentTriggerOid</name></decl></parameter>,
					  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>whenClause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInternal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_partition</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>trigger_fires_when</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>tgtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>tgattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>whenRtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trigoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>internaltrigname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trigname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constrrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldtablename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newtablename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partition_recurse</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relid_laboid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create trigger on graph label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * Triggers must be on tables or views, and there are additional
	 * relation-type-specific restrictions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tables can't have INSTEAD OF triggers */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_BEFORE</name> <operator>&amp;&amp;</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Tables cannot have INSTEAD OF triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Partitioned tables can't have INSTEAD OF triggers */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_BEFORE</name> <operator>&amp;&amp;</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Tables cannot have INSTEAD OF triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * FOR EACH ROW triggers have further restrictions
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Disallow use of transition tables.
			 *
			 * Note that we have another restriction about transition tables
			 * in partitions; search for 'has_superclass' below for an
			 * explanation.  The check here is just to protect from the fact
			 * that if we allowed it here, the creation would succeed for a
			 * partitioned table with no partitions, but would be blocked by
			 * the other restriction when the first partition was created,
			 * which is very unfriendly behavior.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a partitioned table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Triggers on partitioned tables cannot have transition tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Views can have INSTEAD OF triggers (which we check below are
		 * row-level), or statement-level BEFORE/AFTER triggers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_INSTEAD</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>row</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a view"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Views cannot have row-level BEFORE or AFTER triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Disallow TRUNCATE triggers on VIEWs */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a view"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Views cannot have TRUNCATE triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_BEFORE</name> <operator>&amp;&amp;</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Foreign tables cannot have INSTEAD OF triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Foreign tables cannot have TRUNCATE triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We disallow constraint triggers to protect the assumption that
		 * triggers on FKs can't be deferred.  See notes with AfterTriggers
		 * data structures, below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Foreign tables cannot have constraint triggers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We must take a lock on the target relation to protect against
		 * concurrent drop.  It's not clear that AccessShareLock is strong
		 * enough, but we certainly need at least that much... otherwise, we
		 * might end up creating a pg_constraint entry referencing a
		 * nonexistent table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>refRelOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>constrrelid</name> <operator>=</operator> <name>refRelOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>constrrelid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constrrel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* permission checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInternal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										  <argument><expr><name>ACL_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When called on a partitioned table to create a FOR EACH ROW trigger
	 * that's not internal, we create one trigger for each partition, too.
	 *
	 * For that, we'd better hold lock on all of them ahead of time.
	 */</comment>
	<expr_stmt><expr><name>partition_recurse</name> <operator>=</operator> <operator>!</operator><name>isInternal</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>row</name></name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>partition_recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Compute tgtype */</comment>
	<expr_stmt><expr><call><name>TRIGGER_CLEAR_TYPE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>row</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TRIGGER_SETT_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tgtype</name> <operator>|=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tgtype</name> <operator>|=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>

	<comment type="block">/* Disallow ROW-level TRUNCATE triggers */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TRUNCATE FOR EACH ROW triggers are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* INSTEAD triggers must be row-level, and can't have WHEN or columns */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSTEAD OF triggers must be FOR EACH ROW"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whenClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSTEAD OF triggers cannot have WHEN conditions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>columns</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSTEAD OF triggers cannot have column lists"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relid_laboid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create trigger on graph label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't yet support naming ROW transition variables, but the parser
	 * recognizes the syntax so we can give a nicer message here.
	 *
	 * Per standard, REFERENCING TABLE names are only allowed on AFTER
	 * triggers.  Per standard, REFERENCING ROW names are not allowed with FOR
	 * EACH STATEMENT.  Per standard, each OLD/NEW, ROW/TABLE permutation is
	 * only allowed once.  Per standard, OLD may not be specified when
	 * creating a trigger only for INSERT, and NEW may not be specified when
	 * creating a trigger only for DELETE.
	 *
	 * Notice that the standard allows an AFTER ... FOR EACH ROW trigger to
	 * reference both ROW and TABLE transition data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varList</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>transitionRels</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>varList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TriggerTransition</name> <modifier>*</modifier></type><name>tt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TriggerTransition</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tt</name><operator>-&gt;</operator><name>isTable</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROW variable naming in the REFERENCING clause is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use OLD TABLE or NEW TABLE for naming transition tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Because of the above test, we omit further ROW-related testing
			 * below.  If we later allow naming OLD and NEW ROW variables,
			 * adjustments will be needed below.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a foreign table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Triggers on foreign tables cannot have transition tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a view"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Triggers on views cannot have transition tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We currently don't allow row-level triggers with transition
			 * tables on partition or inheritance children.  Such triggers
			 * would somehow need to see tuples converted to the format of the
			 * table they're attached to, and it's not clear which subset of
			 * tuples each child should see.  See also the prohibitions in
			 * ATExecAttachPartition() and ATExecAddInherit().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>has_superclass</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Use appropriate error message. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported on inheritance children"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>!=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transition table name can only be specified for an AFTER trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TRUNCATE triggers with transition tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We currently don't allow multi-event triggers ("INSERT OR
			 * UPDATE") with transition tables, because it's not clear how to
			 * handle INSERT ... ON CONFLICT statements which can fire both
			 * INSERT and UPDATE triggers.  We show the inserted tuples to
			 * INSERT triggers and the updated tuples to UPDATE triggers, but
			 * it's not yet clear what INSERT OR UPDATE trigger should see.
			 * This restriction could be lifted if we can decide on the right
			 * semantics in a later release.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><ternary><condition><expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
				 <operator>(</operator><ternary><condition><expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
				 <operator>(</operator><ternary><condition><expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transition tables cannot be specified for triggers with more than one event"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We currently don't allow column-specific triggers with
			 * transition tables.  Per spec, that seems to require
			 * accumulating separate transition tables for each combination of
			 * columns, which is a lot of work for a rather marginal feature.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>columns</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transition tables cannot be specified for triggers with column lists"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We disallow constraint triggers with transition tables, to
			 * protect the assumption that such triggers can't be deferred.
			 * See notes with AfterTriggers data structures, below.
			 *
			 * Currently this is enforced by the grammar, so just Assert here.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tt</name><operator>-&gt;</operator><name>isNew</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NEW TABLE can only be specified for an INSERT or UPDATE trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>newtablename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NEW TABLE cannot be specified multiple times"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>newtablename</name> <operator>=</operator> <name><name>tt</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OLD TABLE can only be specified for a DELETE or UPDATE trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldtablename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OLD TABLE cannot be specified multiple times"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>oldtablename</name> <operator>=</operator> <name><name>tt</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>newtablename</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>oldtablename</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>newtablename</name></expr></argument>, <argument><expr><name>oldtablename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OLD TABLE name and NEW TABLE name cannot be the same"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse the WHEN clause, if any and we weren't passed an already
	 * transformed one.
	 *
	 * Note that as a side effect, we fill whenRtable when parsing.  If we got
	 * an already parsed clause, this does not occur, which is what we want --
	 * no point in adding redundant dependencies below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>whenClause</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>whenClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Set up a pstate to parse with */</comment>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up nsitems for OLD and NEW references.
		 *
		 * 'OLD' must always have varno equal to 1 and 'NEW' equal to 2.
		 */</comment>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>,
											   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>,
											   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Transform expression.  Copy to be sure we don't modify original */</comment>
		<expr_stmt><expr><name>whenClause</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whenClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr></argument>,
										  <argument><expr><literal type="string">"WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we have to fix its collations too */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for disallowed references to OLD/NEW.
		 *
		 * NB: pull_var_clause is okay here only because we don't allow
		 * subselects in WHEN clauses; it would fail to examine the contents
		 * of subselects.
		 */</comment>
		<expr_stmt><expr><name>varList</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>varList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PRS2_OLD_VARNO</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement trigger's WHEN condition cannot reference column values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT trigger's WHEN condition cannot reference OLD values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* system columns are okay here */</comment>
					<break>break;</break>
				<case>case <expr><name>PRS2_NEW_VARNO</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement trigger's WHEN condition cannot reference column values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DELETE trigger's WHEN condition cannot reference NEW values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE trigger's WHEN condition cannot reference NEW system columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constr</name> <operator>&amp;&amp;</operator>
						<call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE trigger's WHEN condition cannot reference NEW generated columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A whole-row reference is used and the table contains generated columns."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE trigger's WHEN condition cannot reference NEW generated columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is a generated column."</literal></expr></argument>,
										   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* can't happen without add_missing_from, so just elog */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger WHEN condition cannot contain references to other relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>

		<comment type="block">/* we'll need the rtable for recordDependencyOnExpr */</comment>
		<expr_stmt><expr><name>whenRtable</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>whenClause</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>whenClause</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>whenRtable</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>whenRtable</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Find and validate the trigger function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcoid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInternal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
						   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>funcrettype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcrettype</name> <operator>!=</operator> <name>TRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a user-entered CREATE CONSTRAINT TRIGGER command, make a
	 * corresponding pg_constraint entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Internal callers should have made their own constraints */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isInternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>,
											  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>CONSTRAINT_TRIGGER</name></expr></argument>,
											  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
											  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent */</comment>
											  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no conkey */</comment>
											  <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no domain */</comment>
											  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no index */</comment>
											  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no foreign key */</comment>
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><literal type="char">' '</literal></expr></argument>,
											  <argument><expr><literal type="char">' '</literal></expr></argument>,
											  <argument><expr><literal type="char">' '</literal></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no exclusion */</comment>
											  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no check constraint */</comment>
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* islocal */</comment>
											  <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* inhcount */</comment>
											  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* noinherit */</comment>
											  <argument><expr><name>isInternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Generate the trigger's OID now, so that we can use it in the name if
	 * needed.
	 */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trigoid</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>,
								 <argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If trigger is internally generated, modify the provided trigger name to
	 * ensure uniqueness by appending the trigger OID.  (Callers will usually
	 * supply a simple constant trigger name in these cases.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isInternal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>internaltrigname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>internaltrigname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%s_%u"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>trigname</name> <operator>=</operator> <name>internaltrigname</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* user-defined trigger; use the specified trigger name as-is */</comment>
		<expr_stmt><expr><name>trigname</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Scan pg_trigger for existing triggers on relation.  We do this only to
	 * give a nice error message if there's already a trigger of the same
	 * name.  (The unique index on tgrelid/tgname would complain anyway.) We
	 * can skip this for internally generated triggers, since the name
	 * modification above should be sufficient.
	 *
	 * NOTE that this is cool only because we have ShareRowExclusiveLock on
	 * the relation, so the trigger set won't be changing underneath us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInternal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>pg_trigger</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pg_trigger</name><operator>-&gt;</operator><name>tgname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>trigname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
								<argument><expr><name>trigname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the new pg_trigger tuple.
	 *
	 * When we're creating a trigger in a partition, we mark it as internal,
	 * even though we don't do the isInternal magic in this function.  This
	 * makes the triggers in partitions identical to the ones in the
	 * partitioned tables, except that they are marked internal.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgparentid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentTriggerOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
															 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgfoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgtype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>trigger_fires_when</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgisinternal</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isInternal</name> <operator>||</operator> <name>in_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgconstrrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgconstrindid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgconstraint</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgdeferrable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tginitdeferred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ar</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>ar</name></expr>;</condition> <incr><expr><name>ar</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ar</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>d</name> <init>= <expr><name>args</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="string">"\\000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgnargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>byteain</name></expr></argument>,
																 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgnargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>byteain</name></expr></argument>,
																 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* build column number array if it's a column-specific trigger */</comment>
	<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ncolumns</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>columns</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>columns</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;columns</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<comment type="block">/* Lookup column name.  System columns are not allowed */</comment>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Check for duplicates */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>columns</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name><name>columns</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>tgattr</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgattr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tgattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set tgqual if trigger has WHEN clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_trigger_tgqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldtablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgoldtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
																	 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>oldtablename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_trigger_tgoldtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newtablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgnewtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
																	 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>newtablename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_trigger_tgnewtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert tuple into pg_trigger.
	 */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgattr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldtablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgoldtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newtablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_trigger_tgnewtable</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update relation's pg_class entry; if necessary; and if not, send an SI
	 * message to make other backends (and this one) rebuild relcache entries.
	 */</comment>
	<expr_stmt><expr><name>pgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relhastriggers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relhastriggers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record dependencies for trigger.  Always place a normal dependency on
	 * the function.
	 */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TriggerRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>trigoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>funcoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isInternal</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Internally-generated trigger for a constraint, so make it an
		 * internal dependency of the constraint.  We can skip depending on
		 * the relation(s), as there'll be an indirect dependency via the
		 * constraint.
		 */</comment>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>constraintOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * User CREATE TRIGGER, so place dependencies.  We make trigger be
		 * auto-dropped if its relation is dropped or if the FK relation is
		 * dropped.  (Auto drop is compatible with our pre-7.3 behavior.)
		 */</comment>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constrrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>constrrelid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Not possible to have an index dependency in this case */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a user-specified constraint trigger, make the constraint
		 * internally dependent on the trigger instead of vice versa.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>constraintOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's a partition trigger, create the partition dependencies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentTriggerOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>parentTriggerOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_PRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If column-specific trigger, add normal dependencies on columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>columns</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it has a WHEN clause, add dependencies on objects mentioned in the
	 * expression (eg, functions, as well as any columns used).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whenRtable</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>whenClause</name></expr></argument>, <argument><expr><name>whenRtable</name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Post creation hook for new trigger */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHookArg</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>isInternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lastly, create the trigger on child relations, if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partition_recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childTbls</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>,
					<decl><type ref="prev"/><name>perChildCxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>perChildCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"part trig clone"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When a trigger is being created associated with an index, we'll
		 * need to associate the trigger in each child partition with the
		 * corresponding index on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>idxs</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>idxs</argument>)</argument_list></macro>
				<expr_stmt><expr><name>childTbls</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>childTbls</name></expr></argument>,
										<argument><expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perChildCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Iterate to create the trigger on each existing partition */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOnChild</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>childStmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childTbl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childTbl</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find which of the child indexes is the one on this partition */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>idxs</argument>, <argument>l2</argument>, <argument>childTbls</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexOnChild</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOnChild</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find index matching index \"%s\" in partition \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Initialize our fabricated parse node by copying the original
			 * one, then resetting fields that we pass separately.
			 */</comment>
			<expr_stmt><expr><name>childStmt</name> <operator>=</operator> <operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>childStmt</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* If there is a WHEN clause, create a modified copy of it */</comment>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>,
										<argument><expr><name>childTbl</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>,
										<argument><expr><name>childTbl</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CreateTriggerFiringOn</name><argument_list>(<argument><expr><name>childStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								  <argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexOnChild</name></expr></argument>,
								  <argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
								  <argument><expr><name>isInternal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>trigger_fires_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childTbl</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>perChildCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>perChildCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>idxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>childTbls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Keep lock on target rel until end of xact */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Guts of trigger deletion.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveTriggerById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the trigger to delete.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for trigger %u"</literal></expr></argument>, <argument><expr><name>trigOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Open and exclusive-lock the relation the trigger belongs to.
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tgrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Delete the pg_trigger tuple.
	 */</comment>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do not bother to try to determine whether any other triggers remain,
	 * which would be needed in order to decide whether it's safe to clear the
	 * relation's relhastriggers.  (In any case, there might be a concurrent
	 * process adding new triggers.)  Instead, just force a relcache inval to
	 * make other backends (and this one too!) rebuild their relcache entries.
	 * There's no great harm in leaving relhastriggers true even if there are
	 * no triggers left.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep lock on trigger's rel until end of xact */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_trigger_oid - Look up a trigger by name to find its OID.
 *
 * If missing_ok is false, throw an error if trigger not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_trigger_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find the trigger, verify permissions, set up object address
	 */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>trigname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform permissions and integrity checks before acquiring a relation lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForRenameTrigger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only tables and views can have triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, or foreign table"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* you must own the table to rename one of its triggers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renametrig		- changes the name of a trigger on a relation
 *
 *		trigger name is changed in trigger catalog.
 *		No record of the previous name is kept.
 *
 *		get proper relrelation from relation catalog (if not arg)
 *		scan trigger catalog
 *				for name conflict (within rel)
 *				for original trigger (if not arg)
 *		modify tgname in trigger tuple
 *		update row in catalog
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>renametrig</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tgoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up name, check permissions, and acquire lock (which we will NOT
	 * release until end of transaction).
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForRenameTrigger</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Have lock already, so just need to build relcache entry. */</comment>
	<expr_stmt><expr><name>targetrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_trigger twice for existing triggers on relation.  We do this in
	 * order to ensure a trigger does not exist with newname (The unique index
	 * on tgrelid/tgname would complain anyway) and to ensure a trigger does
	 * exist with oldname.
	 *
	 * NOTE that this is cool only because we have AccessExclusiveLock on the
	 * relation, so the trigger set won't be changing underneath us.
	 */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First pass -- look for name conflict
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Second pass -- look for trigger existing with oldname and update
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trigform</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Update pg_trigger tuple with new tgname.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* need a modifiable copy */</comment>
		<expr_stmt><expr><name>trigform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tgoid</name> <operator>=</operator> <name><name>trigform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trigform</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>,
				   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
								  <argument><expr><name>tgoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate relation's relcache entry so that other backends (and
		 * this one too!) are sent SI message to make them rebuild relcache
		 * entries.  (Ideally this should happen automatically...)
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>tgoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close rel, but keep exclusive lock!
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnableDisableTrigger()
 *
 *	Called by ALTER TABLE ENABLE/DISABLE [ REPLICA | ALWAYS ] TRIGGER
 *	to change 'tgenabled' field for the specified trigger(s)
 *
 * rel: relation to process (caller must hold suitable lock on it)
 * tgname: trigger to process, or NULL to scan all triggers
 * fires_when: new value for tgenabled field. In addition to generic
 *			   enablement/disablement, this also defines when the trigger
 *			   should be fired in session replication roles.
 * skip_system: if true, skip "system" triggers (constraint triggers)
 * recurse: if true, recurse to partitions
 *
 * Caller should have checked permissions for the table; here we also
 * enforce that superuser privilege is required to alter the state of
 * system triggers
 */</comment>
<function><type><name>void</name></type>
<name>EnableDisableTriggerNew</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgname</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
						<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name></decl>;</decl_stmt>

	<comment type="block">/* Scan the relevant entries in pg_triggers */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tgname</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_trigger_tgname</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
					<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>tgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>oldtrig</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oldtrig</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* system trigger ... ok to process? */</comment>
			<if_stmt><if>if <condition>(<expr><name>skip_system</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system trigger"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oldtrig</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oldtrig</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <name>fires_when</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* need to change this one ... make a copy to scribble on */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>newtrig</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newtrig</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>=</operator> <name>fires_when</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * When altering FOR EACH ROW triggers on a partitioned table, do the
		 * same on the partitions as well, unless ONLY is specified.
		 *
		 * Note that we recurse even if we didn't change the trigger above,
		 * because the partitions' copy of the trigger may have a different
		 * value of tgenabled than the parent's trigger and thus might need to
		 * be changed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>oldtrig</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>part</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>part</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EnableDisableTriggerNew</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oldtrig</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>fires_when</name></expr></argument>, <argument><expr><name>skip_system</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>,
										<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
								  <argument><expr><name><name>oldtrig</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tgname</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>tgname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we changed anything, broadcast a SI inval message to force each
	 * backend (including our own!) to rebuild relation's relcache entry.
	 * Otherwise they will fail to apply the change promptly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ABI-compatible wrapper for the above.  To keep as close possible to the old
 * behavior, this never recurses.  Do not call this function in new code.
 */</comment>
<function><type><name>void</name></type>
<name>EnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgname</name></decl></parameter>,
					 <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>,
					 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnableDisableTriggerNew</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tgname</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>, <argument><expr><name>skip_system</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Build trigger data to attach to the given relcache entry.
 *
 * Note that trigger data attached to a relcache entry must be stored in
 * CacheMemoryContext to ensure it survives as long as the relcache entry.
 * But we should be running in a less long-lived working context.  To avoid
 * leaking cache memory if this routine fails partway through, we build a
 * temporary TriggerDesc in working memory and then copy the completed
 * structure into cache memory.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numtrigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxtrigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>triggers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate a working array to hold the triggers (the array is extended if
	 * necessary)
	 */</comment>
	<expr_stmt><expr><name>maxtrigs</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>triggers</name> <operator>=</operator> <operator>(</operator><name>Trigger</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxtrigs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numtrigs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: since we scan the triggers using TriggerRelidNameIndexId, we will
	 * be reading the triggers in name order, except possibly during
	 * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn
	 * ensures that triggers will be fired in name order.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>pg_trigger</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>build</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>numtrigs</name> <operator>&gt;=</operator> <name>maxtrigs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxtrigs</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>triggers</name> <operator>=</operator> <operator>(</operator><name>Trigger</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>triggers</name></expr></argument>, <argument><expr><name>maxtrigs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>build</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>triggers</name><index>[<expr><name>numtrigs</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgoid</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgname</name></name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nameout</name></expr></argument>,
															<argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgfoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgenabled</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgisinternal</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgisclone</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pg_trigger</name><operator>-&gt;</operator><name>tgparentid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgconstrrelid</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgconstrindid</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgconstrindid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgconstraint</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgdeferrable</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tginitdeferred</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</expr_stmt>
		<comment type="block">/* tgattr is first var-width field, so OK to access directly */</comment>
		<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>=</operator> <name><name>pg_trigger</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>build</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgattr</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>build</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>build</name><operator>-&gt;</operator><name>tgattr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pg_trigger</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>values</name></name><operator>)</operator></expr></argument>,
				   <argument><expr><name><name>build</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgattr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>build</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
											  <argument><expr><name>Anum_pg_trigger_tgargs</name></expr></argument>,
											  <argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tgargs is null in trigger for relation \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgargs</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>build</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>build</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgoldtable</name></expr></argument>,
							<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>=</operator>
				<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nameout</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgnewtable</name></expr></argument>,
							<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>=</operator>
				<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nameout</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgqual</name></expr></argument>,
							<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>build</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>numtrigs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There might not be any triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name>numtrigs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>triggers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build trigdesc */</comment>
	<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <operator>(</operator><name>TriggerDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TriggerDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name></name> <operator>=</operator> <name>triggers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>=</operator> <name>numtrigs</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numtrigs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetTriggerFlags</name><argument_list>(<argument><expr><name>trigdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Copy completed trigdesc into cache storage */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>=</operator> <call><name>CopyTriggerDesc</name><argument_list>(<argument><expr><name>trigdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release working memory */</comment>
	<expr_stmt><expr><call><name>FreeTriggerDesc</name><argument_list>(<argument><expr><name>trigdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the TriggerDesc's hint flags to include the specified trigger
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetTriggerFlags</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>, <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>tgtype</name> <init>= <expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_before_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* there are no row-level truncate triggers */</comment>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_truncate_before_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_truncate_after_statement</name></name> <operator>|=</operator>
		<call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
							 <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name> <operator>|=</operator>
		<operator>(</operator><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <call><name>TRIGGER_USES_TRANSITION_TABLE</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_old_table</name></name> <operator>|=</operator>
		<operator>(</operator><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <call><name>TRIGGER_USES_TRANSITION_TABLE</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_new_table</name></name> <operator>|=</operator>
		<operator>(</operator><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <call><name>TRIGGER_USES_TRANSITION_TABLE</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_old_table</name></name> <operator>|=</operator>
		<operator>(</operator><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <call><name>TRIGGER_USES_TRANSITION_TABLE</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy a TriggerDesc data structure.
 *
 * The copy is allocated in the current memory context.
 */</comment>
<function><type><name>TriggerDesc</name> <modifier>*</modifier></type>
<name>CopyTriggerDesc</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>newdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newdesc</name> <operator>=</operator> <operator>(</operator><name>TriggerDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TriggerDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newdesc</name></expr></argument>, <argument><expr><name>trigdesc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TriggerDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trigger</name> <operator>=</operator> <operator>(</operator><name>Trigger</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name></name></expr></argument>,
		   <argument><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newdesc</name><operator>-&gt;</operator><name>triggers</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>newattr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newattr</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newattr</name></expr></argument>, <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgattr</name></name></expr></argument>,
				   <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgattr</name></name> <operator>=</operator> <name>newattr</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>j</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newargs</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newargs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>trigger</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>newdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a TriggerDesc data structure.
 */</comment>
<function><type><name>void</name></type>
<name>FreeTriggerDesc</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>trigger</name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>--</operator><operator>(</operator><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>trigger</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trigdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two TriggerDesc structures for logical equality.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>equalTriggerDescs</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc1</name></decl></parameter>, <parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need not examine the hint flags, just the trigger array itself; if
	 * we have the same triggers with the same types, the flags should match.
	 *
	 * As of 7.3 we assume trigger set ordering is significant in the
	 * comparison; so we just compare corresponding slots of the two sets.
	 *
	 * Note: comparing the stringToNode forms of the WHEN clauses means that
	 * parse column locations will affect the result.  This is okay as long as
	 * this function is only used for detecting exact equality, as for example
	 * in checking for staleness of a cache entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>trigdesc1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>trigdesc2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigdesc1</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>!=</operator> <name><name>trigdesc2</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc1</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trig1</name> <init>= <expr><name><name>trigdesc1</name><operator>-&gt;</operator><name>triggers</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trig2</name> <init>= <expr><name><name>trigdesc2</name><operator>-&gt;</operator><name>triggers</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgoid</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgoid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgfoid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgtype</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgenabled</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgisinternal</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgisclone</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgisclone</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgconstrrelid</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgconstrindid</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgconstrindid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgconstraint</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgdeferrable</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tginitdeferred</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>!=</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgnattr</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>memcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgattr</name></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgattr</name></name></expr></argument>,
					   <argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>trig1</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgqual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgqual</name></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgqual</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>trig2</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>trig1</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>, <argument><expr><name><name>trig2</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>trigdesc2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* NOT_USED */</comment>

<comment type="block">/*
 * Check if there is a row-level trigger with transition tables that prevents
 * a table from becoming an inheritance child or partition.  Return the name
 * of the first such incompatible trigger, or NULL if there is none.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>FindTriggerIncompatibleWithInheritance</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call a trigger function.
 *
 *		trigdata: trigger descriptor.
 *		tgindx: trigger's index in finfo and instr arrays.
 *		finfo: array of cached trigger function call information.
 *		instr: optional array of EXPLAIN ANALYZE instrumentation state.
 *		per_tuple_context: memory context to execute the function in.
 *
 * Returns the tuple (or NULL) as returned by the function.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>ExecCallTriggerFunc</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>tgindx</name></decl></parameter>,
					<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>,
					<parameter><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>per_tuple_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Protect against code paths that may fail to initialize transition table
	 * info.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_DEFERRABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_INITDEFERRED</name><operator>)</operator><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>trigdata</name><operator>-&gt;</operator><name>tg_oldtable</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtable</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>finfo</name> <operator>+=</operator> <name>tgindx</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cache fmgr lookup info, to avoid making the lookup again on each
	 * call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>==</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If doing EXPLAIN ANALYZE, start charging time to this trigger.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name>instr</name> <operator>+</operator> <name>tgindx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do the function evaluation in the per-tuple memory context, so that
	 * leaked memory will be reclaimed once per tuple. Note in particular that
	 * any new tuple created by the trigger function will live till the end of
	 * the tuple cycle.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_tuple_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the function, passing no arguments but setting a context.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>trigdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyTriggerDepth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>MyTriggerDepth</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Trigger protocol allows function to return a null pointer, but NOT to
	 * set the isnull result flag.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger function %u returned null value"</literal></expr></argument>,
						<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
	 * one "tuple returned" (really the number of firings).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name>instr</name> <operator>+</operator> <name>tgindx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecBSInsertTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_before_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no-op if we already fired BS triggers in this context */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>before_stmt_triggers_fired</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE STATEMENT trigger cannot return a value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecASInsertTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_INSERT</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecBRInsertTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>oldtuple</name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* "do nothing" */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>oldtuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * After a tuple in a partition goes through a trigger, the user
			 * could have changed the partition key enough that the tuple no
			 * longer fits the partition.  Verify that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgisclone</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Before executing trigger \"%s\", the row was to be in partition \"%s.%s\"."</literal></expr></argument>,
								   <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>,
								   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* signal tuple should be re-fetched if used */</comment>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecARInsertTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>transition_capture</name> <operator>&amp;&amp;</operator> <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_insert_new_table</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_INSERT</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
							  <argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecIRInsertTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_INSTEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>oldtuple</name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* "do nothing" */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>oldtuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* signal tuple should be re-fetched if used */</comment>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecBSDeleteTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no-op if we already fired BS triggers in this context */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>before_stmt_triggers_fired</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>CMD_DELETE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE STATEMENT trigger cannot return a value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecASDeleteTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_DELETE</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute BEFORE ROW DELETE triggers.
 *
 * True indicates caller can proceed with the delete.  False indicates caller
 * need to suppress the delete and additionally if requested, we need to pass
 * back the concurrently updated tuple if any.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecBRDeleteTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
					 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>fdw_trigtuple</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trigtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fdw_trigtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot_candidate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTupleForTrigger</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
								<argument><expr><name>LockTupleExclusive</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqslot_candidate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the tuple was concurrently updated and the caller of this
		 * function requested for the updated tuple, skip the trigger
		 * execution.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>epqslot_candidate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>epqslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>epqslot</name> <operator>=</operator> <name>epqslot_candidate</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>trigtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>trigtuple</name> <operator>=</operator> <name>fdw_trigtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>trigtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* tell caller to suppress delete */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>trigtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecARDeleteTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>fdw_trigtuple</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>transition_capture</name> <operator>&amp;&amp;</operator> <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_delete_old_table</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fdw_trigtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GetTupleForTrigger</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>relinfo</name></expr></argument>,
							   <argument><expr><name>tupleid</name></expr></argument>,
							   <argument><expr><name>LockTupleExclusive</name></expr></argument>,
							   <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_DELETE</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecIRDeleteTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>trigtuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_INSTEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rettuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_DELETE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>trigtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rettuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Delete was suppressed */</comment>
		<if_stmt><if>if <condition>(<expr><name>rettuple</name> <operator>!=</operator> <name>trigtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecBSUpdateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no-op if we already fired BS triggers in this context */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>before_stmt_triggers_fired</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* statement-level triggers operate on the parent table */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>ExecGetAllUpdatedCols</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_updatedcols</name></name> <operator>=</operator> <name>updatedCols</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>updatedCols</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE STATEMENT trigger cannot return a value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecASUpdateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* statement-level triggers operate on the parent table */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_UPDATE</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
							  <argument><expr><call><name>ExecGetAllUpdatedCols</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecBRUpdateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
					 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>fdw_trigtuple</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trigtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free_trig</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free_new</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>

	<comment type="block">/* Determine lock mode to use */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>ExecUpdateLockMode</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fdw_trigtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot_candidate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get a copy of the on-disk tuple we are planning to update */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTupleForTrigger</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
								<argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqslot_candidate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* cancel the update action */</comment>

		<comment type="block">/*
		 * In READ COMMITTED isolation level it's possible that target tuple
		 * was changed due to concurrent update.  In that case we have a raw
		 * subplan output tuple in epqslot_candidate, and need to run it
		 * through the junk filter to produce an insertable tuple.
		 *
		 * Caution: more than likely, the passed-in slot is the same as the
		 * junkfilter's output slot, so we are clobbering the original value
		 * of slottuple by doing the filtering.  This is OK since neither we
		 * nor our caller have any more interest in the prior contents of that
		 * slot.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>epqslot_candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot_clean</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>epqslot_clean</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>, <argument><expr><name>epqslot_candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>newslot</name> <operator>!=</operator> <name>epqslot_clean</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>epqslot_clean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>trigtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_trig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>trigtuple</name> <operator>=</operator> <name>fdw_trigtuple</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>ExecGetAllUpdatedCols</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_updatedcols</name></name> <operator>=</operator> <name>updatedCols</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>updatedCols</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>trigtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>oldtuple</name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>should_free_trig</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>should_free_new</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* "do nothing" */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>oldtuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the tuple returned by the trigger / being stored, is the old
			 * row version, and the heap tuple passed to the trigger was
			 * allocated locally, materialize the slot. Otherwise we might
			 * free it while still referenced by the slot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>should_free_trig</name> <operator>&amp;&amp;</operator> <name>newtuple</name> <operator>==</operator> <name>trigtuple</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>should_free_new</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* signal tuple should be re-fetched if used */</comment>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>should_free_trig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecARUpdateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>fdw_trigtuple</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name></decl></parameter>,
					 <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>transition_capture</name> <operator>&amp;&amp;</operator>
		 <operator>(</operator><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name> <operator>||</operator>
		  <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note: if the UPDATE is converted into a DELETE+INSERT as part of
		 * update-partition-key operation, then this function is also called
		 * separately for DELETE and INSERT to capture transition table rows.
		 * In such case, either old tuple or new tuple can be NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fdw_trigtuple</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GetTupleForTrigger</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>relinfo</name></expr></argument>,
							   <argument><expr><name>tupleid</name></expr></argument>,
							   <argument><expr><name>LockTupleExclusive</name></expr></argument>,
							   <argument><expr><name>oldslot</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>fdw_trigtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>fdw_trigtuple</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_UPDATE</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>recheckIndexes</name></expr></argument>,
							  <argument><expr><call><name>ExecGetAllUpdatedCols</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>transition_capture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecIRUpdateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					 <parameter><decl><type><name>HeapTuple</name></type> <name>trigtuple</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name> <init>= <expr><call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_ROW</name> <operator>|</operator>
		<name>TRIGGER_EVENT_INSTEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>trigtuple</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSTEAD</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>trigtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>oldtuple</name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* "do nothing" */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>oldtuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* signal tuple should be re-fetched if used */</comment>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecBSTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_truncate_before_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_TRUNCATE</name> <operator>|</operator>
		<name>TRIGGER_EVENT_BEFORE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_STATEMENT</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_TRUNCATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <name>trigger</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
									   <argument><expr><name>i</name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr></argument>,
									   <argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr></argument>,
									   <argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BEFORE STATEMENT trigger cannot return a value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecASTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>&amp;&amp;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_truncate_after_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerSaveEvent</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>TRIGGER_EVENT_TRUNCATE</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fetch tuple into "oldslot", dealing with locking and EPQ if necessary
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GetTupleForTrigger</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
				   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
				   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
				   <parameter><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl></parameter>,
				   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>,
				   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>epqslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TM_Result</name></type>	<name>test</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>lockflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>epqslot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* caller must pass an epqstate if EvalPlanQual is possible */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>epqstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * lock tuple for update
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockflags</name> <operator>|=</operator> <name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
								<argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>,
								<argument><expr><name>lockflags</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TM_SelfModified</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  We ignore the tuple in the former case, and
				 * throw error in the latter case, for the same reasons
				 * enumerated in ExecUpdate and ExecDelete in
				 * nodeModifyTable.c.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* treat it as deleted; do not process */</comment>
				<return>return <expr><name>false</name></expr>;</return>

			<case>case <expr><name>TM_Ok</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>traversed</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>,
											<argument><expr><name>relation</name></expr></argument>,
											<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
											<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If PlanQual failed for updated tuple - we must not
					 * process this tuple!
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><operator>*</operator><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>epqslot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>TM_Updated</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>TM_Deleted</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* tuple was deleted */</comment>
				<return>return <expr><name>false</name></expr>;</return>

			<case>case <expr><name>TM_Invisible</name></expr>:</case>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We expect the tuple to be present, thus very simple error handling
		 * suffices.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>,
										   <argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is trigger enabled to fire?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TriggerEnabled</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
			   <parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>TriggerEvent</name></type> <name>event</name></decl></parameter>,
			   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
			   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check replication-role-dependent enable state */</comment>
	<if_stmt><if>if <condition>(<expr><name>SessionReplicationRole</name> <operator>==</operator> <name>SESSION_REPLICATION_ROLE_REPLICA</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>==</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name> <operator>||</operator>
			<name><name>trigger</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>==</operator> <name>TRIGGER_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* ORIGIN or LOCAL role */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>==</operator> <name>TRIGGER_FIRES_ON_REPLICA</name> <operator>||</operator>
			<name><name>trigger</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>==</operator> <name>TRIGGER_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check for column-specific trigger (only possible for UPDATE, and in
	 * fact we *must* ignore tgattr for other event types)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgnattr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgattr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>modifiedCols</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modified</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for WHEN clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * trigger is an element of relinfo-&gt;ri_TrigDesc-&gt;triggers[]; find the
		 * matching element of relinfo-&gt;ri_TrigWhenExprs[]
		 */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>trigger</name> <operator>-</operator> <name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>triggers</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>predicate</name> <operator>=</operator> <operator>&amp;</operator><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigWhenExprs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If first time through for this WHEN expression, build expression
		 * nodetrees for it.  Keep them in the per-query memory context so
		 * they'll survive throughout the query.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>predicate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tgqual</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tgqual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Change references to OLD and NEW to INNER_VAR and OUTER_VAR */</comment>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>tgqual</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><name>INNER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>tgqual</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><name>OUTER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ExecPrepareQual wants implicit-AND form */</comment>
			<expr_stmt><expr><name>tgqual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tgqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>tgqual</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We will use the EState's per-tuple context for evaluating WHEN
		 * expressions (creating it if it's not already there).
		 */</comment>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Finally evaluate the expression, making the old and/or new tuples
		 * available as INNER_VAR/OUTER_VAR respectively.
		 */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><operator>*</operator><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * After-trigger stuff
 *
 * The AfterTriggersData struct holds data about pending AFTER trigger events
 * during the current transaction tree.  (BEFORE triggers are fired
 * immediately so we don't need any persistent state about them.)  The struct
 * and most of its subsidiary data are kept in TopTransactionContext; however
 * some data that can be discarded sooner appears in the CurTransactionContext
 * of the relevant subtransaction.  Also, the individual event records are
 * kept in a separate sub-context of TopTransactionContext.  This is done
 * mainly so that it's easy to tell from a memory context dump how much space
 * is being eaten by trigger events.
 *
 * Because the list of pending events can grow large, we go to some
 * considerable effort to minimize per-event memory consumption.  The event
 * records are grouped into chunks and common data for similar events in the
 * same chunk is only stored once.
 *
 * XXX We need to be able to save the per-event data in a file if it grows too
 * large.
 * ----------
 */</comment>

<comment type="block">/* Per-trigger SET CONSTRAINT status */</comment>
<typedef>typedef <type><struct>struct <name>SetConstraintTriggerData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sct_tgoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sct_tgisdeferred</name></decl>;</decl_stmt>
}</block></struct></type> <name>SetConstraintTriggerData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>SetConstraintTriggerData</name></name> <modifier>*</modifier></type><name>SetConstraintTrigger</name>;</typedef>

<comment type="block">/*
 * SET CONSTRAINT intra-transaction status.
 *
 * We make this a single palloc'd object so it can be copied and freed easily.
 *
 * all_isset and all_isdeferred are used to keep track
 * of SET CONSTRAINTS ALL {DEFERRED, IMMEDIATE}.
 *
 * trigstates[] stores per-trigger tgisdeferred settings.
 */</comment>
<typedef>typedef <type><struct>struct <name>SetConstraintStateData</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_isset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_isdeferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numstates</name></decl>;</decl_stmt>		<comment type="block">/* number of trigstates[] entries in use */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numalloc</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of trigstates[] */</comment>
	<decl_stmt><decl><type><name>SetConstraintTriggerData</name></type> <name><name>trigstates</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SetConstraintStateData</name>;</typedef>

<typedef>typedef <type><name>SetConstraintStateData</name> <modifier>*</modifier></type><name>SetConstraintState</name>;</typedef>


<comment type="block">/*
 * Per-trigger-event data
 *
 * The actual per-event data, AfterTriggerEventData, includes DONE/IN_PROGRESS
 * status bits and up to two tuple CTIDs.  Each event record also has an
 * associated AfterTriggerSharedData that is shared across all instances of
 * similar events within a "chunk".
 *
 * For row-level triggers, we arrange not to waste storage on unneeded ctid
 * fields.  Updates of regular tables use two; inserts and deletes of regular
 * tables use one; foreign tables always use zero and save the tuple(s) to a
 * tuplestore.  AFTER_TRIGGER_FDW_FETCH directs AfterTriggerExecute() to
 * retrieve a fresh tuple or pair of tuples from that tuplestore, while
 * AFTER_TRIGGER_FDW_REUSE directs it to use the most-recently-retrieved
 * tuple(s).  This permits storing tuples once regardless of the number of
 * row-level triggers on a foreign table.
 *
 * Note that we need triggers on foreign tables to be fired in exactly the
 * order they were queued, so that the tuples come out of the tuplestore in
 * the right order.  To ensure that, we forbid deferrable (constraint)
 * triggers on foreign tables.  This also ensures that such triggers do not
 * get deferred into outer trigger query levels, meaning that it's okay to
 * destroy the tuplestore at the end of the query level.
 *
 * Statement-level triggers always bear AFTER_TRIGGER_1CTID, though they
 * require no ctid field.  We lack the flag bit space to neatly represent that
 * distinct case, and it seems unlikely to be worth much trouble.
 *
 * Note: ats_firing_id is initially zero and is set to something else when
 * AFTER_TRIGGER_IN_PROGRESS is set.  It indicates which trigger firing
 * cycle the trigger will be fired in (or was fired in, if DONE is set).
 * Although this is mutable state, we can keep it in AfterTriggerSharedData
 * because all instances of the same type of event in a given event list will
 * be fired at the same time, if they were queued between the same firing
 * cycles.  So we need only ensure that ats_firing_id is zero when attaching
 * a new event to an existing AfterTriggerSharedData record.
 */</comment>
<typedef>typedef <type><name>uint32</name></type> <name>TriggerFlags</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_OFFSET</name></cpp:macro>			<cpp:value>0x0FFFFFFF</cpp:value></cpp:define>	<comment type="block">/* must be low-order bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_DONE</name></cpp:macro>				<cpp:value>0x10000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_IN_PROGRESS</name></cpp:macro>		<cpp:value>0x20000000</cpp:value></cpp:define>
<comment type="block">/* bits describing the size and tuple sources of this event */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_FDW_REUSE</name></cpp:macro>			<cpp:value>0x00000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_FDW_FETCH</name></cpp:macro>			<cpp:value>0x80000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_1CTID</name></cpp:macro>				<cpp:value>0x40000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_2CTID</name></cpp:macro>				<cpp:value>0xC0000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTER_TRIGGER_TUP_BITS</name></cpp:macro>			<cpp:value>0xC0000000</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>AfterTriggerSharedData</name></name> <modifier>*</modifier></type><name>AfterTriggerShared</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AfterTriggerSharedData</name>
<block>{
	<decl_stmt><decl><type><name>TriggerEvent</name></type> <name>ats_event</name></decl>;</decl_stmt>		<comment type="block">/* event type indicator, see trigger.h */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ats_tgoid</name></decl>;</decl_stmt>		<comment type="block">/* the trigger's ID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ats_relid</name></decl>;</decl_stmt>		<comment type="block">/* the relation it's on */</comment>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>ats_firing_id</name></decl>;</decl_stmt>	<comment type="block">/* ID for firing cycle */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>AfterTriggersTableData</name></name> <modifier>*</modifier></type><name>ats_table</name></decl>;</decl_stmt>	<comment type="block">/* transition table access */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>ats_modifiedcols</name></decl>;</decl_stmt>	<comment type="block">/* modified columns */</comment>
}</block></struct></type> <name>AfterTriggerSharedData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>AfterTriggerEventData</name></name> <modifier>*</modifier></type><name>AfterTriggerEvent</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AfterTriggerEventData</name>
<block>{
	<decl_stmt><decl><type><name>TriggerFlags</name></type> <name>ate_flags</name></decl>;</decl_stmt>		<comment type="block">/* status bits and offset to shared data */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ate_ctid1</name></decl>;</decl_stmt>	<comment type="block">/* inserted, deleted, or old updated tuple */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ate_ctid2</name></decl>;</decl_stmt>	<comment type="block">/* new updated tuple */</comment>
}</block></struct></type> <name>AfterTriggerEventData</name>;</typedef>

<comment type="block">/* AfterTriggerEventData, minus ate_ctid2 */</comment>
<typedef>typedef <type><struct>struct <name>AfterTriggerEventDataOneCtid</name>
<block>{
	<decl_stmt><decl><type><name>TriggerFlags</name></type> <name>ate_flags</name></decl>;</decl_stmt>		<comment type="block">/* status bits and offset to shared data */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ate_ctid1</name></decl>;</decl_stmt>	<comment type="block">/* inserted, deleted, or old updated tuple */</comment>
}</block></struct></type>			<name>AfterTriggerEventDataOneCtid</name>;</typedef>

<comment type="block">/* AfterTriggerEventData, minus ate_ctid1 and ate_ctid2 */</comment>
<typedef>typedef <type><struct>struct <name>AfterTriggerEventDataZeroCtids</name>
<block>{
	<decl_stmt><decl><type><name>TriggerFlags</name></type> <name>ate_flags</name></decl>;</decl_stmt>		<comment type="block">/* status bits and offset to shared data */</comment>
}</block></struct></type>			<name>AfterTriggerEventDataZeroCtids</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeofTriggerEvent</name><parameter_list>(<parameter><type><name>evt</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((evt)-&gt;ate_flags &amp; AFTER_TRIGGER_TUP_BITS) == AFTER_TRIGGER_2CTID ? \
	 sizeof(AfterTriggerEventData) : \
		((evt)-&gt;ate_flags &amp; AFTER_TRIGGER_TUP_BITS) == AFTER_TRIGGER_1CTID ? \
		sizeof(AfterTriggerEventDataOneCtid) : \
			sizeof(AfterTriggerEventDataZeroCtids))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetTriggerSharedData</name><parameter_list>(<parameter><type><name>evt</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((AfterTriggerShared) ((char *) (evt) + ((evt)-&gt;ate_flags &amp; AFTER_TRIGGER_OFFSET)))</cpp:value></cpp:define>

<comment type="block">/*
 * To avoid palloc overhead, we keep trigger events in arrays in successively-
 * larger chunks (a slightly more sophisticated version of an expansible
 * array).  The space between CHUNK_DATA_START and freeptr is occupied by
 * AfterTriggerEventData records; the space between endfree and endptr is
 * occupied by AfterTriggerSharedData records.
 */</comment>
<typedef>typedef <type><struct>struct <name>AfterTriggerEventChunk</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>AfterTriggerEventChunk</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>	<comment type="block">/* list link */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>freeptr</name></decl>;</decl_stmt>		<comment type="block">/* start of free space in chunk */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endfree</name></decl>;</decl_stmt>		<comment type="block">/* end of free space in chunk */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>			<comment type="block">/* end of chunk */</comment>
	<comment type="block">/* event data follows here */</comment>
}</block></struct></type> <name>AfterTriggerEventChunk</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_DATA_START</name><parameter_list>(<parameter><type><name>cptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *) (cptr) + MAXALIGN(sizeof(AfterTriggerEventChunk)))</cpp:value></cpp:define>

<comment type="block">/* A list of events */</comment>
<typedef>typedef <type><struct>struct <name>AfterTriggerEventList</name>
<block>{
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tailfree</name></decl>;</decl_stmt>		<comment type="block">/* freeptr of tail chunk */</comment>
}</block></struct></type> <name>AfterTriggerEventList</name>;</typedef>

<comment type="block">/* Macros to help in iterating over a list of events */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>for_each_chunk</name><parameter_list>(<parameter><type><name>cptr</name></type></parameter>, <parameter><type><name>evtlist</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for (cptr = (evtlist).head; cptr != NULL; cptr = cptr-&gt;next)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>for_each_event</name><parameter_list>(<parameter><type><name>eptr</name></type></parameter>, <parameter><type><name>cptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for (eptr = (AfterTriggerEvent) CHUNK_DATA_START(cptr); \
		 (char *) eptr &lt; (cptr)-&gt;freeptr; \
		 eptr = (AfterTriggerEvent) (((char *) eptr) + SizeofTriggerEvent(eptr)))</cpp:value></cpp:define>
<comment type="block">/* Use this if no special per-chunk processing is needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>for_each_event_chunk</name><parameter_list>(<parameter><type><name>eptr</name></type></parameter>, <parameter><type><name>cptr</name></type></parameter>, <parameter><type><name>evtlist</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for_each_chunk(cptr, evtlist) for_each_event(eptr, cptr)</cpp:value></cpp:define>

<comment type="block">/* Macros for iterating from a start point that might not be list start */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>for_each_chunk_from</name><parameter_list>(<parameter><type><name>cptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for (; cptr != NULL; cptr = cptr-&gt;next)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>for_each_event_from</name><parameter_list>(<parameter><type><name>eptr</name></type></parameter>, <parameter><type><name>cptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for (; \
		 (char *) eptr &lt; (cptr)-&gt;freeptr; \
		 eptr = (AfterTriggerEvent) (((char *) eptr) + SizeofTriggerEvent(eptr)))</cpp:value></cpp:define>


<comment type="block">/*
 * All per-transaction data for the AFTER TRIGGERS module.
 *
 * AfterTriggersData has the following fields:
 *
 * firing_counter is incremented for each call of afterTriggerInvokeEvents.
 * We mark firable events with the current firing cycle's ID so that we can
 * tell which ones to work on.  This ensures sane behavior if a trigger
 * function chooses to do SET CONSTRAINTS: the inner SET CONSTRAINTS will
 * only fire those events that weren't already scheduled for firing.
 *
 * state keeps track of the transaction-local effects of SET CONSTRAINTS.
 * This is saved and restored across failed subtransactions.
 *
 * events is the current list of deferred events.  This is global across
 * all subtransactions of the current transaction.  In a subtransaction
 * abort, we know that the events added by the subtransaction are at the
 * end of the list, so it is relatively easy to discard them.  The event
 * list chunks themselves are stored in event_cxt.
 *
 * query_depth is the current depth of nested AfterTriggerBeginQuery calls
 * (-1 when the stack is empty).
 *
 * query_stack[query_depth] is the per-query-level data, including these fields:
 *
 * events is a list of AFTER trigger events queued by the current query.
 * None of these are valid until the matching AfterTriggerEndQuery call
 * occurs.  At that point we fire immediate-mode triggers, and append any
 * deferred events to the main events list.
 *
 * fdw_tuplestore is a tuplestore containing the foreign-table tuples
 * needed by events queued by the current query.  (Note: we use just one
 * tuplestore even though more than one foreign table might be involved.
 * This is okay because tuplestores don't really care what's in the tuples
 * they store; but it's possible that someday it'd break.)
 *
 * tables is a List of AfterTriggersTableData structs for target tables
 * of the current query (see below).
 *
 * maxquerydepth is just the allocated length of query_stack.
 *
 * trans_stack holds per-subtransaction data, including these fields:
 *
 * state is NULL or a pointer to a saved copy of the SET CONSTRAINTS
 * state data.  Each subtransaction level that modifies that state first
 * saves a copy, which we use to restore the state if we abort.
 *
 * events is a copy of the events head/tail pointers,
 * which we use to restore those values during subtransaction abort.
 *
 * query_depth is the subtransaction-start-time value of query_depth,
 * which we similarly use to clean up at subtransaction abort.
 *
 * firing_counter is the subtransaction-start-time value of firing_counter.
 * We use this to recognize which deferred triggers were fired (or marked
 * for firing) within an aborted subtransaction.
 *
 * We use GetCurrentTransactionNestLevel() to determine the correct array
 * index in trans_stack.  maxtransdepth is the number of allocated entries in
 * trans_stack.  (By not keeping our own stack pointer, we can avoid trouble
 * in cases where errors during subxact abort cause multiple invocations
 * of AfterTriggerEndSubXact() at the same nesting depth.)
 *
 * We create an AfterTriggersTableData struct for each target table of the
 * current query, and each operation mode (INSERT/UPDATE/DELETE), that has
 * either transition tables or statement-level triggers.  This is used to
 * hold the relevant transition tables, as well as info tracking whether
 * we already queued the statement triggers.  (We use that info to prevent
 * firing the same statement triggers more than once per statement, or really
 * once per transition table set.)  These structs, along with the transition
 * table tuplestores, live in the (sub)transaction's CurTransactionContext.
 * That's sufficient lifespan because we don't allow transition tables to be
 * used by deferrable triggers, so they only need to survive until
 * AfterTriggerEndQuery.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>AfterTriggersQueryData</name></name></type> <name>AfterTriggersQueryData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AfterTriggersTransData</name></name></type> <name>AfterTriggersTransData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>AfterTriggersTableData</name></name></type> <name>AfterTriggersTableData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AfterTriggersData</name>
<block>{
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>firing_counter</name></decl>;</decl_stmt> <comment type="block">/* next firing ID to assign */</comment>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name></decl>;</decl_stmt>	<comment type="block">/* the active S C state */</comment>
	<decl_stmt><decl><type><name>AfterTriggerEventList</name></type> <name>events</name></decl>;</decl_stmt>	<comment type="block">/* deferred-event list */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>event_cxt</name></decl>;</decl_stmt>	<comment type="block">/* memory context for events, if any */</comment>

	<comment type="block">/* per-query-level data: */</comment>
	<decl_stmt><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>query_stack</name></decl>;</decl_stmt>	<comment type="block">/* array of structs shown below */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_depth</name></decl>;</decl_stmt>	<comment type="block">/* current index in above array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxquerydepth</name></decl>;</decl_stmt>	<comment type="block">/* allocated len of above array */</comment>

	<comment type="block">/* per-subtransaction-level data: */</comment>
	<decl_stmt><decl><type><name>AfterTriggersTransData</name> <modifier>*</modifier></type><name>trans_stack</name></decl>;</decl_stmt>	<comment type="block">/* array of structs shown below */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxtransdepth</name></decl>;</decl_stmt>	<comment type="block">/* allocated len of above array */</comment>
}</block></struct></type> <name>AfterTriggersData</name>;</typedef>

<struct>struct <name>AfterTriggersQueryData</name>
<block>{
	<decl_stmt><decl><type><name>AfterTriggerEventList</name></type> <name>events</name></decl>;</decl_stmt>	<comment type="block">/* events pending from this query */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>fdw_tuplestore</name></decl>;</decl_stmt>	<comment type="block">/* foreign tuples for said events */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>			<comment type="block">/* list of AfterTriggersTableData, see below */</comment>
}</block>;</struct>

<struct>struct <name>AfterTriggersTransData</name>
<block>{
	<comment type="block">/* these fields are just for resetting at subtrans abort: */</comment>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name></decl>;</decl_stmt>	<comment type="block">/* saved S C state, or NULL if not yet saved */</comment>
	<decl_stmt><decl><type><name>AfterTriggerEventList</name></type> <name>events</name></decl>;</decl_stmt>	<comment type="block">/* saved list pointer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_depth</name></decl>;</decl_stmt>	<comment type="block">/* saved query_depth */</comment>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>firing_counter</name></decl>;</decl_stmt> <comment type="block">/* saved firing_counter */</comment>
}</block>;</struct>

<struct>struct <name>AfterTriggersTableData</name>
<block>{
	<comment type="block">/* relid + cmdType form the lookup key for these structs: */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* target table's OID */</comment>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>cmdType</name></decl>;</decl_stmt>		<comment type="block">/* event type, CMD_INSERT/UPDATE/DELETE */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>closed</name></decl>;</decl_stmt>			<comment type="block">/* true when no longer OK to add tuples */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>before_trig_done</name></decl>;</decl_stmt>	<comment type="block">/* did we already queue BS triggers? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>after_trig_done</name></decl>;</decl_stmt>	<comment type="block">/* did we already queue AS triggers? */</comment>
	<decl_stmt><decl><type><name>AfterTriggerEventList</name></type> <name>after_trig_events</name></decl>;</decl_stmt>	<comment type="block">/* if so, saved list pointer */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>old_tuplestore</name></decl>;</decl_stmt>	<comment type="block">/* "old" transition table, if any */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>new_tuplestore</name></decl>;</decl_stmt>	<comment type="block">/* "new" transition table, if any */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>storeslot</name></decl>;</decl_stmt>	<comment type="block">/* for converting to tuplestore's format */</comment>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>AfterTriggersData</name></type> <name>afterTriggers</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AfterTriggerExecute</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl></parameter>,
								<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relInfo</name></decl></parameter>,
								<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>,
								<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>,
								<parameter><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>,
								<parameter><decl><type><name>MemoryContext</name></type> <name>per_tuple_context</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>trig_tuple_slot1</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>trig_tuple_slot2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>GetAfterTriggersTableData</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
														 <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>GetAfterTriggersStoreSlot</name><parameter_list>(<parameter><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,
												 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AfterTriggerFreeQuery</name><parameter_list>(<parameter><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetConstraintState</name></type> <name>SetConstraintStateCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numalloc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetConstraintState</name></type> <name>SetConstraintStateCopy</name><parameter_list>(<parameter><decl><type><name>SetConstraintState</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetConstraintState</name></type> <name>SetConstraintStateAddItem</name><parameter_list>(<parameter><decl><type><name>SetConstraintState</name></type> <name>state</name></decl></parameter>,
													<parameter><decl><type><name>Oid</name></type> <name>tgoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tgisdeferred</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cancel_prior_stmt_triggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tgevent</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Get the FDW tuplestore for the current trigger query level, creating it
 * if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>GetCurrentFDWTuplestore</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name><operator>.</operator><name>fdw_tuplestore</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make the tuplestore valid until end of subtransaction.  We really
		 * only need it until AfterTriggerEndQuery().
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>CurTransactionResourceOwner</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name><operator>.</operator><name>fdw_tuplestore</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * afterTriggerCheckState()
 *
 *	Returns true if the trigger event is actually in state DEFERRED.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>afterTriggerCheckState</name><parameter_list>(<parameter><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tgoid</name> <init>= <expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_tgoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For not-deferrable triggers (i.e. normal AFTER ROW triggers and
	 * constraints declared NOT DEFERRABLE), the state is always false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_DEFERRABLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If constraint state exists, SET CONSTRAINTS might have been executed
	 * either for this trigger or for all triggers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for SET CONSTRAINTS for this specific trigger. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>numstates</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sct_tgoid</name> <operator>==</operator> <name>tgoid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sct_tgisdeferred</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Check for SET CONSTRAINTS ALL. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>all_isset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>all_isdeferred</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise return the default state for the trigger.
	 */</comment>
	<return>return <expr><operator>(</operator><operator>(</operator><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_INITDEFERRED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * afterTriggerAddEvent()
 *
 *	Add a new trigger event to the specified queue.
 *	The passed-in event data is copied.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>afterTriggerAddEvent</name><parameter_list>(<parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl></parameter>,
					 <parameter><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>eventsize</name> <init>= <expr><call><name>SizeofTriggerEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>needed</name> <init>= <expr><name>eventsize</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggerSharedData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>newshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>newevent</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If empty list or not enough room in the tail chunk, make a new chunk.
	 * We assume here that a new shared record will always be needed.
	 */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>events</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name> <operator>-</operator> <name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>&lt;</operator> <name>needed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>chunksize</name></decl>;</decl_stmt>

		<comment type="block">/* Create event context if we didn't already */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name> <operator>=</operator>
				<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
									  <argument><expr><literal type="string">"AfterTriggerEvents"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Chunk size starts at 1KB and is allowed to increase up to 1MB.
		 * These numbers are fairly arbitrary, though there is a hard limit at
		 * AFTER_TRIGGER_OFFSET; else we couldn't link event records to their
		 * shared records using the available space in ate_flags.  Another
		 * constraint is that if the chunk size gets too huge, the search loop
		 * below would get slow given a (not too common) usage pattern with
		 * many distinct event types in a chunk.  Therefore, we double the
		 * preceding chunk size only if there weren't too many shared records
		 * in the preceding chunk; otherwise we halve it.  This gives us some
		 * ability to adapt to the actual usage pattern of the current query
		 * while still having large chunk sizes in typical usage.  All chunk
		 * sizes used should be MAXALIGN multiples, to ensure that the shared
		 * records will be aligned safely.
		 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_CHUNK_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CHUNK_SIZE</name></cpp:macro> <cpp:value>(1024*1024)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAX_CHUNK_SIZE</name> <operator>&gt;</operator> <operator>(</operator><name>AFTER_TRIGGER_OFFSET</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> MAX_CHUNK_SIZE must not exceed AFTER_TRIGGER_OFFSET</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <name>MIN_CHUNK_SIZE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* preceding chunk size... */</comment>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endptr</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
			<comment type="block">/* check number of shared records in preceding chunk */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>endptr</name></name> <operator>-</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name><operator>)</operator> <operator>&lt;=</operator>
				<operator>(</operator><literal type="number">100</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggerSharedData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>chunksize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* okay, double it */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>chunksize</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* too many shared records */</comment>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>chunksize</name></expr></argument>, <argument><expr><name>MAX_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name></expr></argument>, <argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>=</operator> <call><name>CHUNK_DATA_START</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>endptr</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chunk</name> <operator>+</operator> <name>chunksize</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name> <operator>-</operator> <name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>&gt;=</operator> <name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>events</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>chunk</name></expr>;</expr_stmt>
		<comment type="block">/* events-&gt;tailfree is now out of sync, but we'll fix it below */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to locate a matching shared-data record already in the chunk. If
	 * none, make a new one.
	 */</comment>
	<for>for <control>(<init><expr><name>newshared</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AfterTriggerShared</name><operator>)</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endptr</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</init>
		 <condition><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newshared</name> <operator>&gt;=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name></expr>;</condition>
		 <incr><expr><name>newshared</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>newshared</name><operator>-&gt;</operator><name>ats_tgoid</name></name> <operator>==</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_tgoid</name></name> <operator>&amp;&amp;</operator>
			<name><name>newshared</name><operator>-&gt;</operator><name>ats_relid</name></name> <operator>==</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name> <operator>&amp;&amp;</operator>
			<name><name>newshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>==</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;&amp;</operator>
			<name><name>newshared</name><operator>-&gt;</operator><name>ats_table</name></name> <operator>==</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name></name> <operator>&amp;&amp;</operator>
			<name><name>newshared</name><operator>-&gt;</operator><name>ats_firing_id</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newshared</name> <operator>&lt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>newshared</name> <operator>=</operator> <operator>*</operator><name>evtshared</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newshared</name><operator>-&gt;</operator><name>ats_firing_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* just to be sure */</comment>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newshared</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Insert the data */</comment>
	<expr_stmt><expr><name>newevent</name> <operator>=</operator> <operator>(</operator><name>AfterTriggerEvent</name><operator>)</operator> <name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newevent</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>eventsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and link the new event to its shared record */</comment>
	<expr_stmt><expr><name><name>newevent</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>AFTER_TRIGGER_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newevent</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>|=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newshared</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newevent</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>+=</operator> <name>eventsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tailfree</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * afterTriggerFreeEventList()
 *
 *	Free all the event storage in the given list.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>afterTriggerFreeEventList</name><parameter_list>(<parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>chunk</name> <operator>=</operator> <name><name>events</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tailfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * afterTriggerRestoreEventList()
 *
 *	Restore an event list to its prior length, removing all the events
 *	added since it had the value old_events.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>afterTriggerRestoreEventList</name><parameter_list>(<parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>old_events</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>next_chunk</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>old_events</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* restoring to a completely empty state, so free everything */</comment>
		<expr_stmt><expr><call><name>afterTriggerFreeEventList</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>events</name> <operator>=</operator> <operator>*</operator><name>old_events</name></expr>;</expr_stmt>
		<comment type="block">/* free any chunks after the last one we want to keep */</comment>
		<for>for <control>(<init><expr><name>chunk</name> <operator>=</operator> <name><name>events</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>chunk</name> <operator>=</operator> <name>next_chunk</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>next_chunk</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* and clean up the tail chunk to be the right length */</comment>
		<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>=</operator> <name><name>events</name><operator>-&gt;</operator><name>tailfree</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't make any effort to remove now-unused shared data records.
		 * They might still be useful, anyway.
		 */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * afterTriggerDeleteHeadEventChunk()
 *
 *	Remove the first chunk of events from the query level's event list.
 *	Keep any event list pointers elsewhere in the query level's data
 *	structures in sync.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>afterTriggerDeleteHeadEventChunk</name><parameter_list>(<parameter><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target</name> <operator>&amp;&amp;</operator> <name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, update any pointers in the per-table data, so that they won't be
	 * dangling.  Resetting obsoleted pointers to NULL will make
	 * cancel_prior_stmt_triggers start from the list head, which is fine.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qs-&gt;tables</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><operator>(</operator><name>AfterTriggersTableData</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_done</name></name> <operator>&amp;&amp;</operator>
			<name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tail</name></name> <operator>==</operator> <name>target</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tailfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Now we can flush the head chunk */</comment>
	<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerExecute()
 *
 *	Fetch the required tuples back from the heap and fire one
 *	single trigger function.
 *
 *	Frequently, this will be fired many times in a row for triggers of
 *	a single relation.  Therefore, we cache the open relation and provide
 *	fmgr lookup cache space at the caller level.  (For triggers fired at
 *	the end of a query, we can even piggyback on the executor's state.)
 *
 *	event: event currently being fired.
 *	rel: open relation for event.
 *	trigdesc: working copy of rel's trigger info.
 *	finfo: array of fmgr lookup cache entries (one per trigger in trigdesc).
 *	instr: array of EXPLAIN ANALYZE instrumentation nodes (one per trigger),
 *		or NULL if no instrumentation is wanted.
 *	per_tuple_context: memory context to call trigger function in.
 *	trig_tuple_slot1: scratch slot for tg_trigtuple (foreign tables only)
 *	trig_tuple_slot2: scratch slot for tg_newtuple (foreign tables only)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AfterTriggerExecute</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relInfo</name></decl></parameter>,
					<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>,
					<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>per_tuple_context</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>trig_tuple_slot1</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>trig_tuple_slot2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tgoid</name> <init>= <expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_tgoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name></type> <name>LocTriggerData</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rettuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tgindx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free_trig</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free_new</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Locate trigger in trigdesc.
	 */</comment>
	<for>for <control>(<init><expr><name>tgindx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tgindx</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>tgindx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>tgindx</name></expr>]</index></name><operator>.</operator><name>tgoid</name> <operator>==</operator> <name>tgoid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>tgindx</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find trigger %u"</literal></expr></argument>, <argument><expr><name>tgoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If doing EXPLAIN ANALYZE, start charging time to this trigger. We want
	 * to include time spent re-fetching tuples in the trigger cost.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name>instr</name> <operator>+</operator> <name>tgindx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch the required tuple(s).
	 */</comment>
	<switch>switch <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_TUP_BITS</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AFTER_TRIGGER_FDW_FETCH</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>fdw_tuplestore</name> <init>= <expr><call><name>GetCurrentFDWTuplestore</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>fdw_tuplestore</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>trig_tuple_slot1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple1 for AFTER trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <name>TRIGGER_EVENT_OPMASK</name><operator>)</operator> <operator>==</operator>
					<name>TRIGGER_EVENT_UPDATE</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>fdw_tuplestore</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>trig_tuple_slot2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple2 for AFTER trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>AFTER_TRIGGER_FDW_REUSE</name></expr>:</case>

			<comment type="block">/*
			 * Store tuple in the slot so that tg_trigtuple does not reference
			 * tuplestore memory.  (It is formally possible for the trigger
			 * function to queue trigger events that add to the same
			 * tuplestore, which can push other tuples out of memory.)  The
			 * distinction is academic, because we start with a minimal tuple
			 * that is stored as a heap tuple, constructed in different memory
			 * context, in the slot anyway.
			 */</comment>
			<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>trig_tuple_slot1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator>
				<call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>trig_tuple_slot1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_trig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <name>TRIGGER_EVENT_OPMASK</name><operator>)</operator> <operator>==</operator>
				<name>TRIGGER_EVENT_UPDATE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name> <operator>=</operator> <name>trig_tuple_slot2</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator>
					<call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>trig_tuple_slot2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <call><name>ExecGetTriggerOldSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>,
												   <argument><expr><name>SnapshotAny</name></expr></argument>,
												   <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple1 for AFTER trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator>
					<call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_trig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* don't touch ctid2 if not there */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_TUP_BITS</name><operator>)</operator> <operator>==</operator>
				<name>AFTER_TRIGGER_2CTID</name> <operator>&amp;&amp;</operator>
				<call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name> <operator>=</operator> <call><name>ExecGetTriggerNewSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>,
												   <argument><expr><name>SnapshotAny</name></expr></argument>,
												   <argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple2 for AFTER trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator>
					<call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Set up the tuplestore information to let the trigger have access to
	 * transition tables.  When we first make a transition table available to
	 * a trigger, mark it "closed" so that it cannot change anymore.  If any
	 * additional events of the same type get queued in the current trigger
	 * query level, they'll go into new transition tables.
	 */</comment>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_oldtable</name></name> <operator>=</operator> <name><name>LocTriggerData</name><operator>.</operator><name>tg_newtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_oldtable</name></name> <operator>=</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name><operator>-&gt;</operator><name>old_tuplestore</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtable</name></name> <operator>=</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name><operator>-&gt;</operator><name>new_tuplestore</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_table</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Setup the remaining trigger information
	 */</comment>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator>
		<name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <operator>(</operator><name>TRIGGER_EVENT_OPMASK</name> <operator>|</operator> <name>TRIGGER_EVENT_ROW</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_updatedcols</name></name> <operator>=</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_modifiedcols</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>per_tuple_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the trigger and throw away any possibly returned updated tuple.
	 * (Don't let ExecCallTriggerFunc measure EXPLAIN time.)
	 */</comment>
	<expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>ExecCallTriggerFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LocTriggerData</name></expr></argument>,
								   <argument><expr><name>tgindx</name></expr></argument>,
								   <argument><expr><name>finfo</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>per_tuple_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rettuple</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name>rettuple</name> <operator>!=</operator> <name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>&amp;&amp;</operator>
		<name>rettuple</name> <operator>!=</operator> <name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Release resources
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>should_free_trig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>should_free_new</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* don't clear slots' contents if foreign table */</comment>
	<if_stmt><if>if <condition>(<expr><name>trig_tuple_slot1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_trigslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>LocTriggerData</name><operator>.</operator><name>tg_newslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If doing EXPLAIN ANALYZE, stop charging time to this trigger, and count
	 * one "tuple returned" (really the number of firings).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name>instr</name> <operator>+</operator> <name>tgindx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * afterTriggerMarkEvents()
 *
 *	Scan the given event list for not yet invoked events.  Mark the ones
 *	that can be invoked now with the current firing ID.
 *
 *	If move_list isn't NULL, events that are not to be invoked now are
 *	transferred to move_list.
 *
 *	When immediate_only is true, do not invoke currently-deferred triggers.
 *	(This will be false only at main transaction exit.)
 *
 *	Returns true if any invokable events were found.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>afterTriggerMarkEvents</name><parameter_list>(<parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl></parameter>,
					   <parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>move_list</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>immediate_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>deferred_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<macro><name>for_each_event_chunk</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>, <argument>*events</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>defer_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator>
			  <operator>(</operator><name>AFTER_TRIGGER_DONE</name> <operator>|</operator> <name>AFTER_TRIGGER_IN_PROGRESS</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This trigger hasn't been called or scheduled yet. Check if we
			 * should call it now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>immediate_only</name> <operator>&amp;&amp;</operator> <call><name>afterTriggerCheckState</name><argument_list>(<argument><expr><name>evtshared</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>defer_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Mark it as to be fired in this firing cycle.
				 */</comment>
				<expr_stmt><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_firing_id</name></name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>|=</operator> <name>AFTER_TRIGGER_IN_PROGRESS</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's deferred, move it to move_list, if requested.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>defer_it</name> <operator>&amp;&amp;</operator> <name>move_list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>deferred_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* add it to move_list */</comment>
			<expr_stmt><expr><call><name>afterTriggerAddEvent</name><argument_list>(<argument><expr><name>move_list</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>evtshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* mark original copy "done" so we don't do it again */</comment>
			<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>|=</operator> <name>AFTER_TRIGGER_DONE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We could allow deferred triggers if, before the end of the
	 * security-restricted operation, we were to verify that a SET CONSTRAINTS
	 * ... IMMEDIATE has fired all such triggers.  For now, don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>deferred_found</name> <operator>&amp;&amp;</operator> <call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot fire deferred trigger within security-restricted operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * afterTriggerInvokeEvents()
 *
 *	Scan the given event list for events that are marked as to be fired
 *	in the current firing cycle, and fire them.
 *
 *	If estate isn't NULL, we use its result relation info to avoid repeated
 *	openings and closing of trigger target relations.  If it is NULL, we
 *	make one locally to cache the info in case there are multiple trigger
 *	events per rel.
 *
 *	When delete_ok is true, it's safe to delete fully-processed events.
 *	(We are not very tense about that: we simply reset a chunk to be empty
 *	if all its events got fired.  The objective here is just to avoid useless
 *	rescanning of events when a trigger queues new events during transaction
 *	end, so it's not necessary to worry much about the case where only
 *	some events are fired.)
 *
 *	Returns true if no unfired events remain in the list (this allows us
 *	to avoid repeating afterTriggerMarkEvents).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>afterTriggerInvokeEvents</name><parameter_list>(<parameter><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl></parameter>,
						 <parameter><decl><type><name>CommandId</name></type> <name>firing_id</name></decl></parameter>,
						 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>delete_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_fired</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_tuple_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>local_estate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>slot2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make a local EState if need be */</comment>
	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_estate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make a per-tuple memory context for trigger function calls */</comment>
	<expr_stmt><expr><name>per_tuple_context</name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"AfterTriggerTupleContext"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>for_each_chunk</name><argument_list>(<argument>chunk</argument>, <argument>*events</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_fired_in_chunk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<macro><name>for_each_event</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Is it one for me to fire?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_IN_PROGRESS</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>evtshared</name><operator>-&gt;</operator><name>ats_firing_id</name></name> <operator>==</operator> <name>firing_id</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * So let's fire it... but first, find the correct relation if
				 * this is not the same relation as before.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <call><name>ExecGetTriggerResultRel</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>
					<comment type="block">/* Catch calls with insufficient relcache refcounting */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelationHasReferenceCountZero</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>trigdesc</name> <operator>=</operator> <name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>finfo</name> <operator>=</operator> <name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>instr</name> <operator>=</operator> <name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>slot1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>slot1</name> <operator>=</operator> <name>slot2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>slot1</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>slot2</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has no triggers"</literal></expr></argument>,
							 <argument><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Fire it.  Note that the AFTER_TRIGGER_IN_PROGRESS flag is
				 * still set, so recursive examinations of the event list
				 * won't try to re-fire it.
				 */</comment>
				<expr_stmt><expr><call><name>AfterTriggerExecute</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>rInfo</name></expr></argument>, <argument><expr><name>trigdesc</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>instr</name></expr></argument>,
									<argument><expr><name>per_tuple_context</name></expr></argument>, <argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Mark the event as done.
				 */</comment>
				<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>AFTER_TRIGGER_IN_PROGRESS</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>|=</operator> <name>AFTER_TRIGGER_DONE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_DONE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* something remains to be done */</comment>
				<expr_stmt><expr><name>all_fired</name> <operator>=</operator> <name>all_fired_in_chunk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Clear the chunk if delete_ok and nothing left of interest */</comment>
		<if_stmt><if>if <condition>(<expr><name>delete_ok</name> <operator>&amp;&amp;</operator> <name>all_fired_in_chunk</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name> <operator>=</operator> <call><name>CHUNK_DATA_START</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>endfree</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>endptr</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it's last chunk, must sync event list's tailfree too.  Note
			 * that delete_ok must NOT be passed as true if there could be
			 * additional AfterTriggerEventList values pointing at this event
			 * list, since we'd fail to fix their copies of tailfree.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name><name>events</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>tailfree</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>freeptr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>slot1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release working resources */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>per_tuple_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>local_estate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>all_fired</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAfterTriggersTableData
 *
 * Find or create an AfterTriggersTableData struct for the specified
 * trigger event (relation + operation type).  Ignore existing structs
 * marked "closed"; we don't want to put any additional tuples into them,
 * nor change their stmt-triggers-fired state.
 *
 * Note: the AfterTriggersTableData list is allocated in the current
 * (sub)transaction's CurTransactionContext.  This is OK because
 * we don't need it to live past AfterTriggerEndQuery.
 */</comment>
<function><type><specifier>static</specifier> <name>AfterTriggersTableData</name> <modifier>*</modifier></type>
<name>GetAfterTriggersTableData</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should have ensured query_depth is OK. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&lt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qs</name> <operator>=</operator> <operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qs-&gt;tables</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <operator>(</operator><name>AfterTriggersTableData</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name> <operator>&amp;&amp;</operator> <name><name>table</name><operator>-&gt;</operator><name>cmdType</name></name> <operator>==</operator> <name>cmdType</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>table</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>table</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <operator>(</operator><name>AfterTriggersTableData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggersTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>cmdType</name></name> <operator>=</operator> <name>cmdType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qs</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a TupleTableSlot suitable for holding the tuples to be put
 * into AfterTriggersTableData's transition table tuplestores.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>GetAfterTriggersStoreSlot</name><parameter_list>(<parameter><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,
						  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create it if not already done. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>table</name><operator>-&gt;</operator><name>storeslot</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only need this slot only until AfterTriggerEndQuery, but making
		 * it last till end-of-subxact is good enough.  It'll be freed by
		 * AfterTriggerFreeQuery().
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>storeslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>table</name><operator>-&gt;</operator><name>storeslot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MakeTransitionCaptureState
 *
 * Make a TransitionCaptureState object for the given TriggerDesc, target
 * relation, and operation type.  The TCS object holds all the state needed
 * to decide whether to capture tuples in transition tables.
 *
 * If there are no triggers in 'trigdesc' that request relevant transition
 * tables, then return NULL.
 *
 * The resulting object can be passed to the ExecAR* functions.  The caller
 * should set tcs_map or tcs_original_insert_tuple as appropriate when dealing
 * with child tables.
 *
 * Note that we copy the flags from a parent table into this struct (rather
 * than subsequently using the relation's TriggerDesc directly) so that we can
 * use it to control collection of transition tuples from child tables.
 *
 * Per SQL spec, all operations of the same kind (INSERT/UPDATE/DELETE)
 * on the same table during one query should share one transition table.
 * Therefore, the Tuplestores are owned by an AfterTriggersTableData struct
 * looked up using the table OID + CmdType, and are merely referenced by
 * the TransitionCaptureState objects we hand out to callers.
 */</comment>
<function><type><name>TransitionCaptureState</name> <modifier>*</modifier></type>
<name>MakeTransitionCaptureState</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_old</name></decl>,
				<decl><type ref="prev"/><name>need_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Detect which table(s) we need. */</comment>
	<switch>switch <condition>(<expr><name>cmdType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><name>need_old</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_new</name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name>need_old</name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_old_table</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_new</name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_new_table</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><name>need_old</name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_old_table</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>cmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_old</name> <operator>=</operator> <name>need_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_old</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_new</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check state, like AfterTriggerSaveEvent. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"MakeTransitionCaptureState() called outside of query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure we have enough space to record events at this query depth. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerEnlargeQueryState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find or create an AfterTriggersTableData struct to hold the
	 * tuplestore(s).  If there's a matching struct but it's marked closed,
	 * ignore it; we need a newer one.
	 *
	 * Note: the AfterTriggersTableData list, as well as the tuplestores, are
	 * allocated in the current (sub)transaction's CurTransactionContext, and
	 * the tuplestores are managed by the (sub)transaction's resource owner.
	 * This is sufficient lifespan because we do not allow triggers using
	 * transition tables to be deferrable; they will be fired during
	 * AfterTriggerEndQuery, after which it's okay to delete the data.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetAfterTriggersTableData</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>cmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now create required tuplestore(s), if we don't have them already. */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>CurTransactionResourceOwner</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_old</name> <operator>&amp;&amp;</operator> <name><name>table</name><operator>-&gt;</operator><name>old_tuplestore</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>old_tuplestore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_new</name> <operator>&amp;&amp;</operator> <name><name>table</name><operator>-&gt;</operator><name>new_tuplestore</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>new_tuplestore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now build the TransitionCaptureState struct, in caller's context */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>TransitionCaptureState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransitionCaptureState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcs_delete_old_table</name></name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_old_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_old_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_new_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcs_insert_new_table</name></name> <operator>=</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcs_private</name></name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerBeginXact()
 *
 *	Called at transaction start (either BEGIN or implicit for single
 *	statement outside of transaction block).
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerBeginXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Initialize after-trigger state structure to empty
	 */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name> <operator>=</operator> <operator>(</operator><name>CommandId</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* mustn't be 0 */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that there is no leftover state remaining.  If these assertions
	 * trip, it means that AfterTriggerEndXact wasn't called or didn't clean
	 * up properly.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>events</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerBeginQuery()
 *
 *	Called just before we start processing a single query within a
 *	transaction (or subtransaction).  Most of the real work gets deferred
 *	until somebody actually tries to queue a trigger event.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerBeginQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Increase the query stack depth */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerEndQuery()
 *
 *	Called after one query has been completely processed. At this time
 *	we invoke all AFTER IMMEDIATE trigger events queued by the query, and
 *	transfer deferred trigger events to the global deferred-trigger list.
 *
 *	Note that this must be called BEFORE closing down the executor
 *	with ExecutorEnd, because we make use of the EState's info about
 *	target relations.  Normally it is called from ExecutorFinish.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerEndQuery</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name></decl>;</decl_stmt>

	<comment type="block">/* Must be inside a query, too */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we never even got as far as initializing the event stack, there
	 * certainly won't be any events, so exit quickly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process all immediate-mode triggers queued by the query, and move the
	 * deferred ones to the main list of deferred events.
	 *
	 * Notice that we decide which ones will be fired, and put the deferred
	 * ones on the main list, before anything is actually fired.  This ensures
	 * reasonably sane behavior if a trigger function does SET CONSTRAINTS ...
	 * IMMEDIATE: all events we have decided to defer will be available for it
	 * to fire.
	 *
	 * We loop in case a trigger queues more events at the same query level.
	 * Ordinary trigger functions, including all PL/pgSQL trigger functions,
	 * will instead fire any triggers in a dedicated query level.  Foreign key
	 * enforcement triggers do add to the current query level, thanks to their
	 * passing fire_triggers = false to SPI_execute_snapshot().  Other
	 * C-language triggers might do likewise.
	 *
	 * If we find no firable events, we don't have to increment
	 * firing_counter.
	 */</comment>
	<expr_stmt><expr><name>qs</name> <operator>=</operator> <operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>afterTriggerMarkEvents</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qs</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>events</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommandId</name></type>	<name>firing_id</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>oldtail</name> <init>= <expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>afterTriggerInvokeEvents</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qs</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>firing_id</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* all fired */</comment>

			<comment type="block">/*
			 * Firing a trigger could result in query_stack being repalloc'd,
			 * so we must recalculate qs after each afterTriggerInvokeEvents
			 * call.  Furthermore, it's unsafe to pass delete_ok = true here,
			 * because that could cause afterTriggerInvokeEvents to try to
			 * access qs-&gt;events after the stack has been repalloc'd.
			 */</comment>
			<expr_stmt><expr><name>qs</name> <operator>=</operator> <operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We'll need to scan the events list again.  To reduce the cost
			 * of doing so, get rid of completely-fired chunks.  We know that
			 * all events were marked IN_PROGRESS or DONE at the conclusion of
			 * afterTriggerMarkEvents, so any still-interesting events must
			 * have been added after that, and so must be in the chunk that
			 * was then the tail chunk, or in later chunks.  So, zap all
			 * chunks before oldtail.  This is approximately the same set of
			 * events we would have gotten rid of by passing delete_ok = true.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldtail</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>oldtail</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>afterTriggerDeleteHeadEventChunk</name><argument_list>(<argument><expr><name>qs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Release query-level-local storage, including tuplestores if any */</comment>
	<expr_stmt><expr><call><name>AfterTriggerFreeQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AfterTriggerFreeQuery
 *	Release subsidiary storage for a trigger query level.
 *	This includes closing down tuplestores.
 *	Note: it's important for this to be safe if interrupted by an error
 *	and then called again for the same query level.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AfterTriggerFreeQuery</name><parameter_list>(<parameter><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Drop the trigger events */</comment>
	<expr_stmt><expr><call><name>afterTriggerFreeEventList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qs</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop FDW tuplestore if any */</comment>
	<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>qs</name><operator>-&gt;</operator><name>fdw_tuplestore</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>fdw_tuplestore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release per-table subsidiary storage */</comment>
	<expr_stmt><expr><name>tables</name> <operator>=</operator> <name><name>qs</name><operator>-&gt;</operator><name>tables</name></name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tables</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><operator>(</operator><name>AfterTriggersTableData</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>old_tuplestore</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>old_tuplestore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>new_tuplestore</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>new_tuplestore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>storeslot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>storeslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now free the AfterTriggersTableData structs and list cells.  Reset list
	 * pointer first; if list_free_deep somehow gets an error, better to leak
	 * that storage than have an infinite loop.
	 */</comment>
	<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerFireDeferred()
 *
 *	Called just before the current transaction is committed. At this
 *	time we invoke all pending DEFERRED triggers.
 *
 *	It is possible for other modules to queue additional deferred triggers
 *	during pre-commit processing; therefore xact.c may have to call this
 *	multiple times.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerFireDeferred</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>snap_pushed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Must not be inside a query */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any triggers to fire, make sure we have set a snapshot for
	 * them to use.  (Since PortalRunUtility doesn't set a snap for COMMIT, we
	 * can't assume ActiveSnapshot is valid on entry.)
	 */</comment>
	<expr_stmt><expr><name>events</name> <operator>=</operator> <operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>events</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>events</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snap_pushed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Run all the remaining triggers.  Loop until they are all gone, in case
	 * some trigger queues more for us to do.
	 */</comment>
	<while>while <condition>(<expr><call><name>afterTriggerMarkEvents</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommandId</name></type>	<name>firing_id</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>afterTriggerInvokeEvents</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>firing_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* all fired */</comment>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We don't bother freeing the event list, since it will go away anyway
	 * (and more efficiently than via pfree) in AfterTriggerEndXact.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>snap_pushed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerEndXact()
 *
 *	The current transaction is finishing.
 *
 *	Any unfired triggers are canceled so we simply throw
 *	away anything we know.
 *
 *	Note: it is possible for this to be called repeatedly in case of
 *	error during transaction abort; therefore, do not complain if
 *	already closed down.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerEndXact</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Forget the pending-events list.
	 *
	 * Since all the info is in TopTransactionContext or children thereof, we
	 * don't really need to do anything to reclaim memory.  However, the
	 * pending-events list could be large, and so it's useful to discard it as
	 * soon as possible --- especially if we are aborting because we ran out
	 * of memory for the list!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>event_cxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>events</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>events</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>events</name><operator>.</operator><name>tailfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Forget any subtransaction state as well.  Since this can't be very
	 * large, we let the eventual reset of TopTransactionContext free the
	 * memory instead of doing it here.
	 */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


	<comment type="block">/*
	 * Forget the query stack and constraint-related state information.  As
	 * with the subtransaction state information, we don't bother freeing the
	 * memory here.
	 */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* No more afterTriggers manipulation until next transaction starts. */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AfterTriggerBeginSubXact()
 *
 *	Start a subtransaction.
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerBeginSubXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate more space in the trans_stack if needed.  (Note: because the
	 * minimum nest level of a subtransaction is 2, we waste the first couple
	 * entries of the array; not worth the notational effort to avoid it.)
	 */</comment>
	<while>while <condition>(<expr><name>my_level</name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Arbitrarily initialize for max of 8 subtransaction levels */</comment>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name></name> <operator>=</operator> <operator>(</operator><name>AfterTriggersTransData</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
								   <argument><expr><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggersTransData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* repalloc will keep the stack in the same context */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_alloc</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name></name> <operator>=</operator> <operator>(</operator><name>AfterTriggersTransData</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name></name></expr></argument>,
						 <argument><expr><name>new_alloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggersTransData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name> <operator>=</operator> <name>new_alloc</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Push the current information into the stack.  The SET CONSTRAINTS state
	 * is not saved until/unless changed.  Likewise, we don't make a
	 * per-subtransaction event context until needed.
	 */</comment>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>events</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>query_depth</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>firing_counter</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AfterTriggerEndSubXact()
 *
 *	The current subtransaction is ending.
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerEndSubXact</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>subxact_firing_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pop the prior state if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>my_level</name> <operator>&lt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If we saved a prior state, we don't need it anymore */</comment>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* this avoids double pfree if error later: */</comment>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>==</operator>
			   <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>query_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Aborting.  It is possible subxact start failed before calling
		 * AfterTriggerBeginSubXact, in which case we mustn't risk touching
		 * trans_stack levels that aren't there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>my_level</name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxtransdepth</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Release query-level storage for queries being aborted, and restore
		 * query_depth to its pre-subxact value.  This assumes that a
		 * subtransaction will not add events to query levels started in a
		 * earlier transaction state.
		 */</comment>
		<while>while <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>query_depth</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&lt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>AfterTriggerFreeQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>==</operator>
			   <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>query_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restore the global deferred-event list to its former length,
		 * discarding any events queued by the subxact.
		 */</comment>
		<expr_stmt><expr><call><name>afterTriggerRestoreEventList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>events</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restore the trigger state.  If the saved state is NULL, then this
		 * subxact didn't save it, so it doesn't need restoring.
		 */</comment>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* this avoids double pfree if error later: */</comment>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan for any remaining deferred events that were marked DONE or IN
		 * PROGRESS by this subxact or a child, and un-mark them. We can
		 * recognize such events because they have a firing ID greater than or
		 * equal to the firing_counter value we saved at subtransaction start.
		 * (This essentially assumes that the current subxact includes all
		 * subxacts started after it.)
		 */</comment>
		<expr_stmt><expr><name>subxact_firing_id</name> <operator>=</operator> <name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>firing_counter</name></expr>;</expr_stmt>
		<macro><name>for_each_event_chunk</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>, <argument>afterTriggers.events</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator>
				<operator>(</operator><name>AFTER_TRIGGER_DONE</name> <operator>|</operator> <name>AFTER_TRIGGER_IN_PROGRESS</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_firing_id</name></name> <operator>&gt;=</operator> <name>subxact_firing_id</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;=</operator>
						<operator>~</operator><operator>(</operator><name>AFTER_TRIGGER_DONE</name> <operator>|</operator> <name>AFTER_TRIGGER_IN_PROGRESS</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * AfterTriggerEnlargeQueryState()
 *
 *	Prepare the necessary state so that we can record AFTER trigger events
 *	queued by a query.  It is allowed to have nested queries within a
 *	(sub)transaction, so we need to have separate state for each query
 *	nesting level.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AfterTriggerEnlargeQueryState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>init_depth</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_alloc</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name></name> <operator>=</operator> <operator>(</operator><name>AfterTriggersQueryData</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><name>new_alloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggersQueryData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name> <operator>=</operator> <name>new_alloc</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* repalloc will keep the stack in the same context */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>old_alloc</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_alloc</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><name>old_alloc</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name></name> <operator>=</operator> <operator>(</operator><name>AfterTriggersQueryData</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name></name></expr></argument>,
					 <argument><expr><name>new_alloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AfterTriggersQueryData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name> <operator>=</operator> <name>new_alloc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize new array entries to empty */</comment>
	<while>while <condition>(<expr><name>init_depth</name> <operator>&lt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name> <init>= <expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name>init_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>tailfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>fdw_tuplestore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qs</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name>init_depth</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Create an empty SetConstraintState with room for numalloc trigstates
 */</comment>
<function><type><specifier>static</specifier> <name>SetConstraintState</name></type>
<name>SetConstraintStateCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numalloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/* Behave sanely with numalloc == 0 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numalloc</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numalloc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We assume that zeroing will correctly initialize the state values.
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>SetConstraintState</name><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SetConstraintStateData</name></expr></argument>, <argument><expr><name>trigstates</name></expr></argument>)</argument_list></call> <operator>+</operator>
							   <name>numalloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SetConstraintTriggerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>numalloc</name></name> <operator>=</operator> <name>numalloc</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy a SetConstraintState
 */</comment>
<function><type><specifier>static</specifier> <name>SetConstraintState</name></type>
<name>SetConstraintStateCopy</name><parameter_list>(<parameter><decl><type><name>SetConstraintState</name></type> <name>origstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>SetConstraintStateCreate</name><argument_list>(<argument><expr><name><name>origstate</name><operator>-&gt;</operator><name>numstates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>all_isset</name></name> <operator>=</operator> <name><name>origstate</name><operator>-&gt;</operator><name>all_isset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>all_isdeferred</name></name> <operator>=</operator> <name><name>origstate</name><operator>-&gt;</operator><name>all_isdeferred</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name> <operator>=</operator> <name><name>origstate</name><operator>-&gt;</operator><name>numstates</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name></name></expr></argument>, <argument><expr><name><name>origstate</name><operator>-&gt;</operator><name>trigstates</name></name></expr></argument>,
		   <argument><expr><name><name>origstate</name><operator>-&gt;</operator><name>numstates</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SetConstraintTriggerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a per-trigger item to a SetConstraintState.  Returns possibly-changed
 * pointer to the state object (it will change if we have to repalloc).
 */</comment>
<function><type><specifier>static</specifier> <name>SetConstraintState</name></type>
<name>SetConstraintStateAddItem</name><parameter_list>(<parameter><decl><type><name>SetConstraintState</name></type> <name>state</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>tgoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tgisdeferred</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>numalloc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newalloc</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>numalloc</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newalloc</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newalloc</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* in case original has size 0 */</comment>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>SetConstraintState</name><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
					 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SetConstraintStateData</name></expr></argument>, <argument><expr><name>trigstates</name></expr></argument>)</argument_list></call> <operator>+</operator>
					 <name>newalloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SetConstraintTriggerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>numalloc</name></name> <operator>=</operator> <name>newalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>numalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name></expr>]</index></name><operator>.</operator><name>sct_tgoid</name> <operator>=</operator> <name>tgoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name></expr>]</index></name><operator>.</operator><name>sct_tgisdeferred</name> <operator>=</operator> <name>tgisdeferred</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>numstates</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * AfterTriggerSetState()
 *
 *	Execute the SET CONSTRAINTS ... utility command.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>AfterTriggerSetState</name><parameter_list>(<parameter><decl><type><name>ConstraintsSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we haven't already done so, initialize our state. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>=</operator> <call><name>SetConstraintStateCreate</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If in a subtransaction, and we didn't save the current state already,
	 * save it so it can be restored if the subtransaction aborts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>my_level</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>trans_stack</name><index>[<expr><name>my_level</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator>
			<call><name>SetConstraintStateCopy</name><argument_list>(<argument><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Handle SET CONSTRAINTS ALL ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Forget any previous SET CONSTRAINTS commands in this transaction.
		 */</comment>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>numstates</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set the per-transaction ALL state to known.
		 */</comment>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>all_isset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>all_isdeferred</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>deferred</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>conoidlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tgoidlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Handle SET CONSTRAINTS constraint-name [, ...]
		 *
		 * First, identify all the named constraints and make a list of their
		 * OIDs.  Since, unlike the SQL spec, we allow multiple constraints of
		 * the same name within a schema, the specifications are not
		 * necessarily unique.  Our strategy is to target all matching
		 * constraints within the first search-path schema that has any
		 * matches, but disregard matches in schemas beyond the first match.
		 * (This is a bit odd but it's the historical behavior.)
		 *
		 * A constraint in a partitioned table may have corresponding
		 * constraints in the partitions.  Grab those too.
		 */</comment>
		<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;constraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namespacelist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nslc</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>catalogname</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: \"%s.%s.%s\""</literal></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
									<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we're given the schema name with the constraint, look only
			 * in that schema.  If given a bare constraint name, use the
			 * search path to find the first matching constraint.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
																  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>namespacelist</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>namespacelist</name> <operator>=</operator> <call><name>fetch_search_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>nslc</argument>, <argument>namespacelist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>nslc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
							<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
							<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name>Anum_pg_constraint_connamespace</name></expr></argument>,
							<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintNameNspIndexId</name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>conoidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>conoidlist</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>deferred</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" is not deferrable"</literal></expr></argument>,
										<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></while>

				<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Once we've found a matching constraint we do not search
				 * later parts of the search path.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namespacelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Not found ?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Scan for any possible descendants of the constraints.  We append
		 * whatever we find to the same list that we're scanning; this has the
		 * effect that we create new scans for those, too, so if there are
		 * further descendents, we'll also catch them.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>conoidlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>parent</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
						<argument><expr><name>Anum_pg_constraint_conparentid</name></expr></argument>,
						<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>conoidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>conoidlist</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now, locate the trigger(s) implementing each of these constraints,
		 * and make a list of their OIDs.
		 */</comment>
		<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>conoidlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>conoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
						<argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
						<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>pg_trigger</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Silently skip triggers that are marked as non-deferrable in
				 * pg_trigger.  This is not an error condition, since a
				 * deferrable RI constraint may have some non-deferrable
				 * actions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pg_trigger</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tgoidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>tgoidlist</name></expr></argument>, <argument><expr><name><name>pg_trigger</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can set the trigger states of individual triggers for this
		 * xact.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tgoidlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tgoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SetConstraintState</name></type> <name>state</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>numstates</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sct_tgoid</name> <operator>==</operator> <name>tgoid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>trigstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sct_tgisdeferred</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>deferred</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>afterTriggers</name><operator>.</operator><name>state</name></name> <operator>=</operator>
					<call><name>SetConstraintStateAddItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tgoid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * SQL99 requires that when a constraint is set to IMMEDIATE, any deferred
	 * checks against that constraint must be made when the SET CONSTRAINTS
	 * command is executed -- i.e. the effects of the SET CONSTRAINTS command
	 * apply retroactively.  We've updated the constraints state, so scan the
	 * list of previously deferred events to fire any that have now become
	 * immediate.
	 *
	 * Obviously, if this was SET ... DEFERRED then it can't have converted
	 * any unfired events to immediate, so we need do nothing in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>deferred</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggerEventList</name> <modifier>*</modifier></type><name>events</name> <init>= <expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>events</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>afterTriggerMarkEvents</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommandId</name></type>	<name>firing_id</name> <init>= <expr><name><name>afterTriggers</name><operator>.</operator><name>firing_counter</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Make sure a snapshot has been established in case trigger
			 * functions need one.  Note that we avoid setting a snapshot if
			 * we don't find at least one trigger that has to be fired now.
			 * This is so that BEGIN; SET CONSTRAINTS ...; SET TRANSACTION
			 * ISOLATION LEVEL SERIALIZABLE; ... works properly.  (If we are
			 * at the start of a transaction it's not possible for any trigger
			 * events to be queued yet.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>snapshot_set</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We can delete fired events if we are at top transaction level,
			 * but we'd better not if inside a subtransaction, since the
			 * subtransaction could later get rolled back.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>afterTriggerInvokeEvents</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>firing_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>!</operator><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* all fired */</comment>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * AfterTriggerPendingOnRel()
 *		Test to see if there are any pending after-trigger events for rel.
 *
 * This is used by TRUNCATE, CLUSTER, ALTER TABLE, etc to detect whether
 * it is unsafe to perform major surgery on a relation.  Note that only
 * local pending events are examined.  We assume that having exclusive lock
 * on a rel guarantees there are no unserviced events in other backends ---
 * but having a lock does not prevent there being such events in our own.
 *
 * In some scenarios it'd be reasonable to remove pending events (more
 * specifically, mark them DONE by the current subxact) but without a lot
 * of knowledge of the trigger semantics we can't do this in general.
 * ----------
 */</comment>
<function><type><name>bool</name></type>
<name>AfterTriggerPendingOnRel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name></decl>;</decl_stmt>

	<comment type="block">/* Scan queued events */</comment>
	<macro><name>for_each_event_chunk</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>, <argument>afterTriggers.events</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can ignore completed events.  (Even if a DONE flag is rolled
		 * back by subxact abort, it's OK because the effects of the TRUNCATE
		 * or whatever must get rolled back too.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_DONE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Also scan events queued by incomplete queries.  This could only matter
	 * if TRUNCATE/etc is executed by a function or trigger within an updating
	 * query on the same relation, which is pretty perverse, but let's check.
	 */</comment>
	<for>for <control>(<init><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>depth</name> <operator>&lt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&lt;</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>;</condition> <incr><expr><name>depth</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>for_each_event_chunk</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>, <argument>afterTriggers.query_stack[depth].events</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;</operator> <name>AFTER_TRIGGER_DONE</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * AfterTriggerSaveEvent()
 *
 *	Called by ExecA[RS]...Triggers() to queue up the triggers that should
 *	be fired for an event.
 *
 *	NOTE: this is called whenever there are any triggers associated with
 *	the event (even if they are disabled).  This function decides which
 *	triggers actually need to be queued.  It is also called after each row,
 *	even if there are no triggers for that event, if there are any AFTER
 *	STATEMENT triggers for the statement which use transition tables, so that
 *	the transition tuplestores can be built.  Furthermore, if the transition
 *	capture is happening for UPDATEd rows being moved to another partition due
 *	to the partition-key being changed, then this function is called once when
 *	the row is deleted (to capture OLD row), and once when the row is inserted
 *	into another partition (to capture NEW row).  This is done separately because
 *	DELETE and INSERT happen on different tables.
 *
 *	Transition tuplestores are built now, rather than when events are pulled
 *	off of the queue because AFTER ROW triggers are allowed to select from the
 *	transition tables for the statement.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AfterTriggerSaveEvent</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>row_trigger</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
					  <parameter><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>transition_capture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerEventData</name></type> <name>new_event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggerSharedData</name></type> <name>new_shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tgtype_event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tgtype_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>fdw_tuplestore</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check state.  We use a normal test not Assert because it is possible to
	 * reach here in the wrong state given misconfigured RI triggers, in
	 * particular deferring a cascade action trigger.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AfterTriggerSaveEvent() called outside of query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure we have enough space to record events at this query depth. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerEnlargeQueryState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the directly named relation has any triggers with transition tables,
	 * then we need to capture transition tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>row_trigger</name> <operator>&amp;&amp;</operator> <name>transition_capture</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>original_insert_tuple</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>delete_old_table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_delete_old_table</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>update_old_table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>update_new_table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>insert_new_table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_insert_new_table</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For INSERT events NEW should be non-NULL, for DELETE events OLD
		 * should be non-NULL, whereas for UPDATE events normally both OLD and
		 * NEW are non-NULL.  But for UPDATE events fired for capturing
		 * transition tuples during UPDATE partition-key row movement, OLD is
		 * NULL when the event is for a row being inserted, whereas NEW is
		 * NULL when the event is for a row being deleted.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>&amp;&amp;</operator> <name>delete_old_table</name> <operator>&amp;&amp;</operator>
				 <call><name>TupIsNull</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>&amp;&amp;</operator> <name>insert_new_table</name> <operator>&amp;&amp;</operator>
				 <call><name>TupIsNull</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>&amp;&amp;</operator> <name>delete_old_table</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>&amp;&amp;</operator> <name>update_old_table</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>old_tuplestore</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>old_tuplestore</name> <operator>=</operator> <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_private</name><operator>-&gt;</operator><name>old_tuplestore</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_private</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>storeslot</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>storeslot</name> <operator>=</operator> <call><name>GetAfterTriggersStoreSlot</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>storeslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>old_tuplestore</name></expr></argument>, <argument><expr><name>storeslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>old_tuplestore</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>&amp;&amp;</operator> <name>insert_new_table</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>&amp;&amp;</operator> <name>update_new_table</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>new_tuplestore</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_tuplestore</name> <operator>=</operator> <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_private</name><operator>-&gt;</operator><name>new_tuplestore</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>original_insert_tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>new_tuplestore</name></expr></argument>,
										<argument><expr><name>original_insert_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_private</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>storeslot</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>storeslot</name> <operator>=</operator> <call><name>GetAfterTriggersStoreSlot</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>storeslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>new_tuplestore</name></expr></argument>, <argument><expr><name>storeslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>new_tuplestore</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If transition tables are the only reason we're here, return. As
		 * mentioned above, we can also be here during update tuple routing in
		 * presence of transition tables, in which case this function is
		 * called separately for oldtup and newtup, so we expect exactly one
		 * of them to be NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_DELETE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_UPDATE</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>TupIsNull</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate the event code and collect the associated tuple CTIDs.
	 *
	 * The event code will be used both as a bitmask and an array offset, so
	 * validation is important to make sure we don't walk off the edge of our
	 * arrays.
	 *
	 * Also, if we're considering statement-level triggers, check whether we
	 * already queued a set of them for this event, and cancel the prior set
	 * if so.  This preserves the behavior that statement-level triggers fire
	 * just once per statement and fire after row-level triggers.
	 */</comment>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TRIGGER_EVENT_INSERT</name></expr>:</case>
			<expr_stmt><expr><name>tgtype_event</name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>row_trigger</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newslot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cancel_prior_stmt_triggers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>CMD_INSERT</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TRIGGER_EVENT_DELETE</name></expr>:</case>
			<expr_stmt><expr><name>tgtype_event</name> <operator>=</operator> <name>TRIGGER_TYPE_DELETE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>row_trigger</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldslot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cancel_prior_stmt_triggers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>CMD_DELETE</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TRIGGER_EVENT_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name>tgtype_event</name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>row_trigger</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldslot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newslot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cancel_prior_stmt_triggers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>CMD_UPDATE</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TRIGGER_EVENT_TRUNCATE</name></expr>:</case>
			<expr_stmt><expr><name>tgtype_event</name> <operator>=</operator> <name>TRIGGER_TYPE_TRUNCATE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newslot</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_event</name><operator>.</operator><name>ate_ctid2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid after-trigger event code: %d"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tgtype_event</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name>row_trigger</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_event</name><operator>.</operator><name>ate_flags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>row_trigger</name> <operator>&amp;&amp;</operator> <name>event</name> <operator>==</operator> <name>TRIGGER_EVENT_UPDATE</name><operator>)</operator></expr> ?</condition><then>
			<expr><name>AFTER_TRIGGER_2CTID</name></expr> </then><else>: <expr><name>AFTER_TRIGGER_1CTID</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* else, we'll initialize ate_flags for each trigger */</comment>

	<expr_stmt><expr><name>tgtype_level</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>row_trigger</name></expr> ?</condition><then> <expr><name>TRIGGER_TYPE_ROW</name></expr> </then><else>: <expr><name>TRIGGER_TYPE_STATEMENT</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>tgtype_level</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_AFTER</name></expr></argument>,
								  <argument><expr><name>tgtype_event</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TriggerEnabled</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>event</name></expr></argument>,
							<argument><expr><name>modifiedCols</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name>row_trigger</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>fdw_tuplestore</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fdw_tuplestore</name> <operator>=</operator> <call><name>GetCurrentFDWTuplestore</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_event</name><operator>.</operator><name>ate_flags</name></name> <operator>=</operator> <name>AFTER_TRIGGER_FDW_FETCH</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<comment type="block">/* subsequent event for the same tuple */</comment>
				<expr_stmt><expr><name><name>new_event</name><operator>.</operator><name>ate_flags</name></name> <operator>=</operator> <name>AFTER_TRIGGER_FDW_REUSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the trigger is a foreign key enforcement trigger, there are
		 * certain cases where we can skip queueing the event because we can
		 * tell by inspection that the FK constraint will still pass.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>RI_FKey_trigger_type</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RI_TRIGGER_PK</name></expr>:</case>
					<comment type="block">/* Update or delete on trigger's PK table */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RI_FKey_pk_upd_check_required</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													   <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* skip queuing this event */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RI_TRIGGER_FK</name></expr>:</case>
					<comment type="block">/* Update on trigger's FK table */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RI_FKey_fk_upd_check_required</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													   <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* skip queuing this event */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RI_TRIGGER_NONE</name></expr>:</case>
					<comment type="block">/* Not an FK trigger */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the trigger is a deferred unique constraint check trigger, only
		 * queue it if the unique constraint was potentially violated, which
		 * we know from index insertion time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>==</operator> <name>F_UNIQUE_KEY_RECHECK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgconstrindid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* Uniqueness definitely not violated */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Fill in event structure and add it to the current query's queue.
		 * Note we set ats_table to NULL whenever this trigger doesn't use
		 * transition tables, to improve sharability of the shared event data.
		 */</comment>
		<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_event</name></name> <operator>=</operator>
			<operator>(</operator><name>event</name> <operator>&amp;</operator> <name>TRIGGER_EVENT_OPMASK</name><operator>)</operator> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><name>row_trigger</name></expr> ?</condition><then> <expr><name>TRIGGER_EVENT_ROW</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr> ?</condition><then> <expr><name>AFTER_TRIGGER_DEFERRABLE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><name><name>trigger</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr> ?</condition><then> <expr><name>AFTER_TRIGGER_INITDEFERRED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_tgoid</name></name> <operator>=</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_firing_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name> <operator>||</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>transition_capture</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_table</name></name> <operator>=</operator> <name><name>transition_capture</name><operator>-&gt;</operator><name>tcs_private</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>new_shared</name><operator>.</operator><name>ats_modifiedcols</name></name> <operator>=</operator> <name>modifiedCols</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>afterTriggerAddEvent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name><operator>.</operator><name>events</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>new_event</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Finally, spool any foreign tuple(s).  The tuplestore squashes them to
	 * minimal tuples, so this loses any system columns.  The executor lost
	 * those columns before us, for an unrelated reason, so this is fine.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdw_tuplestore</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>oldslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>fdw_tuplestore</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>newslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>fdw_tuplestore</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether we already queued BEFORE STATEMENT triggers for the given
 * relation + operation, and set the flag so the next call will report "true".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>before_stmt_triggers_fired</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>

	<comment type="block">/* Check state, like AfterTriggerSaveEvent. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"before_stmt_triggers_fired() called outside of query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure we have enough space to record events at this query depth. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name> <operator>&gt;=</operator> <name><name>afterTriggers</name><operator>.</operator><name>maxquerydepth</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerEnlargeQueryState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We keep this state in the AfterTriggersTableData that also holds
	 * transition tables for the relation + operation.  In this way, if we are
	 * forced to make a new set of transition tables because more tuples get
	 * entered after we've already fired triggers, we will allow a new set of
	 * statement triggers to get queued.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetAfterTriggersTableData</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>cmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>before_trig_done</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>before_trig_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If we previously queued a set of AFTER STATEMENT triggers for the given
 * relation + operation, and they've not been fired yet, cancel them.  The
 * caller will queue a fresh set that's after any row-level triggers that may
 * have been queued by the current sub-statement, preserving (as much as
 * possible) the property that AFTER ROW triggers fire before AFTER STATEMENT
 * triggers, and that the latter only fire once.  This deals with the
 * situation where several FK enforcement triggers sequentially queue triggers
 * for the same table into the same trigger query level.  We can't fully
 * prevent odd behavior though: if there are AFTER ROW triggers taking
 * transition tables, we don't want to change the transition tables once the
 * first such trigger has seen them.  In such a case, any additional events
 * will result in creating new transition tables and allowing new firings of
 * statement triggers.
 *
 * This also saves the current event list location so that a later invocation
 * of this function can cheaply find the triggers we're about to queue and
 * cancel them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cancel_prior_stmt_triggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tgevent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AfterTriggersTableData</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AfterTriggersQueryData</name> <modifier>*</modifier></type><name>qs</name> <init>= <expr><operator>&amp;</operator><name><name>afterTriggers</name><operator>.</operator><name>query_stack</name><index>[<expr><name><name>afterTriggers</name><operator>.</operator><name>query_depth</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We keep this state in the AfterTriggersTableData that also holds
	 * transition tables for the relation + operation.  In this way, if we are
	 * forced to make a new set of transition tables because more tuples get
	 * entered after we've already fired triggers, we will allow a new set of
	 * statement triggers to get queued without canceling the old ones.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetAfterTriggersTableData</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>cmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We want to start scanning from the tail location that existed just
		 * before we inserted any statement triggers.  But the events list
		 * might've been entirely empty then, in which case scan from the
		 * current head.
		 */</comment>
		<decl_stmt><decl><type><name>AfterTriggerEvent</name></type> <name>event</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AfterTriggerEventChunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tail</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tail</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>event</name> <operator>=</operator> <operator>(</operator><name>AfterTriggerEvent</name><operator>)</operator> <name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name><operator>.</operator><name>tailfree</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>qs</name><operator>-&gt;</operator><name>events</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>event</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<macro><name>for_each_chunk_from</name><argument_list>(<argument>chunk</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>event</name> <operator>=</operator> <operator>(</operator><name>AfterTriggerEvent</name><operator>)</operator> <call><name>CHUNK_DATA_START</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<macro><name>for_each_event_from</name><argument_list>(<argument>event</argument>, <argument>chunk</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AfterTriggerShared</name></type> <name>evtshared</name> <init>= <expr><call><name>GetTriggerSharedData</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Exit loop when we reach events that aren't AS triggers for
				 * the target relation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_relid</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name> <operator>&amp;</operator> <name>TRIGGER_EVENT_OPMASK</name><operator>)</operator> <operator>!=</operator> <name>tgevent</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>evtshared</name><operator>-&gt;</operator><name>ats_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
				<comment type="block">/* OK, mark it DONE */</comment>
				<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>AFTER_TRIGGER_IN_PROGRESS</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>ate_flags</name></name> <operator>|=</operator> <name>AFTER_TRIGGER_DONE</name></expr>;</expr_stmt>
			</block_content>}</block>
			<comment type="block">/* signal we must reinitialize event ptr for next chunk */</comment>
			<expr_stmt><expr><name>event</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
<label><name>done</name>:</label>

	<comment type="block">/* In any case, save current insertion point for next time */</comment>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>after_trig_events</name></name> <operator>=</operator> <name><name>qs</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function pg_trigger_depth()
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_trigger_depth</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>MyTriggerDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
