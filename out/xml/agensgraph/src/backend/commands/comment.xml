<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/comment.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * comment.c
 *
 * PostgreSQL object comments utility code.
 *
 * Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/commands/comment.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_description.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdescription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 * CommentObject --
 *
 * This routine is used to add the associated comment into
 * pg_description for the object specified by the given SQL command.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CommentObject</name><parameter_list>(<parameter><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When loading a dump, we may see a COMMENT ON DATABASE for the old name
	 * of the database.  Erroring out would prevent pg_restore from completing
	 * (which is really pg_restore's fault, but for now we will work around
	 * the problem here).  Consensus is that the best fix is to treat wrong
	 * database name as a WARNING not an ERROR; hence, the following special
	 * case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_DATABASE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>database</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>address</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Translate the parser representation that identifies this object into an
	 * ObjectAddress.  get_object_address() will throw an error if the object
	 * does not exist, and will also acquire a lock on the target to guard
	 * against concurrent DROP operations.
	 */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>get_object_address</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>relation</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Require ownership of the target object. */</comment>
	<expr_stmt><expr><call><name>check_object_ownership</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name>address</name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform other integrity checks as needed. */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>

			<comment type="block">/*
			 * Allow comments only on columns of tables, views, materialized
			 * views, composite types, and foreign tables (which are the only
			 * relkinds for which pg_dump will dump per-column comments).  In
			 * particular we wish to disallow comments on index columns,
			 * because the naming of an index's columns may change across PG
			 * versions, so dumping per-column comments could create reload
			 * failures.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
				<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
				<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
				<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
				<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
				<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, or foreign table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Databases, tablespaces, and roles are cluster-wide objects, so any
	 * comments on those objects are recorded in the shared pg_shdescription
	 * catalog.  Comments on all other objects are recorded in pg_description.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_DATABASE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLESPACE</name>
		<operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_ROLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateSharedComments</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateComments</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>address</name><operator>.</operator><name>objectSubId</name></name></expr></argument>,
					   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If get_object_address() opened the relation for us, we close it to keep
	 * the reference count correct - but we retain any locks acquired by
	 * get_object_address() until commit time, to guard against concurrent
	 * activity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateComments --
 *
 * Create a comment for the specified object descriptor.  Inserts a new
 * pg_description tuple, or replaces an existing one with the same key.
 *
 * If the comment given is null or an empty string, instead delete any
 * existing comment for the specified key.
 */</comment>
<function><type><name>void</name></type>
<name>CreateComments</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>description</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_description</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_description</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_description</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Reduce empty-string to NULL case */</comment>
	<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>comment</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare to form or update a tuple, if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_description</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_description_objoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_description_classoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_description_objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_description_description</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use the index to search for a matching old tuple */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>description</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DescriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>DescriptionObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found the old tuple, so delete or update it */</comment>

		<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
										 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<break>break;</break>					<comment type="block">/* Assume there can be only one match */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we didn't find an old tuple, insert a new one */</comment>

	<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>comment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Done */</comment>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CreateSharedComments --
 *
 * Create a comment for the specified shared object descriptor.  Inserts a
 * new pg_shdescription tuple, or replaces an existing one with the same key.
 *
 * If the comment given is null or an empty string, instead delete any
 * existing comment for the specified key.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSharedComments</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>shdescription</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_shdescription</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_shdescription</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_shdescription</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Reduce empty-string to NULL case */</comment>
	<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>comment</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare to form or update a tuple, if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_shdescription</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdescription_objoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdescription_classoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdescription_description</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use the index to search for a matching old tuple */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdescription_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdescription_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shdescription</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDescriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><name>SharedDescriptionObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found the old tuple, so delete or update it */</comment>

		<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<break>break;</break>					<comment type="block">/* Assume there can be only one match */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we didn't find an old tuple, insert a new one */</comment>

	<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>comment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Done */</comment>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DeleteComments -- remove comments for an object
 *
 * If subid is nonzero then only comments matching it will be removed.
 * If subid is zero, all comments matching the oid/classoid will be removed
 * (this corresponds to deleting a whole object).
 */</comment>
<function><type><name>void</name></type>
<name>DeleteComments</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>subid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>description</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

	<comment type="block">/* Use the index to search for all matching old tuples */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>subid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_description_objsubid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>description</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DescriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>DescriptionObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Done */</comment>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DeleteSharedComments -- remove comments for a shared object
 */</comment>
<function><type><name>void</name></type>
<name>DeleteSharedComments</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>shdescription</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

	<comment type="block">/* Use the index to search for all matching old tuples */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdescription_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdescription_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shdescription</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDescriptionRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><name>SharedDescriptionObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Done */</comment>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>shdescription</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetComment -- get the comment for an object, or null if not found.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetComment</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>subid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>description</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>

	<comment type="block">/* Use the index to search for a matching old tuple */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_description_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>subid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>description</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DescriptionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>DescriptionObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>comment</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* Found the tuple, get description field */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_description_description</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<break>break;</break>					<comment type="block">/* Assume there can be only one match */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>description</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>comment</name></expr>;</return>
</block_content>}</block></function>
</unit>
