<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/datetime.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * datetime.c
 *	  Support functions for date/time types.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/datetime.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tzparser.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DecodeNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>haveTextMonth</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DecodeNumberField</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>,
							  <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DecodeTime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>range</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>datebsearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DecodeDate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>AppendSeconds</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fillzeros</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustFractSeconds</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustFractDays</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DetermineTimeZoneOffsetInternal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>,
											<parameter><decl><type><name>pg_time_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DetermineTimeZoneAbbrevOffsetInternal</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>t</name></decl></parameter>,
												  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>,
												  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>isdst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>FetchDynamicTimeZone</name><parameter_list>(<parameter><decl><type><name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>day_tab</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">13</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>months</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"Jan"</literal></expr>, <expr><literal type="string">"Feb"</literal></expr>, <expr><literal type="string">"Mar"</literal></expr>, <expr><literal type="string">"Apr"</literal></expr>, <expr><literal type="string">"May"</literal></expr>, <expr><literal type="string">"Jun"</literal></expr>,
<expr><literal type="string">"Jul"</literal></expr>, <expr><literal type="string">"Aug"</literal></expr>, <expr><literal type="string">"Sep"</literal></expr>, <expr><literal type="string">"Oct"</literal></expr>, <expr><literal type="string">"Nov"</literal></expr>, <expr><literal type="string">"Dec"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>days</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"Sunday"</literal></expr>, <expr><literal type="string">"Monday"</literal></expr>, <expr><literal type="string">"Tuesday"</literal></expr>, <expr><literal type="string">"Wednesday"</literal></expr>,
<expr><literal type="string">"Thursday"</literal></expr>, <expr><literal type="string">"Friday"</literal></expr>, <expr><literal type="string">"Saturday"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 PRIVATE ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * datetktbl holds date/time keywords.
 *
 * Note that this table must be strictly alphabetically ordered to allow an
 * O(ln(N)) search algorithm to be used.
 *
 * The token field must be NUL-terminated; we truncate entries to TOKMAXLEN
 * characters to fit.
 *
 * The static table contains no TZ, DTZ, or DYNTZ entries; rather those
 * are loaded from configuration files and stored in zoneabbrevtbl, whose
 * abbrevs[] field has the same format as the static datetktbl.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name></type> <name><name>datetktbl</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* token, type, value */</comment>
	<expr><block>{<expr><name>EARLY</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_EARLY</name></expr>}</block></expr>, <comment type="block">/* "-infinity" reserved for "early time" */</comment>
	<expr><block>{<expr><name>DA_D</name></expr>, <expr><name>ADBC</name></expr>, <expr><name>AD</name></expr>}</block></expr>,			<comment type="block">/* "ad" for years &gt; 0 */</comment>
	<expr><block>{<expr><literal type="string">"allballs"</literal></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_ZULU</name></expr>}</block></expr>, <comment type="block">/* 00:00:00 */</comment>
	<expr><block>{<expr><literal type="string">"am"</literal></expr>, <expr><name>AMPM</name></expr>, <expr><name>AM</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"apr"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"april"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"at"</literal></expr>, <expr><name>IGNORE_DTF</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,		<comment type="block">/* "at" (throwaway) */</comment>
	<expr><block>{<expr><literal type="string">"aug"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"august"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
	<expr><block>{<expr><name>DB_C</name></expr>, <expr><name>ADBC</name></expr>, <expr><name>BC</name></expr>}</block></expr>,			<comment type="block">/* "bc" for years &lt;= 0 */</comment>
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DAY</name></expr>}</block></expr>,		<comment type="block">/* "day of month" for ISO input */</comment>
	<expr><block>{<expr><literal type="string">"dec"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">12</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"december"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">12</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"dow"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DOW</name></expr>}</block></expr>,	<comment type="block">/* day of week */</comment>
	<expr><block>{<expr><literal type="string">"doy"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DOY</name></expr>}</block></expr>,	<comment type="block">/* day of year */</comment>
	<expr><block>{<expr><literal type="string">"dst"</literal></expr>, <expr><name>DTZMOD</name></expr>, <expr><name>SECS_PER_HOUR</name></expr>}</block></expr>,
	<expr><block>{<expr><name>EPOCH</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_EPOCH</name></expr>}</block></expr>, <comment type="block">/* "epoch" reserved for system epoch time */</comment>
	<expr><block>{<expr><literal type="string">"feb"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"february"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fri"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"friday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>,		<comment type="block">/* "hour" */</comment>
	<expr><block>{<expr><name>LATE</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_LATE</name></expr>}</block></expr>,	<comment type="block">/* "infinity" reserved for "late time" */</comment>
	<expr><block>{<expr><literal type="string">"isodow"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_ISODOW</name></expr>}</block></expr>,	<comment type="block">/* ISO day of week, Sunday == 7 */</comment>
	<expr><block>{<expr><literal type="string">"isoyear"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_ISOYEAR</name></expr>}</block></expr>,	<comment type="block">/* year in terms of the ISO week date */</comment>
	<expr><block>{<expr><literal type="string">"j"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_JULIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"jan"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"january"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"jd"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_JULIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"jul"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"julian"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_JULIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"july"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"jun"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"june"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"m"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MONTH</name></expr>}</block></expr>,	<comment type="block">/* "month" for ISO input */</comment>
	<expr><block>{<expr><literal type="string">"mar"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"march"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"may"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"mm"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>,	<comment type="block">/* "minute" for ISO input */</comment>
	<expr><block>{<expr><literal type="string">"mon"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"monday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"nov"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"november"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,
	<expr><block>{<expr><name>NOW</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_NOW</name></expr>}</block></expr>,		<comment type="block">/* current transaction time */</comment>
	<expr><block>{<expr><literal type="string">"oct"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"october"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>IGNORE_DTF</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,		<comment type="block">/* "on" (throwaway) */</comment>
	<expr><block>{<expr><literal type="string">"pm"</literal></expr>, <expr><name>AMPM</name></expr>, <expr><name>PM</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,	<comment type="block">/* "seconds" for ISO input */</comment>
	<expr><block>{<expr><literal type="string">"sat"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"saturday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sep"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sept"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"september"</literal></expr>, <expr><name>MONTH</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sun"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sunday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"t"</literal></expr>, <expr><name>ISOTIME</name></expr>, <expr><name>DTK_TIME</name></expr>}</block></expr>,	<comment type="block">/* Filler for ISO time fields */</comment>
	<expr><block>{<expr><literal type="string">"thu"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"thur"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"thurs"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"thursday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
	<expr><block>{<expr><name>TODAY</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_TODAY</name></expr>}</block></expr>, <comment type="block">/* midnight */</comment>
	<expr><block>{<expr><name>TOMORROW</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_TOMORROW</name></expr>}</block></expr>,	<comment type="block">/* tomorrow midnight */</comment>
	<expr><block>{<expr><literal type="string">"tue"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tues"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tuesday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"wed"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"wednesday"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"weds"</literal></expr>, <expr><name>DOW</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"y"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>,		<comment type="block">/* "year" for ISO input */</comment>
	<expr><block>{<expr><name>YESTERDAY</name></expr>, <expr><name>RESERV</name></expr>, <expr><name>DTK_YESTERDAY</name></expr>}</block></expr>	<comment type="block">/* yesterday midnight */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>szdatetktbl</name> <init>= <expr><sizeof>sizeof <name>datetktbl</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>datetktbl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * deltatktbl: same format as datetktbl, but holds keywords used to represent
 * time units (eg, for intervals, and for EXTRACT).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name></type> <name><name>deltatktbl</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* token, type, value */</comment>
	<expr><block>{<expr><literal type="string">"@"</literal></expr>, <expr><name>IGNORE_DTF</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,		<comment type="block">/* postgres relative prefix */</comment>
	<expr><block>{<expr><name>DAGO</name></expr>, <expr><name>AGO</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,				<comment type="block">/* "ago" indicates negative time offset */</comment>
	<expr><block>{<expr><literal type="string">"c"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_CENTURY</name></expr>}</block></expr>,	<comment type="block">/* "century" relative */</comment>
	<expr><block>{<expr><literal type="string">"cent"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_CENTURY</name></expr>}</block></expr>,	<comment type="block">/* "century" relative */</comment>
	<expr><block>{<expr><literal type="string">"centuries"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_CENTURY</name></expr>}</block></expr>,	<comment type="block">/* "centuries" relative */</comment>
	<expr><block>{<expr><name>DCENTURY</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_CENTURY</name></expr>}</block></expr>, <comment type="block">/* "century" relative */</comment>
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DAY</name></expr>}</block></expr>,		<comment type="block">/* "day" relative */</comment>
	<expr><block>{<expr><name>DDAY</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DAY</name></expr>}</block></expr>,		<comment type="block">/* "day" relative */</comment>
	<expr><block>{<expr><literal type="string">"days"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DAY</name></expr>}</block></expr>,	<comment type="block">/* "days" relative */</comment>
	<expr><block>{<expr><literal type="string">"dec"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DECADE</name></expr>}</block></expr>, <comment type="block">/* "decade" relative */</comment>
	<expr><block>{<expr><name>DDECADE</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DECADE</name></expr>}</block></expr>,	<comment type="block">/* "decade" relative */</comment>
	<expr><block>{<expr><literal type="string">"decades"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DECADE</name></expr>}</block></expr>, <comment type="block">/* "decades" relative */</comment>
	<expr><block>{<expr><literal type="string">"decs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_DECADE</name></expr>}</block></expr>,	<comment type="block">/* "decades" relative */</comment>
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>,		<comment type="block">/* "hour" relative */</comment>
	<expr><block>{<expr><name>DHOUR</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>,	<comment type="block">/* "hour" relative */</comment>
	<expr><block>{<expr><literal type="string">"hours"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>, <comment type="block">/* "hours" relative */</comment>
	<expr><block>{<expr><literal type="string">"hr"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>,	<comment type="block">/* "hour" relative */</comment>
	<expr><block>{<expr><literal type="string">"hrs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_HOUR</name></expr>}</block></expr>,	<comment type="block">/* "hours" relative */</comment>
	<expr><block>{<expr><literal type="string">"m"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>,	<comment type="block">/* "minute" relative */</comment>
	<expr><block>{<expr><literal type="string">"microsecon"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>,	<comment type="block">/* "microsecond" relative */</comment>
	<expr><block>{<expr><literal type="string">"mil"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLENNIUM</name></expr>}</block></expr>, <comment type="block">/* "millennium" relative */</comment>
	<expr><block>{<expr><literal type="string">"millennia"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLENNIUM</name></expr>}</block></expr>,	<comment type="block">/* "millennia" relative */</comment>
	<expr><block>{<expr><name>DMILLENNIUM</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLENNIUM</name></expr>}</block></expr>,	<comment type="block">/* "millennium" relative */</comment>
	<expr><block>{<expr><literal type="string">"millisecon"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,	<comment type="block">/* relative */</comment>
	<expr><block>{<expr><literal type="string">"mils"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLENNIUM</name></expr>}</block></expr>,	<comment type="block">/* "millennia" relative */</comment>
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>, <comment type="block">/* "minute" relative */</comment>
	<expr><block>{<expr><literal type="string">"mins"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>,	<comment type="block">/* "minutes" relative */</comment>
	<expr><block>{<expr><name>DMINUTE</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>,	<comment type="block">/* "minute" relative */</comment>
	<expr><block>{<expr><literal type="string">"minutes"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MINUTE</name></expr>}</block></expr>, <comment type="block">/* "minutes" relative */</comment>
	<expr><block>{<expr><literal type="string">"mon"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MONTH</name></expr>}</block></expr>,	<comment type="block">/* "months" relative */</comment>
	<expr><block>{<expr><literal type="string">"mons"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MONTH</name></expr>}</block></expr>, <comment type="block">/* "months" relative */</comment>
	<expr><block>{<expr><name>DMONTH</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MONTH</name></expr>}</block></expr>, <comment type="block">/* "month" relative */</comment>
	<expr><block>{<expr><literal type="string">"months"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MONTH</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"msec"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,
	<expr><block>{<expr><name>DMILLISEC</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"mseconds"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"msecs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MILLISEC</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"qtr"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_QUARTER</name></expr>}</block></expr>,	<comment type="block">/* "quarter" relative */</comment>
	<expr><block>{<expr><name>DQUARTER</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_QUARTER</name></expr>}</block></expr>, <comment type="block">/* "quarter" relative */</comment>
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sec"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,
	<expr><block>{<expr><name>DSECOND</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"seconds"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"secs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_SECOND</name></expr>}</block></expr>,
	<expr><block>{<expr><name>DTIMEZONE</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_TZ</name></expr>}</block></expr>, <comment type="block">/* "timezone" time offset */</comment>
	<expr><block>{<expr><literal type="string">"timezone_h"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_TZ_HOUR</name></expr>}</block></expr>, <comment type="block">/* timezone hour units */</comment>
	<expr><block>{<expr><literal type="string">"timezone_m"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_TZ_MINUTE</name></expr>}</block></expr>,	<comment type="block">/* timezone minutes units */</comment>
	<expr><block>{<expr><literal type="string">"us"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>,	<comment type="block">/* "microsecond" relative */</comment>
	<expr><block>{<expr><literal type="string">"usec"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>,	<comment type="block">/* "microsecond" relative */</comment>
	<expr><block>{<expr><name>DMICROSEC</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>,	<comment type="block">/* "microsecond" relative */</comment>
	<expr><block>{<expr><literal type="string">"useconds"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>,	<comment type="block">/* "microseconds" relative */</comment>
	<expr><block>{<expr><literal type="string">"usecs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_MICROSEC</name></expr>}</block></expr>, <comment type="block">/* "microseconds" relative */</comment>
	<expr><block>{<expr><literal type="string">"w"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_WEEK</name></expr>}</block></expr>,		<comment type="block">/* "week" relative */</comment>
	<expr><block>{<expr><name>DWEEK</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_WEEK</name></expr>}</block></expr>,	<comment type="block">/* "week" relative */</comment>
	<expr><block>{<expr><literal type="string">"weeks"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_WEEK</name></expr>}</block></expr>, <comment type="block">/* "weeks" relative */</comment>
	<expr><block>{<expr><literal type="string">"y"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>,		<comment type="block">/* "year" relative */</comment>
	<expr><block>{<expr><name>DYEAR</name></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>,	<comment type="block">/* "year" relative */</comment>
	<expr><block>{<expr><literal type="string">"years"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>, <comment type="block">/* "years" relative */</comment>
	<expr><block>{<expr><literal type="string">"yr"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>,	<comment type="block">/* "year" relative */</comment>
	<expr><block>{<expr><literal type="string">"yrs"</literal></expr>, <expr><name>UNITS</name></expr>, <expr><name>DTK_YEAR</name></expr>}</block></expr>	<comment type="block">/* "years" relative */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>szdeltatktbl</name> <init>= <expr><sizeof>sizeof <name>deltatktbl</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>deltatktbl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type><name>zoneabbrevtbl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Caches of recent lookup results in the above tables */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name><name>datecache</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name><name>deltacache</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name><name>abbrevcache</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Calendar time to Julian date conversions.
 * Julian date is commonly used in astronomical applications,
 *	since it is numerically accurate and computationally simple.
 * The algorithms here will accurately convert between Julian day
 *	and calendar date for all non-negative Julian days
 *	(i.e. from Nov 24, -4713 on).
 *
 * Rewritten to eliminate overflow problems. This now allows the
 * routines to work correctly for all Julian day counts from
 * 0 to 2147483647	(Nov 24, -4713 to Jun 3, 5874898) assuming
 * a 32-bit integer. Longer types should also work to the limits
 * of their precision.
 *
 * Actually, date2j() will work sanely, in the sense of producing
 * valid negative Julian dates, significantly before Nov 24, -4713.
 * We rely on it to do so back to Nov 1, -4713; see IS_VALID_JULIAN()
 * and associated commentary in timestamp.h.
 */</comment>

<function><type><name>int</name></type>
<name>date2j</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>julian</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>century</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>m</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">4800</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>m</name> <operator>+=</operator> <literal type="number">13</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>+=</operator> <literal type="number">4799</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>century</name> <operator>=</operator> <name>y</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>=</operator> <name>y</name> <operator>*</operator> <literal type="number">365</literal> <operator>-</operator> <literal type="number">32167</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>+=</operator> <name>y</name> <operator>/</operator> <literal type="number">4</literal> <operator>-</operator> <name>century</name> <operator>+</operator> <name>century</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>+=</operator> <literal type="number">7834</literal> <operator>*</operator> <name>m</name> <operator>/</operator> <literal type="number">256</literal> <operator>+</operator> <name>d</name></expr>;</expr_stmt>

	<return>return <expr><name>julian</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* date2j() */</comment>

<function><type><name>void</name></type>
<name>j2date</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>jd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>year</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>month</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>day</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>julian</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>quad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>y</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>julian</name> <operator>=</operator> <name>jd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>+=</operator> <literal type="number">32044</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>quad</name> <operator>=</operator> <name>julian</name> <operator>/</operator> <literal type="number">146097</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>extra</name> <operator>=</operator> <operator>(</operator><name>julian</name> <operator>-</operator> <name>quad</name> <operator>*</operator> <literal type="number">146097</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>+=</operator> <literal type="number">60</literal> <operator>+</operator> <name>quad</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>extra</name> <operator>/</operator> <literal type="number">146097</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>quad</name> <operator>=</operator> <name>julian</name> <operator>/</operator> <literal type="number">1461</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>-=</operator> <name>quad</name> <operator>*</operator> <literal type="number">1461</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name>julian</name> <operator>*</operator> <literal type="number">4</literal> <operator>/</operator> <literal type="number">1461</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>julian</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>y</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>julian</name> <operator>+</operator> <literal type="number">305</literal><operator>)</operator> <operator>%</operator> <literal type="number">365</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>julian</name> <operator>+</operator> <literal type="number">306</literal><operator>)</operator> <operator>%</operator> <literal type="number">366</literal><operator>)</operator></expr></else></ternary><operator>)</operator>
		<operator>+</operator> <literal type="number">123</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>+=</operator> <name>quad</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>year</name> <operator>=</operator> <name>y</name> <operator>-</operator> <literal type="number">4800</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>quad</name> <operator>=</operator> <name>julian</name> <operator>*</operator> <literal type="number">2141</literal> <operator>/</operator> <literal type="number">65536</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>day</name> <operator>=</operator> <name>julian</name> <operator>-</operator> <literal type="number">7834</literal> <operator>*</operator> <name>quad</name> <operator>/</operator> <literal type="number">256</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>month</name> <operator>=</operator> <operator>(</operator><name>quad</name> <operator>+</operator> <literal type="number">10</literal><operator>)</operator> <operator>%</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* j2date() */</comment>


<comment type="block">/*
 * j2day - convert Julian date to day-of-week (0..6 == Sun..Sat)
 *
 * Note: various places use the locution j2day(date - 1) to produce a
 * result according to the convention 0..6 = Mon..Sun.  This is a bit of
 * a crock, but will work as long as the computation here is just a modulo.
 */</comment>
<function><type><name>int</name></type>
<name>j2day</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>date</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>date</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>date</name> <operator>%=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
	<comment type="block">/* Cope if division truncates towards zero, as it probably does */</comment>
	<if_stmt><if>if <condition>(<expr><name>date</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>date</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>date</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* j2day() */</comment>


<comment type="block">/*
 * GetCurrentDateTime()
 *
 * Get the transaction start time ("now()") broken down as a struct pg_tm.
 */</comment>
<function><type><name>void</name></type>
<name>GetCurrentDateTime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * GetCurrentTimeUsec()
 *
 * Get the transaction start time ("now()") broken down as a struct pg_tm,
 * including fractional seconds and timezone offset.
 */</comment>
<function><type><name>void</name></type>
<name>GetCurrentTimeUsec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */</comment>
	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Append seconds and fractional seconds (if any) at *cp.
 *
 * precision is the max number of fraction digits, fillzeros says to
 * pad to two integral-seconds digits.
 *
 * Returns a pointer to the new end of string.  No NUL terminator is put
 * there; callers are responsible for NUL terminating str themselves.
 *
 * Note that any sign is stripped from the input seconds values.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AppendSeconds</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fillzeros</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>precision</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fillzeros</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name>Abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>pg_ultostr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name>Abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* fsec_t is just an int32 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>value</name> <init>= <expr><call><name>Abs</name><argument_list>(<argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>&amp;</operator><name><name>cp</name><index>[<expr><name>precision</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>gotnonzero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Append the fractional seconds part.  Note that we don't want any
		 * trailing zeros here, so since we're building the number in reverse
		 * we'll skip appending zeros until we've output a non-zero digit.
		 */</comment>
		<while>while <condition>(<expr><name>precision</name><operator>--</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>oldval</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>remainder</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>oldval</name> <operator>-</operator> <name>value</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>

			<comment type="block">/* check if we got a non-zero */</comment>
			<if_stmt><if>if <condition>(<expr><name>remainder</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>gotnonzero</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>gotnonzero</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cp</name><index>[<expr><name>precision</name></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>remainder</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><index>[<expr><name>precision</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If we still have a non-zero value then precision must have not been
		 * enough to print the number.  We punt the problem to pg_ltostr(),
		 * which will generate a correct answer in the minimum valid width.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_ultostr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name>Abs</name><argument_list>(<argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>end</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Variant of above that's specialized to timestamp case.
 *
 * Returns a pointer to the new end of string.  No NUL terminator is put
 * there; callers are responsible for NUL terminating str themselves.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AppendTimestampSeconds</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_TIMESTAMP_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Multiply frac by scale (to produce seconds) and add to *tm &amp; *fsec.
 * We assume the input frac is less than 1 so overflow is not an issue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustFractSeconds</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>frac</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name>scale</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>frac</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>sec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>frac</name> <operator>-=</operator> <name>sec</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>frac</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* As above, but initial scale produces days */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustFractDays</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>frac</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>extra_days</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>frac</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name>scale</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>extra_days</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>frac</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>extra_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>frac</name> <operator>-=</operator> <name>extra_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fetch a fractional-second value with suitable error checking */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParseFractionalSecond</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>frac</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should always pass the start of the fraction part */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>frac</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check for parse failure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>frac</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ParseDateTime()
 *	Break string into tokens based on a date/time context.
 *	Returns 0 if successful, DTERR code if bogus input detected.
 *
 * timestr - the input string
 * workbuf - workspace for field string storage. This must be
 *	 larger than the largest legal input for this datetime type --
 *	 some additional space will be needed to NUL terminate fields.
 * buflen - the size of workbuf
 * field[] - pointers to field strings are returned in this array
 * ftype[] - field type indicators are returned in this array
 * maxfields - dimensions of the above two arrays
 * *numfields - set to the actual number of fields detected
 *
 * The fields extracted from the input are stored as separate,
 * null-terminated strings in the workspace at workbuf. Any text is
 * converted to lower case.
 *
 * Several field types are assigned:
 *	DTK_NUMBER - digits and (possibly) a decimal point
 *	DTK_DATE - digits and two delimiters, or digits and text
 *	DTK_TIME - digits, colon delimiters, and possibly a decimal point
 *	DTK_STRING - text (no digits or punctuation)
 *	DTK_SPECIAL - leading "+" or "-" followed by text
 *	DTK_TZ - leading "+" or "-" followed by digits (also eats ':', '.', '-')
 *
 * Note that some field types can hold unexpected items:
 *	DTK_NUMBER can hold date fields (yy.ddd)
 *	DTK_STRING can hold months (January) and time zones (PST)
 *	DTK_DATE can hold time zone names (America/New_York, GMT-8)
 */</comment>
<function><type><name>int</name></type>
<name>ParseDateTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timestr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxfields</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>timestr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufp</name> <init>= <expr><name>workbuf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bufend</name> <init>= <expr><name>workbuf</name> <operator>+</operator> <name>buflen</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set the character pointed-to by "bufptr" to "newchar", and increment
	 * "bufptr". "end" gives the end of the buffer -- we return an error if
	 * there is no space left to append a character to the buffer. Note that
	 * "bufptr" is evaluated twice.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_CHAR</name><parameter_list>(<parameter><type><name>bufptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>newchar</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>do											\
	{											\
		if (((bufptr) + 1) &gt;= (end))			\
			return DTERR_BAD_FORMAT;			\
		*(bufptr)++ = newchar;					\
	} while (0)</cpp:value></cpp:define>

	<comment type="block">/* outer loop through fields */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore spaces between fields */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Record start of current field */</comment>
		<if_stmt><if>if <condition>(<expr><name>nf</name> <operator>&gt;=</operator> <name>maxfields</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>field</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>bufp</name></expr>;</expr_stmt>

		<comment type="block">/* leading digit? then date or time */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<comment type="block">/* time field? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_TIME</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <operator>(</operator><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			</block_content>}</block></if>
			<comment type="block">/* date field? allow embedded text month */</comment>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* save delimiting character to use later */</comment>
				<decl_stmt><decl><type><name>char</name></type>		<name>delim</name> <init>= <expr><operator>*</operator><name>cp</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* second field is all digits? then no embedded text month */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>delim</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>DTK_NUMBER</name></expr> </then><else>: <expr><name>DTK_DATE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
					<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

					<comment type="block">/*
					 * insist that the delimiters match to get a three-field
					 * date.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <name>delim</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
					<while>while <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>

			<comment type="block">/*
			 * otherwise, number only and will determine year, month, day, or
			 * concatenated fields later...
			 */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_NUMBER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* Leading decimal point? Then fractional seconds... */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_NUMBER</name></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * text? then date string, month, day of week, special, or timezone
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_date</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_STRING</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<comment type="block">/*
			 * Dates can have embedded '-', '/', or '.' separators.  It could
			 * also be a timezone name containing embedded '/', '+', '-', '_',
			 * or ':' (but '_' or ':' can't be the first punctuation). If the
			 * next character is a digit or '+', we need to check whether what
			 * we have so far is a recognized non-timezone keyword --- if so,
			 * don't believe that this is the start of a timezone.
			 */</comment>
			<expr_stmt><expr><name>is_date</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_date</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* null-terminate current field value */</comment>
				<comment type="block">/* we need search only the core token table, not TZ names */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>datebsearch</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>nf</name></expr>]</index></name></expr></argument>, <argument><expr><name>datetktbl</name></expr></argument>, <argument><expr><name>szdatetktbl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_date</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_date</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
				<do>do
				<block>{<block_content>
					<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block> while <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator>
						 <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator>
						 <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator>
						 <call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* sign? then special or numeric timezone */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* soak up leading whitespace */</comment>
			<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<comment type="block">/* numeric timezone? */</comment>
			<comment type="block">/* note that "DTK_TZ" could also be a signed float or yyyy-mm */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_TZ</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			</block_content>}</block></if>
			<comment type="block">/* special? */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>DTK_SPECIAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>APPEND_CHAR</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>bufend</name></expr></argument>, <argument><expr><call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			</block_content>}</block></if>
			<comment type="block">/* otherwise something wrong... */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* ignore other punctuation but use as delimiter */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>ispunct</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<comment type="block">/* otherwise, something is not right... */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>

		<comment type="block">/* force in a delimiter after each field */</comment>
		<expr_stmt><expr><operator>*</operator><name>bufp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nf</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>numfields</name> <operator>=</operator> <name>nf</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeDateTime()
 * Interpret previously parsed fields for general date and time.
 * Return 0 if full date, 1 if only time, and negative DTERR code if problems.
 * (Currently, all callers treat 1 as an error return too.)
 *
 *		External format(s):
 *				"&lt;weekday&gt; &lt;month&gt;-&lt;day&gt;-&lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt;"
 *				"Fri Feb-7-1997 15:23:27"
 *				"Feb-7-1997 15:23:27"
 *				"2-7-1997 15:23:27"
 *				"1997-2-7 15:23:27"
 *				"1997.038 15:23:27"		(day of year 1-366)
 *		Also supports input in compact time:
 *				"970207 152327"
 *				"97038 152327"
 *				"20011225T040506.789-07"
 *
 * Use the system-provided functions to get the current time zone
 * if not specified in the input string.
 *
 * If the date is outside the range of pg_time_t (in practice that could only
 * happen if pg_time_t is just 32 bits), then assume UTC time zone - thomas
 * 1997-05-27
 */</comment>
<function><type><name>int</name></type>
<name>DecodeDateTime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nf</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tmask</name></decl>,
				<decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ptype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* "prefix type" for ISO y2001m02d04 format */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mer</name> <init>= <expr><name>HR24</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveTextMonth</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isjulian</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is2digits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>namedTz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>abbrevTz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>valtz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>abbrev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>cur_tm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll insist on at least all of the date fields, but initialize the
	 * remaining fields in case they are not set later...
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* don't know daylight savings time status apriori */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_DATE</name></expr>:</case>

				<comment type="block">/*
				 * Integral julian day with attached time zone? All other
				 * forms with JD will be separated into distinct fields, so we
				 * handle just this case here.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>DTK_JULIAN</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isjulian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* Get the time zone from the end of the string */</comment>
					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name> <operator>|</operator> <name>DTK_TIME_M</name> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if>

				<comment type="block">/*
				 * Already have a date? Then this might be a time zone name
				 * with embedded punctuation (e.g. "America/New_York") or a
				 * run-together time with trailing time zone (e.g. hhmmss-zz).
				 * - thomas 2001-12-25
				 *
				 * We consider it a time zone if we already have month &amp; day.
				 * This is to allow the form "mmm dd hhmmss tz year", which
				 * we've historically accepted.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
						 <operator>(</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>==</operator>
						  <operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No time zone accepted? Then quit... */</comment>
					<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ptype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Sanity check; should not fail this test */</comment>
							<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <name>DTK_TIME</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Starts with a digit but we already have a time
						 * field? Then we are in trouble with a date and time
						 * already...
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator> <operator>==</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/* Get the time zone from the end of the string */</comment>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

						<comment type="block">/*
						 * Then read the rest of the field as a concatenated
						 * time
						 */</comment>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												  <argument><expr><name>fmask</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
												  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * modify tmask after returning from
						 * DecodeNumberField()
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>namedTz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>namedTz</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * We should return an error code instead of
							 * ereport'ing directly, but then there is no way
							 * to report the bad time zone name.
							 */</comment>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>,
											<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* we'll apply the zone setting below */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDate</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TIME</name></expr>:</case>

				<comment type="block">/*
				 * This might be an ISO time following a "t" field.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Sanity check; should not fail this test */</comment>
					<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <name>DTK_TIME</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>INTERVAL_FULL_RANGE</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* check for time overflow */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>time_overflows</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>,
								   <argument><expr><operator>*</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>DTK_NUMBER</name></expr>:</case>

				<comment type="block">/*
				 * Was this an "ISO date" with embedded field labels? An
				 * example is "y2001m02d04" - thomas 2001-02-04
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * only a few kinds are allowed to have an embedded
					 * decimal
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
						<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
							<case>case <expr><name>DTK_TIME</name></expr>:</case>
							<case>case <expr><name>DTK_SECOND</name></expr>:</case>
								<break>break;</break>
							<default>default:</default>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
								<break>break;</break>
						</block_content>}</block></switch></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>DTK_YEAR</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_MONTH</name></expr>:</case>

							<comment type="block">/*
							 * already have a month and hour? then assume
							 * minutes
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
								<operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_DAY</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_HOUR</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_SECOND</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseFractionalSecond</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_ALL_SECS_M</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_TZ</name></expr>:</case>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
							<comment type="block">/* previous field was a label for "julian date" */</comment>
							<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>isjulian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/* fractional Julian Day? */</comment>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>double</name></type>		<name>time</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name>time</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
								<expr_stmt><expr><name>time</name> <operator>*=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>dt2time</name><argument_list>(<argument><expr><name>time</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_TIME</name></expr>:</case>
							<comment type="block">/* previous field was "t" for ISO time */</comment>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
													  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>!=</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
							<break>break;</break>

						<default>default:</default>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
							<break>break;</break>
					</block_content>}</block></switch>

					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>flen</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Embedded decimal and no date yet? */</comment>
					<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDate</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<comment type="block">/* embedded decimal and several digits before? */</comment>
					<if type="elseif">else if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>flen</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Interpret as a concatenated date or time Set the
						 * type field to allow decoding other fields later.
						 * Example: 20011223 or 040506
						 */</comment>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
												  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>

					<comment type="block">/*
					 * Is this a YMD or HMS specification, or a year number?
					 * YMD and HMS are required to be six digits or more, so
					 * if it is 5 digits, it is a year.  If it is six or more
					 * digits, we assume it is YMD or HMS unless no date and
					 * no time values have been specified.  This forces 6+
					 * digit years to be at the end of the string, or to use
					 * the ISO date specification.
					 */</comment>
					<if type="elseif">else if <condition>(<expr><name>flen</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>||</operator>
										   <operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
												  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<comment type="block">/* otherwise it is a single date/time field... */</comment>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumber</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name>haveTextMonth</name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
											 <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_STRING</name></expr>:</case>
			<case>case <expr><name>DTK_SPECIAL</name></expr>:</case>
				<comment type="block">/* timezone abbrevs take precedence over built-in tokens */</comment>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RESERV</name></expr>:</case>
						<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>DTK_NOW</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>DTK_DATE_M</name> <operator>|</operator> <name>DTK_TIME_M</name> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>GetCurrentTimeUsec</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>DTK_YESTERDAY</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>DTK_TODAY</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>cur_tm</name><operator>.</operator><name>tm_year</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>cur_tm</name><operator>.</operator><name>tm_mon</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>cur_tm</name><operator>.</operator><name>tm_mday</name></name></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>DTK_TOMORROW</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>cur_tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>DTK_ZULU</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>DTK_TIME_M</name> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>

							<default>default:</default>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						</block_content>}</block></switch>

						<break>break;</break>

					<case>case <expr><name>MONTH</name></expr>:</case>

						<comment type="block">/*
						 * already have a (numeric) month? then see if we can
						 * substitute...
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>haveTextMonth</name> <operator>&amp;&amp;</operator>
							<operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
							<name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <literal type="number">31</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>haveTextMonth</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTZMOD</name></expr>:</case>

						<comment type="block">/*
						 * daylight savings time modifier (solves "MET DST"
						 * syntax)
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>-=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTZ</name></expr>:</case>

						<comment type="block">/*
						 * set mask for TZ here _or_ check for DTZ later when
						 * getting default timezone
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TZ</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DYNTZ</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<comment type="block">/* we'll determine the actual offset later */</comment>
						<expr_stmt><expr><name>abbrevTz</name> <operator>=</operator> <name>valtz</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>abbrev</name> <operator>=</operator> <name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>AMPM</name></expr>:</case>
						<expr_stmt><expr><name>mer</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>ADBC</name></expr>:</case>
						<expr_stmt><expr><name>bc</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>==</operator> <name>BC</name><operator>)</operator></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DOW</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>UNITS</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>ISOTIME</name></expr>:</case>

						<comment type="block">/*
						 * This is a filler field "t" indicating that the next
						 * field is time. Try to verify that this is sensible.
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<comment type="block">/* No preceding date? Then quit... */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block" format="doxygen">/***
						 * We will need one of the following fields:
						 *	DTK_NUMBER should be hhmmss.fff
						 *	DTK_TIME should be hh:mm:ss.fff
						 *	DTK_DATE should be hhmmss-zz
						 ***/</comment>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nf</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
							<operator>(</operator><name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_NUMBER</name> <operator>&amp;&amp;</operator>
							 <name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_TIME</name> <operator>&amp;&amp;</operator>
							 <name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_DATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>UNKNOWN_FIELD</name></expr>:</case>

						<comment type="block">/*
						 * Before giving up and declaring error, check to see
						 * if it is an all-alpha timezone name.
						 */</comment>
						<expr_stmt><expr><name>namedTz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>namedTz</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<comment type="block">/* we'll apply the zone setting below */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<default>default:</default>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>&amp;</operator> <name>fmask</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>tmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* end loop over fields */</comment>

	<comment type="block">/* do final checking/adjustment of Y/M/D fields */</comment>
	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ValidateDate</name><argument_list>(<argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>isjulian</name></expr></argument>, <argument><expr><name>is2digits</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* handle AM/PM */</comment>
	<if_stmt><if>if <condition>(<expr><name>mer</name> <operator>!=</operator> <name>HR24</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mer</name> <operator>==</operator> <name>AM</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>==</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>mer</name> <operator>==</operator> <name>PM</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>!=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* do additional checking for full date specs... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dtype</name> <operator>==</operator> <name>DTK_DATE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator> <operator>==</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we had a full timezone spec, compute the offset (we could not do
		 * it before, because we need the date to resolve DST status).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>namedTz</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* daylight savings time modifier disallowed with full TZ */</comment>
			<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>namedTz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Likewise, if we had a dynamic timezone abbreviation, resolve it
		 * now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>abbrevTz</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* daylight savings time modifier disallowed with dynamic TZ */</comment>
			<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneAbbrevOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>abbrev</name></expr></argument>, <argument><expr><name>abbrevTz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* timezone not specified? then use session timezone */</comment>
		<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * daylight savings time modifier but no standard timezone? then
			 * error
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DetermineTimeZoneOffset()
 *
 * Given a struct pg_tm in which tm_year, tm_mon, tm_mday, tm_hour, tm_min,
 * and tm_sec fields are set, and a zic-style time zone definition, determine
 * the applicable GMT offset and daylight-savings status at that time.
 * Set the struct pg_tm's tm_isdst field accordingly, and return the GMT
 * offset as the function result.
 *
 * Note: if the date is out of the range we can deal with, we return zero
 * as the GMT offset and set tm_isdst = 0.  We don't throw an error here,
 * though probably some higher-level code will.
 */</comment>
<function><type><name>int</name></type>
<name>DetermineTimeZoneOffset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>t</name></decl>;</decl_stmt>

	<return>return <expr><call><name>DetermineTimeZoneOffsetInternal</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DetermineTimeZoneOffsetInternal()
 *
 * As above, but also return the actual UTC time imputed to the date/time
 * into *tp.
 *
 * In event of an out-of-range date, we punt by returning zero into *tp.
 * This is okay for the immediate callers but is a good reason for not
 * exposing this worker function globally.
 *
 * Note: it might seem that we should use mktime() for this, but bitter
 * experience teaches otherwise.  This code is much faster than most versions
 * of mktime(), anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DetermineTimeZoneOffsetInternal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>, <parameter><decl><type><name>pg_time_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>date</name></decl>,
				<decl><type ref="prev"/><name>sec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>day</name></decl>,
				<decl><type ref="prev"/><name>mytime</name></decl>,
				<decl><type ref="prev"/><name>prevtime</name></decl>,
				<decl><type ref="prev"/><name>boundary</name></decl>,
				<decl><type ref="prev"/><name>beforetime</name></decl>,
				<decl><type ref="prev"/><name>aftertime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>int</name></type>	<name>before_gmtoff</name></decl>,
				<decl><type ref="prev"/><name>after_gmtoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>before_isdst</name></decl>,
				<decl><type ref="prev"/><name>after_isdst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, generate the pg_time_t value corresponding to the given
	 * y/m/d/h/m/s taken as GMT time.  If this overflows, punt and decide the
	 * timezone is GMT.  (For a valid Julian date, integer overflow should be
	 * impossible with 64-bit pg_time_t, but let's check for safety.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>day</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>pg_time_t</name><operator>)</operator> <name>date</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>day</name> <operator>/</operator> <name>SECS_PER_DAY</name> <operator>!=</operator> <name>date</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sec</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mytime</name> <operator>=</operator> <name>day</name> <operator>+</operator> <name>sec</name></expr>;</expr_stmt>
	<comment type="block">/* since sec &gt;= 0, overflow could only be from +day to -mytime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>day</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the DST time boundary just before or following the target time. We
	 * assume that all zones have GMT offsets less than 24 hours, and that DST
	 * boundaries can't be closer together than 48 hours, so backing up 24
	 * hours and finding the "next" boundary will work.
	 */</comment>
	<expr_stmt><expr><name>prevtime</name> <operator>=</operator> <name>mytime</name> <operator>-</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prevtime</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_next_dst_boundary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prevtime</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>before_gmtoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>before_isdst</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>boundary</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>after_gmtoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>after_isdst</name></expr></argument>,
							   <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* failure? */</comment>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Non-DST zone, life is simple */</comment>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>before_isdst</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>mytime</name> <operator>-</operator> <name>before_gmtoff</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>before_gmtoff</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Form the candidate pg_time_t values with local-time adjustment
	 */</comment>
	<expr_stmt><expr><name>beforetime</name> <operator>=</operator> <name>mytime</name> <operator>-</operator> <name>before_gmtoff</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>before_gmtoff</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name><name>mytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>beforetime</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>before_gmtoff</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name>mytime</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>beforetime</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>aftertime</name> <operator>=</operator> <name>mytime</name> <operator>-</operator> <name>after_gmtoff</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>after_gmtoff</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name><name>mytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>aftertime</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>after_gmtoff</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name>mytime</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>aftertime</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>overflow</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If both before or both after the boundary time, we know what to do. The
	 * boundary time itself is considered to be after the transition, which
	 * means we can accept aftertime == boundary in the second case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>beforetime</name> <operator>&lt;</operator> <name>boundary</name> <operator>&amp;&amp;</operator> <name>aftertime</name> <operator>&lt;</operator> <name>boundary</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>before_isdst</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>beforetime</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>before_gmtoff</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>beforetime</name> <operator>&gt;</operator> <name>boundary</name> <operator>&amp;&amp;</operator> <name>aftertime</name> <operator>&gt;=</operator> <name>boundary</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>after_isdst</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>aftertime</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>after_gmtoff</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's an invalid or ambiguous time due to timezone transition.  In a
	 * spring-forward transition, prefer the "before" interpretation; in a
	 * fall-back transition, prefer "after".  (We used to define and implement
	 * this test as "prefer the standard-time interpretation", but that rule
	 * does not help to resolve the behavior when both times are reported as
	 * standard time; which does happen, eg Europe/Moscow in Oct 2014.  Also,
	 * in some zones such as Europe/Dublin, there is widespread confusion
	 * about which time offset is "standard" time, so it's fortunate that our
	 * behavior doesn't depend on that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>beforetime</name> <operator>&gt;</operator> <name>aftertime</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>before_isdst</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>beforetime</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>before_gmtoff</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>after_isdst</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>aftertime</name></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>after_gmtoff</name></expr>;</return>

<label><name>overflow</name>:</label>
	<comment type="block">/* Given date is out of range, so assume UTC */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DetermineTimeZoneAbbrevOffset()
 *
 * Determine the GMT offset and DST flag to be attributed to a dynamic
 * time zone abbreviation, that is one whose meaning has changed over time.
 * *tm contains the local time at which the meaning should be determined,
 * and tm-&gt;tm_isdst receives the DST flag.
 *
 * This differs from the behavior of DetermineTimeZoneOffset() in that a
 * standard-time or daylight-time abbreviation forces use of the corresponding
 * GMT offset even when the zone was then in DS or standard time respectively.
 * (However, that happens only if we can match the given abbreviation to some
 * abbreviation that appears in the IANA timezone data.  Otherwise, we fall
 * back to doing DetermineTimeZoneOffset().)
 */</comment>
<function><type><name>int</name></type>
<name>DetermineTimeZoneAbbrevOffset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>zone_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>abbr_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>abbr_isdst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute the UTC time we want to probe at.  (In event of overflow, we'll
	 * probe at the epoch, which is a bit random but probably doesn't matter.)
	 */</comment>
	<expr_stmt><expr><name>zone_offset</name> <operator>=</operator> <call><name>DetermineTimeZoneOffsetInternal</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to match the abbreviation to something in the zone definition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DetermineTimeZoneAbbrevOffsetInternal</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>abbr_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abbr_isdst</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Success, so use the abbrev-specific answers. */</comment>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name>abbr_isdst</name></expr>;</expr_stmt>
		<return>return <expr><name>abbr_offset</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * No match, so use the answers we already got from
	 * DetermineTimeZoneOffsetInternal.
	 */</comment>
	<return>return <expr><name>zone_offset</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DetermineTimeZoneAbbrevOffsetTS()
 *
 * As above but the probe time is specified as a TimestampTz (hence, UTC time),
 * and DST status is returned into *isdst rather than into tm-&gt;tm_isdst.
 */</comment>
<function><type><name>int</name></type>
<name>DetermineTimeZoneAbbrevOffsetTS</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>,
								<parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>isdst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>t</name> <init>= <expr><call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>zone_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>abbr_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the abbrev matches anything in the zone data, this is pretty easy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DetermineTimeZoneAbbrevOffsetInternal</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>abbr_offset</name></expr></argument>, <argument><expr><name>isdst</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>abbr_offset</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Else, break down the timestamp so we can use DetermineTimeZoneOffset.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>zone_offset</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isdst</name> <operator>=</operator> <name><name>tm</name><operator>.</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
	<return>return <expr><name>zone_offset</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DetermineTimeZoneAbbrevOffsetInternal()
 *
 * Workhorse for above two functions: work from a pg_time_t probe instant.
 * On success, return GMT offset and DST status into *offset and *isdst.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DetermineTimeZoneAbbrevOffsetInternal</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>,
									  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>isdst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>upabbr</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>int</name></type>	<name>gmtoff</name></decl>;</decl_stmt>

	<comment type="block">/* We need to force the abbrev to upper case */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>upabbr</name></expr></argument>, <argument><expr><name>abbr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>upabbr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>upabbr</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Look up the abbrev's meaning at this time in this zone */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_interpret_timezone_abbrev</name><argument_list>(<argument><expr><name>upabbr</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>gmtoff</name></expr></argument>,
									 <argument><expr><name>isdst</name></expr></argument>,
									 <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Change sign to agree with DetermineTimeZoneOffset() */</comment>
		<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>-</operator><name>gmtoff</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeTimeOnly()
 * Interpret parsed string as time fields only.
 * Returns 0 if successful, DTERR code if bogus input detected.
 *
 * Note that support for time zone is here for
 * SQL TIME WITH TIME ZONE, but it reveals
 * bogosity with SQL date/time standards, since
 * we must infer a time zone from current time.
 * - thomas 2000-03-10
 * Allow specifying date to get a better time zone,
 * if time zones are allowed. - thomas 2001-12-26
 */</comment>
<function><type><name>int</name></type>
<name>DecodeTimeOnly</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nf</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tmask</name></decl>,
				<decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ptype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* "prefix type" for ISO h04mm05s06 format */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isjulian</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is2digits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mer</name> <init>= <expr><name>HR24</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>namedTz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>abbrevTz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>abbrev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>valtz</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_TIME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* don't know daylight savings time status apriori */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_DATE</name></expr>:</case>

				<comment type="block">/*
				 * Time zone not allowed? Then should not accept dates or time
				 * zones no matter what else!
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Under limited circumstances, we will accept a date... */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nf</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>ftype</name><index>[<expr><name>nf</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DTK_DATE</name> <operator>||</operator> <name><name>ftype</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DTK_TIME</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDate</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<comment type="block">/* otherwise, this is a time and/or time zone */</comment>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

						<comment type="block">/*
						 * Starts with a digit but we already have a time
						 * field? Then we are in trouble with time already...
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator> <operator>==</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * Should not get here and fail. Sanity check only...
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/* Get the time zone from the end of the string */</comment>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

						<comment type="block">/*
						 * Then read the rest of the field as a concatenated
						 * time
						 */</comment>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
												  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dterr</name></expr>;</expr_stmt>

						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>namedTz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>namedTz</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * We should return an error code instead of
							 * ereport'ing directly, but then there is no way
							 * to report the bad time zone name.
							 */</comment>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>,
											<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* we'll apply the zone setting below */</comment>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DTK_TZ</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TIME</name></expr>:</case>
				<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
								   <argument><expr><name>INTERVAL_FULL_RANGE</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>DTK_NUMBER</name></expr>:</case>

				<comment type="block">/*
				 * Was this an "ISO time" with embedded field labels? An
				 * example is "h04mm05s06" - thomas 2001-02-04
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>

					<comment type="block">/* Only accept a date under limited circumstances */</comment>
					<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
						<case>case <expr><name>DTK_YEAR</name></expr>:</case>
						<case>case <expr><name>DTK_MONTH</name></expr>:</case>
						<case>case <expr><name>DTK_DAY</name></expr>:</case>
							<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<default>default:</default>
							<break>break;</break>
					</block_content>}</block></switch>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * only a few kinds are allowed to have an embedded
					 * decimal
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
						<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
							<case>case <expr><name>DTK_TIME</name></expr>:</case>
							<case>case <expr><name>DTK_SECOND</name></expr>:</case>
								<break>break;</break>
							<default>default:</default>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
								<break>break;</break>
						</block_content>}</block></switch></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>DTK_YEAR</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_MONTH</name></expr>:</case>

							<comment type="block">/*
							 * already have a month and hour? then assume
							 * minutes
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
								<operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_DAY</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_HOUR</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_SECOND</name></expr>:</case>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseFractionalSecond</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_ALL_SECS_M</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_TZ</name></expr>:</case>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
							<comment type="block">/* previous field was a label for "julian date" */</comment>
							<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>isjulian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>double</name></type>		<name>time</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name>time</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
								<expr_stmt><expr><name>time</name> <operator>*=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>dt2time</name><argument_list>(<argument><expr><name>time</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>

						<case>case <expr><name>DTK_TIME</name></expr>:</case>
							<comment type="block">/* previous field was "t" for ISO time */</comment>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
													  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
							<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dterr</name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>!=</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
							<break>break;</break>

						<default>default:</default>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
							<break>break;</break>
					</block_content>}</block></switch>

					<expr_stmt><expr><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DATE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>flen</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Embedded decimal? */</comment>
					<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Under limited circumstances, we will accept a
						 * date...
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nf</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ftype</name><index>[<expr><name>nf</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DTK_DATE</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDate</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<comment type="block">/* embedded decimal and several digits before? */</comment>
						<if type="elseif">else if <condition>(<expr><name>flen</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Interpret as a concatenated date or time Set
							 * the type field to allow decoding other fields
							 * later. Example: 20011223 or 040506
							 */</comment>
							<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
													  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
							<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dterr</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>flen</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
												  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>dterr</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<comment type="block">/* otherwise it is a single date/time field... */</comment>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumber</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
											 <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_STRING</name></expr>:</case>
			<case>case <expr><name>DTK_SPECIAL</name></expr>:</case>
				<comment type="block">/* timezone abbrevs take precedence over built-in tokens */</comment>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RESERV</name></expr>:</case>
						<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>DTK_NOW</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_TIME</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>GetCurrentTimeUsec</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>DTK_ZULU</name></expr>:</case>
								<expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>DTK_TIME_M</name> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_TIME</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<break>break;</break>

							<default>default:</default>
								<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
						</block_content>}</block></switch>

						<break>break;</break>

					<case>case <expr><name>DTZMOD</name></expr>:</case>

						<comment type="block">/*
						 * daylight savings time modifier (solves "MET DST"
						 * syntax)
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>-=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTZ</name></expr>:</case>

						<comment type="block">/*
						 * set mask for TZ here _or_ check for DTZ later when
						 * getting default timezone
						 */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DTK_TZ</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TZ</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DTK_TZ</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DYNTZ</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<comment type="block">/* we'll determine the actual offset later */</comment>
						<expr_stmt><expr><name>abbrevTz</name> <operator>=</operator> <name>valtz</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>abbrev</name> <operator>=</operator> <name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DTK_TZ</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>AMPM</name></expr>:</case>
						<expr_stmt><expr><name>mer</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>ADBC</name></expr>:</case>
						<expr_stmt><expr><name>bc</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>==</operator> <name>BC</name><operator>)</operator></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>UNITS</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>ISOTIME</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<comment type="block" format="doxygen">/***
						 * We will need one of the following fields:
						 *	DTK_NUMBER should be hhmmss.fff
						 *	DTK_TIME should be hh:mm:ss.fff
						 *	DTK_DATE should be hhmmss-zz
						 ***/</comment>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nf</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
							<operator>(</operator><name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_NUMBER</name> <operator>&amp;&amp;</operator>
							 <name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_TIME</name> <operator>&amp;&amp;</operator>
							 <name><name>ftype</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>DTK_DATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>UNKNOWN_FIELD</name></expr>:</case>

						<comment type="block">/*
						 * Before giving up and declaring error, check to see
						 * if it is an all-alpha timezone name.
						 */</comment>
						<expr_stmt><expr><name>namedTz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>namedTz</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
						<comment type="block">/* we'll apply the zone setting below */</comment>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<default>default:</default>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>&amp;</operator> <name>fmask</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>tmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* end loop over fields */</comment>

	<comment type="block">/* do final checking/adjustment of Y/M/D fields */</comment>
	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ValidateDate</name><argument_list>(<argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>isjulian</name></expr></argument>, <argument><expr><name>is2digits</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* handle AM/PM */</comment>
	<if_stmt><if>if <condition>(<expr><name>mer</name> <operator>!=</operator> <name>HR24</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mer</name> <operator>==</operator> <name>AM</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>==</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>mer</name> <operator>==</operator> <name>PM</name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>!=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check for time overflow */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>time_overflows</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><operator>*</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_TIME_M</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we had a full timezone spec, compute the offset (we could not do it
	 * before, because we may need the date to resolve DST status).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>namedTz</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name> <name>int</name></type>	<name>gmtoff</name></decl>;</decl_stmt>

		<comment type="block">/* daylight savings time modifier disallowed with full TZ */</comment>
		<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* if non-DST zone, we do not need to know the date */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_get_timezone_offset</name><argument_list>(<argument><expr><name>namedTz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gmtoff</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <name>gmtoff</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* a date has to be specified */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>namedTz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, if we had a dynamic timezone abbreviation, resolve it now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbrevTz</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * daylight savings time modifier but no standard timezone? then error
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* a date has to be specified */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneAbbrevOffset</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>abbrev</name></expr></argument>, <argument><expr><name>abbrevTz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* timezone not specified? then use session timezone */</comment>
	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * daylight savings time modifier but no standard timezone? then error
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DTZMOD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* a date has to be specified */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* DecodeDate()
 * Decode date string which includes delimiters.
 * Return 0 if okay, a DTERR code if not.
 *
 *	str: field to be parsed
 *	fmask: bitmask for field types already seen
 *	*tmask: receives bitmask for fields found here
 *	*is2digits: set to true if we find 2-digit year
 *	*tm: field values are stored into appropriate members of this struct
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DecodeDate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>,
		   <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveTextMonth</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>,
				<decl><type ref="prev"/><name>dmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* parse this string... */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>nf</name> <operator>&lt;</operator> <name>MAXDATEFIELDS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* skip field separators */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* end of string after separator */</comment>

		<expr_stmt><expr><name><name>field</name><index>[<expr><name>nf</name></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Just get rid of any non-digit, non-alpha characters... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nf</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* look first for text fields, since that will be unambiguous month */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>dmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>MONTH</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>haveTextMonth</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
			</block_content>}</block></switch>
			<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <name>dmask</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>dmask</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>|=</operator> <name>dmask</name></expr>;</expr_stmt>

			<comment type="block">/* mark this field as being completed */</comment>
			<expr_stmt><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* now pick up remaining numeric fields */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumber</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>haveTextMonth</name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>dmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <name>dmask</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>dmask</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>|=</operator> <name>dmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>DOY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>TZ</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* validation of the field values must wait until ValidateDate() */</comment>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ValidateDate()
 * Check valid year/month/day values, handle BC and DOY cases
 * Return 0 if okay, a DTERR code if not.
 */</comment>
<function><type><name>int</name></type>
<name>ValidateDate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isjulian</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is2digits</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bc</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isjulian</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* tm_year is correct and should not be touched */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>bc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* there is no year zero in AD/BC notation */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */</comment>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is2digits</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* just paranoia */</comment>
				<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">70</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <literal type="number">2000</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* there is no year zero in AD/BC notation */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now that we have correct year, decode DOY */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DOY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check for valid month */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_MD_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* minimal check for valid day */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_MD_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>==</operator> <name>DTK_DATE_M</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check for valid day of month, now that we know for sure the month
		 * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems
		 * unlikely that "Feb 29" is a YMD-order error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeTime()
 * Decode time string which includes delimiters.
 * Return 0 if okay, a DTERR code if not.
 *
 * Only check the lower limit on hours, since this same code can be
 * used to represent time spans.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DecodeTime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>range</name></decl></parameter>,
		   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */</comment>
		<if_stmt><if>if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* always assume mm:ss.sss is MINUTE TO SECOND */</comment>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseFractionalSecond</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseFractionalSecond</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* do a sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;</operator> <name>MINS_PER_HOUR</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;</operator> <name>SECS_PER_MINUTE</name> <operator>||</operator>
		<operator>*</operator><name><name>fsec</name> <argument_list type="generic">&lt; <argument><expr><name>INT64CONST</name><operator>(</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>*</operator><name>fsec</name></expr></argument> &gt;</argument_list></name> <name>USECS_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeNumber()
 * Interpret plain numeric field as a date value in context.
 * Return 0 if okay, a DTERR code if not.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DecodeNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>haveTextMonth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>,
			 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * More than two digits before decimal point? Then could be a date or
		 * a run-together time: 2001.360 20011225 040506.789
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>-</operator> <name>str</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>fmask</name> <operator>|</operator> <name>DTK_DATE_M</name><operator>)</operator></expr></argument>,
									  <argument><expr><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
									  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseFractionalSecond</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Special case for day of year */</comment>
	<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>==</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>val</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name>val</name> <operator>&lt;=</operator> <literal type="number">366</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>DOY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<comment type="block">/* tm_mon and tm_mday can't actually be set yet ... */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Switch based on what we have so far */</comment>
	<switch>switch <condition>(<expr><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>

			<comment type="block">/*
			 * Nothing so far; make a decision about what we think the input
			 * is.  There used to be lots of heuristics here, but the
			 * consensus now is to be paranoid.  It *must* be either
			 * YYYY-MM-DD (with a more-than-two-digit year field), or the
			 * field order defined by DateOrder.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <name>DateOrder</name> <operator>==</operator> <name>DATEORDER_YMD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>DateOrder</name> <operator>==</operator> <name>DATEORDER_DMY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<comment type="block">/* Must be at second field of YY-MM-DD */</comment>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>haveTextMonth</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We are at the first numeric field of a date that included a
				 * textual month name.  We want to support the variants
				 * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous
				 * inputs.  We will also accept MON-DD-YY or DD-MON-YY in
				 * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <name>DateOrder</name> <operator>==</operator> <name>DATEORDER_YMD</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Must be at second field of MM-DD-YY */</comment>
				<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>haveTextMonth</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Need to accept DD-MON-YYYY even in YMD mode */</comment>
				<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>is2digits</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Guess that first numeric field is day was wrong */</comment>
					<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* YEAR is already set */</comment>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>is2digits</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Must be at third field of YY-MM-DD */</comment>
				<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<comment type="block">/* Must be at second field of DD-MM-YY */</comment>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<comment type="block">/* Must be at third field of DD-MM-YY or MM-DD-YY */</comment>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><operator>(</operator><call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>:</case>
			<comment type="block">/* we have all the date, so it must be a time field */</comment>
			<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeNumberField</name><argument_list>(<argument><expr><name>flen</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>,
									  <argument><expr><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>,
									  <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>is2digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

		<default>default:</default>
			<comment type="block">/* Anything else is bogus input */</comment>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * When processing a year field, mark it for adjustment if it's only one
	 * or two digits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmask</name> <operator>==</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is2digits</name> <operator>=</operator> <operator>(</operator><name>flen</name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeNumberField()
 * Interpret numeric string as a concatenated date or time field.
 * Return a DTK token (&gt;= 0) if successful, a DTERR code (&lt; 0) if not.
 *
 * Use the context of previously decoded fields to help with
 * the interpretation.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DecodeNumberField</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmask</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tmask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is2digits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Have a decimal point? Then this is a date or something with a seconds
	 * field...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can we use ParseFractionalSecond here?  Not clear whether trailing
		 * junk should be rejected ...
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>frac</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>frac</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>frac</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Now truncate off the fraction for further processing */</comment>
		<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* No decimal point and no complete date yet? */</comment>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_DATE_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_DATE_M</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Start from end and consider first 2 as Day, next 2 as Month,
			 * and the rest as Year.
			 */</comment>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>is2digits</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>DTK_DATE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* not all time fields are specified? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmask</name> <operator>&amp;</operator> <name>DTK_TIME_M</name><operator>)</operator> <operator>!=</operator> <name>DTK_TIME_M</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hhmmss */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>DTK_TIME</name></expr>;</return>
		</block_content>}</block></if>
		<comment type="block">/* hhmm? */</comment>
		<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tmask</name> <operator>=</operator> <name>DTK_TIME_M</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>DTK_TIME</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeTimezone()
 * Interpret string as a numeric timezone.
 *
 * Return 0 if okay (and set *tzp), a DTERR code if not okay.
 */</comment>
<function><type><name>int</name></type>
<name>DecodeTimezone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hr</name></decl>,
				<decl><type ref="prev"/><name>min</name></decl>,
				<decl><type ref="prev"/><name>sec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<comment type="block">/* leading character must be "+" or "-" */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hr</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* explicit delimiter? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>sec</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* otherwise, might have run things together... */</comment>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>min</name> <operator>=</operator> <name>hr</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>hr</name> <operator>=</operator> <name>hr</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<comment type="block">/* we could, but don't, support a run-together hhmmss format */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Range-check the values; see notes in datatype/timestamp.h */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hr</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>hr</name></expr></argument> &gt;</argument_list></name> <name>MAX_TZDISP_HOUR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&gt;=</operator> <name>MINS_PER_HOUR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&gt;=</operator> <name>SECS_PER_MINUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>(</operator><name>hr</name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name>min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name> <operator>+</operator> <name>sec</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeTimezoneAbbrev()
 * Interpret string as a timezone abbreviation, if possible.
 *
 * Returns an abbreviation type (TZ, DTZ, or DYNTZ), or UNKNOWN_FIELD if
 * string is not any known abbreviation.  On success, set *offset and *tz to
 * represent the UTC offset (for TZ or DTZ) or underlying zone (for DYNTZ).
 * Note that full timezone names (such as America/New_York) are not handled
 * here, mostly for historical reasons.
 *
 * Given string must be lowercased already.
 *
 * Implement a cache lookup since it is likely that dates
 *	will be related in format.
 */</comment>
<function><type><name>int</name></type>
<name>DecodeTimezoneAbbrev</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lowtoken</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier><modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name><name>abbrevcache</name><index>[<expr><name>field</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* use strncmp so that we match truncated tokens */</comment>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>TOKMAXLEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>zoneabbrevtbl</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>datebsearch</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name><name>zoneabbrevtbl</name><operator>-&gt;</operator><name>abbrevs</name></name></expr></argument>,
							 <argument><expr><name><name>zoneabbrevtbl</name><operator>-&gt;</operator><name>numabbrevs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>UNKNOWN_FIELD</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tz</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>abbrevcache</name><index>[<expr><name>field</name></expr>]</index></name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tz</name> <operator>=</operator> <call><name>FetchDynamicTimeZone</name><argument_list>(<argument><expr><name>zoneabbrevtbl</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tz</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeSpecial()
 * Decode text string using lookup table.
 *
 * Recognizes the keywords listed in datetktbl.
 * Note: at one time this would also recognize timezone abbreviations,
 * but no more; use DecodeTimezoneAbbrev for that.
 *
 * Given string must be lowercased already.
 *
 * Implement a cache lookup since it is likely that dates
 *	will be related in format.
 */</comment>
<function><type><name>int</name></type>
<name>DecodeSpecial</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lowtoken</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name><name>datecache</name><index>[<expr><name>field</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* use strncmp so that we match truncated tokens */</comment>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>TOKMAXLEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>datebsearch</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name>datetktbl</name></expr></argument>, <argument><expr><name>szdatetktbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>UNKNOWN_FIELD</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>datecache</name><index>[<expr><name>field</name></expr>]</index></name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ClearPgTm
 *
 * Zero out a pg_tm and associated fsec_t
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ClearPgTm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* DecodeInterval()
 * Interpret previously parsed fields for general time interval.
 * Returns 0 if successful, DTERR code if bogus input detected.
 * dtype, tm, fsec are output parameters.
 *
 * Allow "date" field DTK_DATE since this could be just
 *	an unsigned floating point number. - thomas 1997-11-16
 *
 * Allow ISO-style time span, with implicit units on number of days
 *	preceding an hh:mm:ss field. - thomas 1998-04-30
 */</comment>
<function><type><name>int</name></type>
<name>DecodeInterval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>range</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_before</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tmask</name></decl>,
				<decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fval</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DELTA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <name>IGNORE_DTF</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearPgTm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read through list backwards to pick up units before values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nf</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>ftype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_TIME</name></expr>:</case>
				<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>range</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>

				<comment type="block">/*
				 * Timezone means a token with a leading sign character and at
				 * least one digit; there could be ':', '.', '-' embedded in
				 * it as well.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check for signed hh:mm or hh:mm:ss.  If so, process exactly
				 * like DTK_TIME case above, plus handling the sign.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<call><name>DecodeTime</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>range</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>tmask</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* flip the sign on all fields */</comment>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Set the next type to be a day, if units are not
					 * specified. This handles the case of '1 +02:03' since we
					 * are reading right to left.
					 */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Otherwise, fall through to DTK_NUMBER case, which can
				 * handle signed float numbers and signed year-month values.
				 */</comment>

				<comment type="block">/* FALLTHROUGH */</comment>

			<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<case>case <expr><name>DTK_NUMBER</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* use typmod to decide what rightmost field is */</comment>
					<switch>switch <condition>(<expr><name>range</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_YEAR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MONTH</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_HOUR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MINUTE</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
						<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_SECOND</name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_SECOND</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* SQL "years-months" syntax */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>val2</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val2</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>val2</name> <operator>&gt;=</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_MONTH</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>val2</name> <operator>=</operator> <operator>-</operator><name>val2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>val</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>val2</name><operator>)</operator> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
						<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>val</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>val2</name><operator>)</operator> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>val2</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fval</name> <operator>=</operator> <operator>-</operator><name>fval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* DTK_M(type); */</comment>

				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>val</name> <operator>+</operator> <name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MICROSECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
						<comment type="block">/* avoid overflowing the fsec field */</comment>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>val</name> <operator>-=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><operator>(</operator><name>val</name> <operator>+</operator> <name>fval</name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MILLISECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_SECOND</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>fval</name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If any subseconds were specified, consider this
						 * microsecond and millisecond input as well.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tmask</name> <operator>=</operator> <name>DTK_ALL_SECS_M</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_HOUR</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>DTK_DAY</name></expr>;</expr_stmt> <comment type="block">/* set for next field */</comment>
						<break>break;</break>

					<case>case <expr><name>DTK_DAY</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_WEEK</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">7</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>WEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MONTH</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_YEAR</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_DECADE</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DECADE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>CENTURY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MILLENNIUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<case>case <expr><name>DTK_STRING</name></expr>:</case>
			<case>case <expr><name>DTK_SPECIAL</name></expr>:</case>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>IGNORE_DTF</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* DTK_M(type); */</comment>
				<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>UNITS</name></expr>:</case>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>AGO</name></expr>:</case>
						<expr_stmt><expr><name>is_before</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RESERV</name></expr>:</case>
						<expr_stmt><expr><name>tmask</name> <operator>=</operator> <operator>(</operator><name>DTK_DATE_M</name> <operator>|</operator> <name>DTK_TIME_M</name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				</block_content>}</block></switch>
				<break>break;</break>

			<default>default:</default>
				<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>tmask</name> <operator>&amp;</operator> <name>fmask</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>tmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ensure that at least one time field has been found */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ensure fractional seconds are fractional */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>*</operator><name>fsec</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>-=</operator> <name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>sec</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * The SQL standard defines the interval literal
	 *	 '-1 1:00:00'
	 * to mean "negative 1 days and negative 1 hours", while Postgres
	 * traditionally treats this as meaning "negative 1 days and positive
	 * 1 hours".  In SQL_STANDARD intervalstyle, we apply the leading sign
	 * to all fields if there are no other explicit signs.
	 *
	 * We leave the signs alone if there are additional explicit signs.
	 * This protects us against misinterpreting postgres-style dump output,
	 * since the postgres-style output code has always put an explicit sign on
	 * all fields following a negative field.  But note that SQL-spec output
	 * is ambiguous and can be misinterpreted on load!	(So it's best practice
	 * to dump in postgres style, not SQL style.)
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IntervalStyle</name> <operator>==</operator> <name>INTSTYLE_SQL_STANDARD</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>field</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for additional explicit signs */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>more_signs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name><name>field</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>more_signs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>more_signs</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Rather than re-determining which field was field[0], just force
			 * 'em all negative.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally, AGO negates everything */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_before</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>*</operator><name>fsec</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Helper functions to avoid duplicated code in DecodeISO8601Interval.
 *
 * Parse a decimal value and break it into integer and fractional parts.
 * Returns 0 or DTERR code.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParseISO8601Number</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ipart</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>fpart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* did we not see anything that looks like a double? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <name>str</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* watch out for overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>val</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>val</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_FIELD_OVERFLOW</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* be very sure we truncate towards zero (cf dtrunc()) */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ipart</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>floor</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ipart</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>-</operator><call><name>floor</name><argument_list>(<argument><expr><operator>-</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>fpart</name> <operator>=</operator> <name>val</name> <operator>-</operator> <operator>*</operator><name>ipart</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine number of integral digits in a valid ISO 8601 number field
 * (we should ignore sign and any fraction part)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ISO8601IntegerWidth</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fieldstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We might have had a leading '-' */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fieldstart</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fieldstart</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>strspn</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeISO8601Interval()
 *	Decode an ISO 8601 time interval of the "format with designators"
 *	(section 4.4.3.2) or "alternative format" (section 4.4.3.3)
 *	Examples:  P1D	for 1 day
 *			   PT1H for 1 hour
 *			   P2Y6M7DT1H30M for 2 years, 6 months, 7 days 1 hour 30 min
 *			   P0002-06-07T01:30:00 the same value in alternative format
 *
 * Returns 0 if successful, DTERR code if bogus input detected.
 * Note: error code should be DTERR_BAD_FORMAT if input doesn't look like
 * ISO8601, otherwise this could cause unexpected error messages.
 * dtype, tm, fsec are output parameters.
 *
 *	A couple exceptions from the spec:
 *	 - a week field ('W') may coexist with other units
 *	 - allows decimals in fields other than the least significant unit.
 */</comment>
<function><type><name>int</name></type>
<name>DecodeISO8601Interval</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>datepart</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havefield</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <name>DTK_DELTA</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearPgTm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'P'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fieldstart</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>fval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>unit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>		<comment type="block">/* T indicates the beginning of the time part */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fieldstart</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note: we could step off the end of the string here.  Code below
		 * *must* exit the loop if unit == '\0'.
		 */</comment>
		<expr_stmt><expr><name>unit</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>datepart</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>unit</name></expr>)</condition>		<comment type="block">/* before T: Y M W D */</comment>
			<block>{<block_content>
				<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'M'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'W'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <literal type="number">7</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'D'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'T'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format / Basic */</comment>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ISO8601IntegerWidth</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>havefield</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name> <operator>/</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Else fall through to extended alternative format */</comment>
					<comment type="block">/* FALLTHROUGH */</comment>
				<case>case <expr><literal type="char">'-'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format,
								 * Extended */</comment>
					<if_stmt><if>if <condition>(<expr><name>havefield</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <operator>(</operator><name>fval</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractDays</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>DAYS_PER_MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>datepart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
				<default>default:</default>
					<comment type="block">/* not a valid date unit suffix */</comment>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>unit</name></expr>)</condition>		<comment type="block">/* after T: H M S */</comment>
			<block>{<block_content>
				<case>case <expr><literal type="char">'H'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'M'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'S'</literal></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\0'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>ISO8601IntegerWidth</name><argument_list>(<argument><expr><name>fieldstart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>havefield</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name> <operator>/</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Else fall through to extended alternative format */</comment>
					<comment type="block">/* FALLTHROUGH */</comment>
				<case>case <expr><literal type="char">':'</literal></expr>:</case>		<comment type="block">/* ISO 8601 4.4.3.3 Alternative Format,
								 * Extended */</comment>
					<if_stmt><if>if <condition>(<expr><name>havefield</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

					<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseISO8601Number</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>dterr</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AdjustFractSeconds</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>

				<default>default:</default>
					<comment type="block">/* not a valid time unit suffix */</comment>
					<return>return <expr><name>DTERR_BAD_FORMAT</name></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>havefield</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* DecodeUnits()
 * Decode text string using lookup table.
 *
 * This routine recognizes keywords associated with time interval units.
 *
 * Given string must be lowercased already.
 *
 * Implement a cache lookup since it is likely that dates
 *	will be related in format.
 */</comment>
<function><type><name>int</name></type>
<name>DecodeUnits</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lowtoken</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name><name>deltacache</name><index>[<expr><name>field</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* use strncmp so that we match truncated tokens */</comment>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>TOKMAXLEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>datebsearch</name><argument_list>(<argument><expr><name>lowtoken</name></expr></argument>, <argument><expr><name>deltatktbl</name></expr></argument>, <argument><expr><name>szdeltatktbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>UNKNOWN_FIELD</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>deltacache</name><index>[<expr><name>field</name></expr>]</index></name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* DecodeUnits() */</comment>

<comment type="block">/*
 * Report an error detected by one of the datetime input processing routines.
 *
 * dterr is the error code, str is the original input string, datatype is
 * the name of the datatype we were trying to accept.
 *
 * Note: it might seem useless to distinguish DTERR_INTERVAL_OVERFLOW and
 * DTERR_TZDISP_OVERFLOW from DTERR_FIELD_OVERFLOW, but SQL99 mandates three
 * separate SQLSTATE codes, so ...
 */</comment>
<function><type><name>void</name></type>
<name>DateTimeParseError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dterr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>dterr</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTERR_FIELD_OVERFLOW</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date/time field value out of range: \"%s\""</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTERR_MD_FIELD_OVERFLOW</name></expr>:</case>
			<comment type="block">/* &lt;nanny&gt;same as above, but add hint about DateStyle&lt;/nanny&gt; */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date/time field value out of range: \"%s\""</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Perhaps you need a different \"datestyle\" setting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTERR_INTERVAL_OVERFLOW</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERVAL_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval field value out of range: \"%s\""</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTERR_TZDISP_OVERFLOW</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone displacement out of range: \"%s\""</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTERR_BAD_FORMAT</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><name>datatype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* datebsearch()
 * Binary search -- from Knuth (6.2.1) Algorithm B.  Special case like this
 * is WAY faster than the generic bsearch().
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type>
<name>datebsearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>base</name> <operator>+</operator> <name>nel</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>position</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>last</name> <operator>&gt;=</operator> <name>base</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>position</name> <operator>=</operator> <name>base</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>last</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<comment type="block">/* precheck the first character for a bit of extra speed */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>position</name><operator>-&gt;</operator><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* use strncmp so that we match truncated tokens */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>position</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>TOKMAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>position</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last</name> <operator>=</operator> <name>position</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>base</name> <operator>=</operator> <name>position</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* EncodeTimezone()
 *		Copies representation of a numeric timezone offset to str.
 *
 * Returns a pointer to the new end of string.  No NUL terminator is put
 * there; callers are responsible for NUL terminating str themselves.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>EncodeTimezone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>hour</name></decl>,
				<decl><type ref="prev"/><name>min</name></decl>,
				<decl><type ref="prev"/><name>sec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sec</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min</name> <operator>=</operator> <name>sec</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec</name> <operator>-=</operator> <name>min</name> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hour</name> <operator>=</operator> <name>min</name> <operator>/</operator> <name>MINS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>min</name> <operator>-=</operator> <name>hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr>;</expr_stmt>

	<comment type="block">/* TZ is negated compared to sign we wish to display ... */</comment>
	<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>tz</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>style</name> <operator>==</operator> <name>USE_XSD_DATES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* EncodeDateOnly()
 * Encode date as local time.
 */</comment>
<function><type><name>void</name></type>
<name>EncodeDateOnly</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <name>MONTHS_PER_YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>style</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>USE_ISO_DATES</name></expr>:</case>
		<case>case <expr><name>USE_XSD_DATES</name></expr>:</case>
			<comment type="block">/* compatible with ISO date formats */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_SQL_DATES</name></expr>:</case>
			<comment type="block">/* compatible with Oracle/Ingres date formats */</comment>
			<if_stmt><if>if <condition>(<expr><name>DateOrder</name> <operator>==</operator> <name>DATEORDER_DMY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_GERMAN_DATES</name></expr>:</case>
			<comment type="block">/* German-style date format */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_POSTGRES_DATES</name></expr>:</case>
		<default>default:</default>
			<comment type="block">/* traditional date-only style for Postgres */</comment>
			<if_stmt><if>if <condition>(<expr><name>DateOrder</name> <operator>==</operator> <name>DATEORDER_DMY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BC"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Don't copy NUL */</comment>
		<expr_stmt><expr><name>str</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* EncodeTimeOnly()
 * Encode time fields only.
 *
 * tm and fsec are the value to encode, print_tz determines whether to include
 * a time zone (the difference between time and timetz types), tz is the
 * numeric time zone offset, style is the date style, str is where to write the
 * output.
 */</comment>
<function><type><name>void</name></type>
<name>EncodeTimeOnly</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>print_tz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_TIME_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>print_tz</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>EncodeTimezone</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* EncodeDateTime()
 * Encode date and time interpreted as local time.
 *
 * tm and fsec are the value to encode, print_tz determines whether to include
 * a time zone (the difference between timestamp and timestamptz types), tz is
 * the numeric time zone offset, tzn is the textual time zone, which if
 * specified will be used instead of tz by some styles, style is the date
 * style, str is where to write the output.
 *
 * Supported date styles:
 *	Postgres - day mon hh:mm:ss yyyy tz
 *	SQL - mm/dd/yyyy hh:mm:ss.ss tz
 *	ISO - yyyy-mm-dd hh:mm:ss+/-tz
 *	German - dd.mm.yyyy hh:mm:ss tz
 *	XSD - yyyy-mm-ddThh:mm:ss.ss+/-tz
 */</comment>
<function><type><name>void</name></type>
<name>EncodeDateTime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>print_tz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>day</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <name>MONTHS_PER_YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Negative tm_isdst means we have no valid time zone translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>print_tz</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>style</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>USE_ISO_DATES</name></expr>:</case>
		<case>case <expr><name>USE_XSD_DATES</name></expr>:</case>
			<comment type="block">/* Compatible with ISO-8601 date formats */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>style</name> <operator>==</operator> <name>USE_ISO_DATES</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendTimestampSeconds</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>print_tz</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>EncodeTimezone</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_SQL_DATES</name></expr>:</case>
			<comment type="block">/* Compatible with Oracle/Ingres date formats */</comment>
			<if_stmt><if>if <condition>(<expr><name>DateOrder</name> <operator>==</operator> <name>DATEORDER_DMY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendTimestampSeconds</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: the uses of %.*s in this function would be risky if the
			 * timezone names ever contain non-ASCII characters.  However, all
			 * TZ abbreviations in the IANA database are plain ASCII.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>print_tz</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>tzn</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><name>MAXTZLEN</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>EncodeTimezone</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_GERMAN_DATES</name></expr>:</case>
			<comment type="block">/* German variant on European style */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendTimestampSeconds</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>print_tz</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>tzn</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><name>MAXTZLEN</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>EncodeTimezone</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>USE_POSTGRES_DATES</name></expr>:</case>
		<default>default:</default>
			<comment type="block">/* Backward-compatible with traditional Postgres abstime dates */</comment>
			<expr_stmt><expr><name>day</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>DateOrder</name> <operator>==</operator> <name>DATEORDER_DMY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendTimestampSeconds</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pg_ultostr_zeropad</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>print_tz</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>tzn</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><name>MAXTZLEN</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We have a time zone, but no string version. Use the
					 * numeric form, but be sure to include a leading space to
					 * avoid formatting something which would be rejected by
					 * the date/time parser later. - thomas 2001-10-19
					 */</comment>
					<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>EncodeTimezone</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BC"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Don't copy NUL */</comment>
		<expr_stmt><expr><name>str</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Helper functions to avoid duplicated code in EncodeInterval.
 */</comment>

<comment type="block">/* Append an ISO-8601-style interval field, but only if value isn't zero */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddISO8601IntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>units</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a postgres-style interval field, but only if value isn't zero */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddPostgresIntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>units</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_before</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%s%s%d %s%s"</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>*</operator><name>is_zero</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>is_before</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name>value</name></expr></argument>,
			<argument><expr><name>units</name></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each nonzero field sets is_before for (only) the next one.  This is a
	 * tad bizarre but it's how it worked before...
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_before</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a verbose-style interval field, but only if value isn't zero */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AddVerboseIntPart</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>units</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_zero</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_before</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cp</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* first nonzero value sets is_before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_zero</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>is_before</name> <operator>=</operator> <operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" %d %s%s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>units</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>cp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* EncodeInterval()
 * Interpret time structure as a delta time and convert to string.
 *
 * Support "traditional Postgres" and ISO-8601 styles.
 * Actually, afaik ISO does not address time interval formatting,
 *	but this looks similar to the spec for absolute date/time.
 * - thomas 1998-04-30
 *
 * Actually, afaik, ISO 8601 does specify formats for "time
 * intervals...[of the]...format with time-unit designators", which
 * are pretty ugly.  The format looks something like
 *	   P1Y1M1DT1H1M1.12345S
 * but useful for exchanging data with computers instead of humans.
 * - ron 2003-07-14
 *
 * And ISO's SQL 2008 standard specifies standards for
 * "year-month literal"s (that look like '2-3') and
 * "day-time literal"s (that look like ('4 5:6:7')
 */</comment>
<function><type><name>void</name></type>
<name>EncodeInterval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>style</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>year</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mon</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mday</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hour</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sec</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_before</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_zero</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The sign of year and month are guaranteed to match, since they are
	 * stored internally as "month". But we'll need to check for is_before and
	 * is_zero when determining the signs of day and hour/minute/seconds
	 * fields.
	 */</comment>
	<switch>switch <condition>(<expr><name>style</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* SQL Standard interval format */</comment>
		<case>case <expr><name>INTSTYLE_SQL_STANDARD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_negative</name> <init>= <expr><name>year</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>mday</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_positive</name> <init>= <expr><name>year</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>mday</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_year_month</name> <init>= <expr><name>year</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_day_time</name> <init>= <expr><name>mday</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_day</name> <init>= <expr><name>mday</name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>sql_standard_value</name> <init>= <expr><operator>!</operator><operator>(</operator><name>has_negative</name> <operator>&amp;&amp;</operator> <name>has_positive</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><name>has_year_month</name> <operator>&amp;&amp;</operator> <name>has_day_time</name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * SQL Standard wants only 1 "&lt;sign&gt;" preceding the whole
				 * interval ... but can't do that if mixed signs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>has_negative</name> <operator>&amp;&amp;</operator> <name>sql_standard_value</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>year</name> <operator>=</operator> <operator>-</operator><name>year</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>mon</name> <operator>=</operator> <operator>-</operator><name>mon</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>mday</name> <operator>=</operator> <operator>-</operator><name>mday</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hour</name> <operator>=</operator> <operator>-</operator><name>hour</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>min</name> <operator>=</operator> <operator>-</operator><name>min</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>-</operator><name>sec</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_negative</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_positive</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>sql_standard_value</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For non sql-standard interval values, force outputting
					 * the signs to avoid ambiguities with intervals with
					 * mixed sign components.
					 */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>year_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>year</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>day_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mday</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>sec_sign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
											<name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'-'</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%c%d-%d %c%d %c%d:%02d:"</literal></expr></argument>,
							<argument><expr><name>year_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>mon</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>day_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>sec_sign</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>has_year_month</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d-%d"</literal></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>has_day</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d %d:%02d:"</literal></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d:%02d:"</literal></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* ISO 8601 "time-intervals by duration only" */</comment>
		<case>case <expr><name>INTSTYLE_ISO_8601</name></expr>:</case>
			<comment type="block">/* special-case zero to avoid printing nothing */</comment>
			<if_stmt><if>if <condition>(<expr><name>year</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mon</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mday</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>hour</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sec</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"PT0S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'P'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="char">'M'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddISO8601IntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="char">'M'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/* Compatible with postgresql &lt; 8.4 when DateStyle = 'iso' */</comment>
		<case>case <expr><name>INTSTYLE_POSTGRES</name></expr>:</case>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="string">"year"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Ideally we should spell out "month" like we do for "year" and
			 * "day".  However, for backward compatibility, we can't easily
			 * fix this.  bjm 2011-05-24
			 */</comment>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="string">"mon"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddPostgresIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="string">"day"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>||</operator> <name>hour</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>minus</name> <init>= <expr><operator>(</operator><name>hour</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%s%s%02d:%02d:"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>is_zero</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>minus</name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>is_before</name></expr> ?</condition><then> <expr><literal type="string">"+"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>hour</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/* Compatible with postgresql &lt; 8.4 when DateStyle != 'iso' */</comment>
		<case>case <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"@"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="string">"year"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><literal type="string">"mon"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>, <argument><expr><literal type="string">"day"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hour</name></expr></argument>, <argument><expr><literal type="string">"hour"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AddVerboseIntPart</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>sec</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_zero</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>is_before</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>AppendSeconds</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" sec%s"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>fsec</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>is_zero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* identically zero? then put in a unitless zero... */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_zero</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_before</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" ago"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * We've been burnt by stupid errors in the ordering of the datetkn tables
 * once too often.  Arrange to check them during postmaster start.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckDateTokenTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* check for token strings that don't fit */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>TOKMAXLEN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* %.*s is safe since all our tokens are ASCII */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"token too long in %s table: \"%.*s\""</literal></expr></argument>,
				 <argument><expr><name>tablename</name></expr></argument>,
				 <argument><expr><name>TOKMAXLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* don't risk applying strcmp */</comment>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* check for out of order */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ordering error in %s table: \"%s\" &gt;= \"%s\""</literal></expr></argument>,
				 <argument><expr><name>tablename</name></expr></argument>,
				 <argument><expr><name><name>base</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>,
				 <argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>CheckDateTokenTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>UNIX_EPOCH_JDATE</name> <operator>==</operator> <call><name>date2j</name><argument_list>(<argument><expr><literal type="number">1970</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>POSTGRES_EPOCH_JDATE</name> <operator>==</operator> <call><name>date2j</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ok</name> <operator>&amp;=</operator> <call><name>CheckDateTokenTable</name><argument_list>(<argument><expr><literal type="string">"datetktbl"</literal></expr></argument>, <argument><expr><name>datetktbl</name></expr></argument>, <argument><expr><name>szdatetktbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ok</name> <operator>&amp;=</operator> <call><name>CheckDateTokenTable</name><argument_list>(<argument><expr><literal type="string">"deltatktbl"</literal></expr></argument>, <argument><expr><name>deltatktbl</name></expr></argument>, <argument><expr><name>szdeltatktbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for temporal prosupport functions: simplify, if possible,
 * a call to a temporal type's length-coercion function.
 *
 * Types time, timetz, timestamp and timestamptz each have a range of allowed
 * precisions.  An unspecified precision is rigorously equivalent to the
 * highest specifiable precision.  We can replace the function call with a
 * no-op RelabelType if it is coercing to the same or higher precision as the
 * input is known to have.
 *
 * The input Node is always a FuncExpr, but to reduce the #include footprint
 * of datetime.h, we declare it as Node *.
 *
 * Note: timestamp_scale throws an error when the typmod is out of range, but
 * we can't get there from a cast: our typmodin will have caught it already.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>TemporalSimplify</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>max_precis</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>typmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>source</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>old_precis</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_precis</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_precis</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>new_precis</name> <operator>==</operator> <name>max_precis</name> <operator>||</operator>
			<operator>(</operator><name>old_precis</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_precis</name> <operator>&gt;=</operator> <name>old_precis</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>relabel_to_typmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>new_precis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function gets called during timezone config file load or reload
 * to create the final array of timezone tokens.  The argument array
 * is already sorted in name order.
 *
 * The result is a TimeZoneAbbrevTable (which must be a single malloc'd chunk)
 * or NULL on malloc failure.  No other error conditions are defined.
 */</comment>
<function><type><name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type>
<name>ConvertTimeZoneAbbrevs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tzEntry</name></name> <modifier>*</modifier></type><name>abbrevs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tbl_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Space for fixed fields and datetkn array */</comment>
	<expr_stmt><expr><name>tbl_size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TimeZoneAbbrevTable</name></expr></argument>, <argument><expr><name>abbrevs</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>datetkn</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbl_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Count up space for dynamic abbreviations */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>tzEntry</name></name> <modifier>*</modifier></type><name>abbr</name> <init>= <expr><name>abbrevs</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>abbr</name><operator>-&gt;</operator><name>zone</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>dsize</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>dsize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>DynamicZoneAbbrev</name></expr></argument>, <argument><expr><name>zone</name></expr></argument>)</argument_list></call> <operator>+</operator>
				<call><name>strlen</name><argument_list>(<argument><expr><name><name>abbr</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tbl_size</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Alloc the result ... */</comment>
	<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ... and fill it in */</comment>
	<expr_stmt><expr><name><name>tbl</name><operator>-&gt;</operator><name>tblsize</name></name> <operator>=</operator> <name>tbl_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbl</name><operator>-&gt;</operator><name>numabbrevs</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<comment type="block">/* in this loop, tbl_size reprises the space calculation above */</comment>
	<expr_stmt><expr><name>tbl_size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TimeZoneAbbrevTable</name></expr></argument>, <argument><expr><name>abbrevs</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>datetkn</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbl_size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>tzEntry</name></name> <modifier>*</modifier></type><name>abbr</name> <init>= <expr><name>abbrevs</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>datetkn</name>    <modifier>*</modifier></type><name>dtoken</name> <init>= <expr><name><name>tbl</name><operator>-&gt;</operator><name>abbrevs</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* use strlcpy to truncate name if necessary */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>dtoken</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name><name>abbr</name><operator>-&gt;</operator><name>abbrev</name></name></expr></argument>, <argument><expr><name>TOKMAXLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>abbr</name><operator>-&gt;</operator><name>zone</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Allocate a DynamicZoneAbbrev for this abbreviation */</comment>
			<decl_stmt><decl><type><name>DynamicZoneAbbrev</name> <modifier>*</modifier></type><name>dtza</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>dsize</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>dtza</name> <operator>=</operator> <operator>(</operator><name>DynamicZoneAbbrev</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tbl</name> <operator>+</operator> <name>tbl_size</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dtza</name><operator>-&gt;</operator><name>tz</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>dtza</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>, <argument><expr><name><name>abbr</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>dtoken</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>DYNTZ</name></expr>;</expr_stmt>
			<comment type="block">/* value is offset from table start to DynamicZoneAbbrev */</comment>
			<expr_stmt><expr><name><name>dtoken</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>tbl_size</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>dsize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>DynamicZoneAbbrev</name></expr></argument>, <argument><expr><name>zone</name></expr></argument>)</argument_list></call> <operator>+</operator>
				<call><name>strlen</name><argument_list>(<argument><expr><name><name>abbr</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tbl_size</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>dtoken</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name><name>abbr</name><operator>-&gt;</operator><name>is_dst</name></name></expr> ?</condition><then> <expr><name>DTZ</name></expr> </then><else>: <expr><name>TZ</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dtoken</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>abbr</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Assert the two loops above agreed on size calculations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>tblsize</name></name> <operator>==</operator> <name>tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the ordering, if testing */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CheckDateTokenTable</name><argument_list>(<argument><expr><literal type="string">"timezone abbreviations"</literal></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>abbrevs</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tbl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Install a TimeZoneAbbrevTable as the active table.
 *
 * Caller is responsible that the passed table doesn't go away while in use.
 */</comment>
<function><type><name>void</name></type>
<name>InstallTimeZoneAbbrevs</name><parameter_list>(<parameter><decl><type><name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>zoneabbrevtbl</name> <operator>=</operator> <name>tbl</name></expr>;</expr_stmt>
	<comment type="block">/* reset abbrevcache, which may contain pointers into old table */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>abbrevcache</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>abbrevcache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper subroutine to locate pg_tz timezone for a dynamic abbreviation.
 */</comment>
<function><type><specifier>static</specifier> <name>pg_tz</name> <modifier>*</modifier></type>
<name>FetchDynamicTimeZone</name><parameter_list>(<parameter><decl><type><name>TimeZoneAbbrevTable</name> <modifier>*</modifier></type><name>tbl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DynamicZoneAbbrev</name> <modifier>*</modifier></type><name>dtza</name></decl>;</decl_stmt>

	<comment type="block">/* Just some sanity checks to prevent indexing off into nowhere */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DYNTZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>value</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name> <operator>&lt;</operator> <name><name>tbl</name><operator>-&gt;</operator><name>tblsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dtza</name> <operator>=</operator> <operator>(</operator><name>DynamicZoneAbbrev</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tbl</name> <operator>+</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Look up the underlying zone if we haven't already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dtza</name><operator>-&gt;</operator><name>tz</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dtza</name><operator>-&gt;</operator><name>tz</name></name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name><name>dtza</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ideally we'd let the caller ereport instead of doing it here, but
		 * then there is no way to report the bad time zone name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dtza</name><operator>-&gt;</operator><name>tz</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>dtza</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This time zone name appears in the configuration file for time zone abbreviation \"%s\"."</literal></expr></argument>,
							   <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>dtza</name><operator>-&gt;</operator><name>tz</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * This set-returning function reads all the available time zone abbreviations
 * and returns a set of (abbrev, utc_offset, is_dst).
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_timezone_abbrevs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>pindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>datetkn</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>TOKMAXLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>gmtoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>resInterval</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>pindex</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pindex</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * build tupdesc for result tuples. This must match this function's
		 * pg_proc entry!
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"abbrev"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"utc_offset"</literal></expr></argument>,
						   <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"is_dst"</literal></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pindex</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>zoneabbrevtbl</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>*</operator><name>pindex</name> <operator>&gt;=</operator> <name><name>zoneabbrevtbl</name><operator>-&gt;</operator><name>numabbrevs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name><name>zoneabbrevtbl</name><operator>-&gt;</operator><name>abbrevs</name></name> <operator>+</operator> <operator>*</operator><name>pindex</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tp</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TZ</name></expr>:</case>
			<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_dst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTZ</name></expr>:</case>
			<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_dst</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DYNTZ</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Determine the current meaning of the abbrev */</comment>
				<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>isdst</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>FetchDynamicTimeZone</name><argument_list>(<argument><expr><name>zoneabbrevtbl</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <operator>-</operator><call><name>DetermineTimeZoneAbbrevOffsetTS</name><argument_list>(<argument><expr><name>now</name></expr></argument>,
															 <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>,
															 <argument><expr><name>tzp</name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name>isdst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>is_dst</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <name>isdst</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized timezone type %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tp</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>is_dst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert name to text, using upcasing conversion that is the inverse of
	 * what ParseDateTime() uses.
	 */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert offset (in seconds) to an interval */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pg_tm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <name>gmtoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resInterval</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tm2interval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>resInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>resInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pindex</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This set-returning function reads all the available full time zones
 * and returns a set of (name, abbrev, utc_offset, is_dst).
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_timezone_names</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randomAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tzenum</name>  <modifier>*</modifier></type><name>tzenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tzoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>resInterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>itm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The tupdesc and tuplestore must be created in ecxt_per_query_memory */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>randomAccess</name> <operator>=</operator> <operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize timezone scanning code */</comment>
	<expr_stmt><expr><name>tzenum</name> <operator>=</operator> <call><name>pg_tzenumerate_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* search for another zone to display */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>pg_tzenumerate_next</name><argument_list>(<argument><expr><name>tzenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tz</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Convert now() to local time in this zone */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>tzoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore if conversion fails */</comment>

		<comment type="block">/*
		 * IANA's rather silly "Factory" time zone used to emit ridiculously
		 * long "abbreviations" such as "Local time zone must be set--see zic
		 * manual page" or "Local time zone must be set--use tzsetup".  While
		 * modern versions of tzdb emit the much saner "-00", it seems some
		 * benighted packagers are hacking the IANA data so that it continues
		 * to produce these strings.  To prevent producing a weirdly wide
		 * abbrev column, reject ridiculously long abbreviations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tzn</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>pg_get_timezone_name</name><argument_list>(<argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>tzn</name></expr> ?</condition><then> <expr><name>tzn</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pg_tm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>itm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name>tzoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resInterval</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tm2interval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>resInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>resInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_isdst</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_tzenumerate_end</name><argument_list>(<argument><expr><name>tzenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
