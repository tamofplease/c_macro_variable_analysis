<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/cash.c"><comment type="block">/*
 * cash.c
 * Written by D'Arcy J.M. Cain
 * darcy@druid.net
 * http://www.druid.net/darcy/
 *
 * Functions to allow input and output of money normally but store
 * and handle it as 64 bit ints
 *
 * A slightly modified version of this file and a discussion of the
 * workings can be found in the book "Software Solutions in C" by
 * Dale Schumacher, Academic Press, ISBN: 0-12-632360-7 except that
 * this version handles 64 bit numbers and so can hold values up to
 * $92,233,720,368,547,758.07.
 *
 * src/backend/utils/adt/cash.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/*************************************************************************
 * Private routines
 ************************************************************************/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>num_word</name><parameter_list>(<parameter><decl><type><name>Cash</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>small</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"zero"</literal></expr>, <expr><literal type="string">"one"</literal></expr>, <expr><literal type="string">"two"</literal></expr>, <expr><literal type="string">"three"</literal></expr>, <expr><literal type="string">"four"</literal></expr>, <expr><literal type="string">"five"</literal></expr>, <expr><literal type="string">"six"</literal></expr>, <expr><literal type="string">"seven"</literal></expr>,
		<expr><literal type="string">"eight"</literal></expr>, <expr><literal type="string">"nine"</literal></expr>, <expr><literal type="string">"ten"</literal></expr>, <expr><literal type="string">"eleven"</literal></expr>, <expr><literal type="string">"twelve"</literal></expr>, <expr><literal type="string">"thirteen"</literal></expr>, <expr><literal type="string">"fourteen"</literal></expr>,
		<expr><literal type="string">"fifteen"</literal></expr>, <expr><literal type="string">"sixteen"</literal></expr>, <expr><literal type="string">"seventeen"</literal></expr>, <expr><literal type="string">"eighteen"</literal></expr>, <expr><literal type="string">"nineteen"</literal></expr>, <expr><literal type="string">"twenty"</literal></expr>,
		<expr><literal type="string">"thirty"</literal></expr>, <expr><literal type="string">"forty"</literal></expr>, <expr><literal type="string">"fifty"</literal></expr>, <expr><literal type="string">"sixty"</literal></expr>, <expr><literal type="string">"seventy"</literal></expr>, <expr><literal type="string">"eighty"</literal></expr>, <expr><literal type="string">"ninety"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>big</name> <init>= <expr><name>small</name> <operator>+</operator> <literal type="number">18</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tu</name> <init>= <expr><name>value</name> <operator>%</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* deal with the simple cases first */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;=</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>small</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* is it an even multiple of 100? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tu</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s hundred"</literal></expr></argument>, <argument><expr><name><name>small</name><index>[<expr><name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>buf</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* more than 99? */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <literal type="number">99</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* is it an even multiple of 10 other than 10? */</comment>
		<if_stmt><if>if <condition>(<expr><name>value</name> <operator>%</operator> <literal type="number">10</literal> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tu</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s hundred %s"</literal></expr></argument>,
					<argument><expr><name><name>small</name><index>[<expr><name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>big</name><index>[<expr><name>tu</name> <operator>/</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>tu</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s hundred and %s"</literal></expr></argument>,
					<argument><expr><name><name>small</name><index>[<expr><name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>small</name><index>[<expr><name>tu</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s hundred %s %s"</literal></expr></argument>,
					<argument><expr><name><name>small</name><index>[<expr><name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>big</name><index>[<expr><name>tu</name> <operator>/</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>small</name><index>[<expr><name>tu</name> <operator>%</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* is it an even multiple of 10 other than 10? */</comment>
		<if_stmt><if>if <condition>(<expr><name>value</name> <operator>%</operator> <literal type="number">10</literal> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tu</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>big</name><index>[<expr><name>tu</name> <operator>/</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>tu</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>small</name><index>[<expr><name>tu</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>big</name><index>[<expr><name>tu</name> <operator>/</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>small</name><index>[<expr><name>tu</name> <operator>%</operator> <literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* num_word() */</comment>

<comment type="block">/* cash_in()
 * Convert a string to a cash data type.
 * Format is [$]###[,]###[.##]
 * Examples: 123.45 $123.45 $123,456.78
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>dec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>sgn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>seen_dot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>dsymbol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssymbol</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>psymbol</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>nsymbol</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>csymbol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * frac_digits will be CHAR_MAX in some locales, notably C.  However, just
	 * testing for == CHAR_MAX is risky, because of compilers like gcc that
	 * "helpfully" let you alter the platform-standard definition of whether
	 * char is signed or not.  If we are so unfortunate as to get compiled
	 * with a nonstandard -fsigned-char or -funsigned-char switch, then our
	 * idea of CHAR_MAX will not agree with libc's. The safest course is not
	 * to test for CHAR_MAX at all, but to impose a range check for plausible
	 * frac_digits values.
	 */</comment>
	<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpoint</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fpoint</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* best guess in this case, I think */</comment>

	<comment type="block">/* we restrict dsymbol to be a single byte, but not the other symbols */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		<name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dsymbol</name> <operator>=</operator> <operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dsymbol</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ssymbol</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* ssymbol should not equal dsymbol */</comment>
		<expr_stmt><expr><name>ssymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>dsymbol</name> <operator>!=</operator> <literal type="char">','</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>csymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>currency_symbol</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>lconvert</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr> </then><else>: <expr><literal type="string">"$"</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>psymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>positive_sign</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>lconvert</name><operator>-&gt;</operator><name>positive_sign</name></name></expr> </then><else>: <expr><literal type="string">"+"</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>negative_sign</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>lconvert</name><operator>-&gt;</operator><name>negative_sign</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASHDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cashin- precision '%d'; decimal '%c'; thousands '%s'; currency '%s'; positive '%s'; negative '%s'\n"</literal></expr></argument>,
		   <argument><expr><name>fpoint</name></expr></argument>, <argument><expr><name>dsymbol</name></expr></argument>, <argument><expr><name>ssymbol</name></expr></argument>, <argument><expr><name>csymbol</name></expr></argument>, <argument><expr><name>psymbol</name></expr></argument>, <argument><expr><name>nsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* we need to add all sorts of checking here.  For now just */</comment>
	<comment type="block">/* strip all leading whitespace and any leading currency symbol */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>csymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASHDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cashin- string is '%s'\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* a leading minus or paren signifies a negative number */</comment>
	<comment type="block">/* again, better heuristics needed */</comment>
	<comment type="block">/* XXX - doesn't properly check for balanced parens - djmc */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nsymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>nsymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sgn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sgn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>psymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>psymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>psymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASHDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cashin- string is '%s'\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* allow whitespace and currency symbol after the sign, too */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>csymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASHDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cashin- string is '%s'\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We accumulate the absolute amount in "value" and then apply the sign at
	 * the end.  (The sign can appear before or after the digits, so it would
	 * be more complicated to do otherwise.)  Because of the larger range of
	 * negative signed integers, we build "value" in the negative and then
	 * flip the sign at the end, catching most-negative-number overflow if
	 * necessary.
	 */</comment>

	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * We look for digits as long as we have found less than the required
		 * number of decimal places.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>seen_dot</name> <operator>||</operator> <name>dec</name> <operator>&lt;</operator> <name>fpoint</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int8</name></type>		<name>digit</name> <init>= <expr><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_mul_s64_overflow</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>pg_sub_s64_overflow</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>digit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value \"%s\" is out of range for type %s"</literal></expr></argument>,
								<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"money"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>seen_dot</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dec</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* decimal point? then start counting fractions... */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>dsymbol</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>seen_dot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>seen_dot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* ignore if "thousands" separator, else we're done */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ssymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ssymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ssymbol</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* round off if there's another digit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'5'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember we build the value in the negative */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_sub_s64_overflow</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value \"%s\" is out of range for type %s"</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"money"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* adjust for less than required decimal places */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>dec</name> <operator>&lt;</operator> <name>fpoint</name></expr>;</condition> <incr><expr><name>dec</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_mul_s64_overflow</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value \"%s\" is out of range for type %s"</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"money"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * should only be trailing digits followed by whitespace, right paren,
	 * trailing sign, and/or trailing currency symbol
	 */</comment>
	<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nsymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>nsymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sgn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>psymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>psymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>psymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>csymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"money"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If the value is supposed to be positive, flip the sign, but check for
	 * the most negative number.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sgn</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>PG_INT64_MIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value \"%s\" is out of range for type %s"</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"money"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASHDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cashin- result is "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_out()
 * Function to convert cash to a dollars and cents representation, using
 * the lc_monetary locale's formatting.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>digit_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>points</name></decl>,
				<decl><type ref="prev"/><name>mon_group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>dsymbol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssymbol</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>csymbol</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>signsymbol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>sign_posn</name></decl>,
				<decl><type ref="prev"/><name>cs_precedes</name></decl>,
				<decl><type ref="prev"/><name>sep_by_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see comments about frac_digits in cash_in() */</comment>
	<expr_stmt><expr><name>points</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>points</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>points</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>points</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* best guess in this case, I think */</comment>

	<comment type="block">/*
	 * As with frac_digits, must apply a range check to mon_grouping to avoid
	 * being fooled by variant CHAR_MAX values.
	 */</comment>
	<expr_stmt><expr><name>mon_group</name> <operator>=</operator> <operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_grouping</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mon_group</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>mon_group</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mon_group</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we restrict dsymbol to be a single byte, but not the other symbols */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		<name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dsymbol</name> <operator>=</operator> <operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_decimal_point</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dsymbol</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ssymbol</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* ssymbol should not equal dsymbol */</comment>
		<expr_stmt><expr><name>ssymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>dsymbol</name> <operator>!=</operator> <literal type="char">','</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>csymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>currency_symbol</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>lconvert</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr> </then><else>: <expr><literal type="string">"$"</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make the amount positive for digit-reconstruction loop */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt>
		<comment type="block">/* set up formatting data */</comment>
		<expr_stmt><expr><name>signsymbol</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>lconvert</name><operator>-&gt;</operator><name>negative_sign</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>lconvert</name><operator>-&gt;</operator><name>negative_sign</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign_posn</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>n_sign_posn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cs_precedes</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>n_cs_precedes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep_by_space</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>n_sep_by_space</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>signsymbol</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>positive_sign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign_posn</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>p_sign_posn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cs_precedes</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>p_cs_precedes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep_by_space</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>p_sep_by_space</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we build the digits+decimal-point+sep string right-to-left in buf[] */</comment>
	<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bufptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate digits till there are no non-zero digits left and we emitted
	 * at least one to the left of the decimal point.  digit_pos is the
	 * current digit position, with zero as the digit just left of the decimal
	 * point, increasing to the right.
	 */</comment>
	<expr_stmt><expr><name>digit_pos</name> <operator>=</operator> <name>points</name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>points</name> <operator>&amp;&amp;</operator> <name>digit_pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* insert decimal point, but not if value cannot be fractional */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufptr</name><operator>)</operator> <operator>=</operator> <name>dsymbol</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>digit_pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>digit_pos</name> <operator>%</operator> <name>mon_group</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* insert thousands sep, but only to left of radix point */</comment>
			<expr_stmt><expr><name>bufptr</name> <operator>-=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ssymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>ssymbol</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ssymbol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufptr</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>value</name> <operator>%</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>value</name><operator>)</operator> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>digit_pos</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>value</name> <operator>||</operator> <name>digit_pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<comment type="block">/*----------
	 * Now, attach currency symbol and sign symbol in the correct order.
	 *
	 * The POSIX spec defines these values controlling this code:
	 *
	 * p/n_sign_posn:
	 *	0	Parentheses enclose the quantity and the currency_symbol.
	 *	1	The sign string precedes the quantity and the currency_symbol.
	 *	2	The sign string succeeds the quantity and the currency_symbol.
	 *	3	The sign string precedes the currency_symbol.
	 *	4	The sign string succeeds the currency_symbol.
	 *
	 * p/n_cs_precedes: 0 means currency symbol after value, else before it.
	 *
	 * p/n_sep_by_space:
	 *	0	No &lt;space&gt; separates the currency symbol and value.
	 *	1	If the currency symbol and sign string are adjacent, a &lt;space&gt;
	 *		separates them from the value; otherwise, a &lt;space&gt; separates
	 *		the currency symbol from the value.
	 *	2	If the currency symbol and sign string are adjacent, a &lt;space&gt;
	 *		separates them; otherwise, a &lt;space&gt; separates the sign string
	 *		from the value.
	 *----------
	 */</comment>
	<switch>switch <condition>(<expr><name>sign_posn</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>cs_precedes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%s%s%s)"</literal></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%s%s%s)"</literal></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>cs_precedes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>cs_precedes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>cs_precedes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>cs_precedes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
								  <argument><expr><name>bufptr</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>csymbol</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>sep_by_space</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>signsymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		cash_recv			- converts external binary format to cash
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><operator>(</operator><name>Cash</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		cash_send			- converts cash to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison functions
 */</comment>

<function><type><name>Datum</name></type>
<name>cash_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>==</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>&lt;</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>&lt;=</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>&gt;</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>c1</name> <operator>&gt;=</operator> <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>cash_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>c1</name> <operator>==</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_pl()
 * Add two cash values.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c1</name> <operator>+</operator> <name>c2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mi()
 * Subtract two cash values.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c1</name> <operator>-</operator> <name>c2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_div_cash()
 * Divide cash by cash, returning float8.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>dividend</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>divisor</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>quotient</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>divisor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>quotient</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>dividend</name> <operator>/</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>divisor</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>quotient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mul_flt8()
 * Multiply cash by float8.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mul_flt8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>c</name> <operator>*</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* flt8_mul_cash()
 * Multiply float8 by cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>flt8_mul_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>f</name> <operator>*</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_div_flt8()
 * Divide cash by float8.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_flt8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>c</name> <operator>/</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mul_flt4()
 * Multiply cash by float4.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mul_flt4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>c</name> <operator>*</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* flt4_mul_cash()
 * Multiply float4 by cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>flt4_mul_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>f</name> <operator>*</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_div_flt4()
 * Divide cash by float4.
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_flt4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>f</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>c</name> <operator>/</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mul_int8()
 * Multiply cash by int8.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mul_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* int8_mul_cash()
 * Multiply int8 by cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_mul_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cash_div_int8()
 * Divide cash by 8-byte integer.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>/</operator> <name>i</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mul_int4()
 * Multiply cash by int4.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mul_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* int4_mul_cash()
 * Multiply int4 by cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>int4_mul_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_div_int4()
 * Divide cash by 4-byte integer.
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>/</operator> <name>i</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_mul_int2()
 * Multiply cash by int2.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_mul_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>s</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>*</operator> <name>s</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* int2_mul_cash()
 * Multiply int2 by cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>int2_mul_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>s</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cash_div_int2()
 * Divide cash by int2.
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_div_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>s</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>c</name> <operator>/</operator> <name>s</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cashlarger()
 * Return larger of two cash values.
 */</comment>
<function><type><name>Datum</name></type>
<name>cashlarger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c1</name> <operator>&gt;</operator> <name>c2</name><operator>)</operator></expr> ?</condition><then> <expr><name>c1</name></expr> </then><else>: <expr><name>c2</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cashsmaller()
 * Return smaller of two cash values.
 */</comment>
<function><type><name>Datum</name></type>
<name>cashsmaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c1</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>c2</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c1</name> <operator>&lt;</operator> <name>c2</name><operator>)</operator></expr> ?</condition><then> <expr><name>c1</name></expr> </then><else>: <expr><name>c2</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* cash_words()
 * This converts an int4 as well but to a representation using words
 * Obviously way North American centric - sorry
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_words</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m5</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>m6</name></decl>;</decl_stmt>

	<comment type="block">/* work with positive numbers */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"minus "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Now treat as unsigned, to avoid trouble at INT_MIN */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>value</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>m0</name> <operator>=</operator> <name>val</name> <operator>%</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cents */</comment>
	<expr_stmt><expr><name>m1</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>	<comment type="block">/* hundreds */</comment>
	<expr_stmt><expr><name>m2</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* thousands */</comment>
	<expr_stmt><expr><name>m3</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>	<comment type="block">/* millions */</comment>
	<expr_stmt><expr><name>m4</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>	<comment type="block">/* billions */</comment>
	<expr_stmt><expr><name>m5</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000000000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>	<comment type="block">/* trillions */</comment>
	<expr_stmt><expr><name>m6</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000000000000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* quadrillions */</comment>

	<if_stmt><if>if <condition>(<expr><name>m6</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m6</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" quadrillion "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>m5</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m5</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" trillion "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>m4</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" billion "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>m3</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" million "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>m2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" thousand "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>m1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>val</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">" dollar and "</literal></expr> </then><else>: <expr><literal type="string">" dollars and "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>num_word</name><argument_list>(<argument><expr><name>m0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>m0</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">" cent"</literal></expr> </then><else>: <expr><literal type="string">" cents"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* capitalize output */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return as text datum */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* cash_numeric()
 * Convert cash to numeric.
 */</comment>
<function><type><name>Datum</name></type>
<name>cash_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>money</name> <init>= <expr><call><name>PG_GETARG_CASH</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see comments about frac_digits in cash_in() */</comment>
	<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpoint</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fpoint</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* convert the integral money value to numeric */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>money</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* scale appropriately, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>fpoint</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>scale</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>numeric_scale</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>quotient</name></decl>;</decl_stmt>

		<comment type="block">/* compute required scale factor */</comment>
		<expr_stmt><expr><name>scale</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fpoint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name>numeric_scale</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
											<argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Given integral inputs approaching INT64_MAX, select_div_scale()
		 * might choose a result scale of zero, causing loss of fractional
		 * digits in the quotient.  We can ensure an exact result by setting
		 * the dscale of either input to be at least as large as the desired
		 * result scale.  numeric_round() will do that for us.
		 */</comment>
		<expr_stmt><expr><name>numeric_scale</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
											<argument><expr><name>numeric_scale</name></expr></argument>,
											<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>fpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can safely divide ... */</comment>
		<expr_stmt><expr><name>quotient</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>numeric_scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and forcibly round to exactly the intended number of digits */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
									 <argument><expr><name>quotient</name></expr></argument>,
									 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>fpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* numeric_cash()
 * Convert numeric to cash.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>amount</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>numeric_scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see comments about frac_digits in cash_in() */</comment>
	<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpoint</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fpoint</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* compute required scale factor */</comment>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fpoint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* multiply the input amount by scale factor */</comment>
	<expr_stmt><expr><name>numeric_scale</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>amount</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_mul</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>numeric_scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* note that numeric_int8 will round to nearest integer for us */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* int4_cash()
 * Convert int4 (int) to cash
 */</comment>
<function><type><name>Datum</name></type>
<name>int4_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>amount</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see comments about frac_digits in cash_in() */</comment>
	<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpoint</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fpoint</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* compute required scale factor */</comment>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fpoint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* compute amount * scale, checking for overflow */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8mul</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* int8_cash()
 * Convert int8 (bigint) to cash
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_cash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>amount</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cash</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconvert</name> <init>= <expr><call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see comments about frac_digits in cash_in() */</comment>
	<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <name><name>lconvert</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpoint</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fpoint</name></expr></argument> &gt;</argument_list></name> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpoint</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* compute required scale factor */</comment>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fpoint</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* compute amount * scale, checking for overflow */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8mul</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CASH</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
