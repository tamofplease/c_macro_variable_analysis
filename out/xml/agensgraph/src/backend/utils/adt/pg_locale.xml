<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/pg_locale.c"><comment type="block">/*-----------------------------------------------------------------------
 *
 * PostgreSQL locale utilities
 *
 * Portions Copyright (c) 2002-2020, PostgreSQL Global Development Group
 *
 * src/backend/utils/adt/pg_locale.c
 *
 *-----------------------------------------------------------------------
 */</comment>

<comment type="block">/*----------
 * Here is how the locale stuff is handled: LC_COLLATE and LC_CTYPE
 * are fixed at CREATE DATABASE time, stored in pg_database, and cannot
 * be changed. Thus, the effects of strcoll(), strxfrm(), isupper(),
 * toupper(), etc. are always in the same fixed locale.
 *
 * LC_MESSAGES is settable at run time and will take effect
 * immediately.
 *
 * The other categories, LC_MONETARY, LC_NUMERIC, and LC_TIME are also
 * settable at run-time.  However, we don't actually set those locale
 * categories permanently.  This would have bizarre effects like no
 * longer accepting standard floating-point literals in some locales.
 * Instead, we only set these locale categories briefly when needed,
 * cache the required information obtained from localeconv() or
 * strftime(), and then set the locale categories back to "C".
 * The cached information is only used by the formatting functions
 * (to_char, etc.) and the money type.  For the user, this should all be
 * transparent.
 *
 * !!! NOW HEAR THIS !!!
 *
 * We've been bitten repeatedly by this bug, so let's try to keep it in
 * mind in future: on some platforms, the locale functions return pointers
 * to static data that will be overwritten by any later locale function.
 * Thus, for example, the obvious-looking sequence
 *			save = setlocale(category, NULL);
 *			if (!setlocale(category, value))
 *				fail = true;
 *			setlocale(category, save);
 * DOES NOT WORK RELIABLY: on some platforms the second setlocale() call
 * will change the memory save is pointing at.  To do this sort of thing
 * safely, you *must* pstrdup what setlocale returns the first time.
 *
 * The POSIX locale standard is available here:
 *
 *	http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap07.html
 *----------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/ucnv.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GLIBC__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gnu/libc-version.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * This Windows file defines StrNCpy. We don't need it here, so we undefine
 * it to keep the compiler quiet, and undefine it again after the file is
 * included, so we don't accidentally use theirs.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>StrNCpy</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shlwapi.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>StrNCpy</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>StrNCpy</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>MAX_L10N_DATA</name></cpp:macro>		<cpp:value>80</cpp:value></cpp:define>


<comment type="block">/* GUC settings */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locale_messages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locale_monetary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locale_numeric</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locale_time</name></decl>;</decl_stmt>

<comment type="block">/*
 * lc_time localization cache.
 *
 * We use only the first 7 or 12 entries of these arrays.  The last array
 * element is left as NULL for the convenience of outside code that wants
 * to sequentially scan these arrays.
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>localized_abbrev_days</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>localized_full_days</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>localized_abbrev_months</name><index>[<expr><literal type="number">12</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>localized_full_months</name><index>[<expr><literal type="number">12</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* indicates whether locale information cache is valid */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CurrentLocaleConvValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CurrentLCTimeValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Environment variable storage area */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_ENV_BUFSIZE</name></cpp:macro> <cpp:value>(NAMEDATALEN + 20)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_collate_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_ctype_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_MESSAGES</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_messages_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_monetary_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_numeric_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lc_time_envbuf</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Cache for collation-related knowledge */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>			<comment type="block">/* hash key: pg_collation OID */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collate_is_c</name></decl>;</decl_stmt>	<comment type="block">/* is collation's LC_COLLATE C? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ctype_is_c</name></decl>;</decl_stmt>		<comment type="block">/* is collation's LC_CTYPE C? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>flags_valid</name></decl>;</decl_stmt>	<comment type="block">/* true if above flags are valid */</comment>
	<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl>;</decl_stmt>			<comment type="block">/* locale_t struct, or 0 if not valid */</comment>
}</block></struct></type> <name>collation_cache_entry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>collation_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>IsoLocaleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* MSVC specific */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>icu_set_collation_attributes</name><parameter_list>(<parameter><decl><type><name>UCollator</name> <modifier>*</modifier></type><name>collator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pg_perm_setlocale
 *
 * This wraps the libc function setlocale(), with two additions.  First, when
 * changing LC_CTYPE, update gettext's encoding for the current message
 * domain.  GNU gettext automatically tracks LC_CTYPE on most platforms, but
 * not on Windows.  Second, if the operation is successful, the corresponding
 * LC_XXX environment variable is set to match.  By setting the environment
 * variable, we ensure that any subsequent use of setlocale(..., "") will
 * preserve the settings made through this routine.  Of course, LC_ALL must
 * also be unset to fully ensure that, but that has to be done elsewhere after
 * all the individual LC_XXX variables have been set correctly.  (Thank you
 * Perl for making this kluge necessary.)
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_perm_setlocale</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>envbuf</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that
	 * the given value is good and set it in the environment variables. We
	 * must ignore attempts to set to "", which means "keep using the old
	 * environment value".
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_MESSAGES</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_MESSAGES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>locale</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>locale</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* fall out immediately on failure */</comment>

	<comment type="block">/*
	 * Use the right encoding in translated messages.  Under ENABLE_NLS, let
	 * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message
	 * format strings are ASCII, but database-encoding strings may enter the
	 * message via %s.  This makes the overall message encoding equal to the
	 * database encoding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_CTYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>save_lc_ctype</name><index>[<expr><name>LC_ENV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* copy setlocale() return value before callee invokes it again */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>save_lc_ctype</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>SetMessageEncoding</name><argument_list>(<argument><expr><call><name>pg_bind_textdomain_codeset</name><argument_list>(<argument><expr><call><name>textdomain</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>SetMessageEncoding</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>category</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LC_COLLATE</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_COLLATE"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_collate_envbuf</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LC_CTYPE</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_CTYPE"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_ctype_envbuf</name></expr>;</expr_stmt>
			<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_MESSAGES</name></cpp:ifdef>
		<case>case <expr><name>LC_MESSAGES</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_MESSAGES"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_messages_envbuf</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>IsoLocaleName</name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"IsoLocaleName() executed; locale: \"%s\""</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LC_MESSAGES */</comment>
		<case>case <expr><name>LC_MONETARY</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_MONETARY"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_monetary_envbuf</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LC_NUMERIC</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_NUMERIC"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_numeric_envbuf</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LC_TIME</name></expr>:</case>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <literal type="string">"LC_TIME"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>lc_time_envbuf</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LC category: %d"</literal></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>envvar</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>envbuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>envbuf</name></expr></argument>, <argument><expr><name>LC_ENV_BUFSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>envvar</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>putenv</name><argument_list>(<argument><expr><name>envbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Is the locale name valid for the locale category?
 *
 * If successful, and canonname isn't NULL, a palloc'd copy of the locale's
 * canonical name is stored there.  This is especially useful for figuring out
 * what locale name "" means (ie, the server environment value).  (Actually,
 * it seems that on most implementations that's the only thing it's good for;
 * we could wish that setlocale gave back a canonically spelled version of
 * the locale name, but typically it doesn't.)
 */</comment>
<function><type><name>bool</name></type>
<name>check_locale</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>canonname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>canonname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>canonname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* in case of failure */</comment>

	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* won't happen, we hope */</comment>

	<comment type="block">/* save may be pointing at a modifiable scratch variable, see above. */</comment>
	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the locale with setlocale, to see if it accepts it. */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save canonical name if requested. */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <name>canonname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>canonname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* restore old value. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"failed to restore old locale \"%s\""</literal></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>res</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GUC check/assign hooks
 *
 * For most locale categories, the assign hook doesn't actually set the locale
 * permanently, just reset flags so that the next use will cache the
 * appropriate values.  (See explanation at the top of this file.)
 *
 * Note: we accept value = "" as selecting the postmaster's environment
 * value, whatever it was (so long as the environment setting is legal).
 * This will have been locked down by an earlier call to pg_perm_setlocale.
 */</comment>
<function><type><name>bool</name></type>
<name>check_locale_monetary</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>check_locale</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_locale_monetary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentLocaleConvValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>check_locale_numeric</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>check_locale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_locale_numeric</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentLocaleConvValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>check_locale_time</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>check_locale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_locale_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentLCTimeValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We allow LC_MESSAGES to actually be set globally.
 *
 * Note: we normally disallow value = "" because it wouldn't have consistent
 * semantics (it'd effectively just use the previous value).  However, this
 * is the value passed for PGC_S_DEFAULT, so don't complain in that case,
 * not even if the attempted setting fails due to invalid environment value.
 * The idea there is just to accept the environment setting *if possible*
 * during startup, until we can read the proper value from postgresql.conf.
 */</comment>
<function><type><name>bool</name></type>
<name>check_locale_messages</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>newval</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * LC_MESSAGES category does not exist everywhere, but accept it anyway
	 *
	 * On Windows, we can't even check the value, so accept blindly
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<return>return <expr><call><name>check_locale</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_locale_messages</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * LC_MESSAGES category does not exist everywhere, but accept it anyway.
	 * We ignore failure, as per comment above.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_MESSAGES</name></cpp:ifdef>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pg_perm_setlocale</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Frees the malloced content of a struct lconv.  (But not the struct
 * itself.)  It's important that this not throw elog(ERROR).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_struct_lconv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>decimal_point</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>grouping</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>grouping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>int_curr_symbol</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>int_curr_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_decimal_point</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mon_decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_grouping</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>mon_grouping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>positive_sign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>positive_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>negative_sign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that all fields of a struct lconv (or at least, the ones we care
 * about) are non-NULL.  The field list must match free_struct_lconv().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>struct_lconv_is_valid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>decimal_point</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>thousands_sep</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>grouping</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>int_curr_symbol</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>currency_symbol</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_decimal_point</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mon_grouping</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>positive_sign</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>negative_sign</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Convert the strdup'd string at *str from the specified encoding to the
 * database encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>db_encoding_convert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mstr</name></decl>;</decl_stmt>

	<comment type="block">/* convert the string to the database encoding */</comment>
	<expr_stmt><expr><name>pstr</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pstr</name> <operator>==</operator> <operator>*</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no conversion happened */</comment>

	<comment type="block">/* need it malloc'd not palloc'd */</comment>
	<expr_stmt><expr><name>mstr</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* replace old string */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <name>mstr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the POSIX lconv struct (contains number/money formatting
 * information) with locale information for all categories.
 */</comment>
<function><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type>
<name>PGLC_localeconv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lconv</name></name></type> <name>CurrentLocaleConv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CurrentLocaleConvAllocated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>extlconv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name></type> <name>worklconv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_lc_monetary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_lc_numeric</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_lc_ctype</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Did we do it already? */</comment>
	<if_stmt><if>if <condition>(<expr><name>CurrentLocaleConvValid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name>CurrentLocaleConv</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Free any already-allocated storage */</comment>
	<if_stmt><if>if <condition>(<expr><name>CurrentLocaleConvAllocated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_struct_lconv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>CurrentLocaleConv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentLocaleConvAllocated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This is tricky because we really don't want to risk throwing error
	 * while the locale is set to other than our usual settings.  Therefore,
	 * the process is: collect the usual settings, set locale to special
	 * setting, copy relevant data into worklconv using strdup(), restore
	 * normal settings, convert data to desired encoding, and finally stash
	 * the collected data in CurrentLocaleConv.  This makes it safe if we
	 * throw an error during encoding conversion or run out of memory anywhere
	 * in the process.  All data pointed to by struct lconv members is
	 * allocated with strdup, to avoid premature elog(ERROR) and to allow
	 * using a single cleanup routine.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worklconv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worklconv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save prevailing values of monetary and numeric locales */</comment>
	<expr_stmt><expr><name>save_lc_monetary</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_lc_monetary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setlocale(NULL) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save_lc_monetary</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save_lc_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>save_lc_numeric</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_lc_numeric</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setlocale(NULL) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save_lc_numeric</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save_lc_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * The POSIX standard explicitly says that it is undefined what happens if
	 * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from
	 * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to
	 * believe that localeconv() should return strings that are encoded in the
	 * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,
	 * once we have successfully collected the localeconv() results, we will
	 * convert them from that codeset to the desired server encoding.
	 *
	 * Windows, of course, resolutely does things its own way; on that
	 * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane
	 * results.  Hence, we must temporarily set that category as well.
	 */</comment>

	<comment type="block">/* Save prevailing value of ctype locale */</comment>
	<expr_stmt><expr><name>save_lc_ctype</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_lc_ctype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setlocale(NULL) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save_lc_ctype</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Here begins the critical section where we must not throw error */</comment>

	<comment type="block">/* use numeric to set the ctype */</comment>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>locale_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Get formatting information for numeric */</comment>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>locale_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extlconv</name> <operator>=</operator> <call><name>localeconv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must copy data now in case setlocale() overwrites it */</comment>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>decimal_point</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>thousands_sep</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>grouping</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>grouping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* use monetary to set the ctype */</comment>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>locale_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Get formatting information for monetary */</comment>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>locale_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extlconv</name> <operator>=</operator> <call><name>localeconv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must copy data now in case setlocale() overwrites it */</comment>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>int_curr_symbol</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>int_curr_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>currency_symbol</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>mon_decimal_point</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>mon_decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>mon_thousands_sep</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>mon_thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>mon_grouping</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>mon_grouping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>positive_sign</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>positive_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>negative_sign</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>extlconv</name><operator>-&gt;</operator><name>negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Copy scalar fields as well */</comment>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>int_frac_digits</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>int_frac_digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>frac_digits</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>frac_digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>p_cs_precedes</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>p_cs_precedes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>p_sep_by_space</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>p_sep_by_space</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>n_cs_precedes</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>n_cs_precedes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>n_sep_by_space</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>n_sep_by_space</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>p_sign_posn</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>p_sign_posn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worklconv</name><operator>.</operator><name>n_sign_posn</name></name> <operator>=</operator> <name><name>extlconv</name><operator>-&gt;</operator><name>n_sign_posn</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore the prevailing locale settings; failure to do so is fatal.
	 * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,
	 * but proceeding with the wrong value of LC_CTYPE would certainly be bad
	 * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC
	 * are almost certainly "C", there's really no reason that restoring those
	 * should fail.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to restore LC_CTYPE to \"%s\""</literal></expr></argument>, <argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>save_lc_monetary</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to restore LC_MONETARY to \"%s\""</literal></expr></argument>, <argument><expr><name>save_lc_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>save_lc_numeric</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to restore LC_NUMERIC to \"%s\""</literal></expr></argument>, <argument><expr><name>save_lc_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At this point we've done our best to clean up, and can call functions
	 * that might possibly throw errors with a clean conscience.  But let's
	 * make sure we don't leak any already-strdup'd fields in worklconv.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>

		<comment type="block">/* Release the pstrdup'd locale names */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save_lc_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save_lc_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* If any of the preceding strdup calls failed, complain now. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>struct_lconv_is_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worklconv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Now we must perform encoding conversion from whatever's associated
		 * with the locales into the database encoding.  If we can't identify
		 * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),
		 * use PG_SQL_ASCII, which will result in just validating that the
		 * strings are OK in the database encoding.
		 */</comment>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>locale_numeric</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* grouping is not text and does not require conversion */</comment>

		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>locale_monetary</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>int_curr_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>currency_symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>mon_decimal_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>mon_thousands_sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mon_grouping is not text and does not require conversion */</comment>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>positive_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>db_encoding_convert</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>worklconv</name><operator>.</operator><name>negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_struct_lconv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worklconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Everything is good, so save the results.
	 */</comment>
	<expr_stmt><expr><name>CurrentLocaleConv</name> <operator>=</operator> <name>worklconv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentLocaleConvAllocated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentLocaleConvValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name>CurrentLocaleConv</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * On Windows, strftime() returns its output in encoding CP_ACP (the default
 * operating system codepage for the computer), which is likely different
 * from SERVER_ENCODING.  This is especially important in Japanese versions
 * of Windows which will use SJIS encoding, which we don't support as a
 * server encoding.
 *
 * So, instead of using strftime(), use wcsftime() to return the value in
 * wide characters (internally UTF16) and then convert to UTF8, which we
 * know how to handle directly.
 *
 * Note that this only affects the calls to strftime() in this file, which are
 * used to get the locale-aware strings. Other parts of the backend use
 * pg_strftime(), which isn't locale-aware and does not need to be replaced.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>strftime_win32</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstlen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name></type>		<name><name>wformat</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* formats used below need 3 chars */</comment>
	<decl_stmt><decl><type><name>wchar_t</name></type>		<name><name>wbuf</name><index>[<expr><name>MAX_L10N_DATA</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get a wchar_t version of the format string.  We only actually use
	 * plain-ASCII formats in this file, so we can say that they're UTF8.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>wformat</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>wformat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert format string from UTF-8: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcsftime</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>, <argument><expr><name>MAX_L10N_DATA</name></expr></argument>, <argument><expr><name>wformat</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * wcsftime failed, possibly because the result would not fit in
		 * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.
		 */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert string to UTF-8: error code %lu"</literal></expr></argument>,
			 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>dst</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* redefine strftime() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strftime</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strftime_win32(a,b,c,d)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Subroutine for cache_locale_time().
 * Convert the given string from encoding "encoding" to the database
 * encoding, and store the result at *dst, replacing any previous value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_single_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>olddst</name></decl>;</decl_stmt>

	<comment type="block">/* Convert the string to the database encoding, or validate it's OK */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the string in long-lived storage, replacing any previous value */</comment>
	<expr_stmt><expr><name>olddst</name> <operator>=</operator> <operator>*</operator><name>dst</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>olddst</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>olddst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Might as well clean up any palloc'd conversion result, too */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>src</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the lc_time localization cache variables if needed.
 */</comment>
<function><type><name>void</name></type>
<name>cache_locale_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">12</literal><operator>)</operator> <operator>*</operator> <name>MAX_L10N_DATA</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>timenow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name>  <modifier>*</modifier></type><name>timeinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>strftimefail</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_lc_time</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_lc_ctype</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* did we do this already? */</comment>
	<if_stmt><if>if <condition>(<expr><name>CurrentLCTimeValid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"cache_locale_time() executed; locale: \"%s\""</literal></expr></argument>, <argument><expr><name>locale_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in PGLC_localeconv(), it's critical that we not throw error while
	 * libc's locale settings have nondefault values.  Hence, we just call
	 * strftime() within the critical section, and then convert and save its
	 * results afterwards.
	 */</comment>

	<comment type="block">/* Save prevailing value of time locale */</comment>
	<expr_stmt><expr><name>save_lc_time</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_lc_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setlocale(NULL) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save_lc_time</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save_lc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we
	 * must set it here.  This code looks the same as what PGLC_localeconv()
	 * does, but the underlying reason is different: this does NOT determine
	 * the encoding we'll get back from strftime_win32().
	 */</comment>

	<comment type="block">/* Save prevailing value of ctype locale */</comment>
	<expr_stmt><expr><name>save_lc_ctype</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_lc_ctype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setlocale(NULL) failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save_lc_ctype</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use lc_time to set the ctype */</comment>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>locale_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>locale_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We use times close to current time as data for strftime(). */</comment>
	<expr_stmt><expr><name>timenow</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>timeinfo</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timenow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */</comment>
	<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * MAX_L10N_DATA is sufficient buffer space for every known locale, and
	 * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an
	 * error.)  An implementation might report errors (e.g. ENOMEM) by
	 * returning 0 (or, less plausibly, a negative value) and setting errno.
	 * Report errno just in case the implementation did that, but clear it in
	 * advance of the calls so we don't emit a stale, unrelated errno.
	 */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* localized days */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>timeinfo</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>MAX_L10N_DATA</name></expr></argument>, <argument><expr><literal type="string">"%a"</literal></expr></argument>, <argument><expr><name>timeinfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strftimefail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>MAX_L10N_DATA</name></expr></argument>, <argument><expr><literal type="string">"%A"</literal></expr></argument>, <argument><expr><name>timeinfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strftimefail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* localized months */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>timeinfo</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeinfo</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* make sure we don't have invalid date */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>MAX_L10N_DATA</name></expr></argument>, <argument><expr><literal type="string">"%b"</literal></expr></argument>, <argument><expr><name>timeinfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strftimefail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>MAX_L10N_DATA</name></expr></argument>, <argument><expr><literal type="string">"%B"</literal></expr></argument>, <argument><expr><name>timeinfo</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strftimefail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Restore the prevailing locale settings; as in PGLC_localeconv(),
	 * failure to do so is fatal.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to restore LC_CTYPE to \"%s\""</literal></expr></argument>, <argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>save_lc_time</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to restore LC_TIME to \"%s\""</literal></expr></argument>, <argument><expr><name>save_lc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At this point we've done our best to clean up, and can throw errors, or
	 * call functions that might throw errors, with a clean conscience.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>strftimefail</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"strftime() failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release the pstrdup'd locale names */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save_lc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>save_lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * As in PGLC_localeconv(), we must convert strftime()'s output from the
	 * encoding implied by LC_TIME to the database encoding.  If we can't
	 * identify the LC_TIME encoding, just perform encoding validation.
	 */</comment>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>locale_time</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On Windows, strftime_win32() always returns UTF8 data, so convert from
	 * that if necessary.
	 */</comment>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name>PG_UTF8</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/* localized days */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cache_single_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localized_abbrev_days</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cache_single_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localized_full_days</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>localized_abbrev_days</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localized_full_days</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* localized months */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cache_single_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localized_abbrev_months</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cache_single_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localized_full_months</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>MAX_L10N_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>localized_abbrev_months</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localized_full_months</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentLCTimeValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * Convert a Windows setlocale() argument to a Unix-style one.
 *
 * Regardless of platform, we install message catalogs under a Unix-style
 * LL[_CC][.ENCODING][@VARIANT] naming convention.  Only LC_MESSAGES settings
 * following that style will elicit localized interface strings.
 *
 * Before Visual Studio 2012 (msvcr110.dll), Windows setlocale() accepted "C"
 * (but not "c") and strings of the form &lt;Language&gt;[_&lt;Country&gt;][.&lt;CodePage&gt;],
 * case-insensitive.  setlocale() returns the fully-qualified form; for
 * example, setlocale("thaI") returns "Thai_Thailand.874".  Internally,
 * setlocale() and _create_locale() select a "locale identifier"[1] and store
 * it in an undocumented _locale_t field.  From that LCID, we can retrieve the
 * ISO 639 language and the ISO 3166 country.  Character encoding does not
 * matter, because the server and client encodings govern that.
 *
 * Windows Vista introduced the "locale name" concept[2], closely following
 * RFC 4646.  Locale identifiers are now deprecated.  Starting with Visual
 * Studio 2012, setlocale() accepts locale names in addition to the strings it
 * accepted historically.  It does not standardize them; setlocale("Th-tH")
 * returns "Th-tH".  setlocale(category, "") still returns a traditional
 * string.  Furthermore, msvcr110.dll changed the undocumented _locale_t
 * content to carry locale names instead of locale identifiers.
 *
 * Visual Studio 2015 should still be able to do the same as Visual Studio
 * 2012, but the declaration of locale_name is missing in _locale_t, causing
 * this code compilation to fail, hence this falls back instead on to
 * enumerating all system locales by using EnumSystemLocalesEx to find the
 * required locale name.  If the input argument is in Unix-style then we can
 * get ISO Locale name directly by using GetLocaleInfoEx() with LCType as
 * LOCALE_SNAME.
 *
 * MinGW headers declare _create_locale(), but msvcrt.dll lacks that symbol in
 * releases before Windows 8. IsoLocaleName() always fails in a MinGW-built
 * postgres.exe, so only Unix-style values of the lc_messages GUC can elicit
 * localized messages. In particular, every lc_messages setting that initdb
 * can select automatically will yield only C-locale messages. XXX This could
 * be fixed by running the fully-qualified locale name through a lookup table.
 *
 * This function returns a pointer to a static buffer bearing the converted
 * name or NULL if conversion fails.
 *
 * [1] https://docs.microsoft.com/en-us/windows/win32/intl/locale-identifiers
 * [2] https://docs.microsoft.com/en-us/windows/win32/intl/locale-names
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1900</literal></expr></cpp:if>
<comment type="block">/*
 * Callback function for EnumSystemLocalesEx() in get_iso_localename().
 *
 * This function enumerates all system locales, searching for one that matches
 * an input with the format: &lt;Language&gt;[_&lt;Country&gt;], e.g.
 * English[_United States]
 *
 * The input is a three wchar_t array as an LPARAM. The first element is the
 * locale_name we want to match, the second element is an allocated buffer
 * where the Unix-style locale is copied if a match is found, and the third
 * element is the search status, 1 if a match was found, 0 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>CALLBACK</name></type>
<name>search_locale_enum</name><parameter_list>(<parameter><decl><type><name>LPWSTR</name></type> <name>pStr</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>dwFlags</name></decl></parameter>, <parameter><decl><type><name>LPARAM</name></type> <name>lparam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>wchar_t</name></type>		<name><name>test_locale</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name>   <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <operator>(</operator><name>dwFlags</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>lparam</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>wchar_t</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>test_locale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_locale</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the name of the &lt;Language&gt; in English */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetLocaleInfoEx</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>LOCALE_SENGLISHLANGUAGENAME</name></expr></argument>,
						<argument><expr><name>test_locale</name></expr></argument>, <argument><expr><name>LOCALE_NAME_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the enumerated locale does not have a hyphen ("en") OR  the
		 * lc_message input does not have an underscore ("English"), we only
		 * need to compare the &lt;Language&gt; tags.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>wcsrchr</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>wcsrchr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>_wcsicmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>test_locale</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>wchar_t</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<return>return <expr><name>FALSE</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * We have to compare a full &lt;Language&gt;_&lt;Country&gt; tag, so we append
		 * the underscore and name of the country/region in English, e.g.
		 * "English_United States".
		 */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>wcscat</name><argument_list>(<argument><expr><name>test_locale</name></expr></argument>, <argument><expr><literal type="string">L"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcslen</name><argument_list>(<argument><expr><name>test_locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>GetLocaleInfoEx</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>LOCALE_SENGLISHCOUNTRYNAME</name></expr></argument>,
								<argument><expr><name>test_locale</name> <operator>+</operator> <name>len</name></expr></argument>,
								<argument><expr><name>LOCALE_NAME_MAX_LENGTH</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>_wcsicmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>test_locale</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>wchar_t</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<return>return <expr><name>FALSE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function converts a Windows locale name to an ISO formatted version
 * for Visual Studio 2015 or greater.
 *
 * Returns NULL, if no valid conversion was found.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_iso_localename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>winlocname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>wchar_t</name></type>		<name><name>wc_locale_name</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>wchar_t</name></type>		<name><name>buffer</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>iso_lc_messages</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>period</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret_val</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Valid locales have the following syntax:
	 * &lt;Language&gt;[_&lt;Country&gt;[.&lt;CodePage&gt;]]
	 *
	 * GetLocaleInfoEx can only take locale name without code-page and for the
	 * purpose of this API the code-page doesn't matter.
	 */</comment>
	<expr_stmt><expr><name>period</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>winlocname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>period</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>period</name> <operator>-</operator> <name>winlocname</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbstrlen</name><argument_list>(<argument><expr><name>winlocname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>wc_locale_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wc_locale_name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>winlocname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>wc_locale_name</name></expr></argument>,
						<argument><expr><name>LOCALE_NAME_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the lc_messages is already an Unix-style string, we have a direct
	 * match with LOCALE_SNAME, e.g. en-US, en_US.
	 */</comment>
	<expr_stmt><expr><name>ret_val</name> <operator>=</operator> <call><name>GetLocaleInfoEx</name><argument_list>(<argument><expr><name>wc_locale_name</name></expr></argument>, <argument><expr><name>LOCALE_SNAME</name></expr></argument>, <argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>,
							  <argument><expr><name>LOCALE_NAME_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret_val</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Search for a locale in the system that matches language and country
		 * name.
		 */</comment>
		<decl_stmt><decl><type><name>wchar_t</name>    <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>wc_locale_name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ret_val</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EnumSystemLocalesEx</name><argument_list>(<argument><expr><name>search_locale_enum</name></expr></argument>, <argument><expr><name>LOCALE_WINDOWS</name></expr></argument>, <argument><expr><operator>(</operator><name>LPARAM</name><operator>)</operator> <name>argv</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret_val</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hyphen</name></decl>;</decl_stmt>

		<comment type="block">/* Locale names use only ASCII, any conversion locale suffices. */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>wchar2char</name><argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>rc</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Simply replace the hyphen with an underscore.  See comments in
		 * IsoLocaleName.
		 */</comment>
		<expr_stmt><expr><name>hyphen</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hyphen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hyphen</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>iso_lc_messages</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* _MSC_VER &gt;= 1900 */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>IsoLocaleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>winlocname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>iso_lc_messages</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>, <argument><expr><name>winlocname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"posix"</literal></expr></argument>, <argument><expr><name>winlocname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>iso_lc_messages</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1900</literal><operator>)</operator></expr></cpp:if>			<comment type="block">/* Visual Studio 2015 or later */</comment>
		<return>return <expr><call><name>get_iso_localename</name><argument_list>(<argument><expr><name>winlocname</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>_locale_t</name></type>	<name>loct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>loct</name> <operator>=</operator> <call><name>_create_locale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>winlocname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>loct</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>rc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hyphen</name></decl>;</decl_stmt>

			<comment type="block">/* Locale names use only ASCII, any conversion locale suffices. */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>wchar2char</name><argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>, <argument><expr><name><name>loct</name><operator>-&gt;</operator><name>locinfo</name><operator>-&gt;</operator><name>locale_name</name><index>[<expr><name>LC_CTYPE</name></expr>]</index></name></expr></argument>,
							<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_free_locale</name><argument_list>(<argument><expr><name>loct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>rc</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Since the message catalogs sit on a case-insensitive
			 * filesystem, we need not standardize letter case here.  So long
			 * as we do not ship message catalogs for which it would matter,
			 * we also need not translate the script/variant portion, e.g.
			 * uz-Cyrl-UZ to uz_UZ@cyrillic.  Simply replace the hyphen with
			 * an underscore.
			 *
			 * Note that the locale name can be less-specific than the value
			 * we would derive under earlier Visual Studio releases.  For
			 * example, French_France.1252 yields just "fr".  This does not
			 * affect any of the country-specific message catalogs available
			 * as of this writing (pt_BR, zh_CN, zh_TW).
			 */</comment>
			<expr_stmt><expr><name>hyphen</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>iso_lc_messages</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>hyphen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>hyphen</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>iso_lc_messages</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* Visual Studio 2015 or later */</comment>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* defined(_MSC_VER) */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* Not supported on this version of msvc/mingw */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 &amp;&amp; LC_MESSAGES */</comment>


<comment type="block">/*
 * Detect aging strxfrm() implementations that, in a subset of locales, write
 * past the specified buffer length.  Affected users must update OS packages
 * before using PostgreSQL 9.5 or later.
 *
 * Assume that the bug can come and go from one postmaster startup to another
 * due to physical replication among diverse machines.  Assume that the bug's
 * presence will not change during the life of a particular postmaster.  Given
 * those assumptions, call this no less than once per postmaster startup per
 * LC_COLLATE setting used.  No known-affected system offers strxfrm_l(), so
 * there is no need to consider pg_collation locales.
 */</comment>
<function><type><name>void</name></type>
<name>check_strxfrm_bug</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>canary</name> <init>= <expr><literal type="number">0x7F</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10
	 * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or
	 * below that range.
	 *
	 * The bug is present in Solaris 8 as well; it is absent in Solaris 10
	 * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,
	 * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales
	 * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.
	 */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>canary</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ab"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>!=</operator> <name>canary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * illumos bug #1594 was present in the source tree from 2010-10-11 to
	 * 2012-02-01.  Given an ASCII string of any length and length limit 1,
	 * affected systems ignore the length limit and modify a number of bytes
	 * one less than the return value.  The problem inputs for this bug do not
	 * overlap those for the Solaris bug, hence a distinct test.
	 *
	 * Affected systems include smartos-20110926T021612Z.  Affected locales
	 * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.
	 */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>canary</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>canary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYSTEM_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"strxfrm(), in locale \"%s\", writes past the specified array length"</literal></expr></argument>,
								 <argument><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Apply system library package updates."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Cache mechanism for collation information.
 *
 * We cache two flags: whether the collation's LC_COLLATE or LC_CTYPE is C
 * (or POSIX), so we can optimize a few code paths in various places.
 * For the built-in C and POSIX collations, we can know that without even
 * doing a cache lookup, but we want to support aliases for C/POSIX too.
 * For the "default" collation, there are separate static cache variables,
 * since consulting the pg_collation catalog doesn't tell us what we need.
 *
 * Also, if a pg_locale_t has been requested for a collation, we cache that
 * for the life of a backend.
 *
 * Note that some code relies on the flags not reporting false negatives
 * (that is, saying it's not C when it is).  For example, char2wchar()
 * could fail if the locale is C, so str_tolower() shouldn't call it
 * in that case.
 *
 * Note that we currently lack any way to flush the cache.  Since we don't
 * support ALTER COLLATION, this is OK.  The worst case is that someone
 * drops a collation, and a useless cache entry hangs around in existing
 * backends.
 */</comment>

<function><type><specifier>static</specifier> <name>collation_cache_entry</name> <modifier>*</modifier></type>
<name>lookup_collation_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>collation_cache_entry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>collation_cache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>collation_cache_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>collation_cache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Collation cache"</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>collation_cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collation</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure cache entry is marked invalid, in case we fail before
		 * setting things.
		 */</comment>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>flags_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>locale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_flags</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cache_entry</name><operator>-&gt;</operator><name>flags_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Attempt to set the flags */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collctype</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>collform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collcollate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>collate_is_c</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
									 <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><literal type="string">"POSIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>ctype_is_c</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>collctype</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
								   <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>collctype</name></expr></argument>, <argument><expr><literal type="string">"POSIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>flags_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cache_entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Detect whether collation's LC_COLLATE property is C
 */</comment>
<function><type><name>bool</name></type>
<name>lc_collate_is_c</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're asked about "collation 0", return false, so that the code will
	 * go into the non-C path and report that the collation is bogus.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're asked about the default collation, we have to inquire of the C
	 * library.  Cache the result so we only have to compute it once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>localeptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>result</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>localeptr</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localeptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid LC_COLLATE setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>localeptr</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>localeptr</name></expr></argument>, <argument><expr><literal type="string">"POSIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're asked about the built-in C/POSIX collations, we know that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>C_COLLATION_OID</name> <operator>||</operator>
		<name>collation</name> <operator>==</operator> <name>POSIX_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we have to consult pg_collation, but we cache that.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>lookup_collation_cache</name><argument_list>(<argument><expr><name>collation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collate_is_c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether collation's LC_CTYPE property is C
 */</comment>
<function><type><name>bool</name></type>
<name>lc_ctype_is_c</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're asked about "collation 0", return false, so that the code will
	 * go into the non-C path and report that the collation is bogus.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're asked about the default collation, we have to inquire of the C
	 * library.  Cache the result so we only have to compute it once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>localeptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>result</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>localeptr</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localeptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid LC_CTYPE setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>localeptr</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>localeptr</name></expr></argument>, <argument><expr><literal type="string">"POSIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're asked about the built-in C/POSIX collations, we know that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>C_COLLATION_OID</name> <operator>||</operator>
		<name>collation</name> <operator>==</operator> <name>POSIX_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we have to consult pg_collation, but we cache that.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>lookup_collation_cache</name><argument_list>(<argument><expr><name>collation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ctype_is_c</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* simple subroutine for reporting errors from newlocale() */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_newlocale_failure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>localename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Windows doesn't provide any useful error indication from
	 * _create_locale(), and BSD-derived platforms don't seem to feel they
	 * need to set errno either (even though POSIX is pretty clear that
	 * newlocale should do so).  So, if errno hasn't been set, assume ENOENT
	 * is what to report.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ENOENT means "no such locale", not "no such file", so clarify that
	 * errno with an errdetail message.
	 */</comment>
	<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>			<comment type="block">/* auxiliary funcs might change errno */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create locale \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>localename</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <operator>(</operator><ternary><condition><expr><name>save_errno</name> <operator>==</operator> <name>ENOENT</name></expr> ?</condition><then>
			  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The operating system could not find any locale data for the locale name \"%s\"."</literal></expr></argument>,
						<argument><expr><name>localename</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_LOCALE_T */</comment>


<comment type="block">/*
 * Create a locale_t from a collation OID.  Results are cached for the
 * lifetime of the backend.  Thus, do not free the result with freelocale().
 *
 * As a special optimization, the default/database collation returns 0.
 * Callers should then revert to the non-locale_t-enabled code path.
 * In fact, they shouldn't call this function at all when they are dealing
 * with the default locale.  That can save quite a bit in hotspots.
 * Also, callers should avoid calling this before going down a C/POSIX
 * fastpath, because such a fastpath should work even on platforms without
 * locale_t support in the C library.
 *
 * For simplicity, we always generate COLLATE + CTYPE even though we
 * might only need one of them.  Since this is called only once per session,
 * it shouldn't cost much.
 */</comment>
<function><type><name>pg_locale_t</name></type>
<name>pg_newlocale_from_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>collation_cache_entry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>

	<comment type="block">/* Callers must pass a valid OID */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return 0 for "default" collation, just in case caller forgets */</comment>
	<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>pg_locale_t</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <call><name>lookup_collation_cache</name><argument_list>(<argument><expr><name>collid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cache_entry</name><operator>-&gt;</operator><name>locale</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We haven't computed this yet in this session, so do it */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
		<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>collctype</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_locale_struct</name></name></type> <name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>resultp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>collversion</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>collform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collcollate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We'll fill in the result struct locally before allocating memory */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>provider</name></name> <operator>=</operator> <name><name>collform</name><operator>-&gt;</operator><name>collprovider</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>deterministic</name></name> <operator>=</operator> <name><name>collform</name><operator>-&gt;</operator><name>collisdeterministic</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>collform</name><operator>-&gt;</operator><name>collprovider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<decl_stmt><decl><type><name>locale_t</name></type>	<name>loc</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Normal case where they're the same */</comment>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>newlocale</name><argument_list>(<argument><expr><name>LC_COLLATE_MASK</name> <operator>|</operator> <name>LC_CTYPE_MASK</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>_create_locale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>report_newlocale_failure</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<comment type="block">/* We need two newlocale() steps */</comment>
				<decl_stmt><decl><type><name>locale_t</name></type>	<name>loc1</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>loc1</name> <operator>=</operator> <call><name>newlocale</name><argument_list>(<argument><expr><name>LC_COLLATE_MASK</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loc1</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>report_newlocale_failure</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>newlocale</name><argument_list>(<argument><expr><name>LC_CTYPE_MASK</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>, <argument><expr><name>loc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>report_newlocale_failure</name><argument_list>(<argument><expr><name>collctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

				<comment type="block">/*
				 * XXX The _create_locale() API doesn't appear to support
				 * this. Could perhaps be worked around by changing
				 * pg_locale_t to contain two separate fields.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations with different collate and ctype values are not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>info</name><operator>.</operator><name>lt</name></name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not HAVE_LOCALE_T */</comment>
			<comment type="block">/* platform that doesn't support locale_t */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation provider LIBC is not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not HAVE_LOCALE_T */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>collform</name><operator>-&gt;</operator><name>collprovider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<decl_stmt><decl><type><name>UCollator</name>  <modifier>*</modifier></type><name>collator</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations with different collate and ctype values are not supported by ICU"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>collator</name> <operator>=</operator> <call><name>ucol_open</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open collator for locale \"%s\": %s"</literal></expr></argument>,
								<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>U_ICU_VERSION_MAJOR_NUM</name> <operator>&lt;</operator> <literal type="number">54</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>icu_set_collation_attributes</name><argument_list>(<argument><expr><name>collator</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* We will leak this string if we get an error below :-( */</comment>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>locale</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
														 <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name> <operator>=</operator> <name>collator</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not USE_ICU */</comment>
			<comment type="block">/* could get here if a collation was created by a build with ICU */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ICU is not supported in this build"</literal></expr></argument>)</argument_list></call><operator>,</operator> \
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You need to rebuild PostgreSQL using --with-icu."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_ICU */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_collation_collversion</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>actual_versionstr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collversionstr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>actual_versionstr</name> <operator>=</operator> <call><name>get_collation_actual_version</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collprovider</name></name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>actual_versionstr</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This could happen when specifying a version in CREATE
				 * COLLATION for a libc locale, or manually creating a mess in
				 * the catalogs.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" has no actual version, but a version was specified"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>collversionstr</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>collversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>actual_versionstr</name></expr></argument>, <argument><expr><name>collversionstr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" has version mismatch"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The collation in the database was created using version %s, "</literal>
								   <literal type="string">"but the operating system provides version %s."</literal></expr></argument>,
								   <argument><expr><name>collversionstr</name></expr></argument>, <argument><expr><name>actual_versionstr</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Rebuild all objects affected by this collation and run "</literal>
								 <literal type="string">"ALTER COLLATION %s REFRESH VERSION, "</literal>
								 <literal type="string">"or build PostgreSQL with the right library version."</literal></expr></argument>,
								 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We'll keep the pg_locale_t structures in TopMemoryContext */</comment>
		<expr_stmt><expr><name>resultp</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>resultp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>resultp</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>locale</name></name> <operator>=</operator> <name>resultp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>locale</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get provider-specific collation version string for the given collation from
 * the operating system/library.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_collation_actual_version</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>collprovider</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collversion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>collprovider</name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>UCollator</name>  <modifier>*</modifier></type><name>collator</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>UVersionInfo</name></type> <name>versioninfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>U_MAX_VERSION_STRING_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>collator</name> <operator>=</operator> <call><name>ucol_open</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open collator for locale \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ucol_getVersion</name><argument_list>(<argument><expr><name>collator</name></expr></argument>, <argument><expr><name>versioninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ucol_close</name><argument_list>(<argument><expr><name>collator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>u_versionToString</name><argument_list>(<argument><expr><name>versioninfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	if <condition>(<expr><name>collprovider</name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copy_suffix</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_version</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for names like C.UTF-8 by chopping off the encoding suffix on
		 * our temporary copy, so we can skip the version.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>copy_suffix</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>copy_suffix</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"posix"</literal></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_version</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_version</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Use the glibc version because we don't have anything better. */</comment>
		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>gnu_get_libc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_WIN32_WINNT</name> <operator>&gt;=</operator> <literal type="number">0x0600</literal></expr></cpp:elif>
		<comment type="block">/*
		 * If we are targeting Windows Vista and above, we can ask for a name
		 * given a collation name (earlier versions required a location code
		 * that we don't have).
		 */</comment>
		<decl_stmt><decl><type><name>NLSVERSIONINFOEX</name></type> <name>version</name> <init>= <expr><block>{<expr>sizeof<operator>(</operator><name>NLSVERSIONINFOEX</name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WCHAR</name></type>		<name><name>wide_collcollate</name><index>[<expr><name>LOCALE_NAME_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* These would be invalid arguments, but have no version. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"posix"</literal></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* For all other names, ask the OS. */</comment>
		<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wide_collcollate</name></expr></argument>,
							<argument><expr><name>LOCALE_NAME_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetNLSVersionEx</name><argument_list>(<argument><expr><name>COMPARE_STRING</name></expr></argument>, <argument><expr><name>wide_collcollate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * GetNLSVersionEx() wants a language tag such as "en-US", not a
			 * locale name like "English_United States.1252".  Until those
			 * values can be prevented from entering the system, or 100%
			 * reliably converted to the more useful tag format, tolerate the
			 * resulting error and report that we have no version data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ERROR_INVALID_PARAMETER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get collation version for locale \"%s\": error code %lu"</literal></expr></argument>,
							<argument><expr><name>collcollate</name></expr></argument>,
							<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>collversion</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%d.%d,%d.%d"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name><name>version</name><operator>.</operator><name>dwNLSVersion</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>,
							   <argument><expr><name><name>version</name><operator>.</operator><name>dwNLSVersion</name></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name><name>version</name><operator>.</operator><name>dwDefinedVersion</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>,
							   <argument><expr><name><name>version</name><operator>.</operator><name>dwDefinedVersion</name></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>collversion</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<comment type="block">/*
 * Converter object for converting between ICU's UChar strings and C strings
 * in database encoding.  Since the database encoding doesn't change, we only
 * need one of these per session.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>UConverter</name> <modifier>*</modifier></type><name>icu_converter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_icu_converter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>icu_encoding_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UConverter</name> <modifier>*</modifier></type><name>conv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>icu_converter</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* already done */</comment>

	<expr_stmt><expr><name>icu_encoding_name</name> <operator>=</operator> <call><name>get_encoding_name_for_icu</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>icu_encoding_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"encoding \"%s\" not supported by ICU"</literal></expr></argument>,
						<argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>conv</name> <operator>=</operator> <call><name>ucnv_open</name><argument_list>(<argument><expr><name>icu_encoding_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open ICU converter for encoding \"%s\": %s"</literal></expr></argument>,
						<argument><expr><name>icu_encoding_name</name></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>icu_converter</name> <operator>=</operator> <name>conv</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a string in the database encoding into a string of UChars.
 *
 * The source string at buff is of length nbytes
 * (it needn't be nul-terminated)
 *
 * *buff_uchar receives a pointer to the palloc'd result string, and
 * the function's result is the number of UChars generated.
 *
 * The result string is nul-terminated, though most callers rely on the
 * result length instead.
 */</comment>
<function><type><name>int32_t</name></type>
<name>icu_to_uchar</name><parameter_list>(<parameter><decl><type><name>UChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff_uchar</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_uchar</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_icu_converter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>ucnv_toUChars</name><argument_list>(<argument><expr><name>icu_converter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>U_BUFFER_OVERFLOW_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %s"</literal></expr></argument>, <argument><expr><literal type="string">"ucnv_toUChars"</literal></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>buff_uchar</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len_uchar</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>buff_uchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>ucnv_toUChars</name><argument_list>(<argument><expr><name>icu_converter</name></expr></argument>, <argument><expr><operator>*</operator><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %s"</literal></expr></argument>, <argument><expr><literal type="string">"ucnv_toUChars"</literal></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>len_uchar</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a string of UChars into the database encoding.
 *
 * The source string at buff_uchar is of length len_uchar
 * (it needn't be nul-terminated)
 *
 * *result receives a pointer to the palloc'd result string, and the
 * function's result is the number of bytes generated (not counting nul).
 *
 * The result string is nul-terminated.
 */</comment>
<function><type><name>int32_t</name></type>
<name>icu_from_uchar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>buff_uchar</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>len_uchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_icu_converter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_result</name> <operator>=</operator> <call><name>ucnv_fromUChars</name><argument_list>(<argument><expr><name>icu_converter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>U_BUFFER_OVERFLOW_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %s"</literal></expr></argument>, <argument><expr><literal type="string">"ucnv_fromUChars"</literal></expr></argument>,
						<argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len_result</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_result</name> <operator>=</operator> <call><name>ucnv_fromUChars</name><argument_list>(<argument><expr><name>icu_converter</name></expr></argument>, <argument><expr><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name>len_result</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed: %s"</literal></expr></argument>, <argument><expr><literal type="string">"ucnv_fromUChars"</literal></expr></argument>,
						<argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>len_result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse collation attributes and apply them to the open collator.  This takes
 * a string like "und@colStrength=primary;colCaseLevel=yes" and parses and
 * applies the key-value arguments.
 *
 * Starting with ICU version 54, the attributes are processed automatically by
 * ucol_open(), so this is only necessary for emulating this behavior on older
 * versions.
 */</comment>
<macro><name>pg_attribute_unused</name><argument_list>()</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>icu_set_collation_attributes</name><parameter_list>(<parameter><decl><type><name>UCollator</name> <modifier>*</modifier></type><name>collator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>asc_tolower</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>token</name></expr>;</condition> <incr><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UColAttribute</name></type> <name>uattr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UColAttributeValue</name></type> <name>uvalue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>e</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * See attribute name and value lists in ICU i18n/coll.cpp
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colstrength"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_STRENGTH</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colbackwards"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_FRENCH_COLLATION</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colcaselevel"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_CASE_LEVEL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colcasefirst"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_CASE_FIRST</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colalternate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_ALTERNATE_HANDLING</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colnormalization"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_NORMALIZATION_MODE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"colnumeric"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uattr</name> <operator>=</operator> <name>UCOL_NUMERIC_COLLATION</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<comment type="block">/* ignore if unknown */</comment>
				<continue>continue;</continue></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"primary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_PRIMARY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"secondary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_SECONDARY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"tertiary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_TERTIARY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"quaternary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_QUATERNARY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"identical"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_IDENTICAL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_OFF</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_ON</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"shifted"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_SHIFTED</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"non-ignorable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_NON_IGNORABLE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"lower"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_LOWER_FIRST</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"upper"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>UCOL_UPPER_FIRST</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ILLEGAL_ARGUMENT_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>U_ZERO_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ucol_setAttribute</name><argument_list>(<argument><expr><name>collator</name></expr></argument>, <argument><expr><name>uattr</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Pretend the error came from ucol_open(), for consistent error
			 * message across ICU versions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open collator for locale \"%s\": %s"</literal></expr></argument>,
								<argument><expr><name>loc</name></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ICU */</comment>

<comment type="block">/*
 * These functions convert from/to libc's wchar_t, *not* pg_wchar_t.
 * Therefore we keep them here rather than with the mbutils code.
 */</comment>

<comment type="block">/*
 * wchar2char --- convert wide characters to multibyte format
 *
 * This has the same API as the standard wcstombs_l() function; in particular,
 * tolen is the maximum number of bytes to store at *to, and *from must be
 * zero-terminated.  The output will be zero-terminated iff there is room.
 */</comment>
<function><type><name>size_t</name></type>
<name>wchar2char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tolen</name></decl></parameter>, <parameter><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>locale</name> <operator>||</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tolen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * On Windows, the "Unicode" locales assume UTF16 not UTF8 encoding, and
	 * for some reason mbstowcs and wcstombs won't do this for us, so we use
	 * MultiByteToWideChar().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* A zero return is failure */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;=</operator> <name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Microsoft counts the zero terminator in the result */</comment>
			<expr_stmt><expr><name>result</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	if <condition>(<expr><name>locale</name> <operator>==</operator> <operator>(</operator><name>pg_locale_t</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use wcstombs directly for the default locale */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcstombs</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCSTOMBS_L</name></cpp:ifdef>
		<comment type="block">/* Use wcstombs_l for nondefault locales */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcstombs_l</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>, <argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_WCSTOMBS_L */</comment>
		<comment type="block">/* We have to temporarily set the locale as current ... ugh */</comment>
		<decl_stmt><decl><type><name>locale_t</name></type>	<name>save_locale</name> <init>= <expr><call><name>uselocale</name><argument_list>(<argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcstombs</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>uselocale</name><argument_list>(<argument><expr><name>save_locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_WCSTOMBS_L */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_LOCALE_T */</comment>
		<comment type="block">/* Can't have locale != 0 without HAVE_LOCALE_T */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wcstombs_l is not available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_LOCALE_T */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * char2wchar --- convert multibyte characters to wide characters
 *
 * This has almost the API of mbstowcs_l(), except that *from need not be
 * null-terminated; instead, the number of input bytes is specified as
 * fromlen.  Also, we ereport() rather than returning -1 for invalid
 * input encoding.  tolen is the maximum number of wchar_t's to store at *to.
 * The output will be zero-terminated iff there is room.
 */</comment>
<function><type><name>size_t</name></type>
<name>char2wchar</name><parameter_list>(<parameter><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tolen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>fromlen</name></decl></parameter>,
		   <parameter><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>locale</name> <operator>||</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tolen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* See WIN32 "Unicode" comment above */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Win32 API does not work for zero-length input */</comment>
		<if_stmt><if>if <condition>(<expr><name>fromlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>fromlen</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>tolen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* A zero return is failure */</comment>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;</operator> <name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Append trailing null wchar (MultiByteToWideChar() does not) */</comment>
			<expr_stmt><expr><name><name>to</name><index>[<expr><name>result</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	<block>{<block_content>
		<comment type="block">/* mbstowcs requires ending '\0' */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>fromlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>==</operator> <operator>(</operator><name>pg_locale_t</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use mbstowcs directly for the default locale */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>mbstowcs</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MBSTOWCS_L</name></cpp:ifdef>
			<comment type="block">/* Use mbstowcs_l for nondefault locales */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>mbstowcs_l</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>, <argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_MBSTOWCS_L */</comment>
			<comment type="block">/* We have to temporarily set the locale as current ... ugh */</comment>
			<decl_stmt><decl><type><name>locale_t</name></type>	<name>save_locale</name> <init>= <expr><call><name>uselocale</name><argument_list>(<argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>mbstowcs</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>tolen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>uselocale</name><argument_list>(<argument><expr><name>save_locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_MBSTOWCS_L */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_LOCALE_T */</comment>
			<comment type="block">/* Can't have locale != 0 without HAVE_LOCALE_T */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mbstowcs_l is not available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_LOCALE_T */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Invalid multibyte character encountered.  We try to give a useful
		 * error message by letting pg_verifymbstr check the string.  But it's
		 * possible that the string is OK to us, and not OK to mbstowcs ---
		 * this suggests that the LC_CTYPE locale is different from the
		 * database encoding.  Give a generic error message if pg_verifymbstr
		 * can't find anything wrong.
		 */</comment>
		<expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>fromlen</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* might not return */</comment>
		<comment type="block">/* but if it does ... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHARACTER_NOT_IN_REPERTOIRE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid multibyte character for locale"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The server's LC_CTYPE locale is probably incompatible with the database encoding."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
