<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/tsvector.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tsvector.c
 *	  I/O functions for tsvector
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/tsvector.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>WordEntry</name></type>	<name>entry</name></decl>;</decl_stmt>			<comment type="block">/* must be first! */</comment>
	<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>poslen</name></decl>;</decl_stmt>			<comment type="block">/* number of elements in pos */</comment>
}</block></struct></type> <name>WordEntryIN</name>;</typedef>


<comment type="block">/* Compare two WordEntryPos values for qsort */</comment>
<function><type><name>int</name></type>
<name>compareWordEntryPos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>apos</name> <init>= <expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>WordEntryPos</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bpos</name> <init>= <expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>WordEntryPos</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>apos</name> <operator>==</operator> <name>bpos</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>apos</name> <operator>&gt;</operator> <name>bpos</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Removes duplicate pos entries. If there's two entries with same pos but
 * different weight, the higher weight is retained, so we can't use
 * qunique here.
 *
 * Returns new length.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uniquePos</name><parameter_list>(<parameter><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>ptr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>l</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compareWordEntryPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>a</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ptr</name> <operator>-</operator> <name>a</name> <operator>&lt;</operator> <name>l</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>-</operator> <name>a</name> <operator>&gt;=</operator> <name>MAXNUMPOS</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MAXENTRYPOS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WEP_SETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>, <argument><expr><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>res</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare two WordEntryIN values for qsort */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compareentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>WordEntryIN</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>WordEntryIN</name> <operator>*</operator><operator>)</operator> <name>va</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>WordEntryIN</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>WordEntryIN</name> <operator>*</operator><operator>)</operator> <name>vb</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>BufferStr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>tsCompareString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>BufferStr</name><index>[<expr><name><name>a</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>BufferStr</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort an array of WordEntryIN, remove duplicates.
 * *outbuflen receives the amount of space needed for strings and positions.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uniqueentry</name><parameter_list>(<parameter><decl><type><name>WordEntryIN</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outbuflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WordEntryIN</name> <modifier>*</modifier></type><name>ptr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>l</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryIN</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compareentry</name></expr></argument>,
				  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>a</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ptr</name> <operator>-</operator> <name>a</name> <operator>&lt;</operator> <name>l</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ptr</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator>
			  <call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name><name>ptr</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr></argument>,
					  <argument><expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* done accumulating data into *res, count space needed */</comment>
			<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>haspos</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>=</operator> <call><name>uniquePos</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryIN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>haspos</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>haspos</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* append ptr's positions to res's positions */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>newlen</name> <init>= <expr><name><name>ptr</name><operator>-&gt;</operator><name>poslen</name></name> <operator>+</operator> <name><name>res</name><operator>-&gt;</operator><name>poslen</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>(</operator><name>WordEntryPos</name> <operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>pos</name><index>[<expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
					   <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>poslen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* just give ptr's positions to pos */</comment>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>poslen</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* count space needed for last item */</comment>
	<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>entry</name><operator>.</operator><name>haspos</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>=</operator> <call><name>uniquePos</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>poslen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name><name>res</name><operator>-&gt;</operator><name>poslen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>outbuflen</name> <operator>=</operator> <name>buflen</name></expr>;</expr_stmt>
	<return>return <expr><name>res</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>WordEntryCMP</name><parameter_list>(<parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>WordEntry</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>compareentry</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>tsvectorin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSVectorParseState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WordEntryIN</name> <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arrlen</name></decl>;</decl_stmt>			<comment type="block">/* allocated size of arr */</comment>
	<decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>inarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSVector</name></type>	<name>in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>poslen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stroff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Tokens are appended to tmpbuf, cur is a pointer to the end of used
	 * space in tmpbuf.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmpbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* allocated size of tmpbuf */</comment>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>init_tsvector_parser</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>arrlen</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <operator>(</operator><name>WordEntryIN</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryIN</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>tmpbuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>gettoken_tsvector</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toklen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>poslen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>toklen</name> <operator>&gt;=</operator> <name>MAXSTRLEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"word is too long (%ld bytes, max %ld bytes)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>toklen</name></expr></argument>,
							<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>MAXSTRLEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>-</operator> <name>tmpbuf</name> <operator>&gt;</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"string is too long for tsvector (%ld bytes, max %ld bytes)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>cur</name> <operator>-</operator> <name>tmpbuf</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>MAXSTRPOS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Enlarge buffers if needed
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>arrlen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arrlen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>arr</name> <operator>=</operator> <operator>(</operator><name>WordEntryIN</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>arr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryIN</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>cur</name> <operator>-</operator> <name>tmpbuf</name><operator>)</operator> <operator>+</operator> <name>toklen</name> <operator>&gt;=</operator> <name>buflen</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>dist</name> <init>= <expr><name>cur</name> <operator>-</operator> <name>tmpbuf</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>buflen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmpbuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tmpbuf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>tmpbuf</name> <operator>+</operator> <name>dist</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>toklen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>cur</name> <operator>-</operator> <name>tmpbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cur</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>token</name></expr></argument>, <argument><expr><name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>toklen</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>poslen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>poslen</name> <operator>=</operator> <name>poslen</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>haspos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>poslen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>close_tsvector_parser</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>uniqueentry</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"string is too long for tsvector (%d bytes, max %d bytes)"</literal></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>MAXSTRPOS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <call><name>CALCDATASIZE</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>in</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>totallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>totallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inarr</name> <operator>=</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strbuf</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stroff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>strbuf</name> <operator>+</operator> <name>stroff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tmpbuf</name><index>[<expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>pos</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>stroff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stroff</name> <operator>+=</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>entry</name><operator>.</operator><name>haspos</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>poslen</name> <operator>&gt;</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"positions array too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Copy number of positions */</comment>
			<expr_stmt><expr><name>stroff</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>stroff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>strbuf</name> <operator>+</operator> <name>stroff</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>poslen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>stroff</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<comment type="block">/* Copy positions */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>strbuf</name> <operator>+</operator> <name>stroff</name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>poslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stroff</name> <operator>+=</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>poslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>inarr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>entry</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>strbuf</name> <operator>+</operator> <name>stroff</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>in</name><operator>)</operator> <operator>==</operator> <name>totallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TSVECTOR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvectorout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSVector</name></type>	<name>out</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>lenbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>pp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curbegin</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>curin</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>curout</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lenbuf</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <literal type="number">2</literal> <comment type="block">/* '' */</comment> <operator>+</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal> <comment type="block">/* space */</comment> <operator>+</operator> <literal type="number">2</literal></expr> <comment type="block">/* \0 */</comment> ;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>lenbuf</name> <operator>+=</operator> <name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call></expr> <comment type="block">/* for escape */</comment> ;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lenbuf</name> <operator>+=</operator> <literal type="number">1</literal> <comment type="block">/* : */</comment> <operator>+</operator> <literal type="number">7</literal> <comment type="block">/* int2 + , + weight */</comment> <operator>*</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>curout</name> <operator>=</operator> <name>outbuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>lenbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>curbegin</name> <operator>=</operator> <name>curin</name> <operator>=</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>curin</name> <operator>-</operator> <name>curbegin</name> <operator>&lt;</operator> <name><name>ptr</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>curin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>curin</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>t_iseq</name><argument_list>(<argument><expr><name>curin</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>curin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></while>

		<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pp</name> <operator>=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>wptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>wptr</name> <operator>=</operator> <call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>pp</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>curout</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>curout</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>WEP_GETPOS</name><argument_list>(<argument><expr><operator>*</operator><name>wptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><call><name>WEP_GETWEIGHT</name><argument_list>(<argument><expr><operator>*</operator><name>wptr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="number">3</literal></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="number">2</literal></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="number">1</literal></expr>:</case>
						<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">'C'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="number">0</literal></expr>:</case>
					<default>default:</default>
						<break>break;</break>
				</block_content>}</block></switch>

				<if_stmt><if>if <condition>(<expr><name>pp</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>curout</name><operator>++</operator> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>wptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>curout</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Binary Input / Output functions. The binary format is as follows:
 *
 * uint32	number of lexemes
 *
 * for each lexeme:
 *		lexeme text in client encoding, null-terminated
 *		uint16	number of positions
 *		for each position:
 *			uint16 WordEntryPos
 */</comment>

<function><type><name>Datum</name></type>
<name>tsvectorsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSVector</name></type>	<name>vec</name> <init>= <expr><call><name>PG_GETARG_TSVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WordEntry</name>  <modifier>*</modifier></type><name>weptr</name> <init>= <expr><call><name>ARRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>vec</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>npos</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * the strings in the TSVector array are not null-terminated, so we
		 * have to send the null-terminator separately
		 */</comment>
		<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>weptr</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>weptr</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>npos</name> <operator>=</operator> <call><name>POSDATALEN</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>weptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>npos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>npos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>wepptr</name> <init>= <expr><call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>weptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>wepptr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>weptr</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsvectorrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSVector</name></type>	<name>vec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nentries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name></decl>;</decl_stmt>		<comment type="block">/* number of bytes used in the variable size
								 * area after fixed size TSVector header and
								 * WordEntries */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hdrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>			<comment type="block">/* allocated size of vec */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needSort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nentries</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name><name>nentries</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nentries</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid size of tsvector"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <name>DATAHDRSIZE</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nentries</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>hdrlen</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>			<comment type="block">/* times two to make room for lexemes */</comment>
	<expr_stmt><expr><name>vec</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>nentries</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>datalen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lexeme</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>npos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>lex_len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lexeme</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>npos</name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sanity checks */</comment>

		<expr_stmt><expr><name>lex_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>lexeme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lex_len</name> <operator>&gt;</operator> <name>MAXSTRLEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsvector: lexeme too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>datalen</name> <operator>&gt;</operator> <name>MAXSTRPOS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tsvector: maximum total lexeme length exceeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>npos</name> <operator>&gt;</operator> <name>MAXNUMPOS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected number of tsvector positions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Looks valid. Fill the WordEntry struct, and copy lexeme.
		 *
		 * But make sure the buffer is large enough first.
		 */</comment>
		<while>while <condition>(<expr><name>hdrlen</name> <operator>+</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>datalen</name> <operator>+</operator> <name>lex_len</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <operator>(</operator><name>npos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>len</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vec</name> <operator>=</operator> <operator>(</operator><name>TSVector</name><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>haspos</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>npos</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>lex_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>datalen</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>datalen</name></expr></argument>, <argument><expr><name>lexeme</name></expr></argument>, <argument><expr><name>lex_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>datalen</name> <operator>+=</operator> <name>lex_len</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>WordEntryCMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needSort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Receive positions */</comment>
		<if_stmt><if>if <condition>(<expr><name>npos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WordEntryPos</name> <modifier>*</modifier></type><name>wepptr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Pad to 2-byte alignment if necessary. Though we used palloc0
			 * for the initial allocation, subsequent repalloc'd memory areas
			 * are not initialized to zero.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>datalen</name> <operator>!=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>datalen</name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>datalen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>wepptr</name> <operator>=</operator> <call><name>POSDATAPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>wepptr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>WordEntryPos</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntryPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>wepptr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>WEP_GETPOS</name><argument_list>(<argument><expr><name><name>wepptr</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"position information is misordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>datalen</name> <operator>+=</operator> <operator>(</operator><name>npos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WordEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>hdrlen</name> <operator>+</operator> <name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needSort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ARRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>vec</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WordEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>compareentry</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>STRPTR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TSVECTOR</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
