<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/geo_ops.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * geo_ops.c
 *	  2D geometric operations
 *
 * This module implements the geometric functions and operators.  The
 * geometric types are (from simple to more complicated):
 *
 * - point
 * - line
 * - line segment
 * - box
 * - circle
 * - polygon
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/geo_ops.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/geo_decls.h"</cpp:file></cpp:include>

<comment type="block">/*
 * * Type constructors have this form:
 *   void type_construct(Type *result, ...);
 *
 * * Operators commonly have signatures such as
 *   void type1_operator_type2(Type *result, Type1 *obj1, Type2 *obj2);
 *
 * Common operators are:
 * * Intersection point:
 *   bool type1_interpt_type2(Point *result, Type1 *obj1, Type2 *obj2);
 *		Return whether the two objects intersect. If *result is not NULL,
 *		it is set to the intersection point.
 *
 * * Containment:
 *   bool type1_contain_type2(Type1 *obj1, Type2 *obj2);
 *		Return whether obj1 contains obj2.
 *   bool type1_contain_type2(Type1 *contains_obj, Type1 *contained_obj);
 *		Return whether obj1 contains obj2 (used when types are the same)
 *
 * * Distance of closest point in or on obj1 to obj2:
 *   float8 type1_closept_type2(Point *result, Type1 *obj1, Type2 *obj2);
 *		Returns the shortest distance between two objects.  If *result is not
 *		NULL, it is set to the closest point in or on obj1 to obj2.
 *
 * These functions may be used to implement multiple SQL-level operators.  For
 * example, determining whether two lines are parallel is done by checking
 * whether they don't intersect.
 */</comment>

<comment type="block">/*
 * Internal routines
 */</comment>

<enum>enum <name>path_delim</name>
<block>{
	<decl><name>PATH_NONE</name></decl>, <decl><name>PATH_OPEN</name></decl>, <decl><name>PATH_CLOSED</name></decl>
}</block>;</enum>

<comment type="block">/* Routines for points */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>point_construct</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>point_add_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>point_sub_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>point_mul_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>point_div_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>point_eq_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>point_dt</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>point_sl</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>point_inside</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for lines */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>line_construct</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>line_sl</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>line_invsl</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>line_interpt_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>line_contain_point</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>line_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for line segments */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>statlseg_construct</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>lseg_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type> <name>lseg_invsl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_interpt_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_interpt_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lseg_crossing</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>px</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>py</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_contain_point</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>lseg_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>lseg_closept_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>lseg_closept_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>on_lseg</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>to_lseg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for boxes */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>box_construct</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>box_cn</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>center</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_ov</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box1</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>box_ar</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>box_ht</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>box_wd</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_contain_point</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_contain_box</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>contains_box</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>contained_box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_contain_lseg</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>box_interpt_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>box_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>box_closept_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for circles */</comment>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>circle_ar</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for polygons */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_bound_box</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>poly_to_circle</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>poly_contain_poly</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>contains_poly</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>contained_poly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>plist_same</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>dist_ppoly_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Routines for encoding and decoding */</comment>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>single_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>single_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pair_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pair_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pair_count</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>path_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opentype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isopen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>path_encode</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>path_delim</name></name></type> <name>path_delim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Delimiters for input and output strings.
 * LDELIM, RDELIM, and DELIM are left, right, and separator delimiters, respectively.
 * LDELIM_EP, RDELIM_EP are left and right delimiters for paths with endpoints.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM</name></cpp:macro>			<cpp:value>'('</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM</name></cpp:macro>			<cpp:value>')'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELIM</name></cpp:macro>			<cpp:value>','</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM_EP</name></cpp:macro>		<cpp:value>'['</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM_EP</name></cpp:macro>		<cpp:value>']'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM_C</name></cpp:macro>		<cpp:value>'&lt;'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM_C</name></cpp:macro>		<cpp:value>'&gt;'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDELIM_L</name></cpp:macro>		<cpp:value>'{'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RDELIM_L</name></cpp:macro>		<cpp:value>'}'</cpp:value></cpp:define>


<comment type="block">/*
 * Geometric data types are composed of points.
 * This code tries to support a common format throughout the data types,
 *	to allow for more predictable usage and data type conversion.
 * The fundamental unit is the point. Other units are line segments,
 *	open paths, boxes, closed paths, and polygons (which should be considered
 *	non-intersecting closed paths).
 *
 * Data representation is as follows:
 *	point:				(x,y)
 *	line segment:		[(x1,y1),(x2,y2)]
 *	box:				(x1,y1),(x2,y2)
 *	open path:			[(x1,y1),...,(xn,yn)]
 *	closed path:		((x1,y1),...,(xn,yn))
 *	polygon:			((x1,y1),...,(xn,yn))
 *
 * For boxes, the points are opposite corners with the first point at the top right.
 * For closed paths and polygons, the points should be reordered to allow
 *	fast and correct equality comparisons.
 *
 * XXX perhaps points in complex shapes should be reordered internally
 *	to allow faster internal operations, but should keep track of input order
 *	and restore that order for text output - tgl 97/01/16
 */</comment>

<function><type><specifier>static</specifier> <name>float8</name></type>
<name>single_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>float8in_internal</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>endptr_p</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* single_decode() */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>single_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* single_encode() */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pair_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_delim</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>has_delim</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>x</name> <operator>=</operator> <call><name>float8in_internal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>y</name> <operator>=</operator> <call><name>float8in_internal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_delim</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator> <operator>!=</operator> <name>RDELIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* report stopping point if wanted, else complain if not end of string */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>endptr_p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pair_encode</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ystr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s,%s"</literal></expr></argument>, <argument><expr><name>xstr</name></expr></argument>, <argument><expr><name>ystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>path_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opentype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isopen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>isopen</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM_EP</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no open delimiter allowed? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opentype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strrchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>str</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>RDELIM</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>==</operator> <name>RDELIM_EP</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>isopen</name> <operator>&amp;&amp;</operator> <name>depth</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* report stopping point if wanted, else complain if not end of string */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>endptr_p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* path_decode() */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>path_encode</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>path_delim</name></name></type> <name>path_delim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>path_delim</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PATH_CLOSED</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PATH_OPEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM_EP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PATH_NONE</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pair_encode</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<switch>switch <condition>(<expr><name>path_delim</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PATH_CLOSED</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PATH_OPEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM_EP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PATH_NONE</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* path_encode() */</comment>

<comment type="block">/*-------------------------------------------------------------
 * pair_count - count the number of points
 * allow the following notation:
 * '((1,2),(3,4))'
 * '(1,3,2,4)'
 * require an odd number of delim characters in the string
 *-------------------------------------------------------------*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pair_count</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndelim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ndelim</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>ndelim</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>ndelim</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for two-dimensional boxes.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 * Formatting and conversion routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		box_in	-		convert a string to internal form.
 *
 *		External format: (two corners of box)
 *				"(f8, f8), (f8, f8)"
 *				also supports the older style "(f8, f8, f8, f8)"
 */</comment>
<function><type><name>Datum</name></type>
<name>box_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isopen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x</name></decl>,
				<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"box"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reorder corners if necessary... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_out -		convert a box to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_NONE</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		box_recv			- converts external binary format to box
 */</comment>
<function><type><name>Datum</name></type>
<name>box_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x</name></decl>,
				<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reorder corners if necessary... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		box_send			- converts box to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>box_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_construct	-		fill in a new box.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>box_construct</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>float8_gt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_gt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relational operators for BOXes.
 *		&lt;, &gt;, &lt;=, &gt;=, and == are based on box area.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		box_same		-		are two boxes identical?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box1</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box2</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>box1</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box2</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_overlap		-		does box1 overlap box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_ov</name><argument_list>(<argument><expr><name>box1</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_ov</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box1</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>FPle</name><argument_list>(<argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>FPle</name><argument_list>(<argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*		box_left		-		is box1 strictly left of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_overleft	-		is the right edge of box1 at or left of
 *								the right edge of box2?
 *
 *		This is "less than or equal" for the end of a time range,
 *		when time ranges are stored as rectangles.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_right		-		is box1 strictly right of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_overright	-		is the left edge of box1 at or right of
 *								the left edge of box2?
 *
 *		This is "greater than or equal" for time ranges, when time ranges
 *		are stored as rectangles.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_below		-		is box1 strictly below box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_overbelow	-		is the upper edge of box1 at or below
 *								the upper edge of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_above		-		is box1 strictly above box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_overabove	-		is the lower edge of box1 at or above
 *								the lower edge of box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_contained	-		is box1 contained by box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_contain_box</name><argument_list>(<argument><expr><name>box2</name></expr></argument>, <argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		box_contain		-		does box1 contain box2?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_contain_box</name><argument_list>(<argument><expr><name>box1</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the second box is in the first box or on its border
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_contain_box</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>contains_box</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>contained_box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>contains_box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>contained_box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>FPle</name><argument_list>(<argument><expr><name><name>contains_box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>contained_box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>FPge</name><argument_list>(<argument><expr><name><name>contains_box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>contained_box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>FPle</name><argument_list>(<argument><expr><name><name>contains_box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>contained_box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*		box_positionop	-
 *				is box1 entirely {above,below} box2?
 *
 * box_below_eq and box_above_eq are obsolete versions that (probably
 * erroneously) accept the equal-boundaries case.  Since these are not
 * in sync with the box_left and box_right code, they are deprecated and
 * not supported in the PG 8.1 rtree operator class extension.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_below_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_above_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_relop		-		is area(box1) relop area(box2), within
 *								our accuracy constraint?
 */</comment>
<function><type><name>Datum</name></type>
<name>box_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	"Arithmetic" operators on boxes.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		box_area		-		returns the area of the box.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_ar</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_width		-		returns the width of the box
 *								  (horizontal magnitude).
 */</comment>
<function><type><name>Datum</name></type>
<name>box_width</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_wd</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_height		-		returns the height of the box
 *								  (vertical magnitude).
 */</comment>
<function><type><name>Datum</name></type>
<name>box_height</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_ht</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_distance	-		returns the distance between the
 *								  center points of two boxes.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>a</name></decl>,
				<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><name>box1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_center		-		returns the center point of the box.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_ar	-		returns the area of the box.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>box_ar</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>float8_mul</name><argument_list>(<argument><expr><call><name>box_wd</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>box_ht</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*		box_cn	-		stores the centerpoint of the box into *center.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>box_cn</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>center</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>center</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>center</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_wd	-		returns the width (length) of the box
 *								  (horizontal magnitude).
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>box_wd</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*		box_ht	-		returns the height of the box
 *								  (vertical magnitude).
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>box_ht</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Funky operations.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		box_intersect	-
 *				returns the overlapping portion of two boxes,
 *				  or NULL if they do not intersect.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><name>box1</name></expr></argument>, <argument><expr><name>box2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		box_diagonal	-
 *				returns a line segment which happens to be the
 *				  positive-slope diagonal of "box".
 */</comment>
<function><type><name>Datum</name></type>
<name>box_diagonal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D lines.
 **
 ***********************************************************************/</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>line_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* s was already advanced over leading '{' */</comment>
	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>RDELIM_L</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>lseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isopen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM_L</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_decode</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: A and B cannot both be zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: must be two distinct points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>line_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>astr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%c%s%c%s%c%s%c"</literal></expr></argument>, <argument><expr><name>LDELIM_L</name></expr></argument>, <argument><expr><name>astr</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>, <argument><expr><name>bstr</name></expr></argument>,
							   <argument><expr><name>DELIM</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>RDELIM_L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		line_recv			- converts external binary format to line
 */</comment>
<function><type><name>Datum</name></type>
<name>line_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>line</name> <operator>=</operator> <operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: A and B cannot both be zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		line_send			- converts line to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>line_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Conversion routines from one line formula to internal.
 *		Internal form:	Ax+By+C=0
 *---------------------------------------------------------*/</comment>

<comment type="block">/*
 * Fill already-allocated LINE struct from the point and the slope
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>line_construct</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>DBL_MAX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* vertical - use "x = C" */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use "mx - y + yinter = 0" */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>A</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>B</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* on some platforms, the preceding expression tends to produce -0 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>C</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* line_construct_pp()
 * two points
 */</comment>
<function><type><name>Datum</name></type>
<name>line_construct_pp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LINE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LINE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line specification: must be two distinct points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pt1</name></expr></argument>, <argument><expr><call><name>point_sl</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LINE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relative position routines.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>line_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>line_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_parallel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>line_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_perp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_vertical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>line_horizontal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the two lines are the same
 *
 * We consider NaNs values to be equal to each other to let those lines
 * to be found.
 */</comment>
<function><type><name>Datum</name></type>
<name>line_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>ratio</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name>ratio</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name>ratio</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name>ratio</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				   <operator>(</operator><call><name>float8_eq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>float8_eq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>float8_eq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Line arithmetic routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*
 * Return slope of the line
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>line_sl</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DBL_MAX</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>float8_div</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return inverse slope of the line
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>line_invsl</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DBL_MAX</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>float8_div</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* line_distance()
 * Distance between two lines.
 */</comment>
<function><type><name>Datum</name></type>
<name>line_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>ratio</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>line_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* intersecting? */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ratio</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>,
											   <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name>ratio</name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* line_interpt()
 * Point where two lines l1, l2 intersect (if any)
 */</comment>
<function><type><name>Datum</name></type>
<name>line_interpt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_interpt_line</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal version of line_interpt
 *
 * Return whether two lines intersect. If *result is not NULL, it is set to
 * the intersection point.
 *
 * NOTE: If the lines are identical then we will find they are parallel
 * and report "no intersection".  This is a little weird, but since
 * there's no *unique* intersection, maybe it's appropriate behavior.
 *
 * If the lines have NaN constants, we will return true, and the intersection
 * point would have NaN coordinates.  We shouldn't return false in this case
 * because that would mean the lines are parallel.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>line_interpt_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x</name></decl>,
				<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><operator>-</operator><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FPzero</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l1</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l1</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><operator>-</operator><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>l2</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>l2</name><operator>-&gt;</operator><name>B</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* On some platforms, the preceding expressions tend to produce -0. */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D paths (sequences of line segments, also
 **				called `polylines').
 **
 **				This is not a general package for geometric paths,
 **				which of course include polygons; the emphasis here
 **				is on (for example) usefulness in wire layout.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *	String to path / path to string conversion.
 *		External format:
 *				"((xcoord, ycoord),... )"
 *				"[(xcoord, ycoord),... ]"
 *				"(xcoord, ycoord),... "
 *				"[xcoord, ycoord,... ]"
 *		Also support older format:
 *				"(closed, npts, xcoord, ycoord,... )"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>area</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isopen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>npts</name> <operator>=</operator> <call><name>pair_count</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* skip single leading paren */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strrchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>s</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <name>RDELIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>isopen</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* prevent instability in unused pad bytes */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr> ?</condition><then> <expr><name>PATH_CLOSED</name></expr> </then><else>: <expr><name>PATH_OPEN</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		path_recv			- converts external binary format to path
 *
 * External representation is closed flag (a boolean byte), int32 number
 * of points, and the points.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>closed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>npts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>closed</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>npts</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>npts</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of points in external \"path\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>closed</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* prevent instability in unused pad bytes */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		path_send			- converts path to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>path_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relational operators.
 *		These are based on the path cardinality,
 *		as stupid as that sounds.
 *
 *		Better relops and access methods coming soon.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_n_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>==</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&lt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_n_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------
 * Conversion operators.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_isclosed</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_isopen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_npoints</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_close</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_open</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* path_inter -
 *		Does p1 intersect p2 at any point?
 *		Use bounding boxes for a quick (O(n)) check, then do a
 *		O(n^2) iterative edge check.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_inter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name></type>			<name>b1</name></decl>,
				<decl><type ref="prev"/><name>b2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>seg1</name></decl>,
				<decl><type ref="prev"/><name>seg2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b1</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>b2</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* pairwise check lseg intersections */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>iprev</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* include the closure segment */</comment>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>jprev</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>jprev</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>jprev</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* include the closure segment */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>jprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* if we dropped through, no two segs intersected */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_distance()
 * This essentially does a cartesian product of the lsegs in the
 *	two paths, and finds the min distance between any two lsegs
 */</comment>
<function><type><name>Datum</name></type>
<name>path_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>min</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* initialize to keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_min</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>seg1</name></decl>,
				<decl><type ref="prev"/><name>seg2</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>iprev</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* include the closure segment */</comment>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>jprev</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>jprev</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>jprev</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* include the closure segment */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>jprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name> <operator>||</operator> <call><name>float8_lt</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	"Arithmetic" operations.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>path_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>iprev</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* include the closure segment */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D points.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *	String to point, point to string conversion.
 *		External format:
 *				"(x,y)"
 *				"x,y"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"point"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_NONE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		point_recv			- converts external binary format to point
 */</comment>
<function><type><name>Datum</name></type>
<name>point_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>point</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		point_send			- converts point to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>point_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize a point
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_construct</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relational operators for Points.
 *		Since we do have a sense of coordinates being
 *		"equal" to a given accuracy (point_vert, point_horiz),
 *		the other ops must preserve that sense.  This means
 *		that results may, strictly speaking, be a lie (unless
 *		EPSILON = 0.0).
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_vert</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_horiz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_eq_point</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>point_eq_point</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the two points are the same
 *
 * We consider NaNs coordinates to be equal to each other to let those points
 * to be found.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>point_eq_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>float8_eq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>float8_eq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	"Arithmetic" operators on points.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>point_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>point_dt</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>HYPOT</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_slope</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_sl</name><argument_list>(<argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return slope of two points
 *
 * Note that this function returns DBL_MAX when the points are the same.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>point_sl</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DBL_MAX</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return inverse slope of two points
 *
 * Note that this function returns 0.0 when the points are the same.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>point_invsl</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DBL_MAX</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D line segments.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 *	String to lseg, lseg to string conversion.
 *		External forms: "[(x1, y1), (x2, y2)]"
 *						"(x1, y1), (x2, y2)"
 *						"x1, y1, x2, y2"
 *		closed form ok	"((x1, y1), (x2, y2))"
 *		(old form)		"(x1, y1, x2, y2)"
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>lseg_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isopen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"lseg"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_OPEN</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		lseg_recv			- converts external binary format to lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lseg</name> <operator>=</operator> <operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		lseg_send			- converts lseg to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* lseg_construct -
 *		form a LSEG from two Points.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_construct</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>LSEG</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LSEG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pt1</name></expr></argument>, <argument><expr><name>pt2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_LSEG_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* like lseg_construct, but assume space already allocated */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>statlseg_construct</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return slope of the line segment
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>lseg_sl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>point_sl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return inverse slope of the line segment
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float8</name></type>
<name>lseg_invsl</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>point_invsl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------
 *	Relative position routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*
 **  find intersection of the two lines, and see if it falls on
 **  both segments.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_intersect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_parallel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if two line segments are perpendicular.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_perp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lseg_invsl</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_vertical</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_horizontal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <operator>!</operator><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Line arithmetic routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/* lseg_distance -
 *		If two segments don't intersect, then the closest
 *		point will be from one of the endpoints to the other
 *		segment.
 */</comment>
<function><type><name>Datum</name></type>
<name>lseg_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>lseg_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return whether the two segments intersect. If *result is not NULL,
 * it is set to the intersection point.
 *
 * This function is almost perfectly symmetric, even though it doesn't look
 * like it.  See lseg_interpt_line() for the other half of it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_interpt_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name></type>		<name>interpt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>l2</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the line intersection point isn't within l2, there is no valid
	 * segment intersection point at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lseg_contain_point</name><argument_list>(<argument><expr><name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>interpt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>lseg_interpt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for position comparisons of differently-typed
 **				2D objects.
 **
 ***********************************************************************/</comment>

<comment type="block">/*---------------------------------------------------------------------
 *		dist_
 *				Minimum distance from one object to another.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * Distance from a point to a line
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a line to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_lp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a lseg to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_sp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float8</name></type>
<name>dist_ppath_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>PATH</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_min</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>lseg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The distance from a point to a path is the smallest distance from the
	 * point to any of its constituent segments.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>iprev</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iprev</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Include the closure segment */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>iprev</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_min</name> <operator>||</operator> <call><name>float8_lt</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a path
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ppath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_ppath_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a path to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pathp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_ppath_internal</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a box to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_bp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a lseg to a line
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_closept_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a line to a lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ls</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>lseg_closept_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a lseg to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_closept_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a box to a lseg
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_bs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>box_closept_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a line to a box
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* need to think about this one for a while */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"dist_lb\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a box to a line
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_bl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* need to think about this one for a while */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"dist_bl\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float8</name></type>
<name>dist_cpoly_internal</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* calculate distance to center, and subtract radius */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a circle to a polygon
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_cpoly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_cpoly_internal</name><argument_list>(<argument><expr><name>circle</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a polygon to a circle
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_polyc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_cpoly_internal</name><argument_list>(<argument><expr><name>circle</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a point to a polygon
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_ppoly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>dist_polyp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>dist_ppoly_internal</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float8</name></type>
<name>dist_ppoly_internal</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>seg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>point_inside</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* initialize distance with segment between first and last points */</comment>
	<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check distances for other segments */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seg</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*---------------------------------------------------------------------
 *		interpt_
 *				Intersection point of objects.
 *				We choose to ignore the "point" of intersection between
 *				  lines and boxes, since there are typically two.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * Return whether the line segment intersect with the line. If *result is not
 * NULL, it is set to the intersection point.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_interpt_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name></type>		<name>interpt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, we promote the line segment to a line, because we know how to
	 * find the intersection point of two lines.  If they don't have an
	 * intersection point, we are done.
	 */</comment>
	<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_interpt_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Then, we check whether the intersection point is actually on the line
	 * segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lseg_contain_point</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there is an intersection, then check explicitly for matching
		 * endpoints since there may be rounding effects with annoying LSB
		 * residue.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>interpt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *		close_
 *				Point of closest proximity between objects.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/*
 * If *result is not NULL, it is set to the intersection point of a
 * perpendicular of the line through the point.  Returns the distance
 * of those two points.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>line_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name></type>		<name>closept</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We drop a perpendicular to find the intersection point.  Ordinarily we
	 * should always find it, but that can fail in the presence of NaN
	 * coordinates, and perhaps even from simple roundoff issues.
	 */</comment>
	<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>point</name></expr></argument>, <argument><expr><call><name>line_invsl</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_interpt_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>*</operator><name>point</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>line_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Closest point on line segment to specified point.
 *
 * If *result is not NULL, set it to the closest point on the line segment
 * to the point.  Returns the distance of the two points.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>lseg_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name></type>		<name>closept</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To find the closest point, we draw a perpendicular line from the point
	 * to the line segment.
	 */</comment>
	<expr_stmt><expr><call><name>line_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><call><name>point_invsl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lseg_closept_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Closest point on line segment to line segment
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>lseg_closept_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>on_lseg</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>to_lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name></type>		<name>point</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>dist</name></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<comment type="block">/* First, we handle the case when the line segments are intersecting. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>on_lseg</name></expr></argument>, <argument><expr><name>to_lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Then, we find the closest points from the endpoints of the second line
	 * segment, and keep the closest one.
	 */</comment>
	<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>on_lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>on_lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>point</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The closest point can still be one of the endpoints, so we test them. */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>to_lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>on_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>on_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>to_lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>on_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>on_lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dist</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_lseg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l1</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>l2</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lseg_sl</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Closest point on or in box to specified point.
 *
 * If *result is not NULL, set it to the closest point on the box to the
 * given point, and return the distance of the two points.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>box_closept_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>dist</name></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>point</name></decl>,
				<decl><type ref="prev"/><name>closept</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>lseg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>*</operator><name>pt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><literal type="number">0.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pairwise check lseg distances */</comment>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dist</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>box_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* close_sl()
 * Closest point on line to line segment.
 *
 * XXX THIS CODE IS WRONG
 * The code is actually calculating the point on the line segment
 *	which is backwards from the routine naming convention.
 * Copied code to new routine close_ls() but haven't fixed this one yet.
 * - thomas 1998-01-31
 */</comment>
<function><type><name>Datum</name></type>
<name>close_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>d1</name></decl>,
				<decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>d1</name> <operator>=</operator> <call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"close_sl\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Closest point on line segment to line.
 *
 * Return the distance between the line and the closest point of the line
 * segment to the line.  If *result is not NULL, set it to that point.
 *
 * NOTE: When the lines are parallel, endpoints of one of the line segment
 * are FPeq(), in presence of NaN or Infinite coordinates, or perhaps =
 * even because of simple roundoff issues, there may not be a single closest
 * point.  We are likely to set the result to the second endpoint in these
 * cases.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>lseg_closept_line</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>dist1</name></decl>,
				<decl><type ref="prev"/><name>dist2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dist1</name> <operator>=</operator> <call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dist2</name> <operator>=</operator> <call><name>line_closept_point</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dist1</name> <operator>&lt;</operator> <name>dist2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>dist1</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>dist2</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_ls</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseg_sl</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>line_sl</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>lseg_closept_line</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Closest point on or in box to line segment.
 *
 * Returns the distance between the closest point on or in the box to
 * the line segment.  If *result is not NULL, it is set to that point.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>box_closept_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>dist</name></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>point</name></decl>,
				<decl><type ref="prev"/><name>closept</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>bseg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>box_interpt_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* pairwise check lseg distances */</comment>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>lseg_closept_lseg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>closept</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>closept</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dist</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>close_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><call><name>box_closept_lseg</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>close_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* think about this one for a while */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"close_lb\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *		on_
 *				Whether one object lies completely within another.
 *-------------------------------------------------------------------*/</comment>

<comment type="block">/*
 *		Does the point satisfy the equation?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>line_contain_point</name><parameter_list>(<parameter><decl><type><name>LINE</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FPzero</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>B</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>line</name><operator>-&gt;</operator><name>C</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>line_contain_point</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		Determine colinearity by detecting a triangle inequality.
 * This algorithm seems to behave nicely even with lsb residues - tgl 1997-07-09
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_contain_point</name><parameter_list>(<parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator>
				<call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_ps</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the point is in the box or on its border
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_contain_point</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&amp;&amp;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>point</name><operator>-&gt;</operator><name>x</name></name> <operator>&amp;&amp;</operator>
		<name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_pb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* on_ppath -
 *		Whether a point lies within (on) a polyline.
 *		If open, we have to (groan) check each segment.
 * (uses same algorithm as for point intersecting segment - tgl 1997-07-09)
 *		If closed, we use the old O(n) ray method for point-in-polygon.
 *				The ray is horizontal, from pt out to the right.
 *				Each segment that crosses the ray counts as an
 *				intersection; note that an endpoint or edge may touch
 *				but not cross.
 *				(we can do p-in-p in lg(n), but it takes preprocessing)
 */</comment>
<function><type><name>Datum</name></type>
<name>on_ppath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>a</name></decl>,
				<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

	<comment type="block">/*-- OPEN --*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*-- CLOSED --*/</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the line segment is on the line or close enough
 *
 * It is, if both of its points are on the line or close enough.
 */</comment>
<function><type><name>Datum</name></type>
<name>on_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>line_contain_point</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <call><name>line_contain_point</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the line segment is in the box or on its border
 *
 * It is, if both of its points are in the box or on its border.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_contain_lseg</name><parameter_list>(<parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>on_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_contain_lseg</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------------
 *		inter_
 *				Whether one object intersects another.
 *-------------------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>inter_sl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Do line segment and box intersect?
 *
 * Segment completely inside box counts as intersection.
 * If you want only segments crossing box boundaries,
 *	try converting box to path first.
 *
 * This function also sets the *result to the closest point on the line
 * segment to the center of the box when they overlap and the result is
 * not NULL.  It is somewhat arbitrary, but maybe the best we can do as
 * there are typically two points they intersect.
 *
 * Optimize for non-intersection by checking for box intersection first.
 * - thomas 1998-01-30
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>box_interpt_lseg</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>BOX</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>lseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name></type>			<name>lbox</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>bseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>point</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nothing close to overlap? then not going to intersect */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lbox</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>box_cn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>point</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lseg_closept_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* an endpoint of segment is inside box? then clearly intersects */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>box_contain_point</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lseg</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* pairwise check lseg intersections */</comment>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>point</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we dropped through, no two segs intersected */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>inter_sb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name>	   <modifier>*</modifier></type><name>lseg</name> <init>= <expr><call><name>PG_GETARG_LSEG_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>box_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>lseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* inter_lb()
 * Do line and box intersect?
 */</comment>
<function><type><name>Datum</name></type>
<name>inter_lb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LINE</name>	   <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>PG_GETARG_LINE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>bseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>p1</name></decl>,
				<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>

	<comment type="block">/* pairwise check lseg intersections */</comment>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p2</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p2</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>p2</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p2</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>statlseg_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseg_interpt_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bseg</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if we dropped through, no intersection */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------
 * The following routines define a data type and operator class for
 * POLYGONS .... Part of which (the polygon's bounding box) is built on
 * top of the BOX data type.
 *
 * make_bound_box - create the bounding box for the input polygon
 *------------------------------------------------------------------*/</comment>

<comment type="block">/*---------------------------------------------------------------------
 * Make the smallest bounding box for the given polygon.
 *---------------------------------------------------------------------*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_bound_box</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x1</name></decl>,
				<decl><type ref="prev"/><name>y1</name></decl>,
				<decl><type ref="prev"/><name>x2</name></decl>,
				<decl><type ref="prev"/><name>y2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>x1</name> <operator>=</operator> <name>x2</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>y2</name> <operator>=</operator> <name>y1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>x1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>float8_gt</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>x2</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>float8_lt</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>y1</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>float8_gt</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>y2</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------
 * poly_in - read in the polygon from a string specification
 *
 *		External format:
 *				"((x0,y0),...,(xn,yn))"
 *				"x0,y0,...,xn,yn"
 *				also supports the older style "(x1,...,xn,y1,...yn)"
 *------------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isopen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>npts</name> <operator>=</operator> <call><name>pair_count</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"polygon"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* zero any holes */</comment>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>path_decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>isopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"polygon"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------------------------------------
 * poly_out - convert internal POLYGON representation to the
 *			  character string format "((f8,f8),...,(f8,f8))"
 *---------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>path_encode</name><argument_list>(<argument><expr><name>PATH_CLOSED</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		poly_recv			- converts external binary format to polygon
 *
 * External representation is int32 number of points, and the points.
 * We recompute the bounding box on read, instead of trusting it to
 * be valid.  (Checking it would take just as long, so may as well
 * omit it from external representation.)
 */</comment>
<function><type><name>Datum</name></type>
<name>poly_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>npts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>npts</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>npts</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of points in external \"polygon\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* zero any holes */</comment>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		poly_send			- converts polygon to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>poly_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly left of polygon B? i.e. is
 * the right most point of A left of the left most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or left of polygon B? i.e. is
 * the right most point of A at or left of the right most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly right of polygon B? i.e. is
 * the left most point of A right of the right most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&gt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or right of polygon B? i.e. is
 * the left most point of A at or right of the left most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly below polygon B? i.e. is
 * the upper most point of A below the lower most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or below polygon B? i.e. is
 * the upper most point of A at or below the upper most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>&lt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A strictly above polygon B? i.e. is
 * the lower most point of A above the upper most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&gt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------
 * Is polygon A overlapping or above polygon B? i.e. is
 * the lower most point of A at or above the lower most point
 * of B?
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name><operator>.</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------
 * Is polygon A the same as polygon B? i.e. are all the
 * points the same?
 * Check all points for matches in both forward and reverse
 *	direction since polygons are non-directional and are
 *	closed shapes.
 *-------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>!=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>plist_same</name><argument_list>(<argument><expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-----------------------------------------------------------------
 * Determine if polygon A overlaps polygon B
 *-----------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick check by bounding box */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>box_ov</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polya</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>polyb</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Brute-force algorithm - try to find intersected edges, if so then
	 * polygons are overlapped else check is one polygon inside other or not
	 * by testing single point of them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ia</name></decl>,
					<decl><type ref="prev"/><name>ib</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LSEG</name></type>		<name>sa</name></decl>,
					<decl><type ref="prev"/><name>sb</name></decl>;</decl_stmt>

		<comment type="block">/* Init first of polya's edge with last point */</comment>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>ia</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ia</name> <operator>&lt;</operator> <name><name>polya</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>;</condition> <incr><expr><name>ia</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Second point of polya's edge is a current one */</comment>
			<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>polya</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>ia</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* Init first of polyb's edge with last point */</comment>
			<expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>ib</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ib</name> <operator>&lt;</operator> <name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>;</condition> <incr><expr><name>ib</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>polyb</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>ib</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * move current endpoint to the first point of next edge
			 */</comment>
			<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sa</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>point_inside</name><argument_list>(<argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <call><name>point_inside</name><argument_list>(<argument><expr><name><name>polyb</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>polya</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tests special kind of segment for in/out of polygon.
 * Special kind means:
 *	- point a should be on segment s
 *	- segment (a,b) should not be contained by s
 * Returns true if:
 *	- segment (a,b) is collinear to s and (a,b) is in polygon
 *	- segment (a,b) s not collinear to s. Note: that doesn't
 *	  mean that segment is in polygon!
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>touched_lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>LSEG</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* point a is on s, b is not */</comment>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* may be not true, but that will check later */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if segment (a,b) is in polygon, option
 * start is used for optimization - function checks
 * polygon's edges starting from start
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lseg_inside_poly</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>s</name></decl>,
				<decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name> <init>= <expr><name>true</name></expr></init></decl>,
				<decl><type ref="prev"/><name>intersection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><ternary><condition><expr><operator>(</operator><name>start</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&amp;&amp;</operator> <name>res</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Point</name></type>		<name>interpt</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* t is contained by s */</comment>

			<comment type="block">/* Y-cross */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>touched_lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>lseg_contain_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Y-cross */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>touched_lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>lseg_interpt_lseg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * segments are X-crossing, go to check each subsegment
			 */</comment>

			<expr_stmt><expr><name>intersection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>interpt</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>intersection</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Point</name></type>		<name>p</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * if X-intersection wasn't found  then check central point of tested
		 * segment. In opposite case we already check all subsegments
		 */</comment>
		<expr_stmt><expr><name><name>p</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>point_inside</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the first polygon contains the second
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>poly_contain_poly</name><parameter_list>(<parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>contains_poly</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>contained_poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LSEG</name></type>		<name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>contains_poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>contained_poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check to see if contained's bounding box is contained in
	 * contains' bb.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>box_contain_box</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contains_poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>contained_poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>contained_poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>contained_poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>contained_poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>contained_poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lseg_inside_poly</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>p</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>contains_poly</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>poly_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>poly_contain_poly</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><name>polyb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-----------------------------------------------------------------
 * Determine if polygon A is contained by polygon B
 *-----------------------------------------------------------------*/</comment>
<function><type><name>Datum</name></type>
<name>poly_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Just switch the arguments and pass it off to poly_contain */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>poly_contain_poly</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><name>polya</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid leaking memory for toasted inputs ... needed for rtree indexes
	 */</comment>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polya</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>polyb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pt_contained_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>point_inside</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polya</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>polyb</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"poly_distance\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D points.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>construct_point</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>y</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_add_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
					<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_sub_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
					<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_sub</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_sub_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_mul_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
					<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_mul_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_div_point</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>pt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>div</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>div</name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
					<argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>div</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>pt1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>pt2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>div</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>point_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_div_point</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D boxes.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>points_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>box_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_sub</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_sub_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_sub_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>high</name></decl>,
				<decl><type ref="prev"/><name>low</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_mul_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>high</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_mul_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>low</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>box_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>high</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>box_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name></type>		<name>high</name></decl>,
				<decl><type ref="prev"/><name>low</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_div_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>high</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_div_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name>low</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>box_construct</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>high</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert point to empty box
 */</comment>
<function><type><name>Datum</name></type>
<name>point_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Smallest bounding box that includes both of the given boxes
 */</comment>
<function><type><name>Datum</name></type>
<name>boxes_bound_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box1</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>box2</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>container</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>container</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_max</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>container</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_min</name><argument_list>(<argument><expr><name><name>box1</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box2</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D paths.
 **
 ***********************************************************************/</comment>

<comment type="block">/* path_add()
 * Concatenate two paths (only if they are both open).
 */</comment>
<function><type><name>Datum</name></type>
<name>path_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>p2</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>,
				<decl><type ref="prev"/><name>base_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>closed</name></name> <operator>||</operator> <name><name>p2</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator> <operator>||</operator>
		<name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>npts</name></name> <operator>+</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>closed</name></name></expr>;</expr_stmt>
	<comment type="block">/* prevent instability in unused pad bytes */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>p1</name><operator>-&gt;</operator><name>npts</name></name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_add_pt()
 * Translation operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_add_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_sub_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_sub_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* path_mul_pt()
 * Rotation and scaling operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>path_mul_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_mul_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_div_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_div_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>path_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"path_center\" not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>path_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_PATH_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* This is not very consistent --- other similar cases return NULL ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>closed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"open path cannot be converted to polygon"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Never overflows: the old size fit in MaxAllocSize, and the new size is
	 * just a small constant larger.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for 2D polygons.
 **
 ***********************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>poly_npoints</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name></type>		<name>circle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>poly_to_circle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>circle</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>circle</name><operator>.</operator><name>center</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>box</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* box_poly()
 * Convert a box to a polygon.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* map four corners of the box to a polygon */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>box_construct</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>boundbox</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>poly_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PATH</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Never overflows: the old size fit in MaxAllocSize, and the new size is
	 * smaller by a small constant.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PATH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>PATH</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* prevent instability in unused pad bytes */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_PATH_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Routines for circles.
 **
 ***********************************************************************/</comment>

<comment type="block">/*----------------------------------------------------------
 * Formatting and conversion routines.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		circle_in		-		convert a string to internal form.
 *
 *		External format: (center and radius of circle)
 *				"&lt;(f8,f8),f8&gt;"
 *				also supports quick entry style "f8,f8,f8"
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM_C</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>depth</name><operator>++</operator></expr><operator>,</operator> <expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If there are two left parens, consume the first one */</comment>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <name>LDELIM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>depth</name><operator>++</operator></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pair_decode will consume parens around the pair, if any */</comment>
	<expr_stmt><expr><call><name>pair_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>DELIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>single_decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We have to accept NaN. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>RDELIM</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <name>RDELIM_C</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>depth</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"circle"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_out		-		convert a circle to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM_C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>LDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pair_encode</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>single_encode</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>RDELIM_C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		circle_recv			- converts external binary format to circle
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>circle</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have to accept NaN. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid radius in external \"circle\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		circle_send			- converts circle to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relational operators for CIRCLEs.
 *		&lt;, &gt;, &lt;=, &gt;=, and == are based on circle area.
 *---------------------------------------------------------*/</comment>

<comment type="block">/*		circles identical?
 *
 * We consider NaNs values to be equal to each other to let those circles
 * to be found.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
					<call><name>FPeq</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				   <call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_overlap	-		does circle1 overlap circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overlap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_overleft -		is the right edge of circle1 at or left of
 *								the right edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overleft</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_left		-		is circle1 strictly left of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_right	-		is circle1 strictly right of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_overright	-	is the left edge of circle1 at or right of
 *								the left edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overright</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_contained		-		is circle1 contained by circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_contained</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_contain	-		does circle1 contain circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_contain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_below		-		is circle1 strictly below circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_below</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_above	-		is circle1 strictly above circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_above</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_overbelow -		is the upper edge of circle1 at or below
 *								the upper edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overbelow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_overabove	-	is the lower edge of circle1 at or above
 *								the lower edge of circle2?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_overabove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_relop	-		is area(circle1) relop area(circle2), within
 *								our accuracy constraint?
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPeq</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPne</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPlt</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPgt</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPle</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FPge</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	"Arithmetic" operators on circles.
 *---------------------------------------------------------*/</comment>

<comment type="block">/* circle_add_pt()
 * Translation operator.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_add_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_sub_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_sub_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* circle_mul_pt()
 * Rotation and scaling operators.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_mul_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_mul_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>float8_mul</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_div_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_div_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><call><name>HYPOT</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>point</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_area		-		returns the area of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_area</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>circle_ar</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_diameter -		returns the diameter of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_diameter</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_radius	-		returns the radius of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_radius</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_distance -		returns the distance between
 *								  two circles.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_distance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle1</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle2</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle1</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle2</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle1</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle2</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>circle_contain_pt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>d</name> <operator>&lt;=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pt_contained_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>d</name> <operator>&lt;=</operator> <name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		dist_pc -		returns the distance between
 *						  a point and a circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_pc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Distance from a circle to a point
 */</comment>
<function><type><name>Datum</name></type>
<name>dist_cpoint</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>point</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*		circle_center	-		returns the center point of the circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>circle_center</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Point</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*		circle_ar		-		returns the area of the circle.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>circle_ar</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>circle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>float8_mul</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>M_PI</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Conversion operators.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>cr_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Point</name>	   <modifier>*</modifier></type><name>center</name> <init>= <expr><call><name>PG_GETARG_POINT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>radius</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <name>radius</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>circle_box</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>delta</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>BOX</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>delta</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOX_P</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* box_circle()
 * Convert a box to a circle.
 */</comment>
<function><type><name>Datum</name></type>
<name>box_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOX</name>		   <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>PG_GETARG_BOX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>circle</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><call><name>float8_pl</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>high</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>low</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>circle</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>high</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>circle_poly</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>npts</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>circle</name> <init>= <expr><call><name>PG_GETARG_CIRCLE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_size</name></decl>,
				<decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>angle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>anglestep</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert circle with radius zero to polygon"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>npts</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must request at least 2 points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>base_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>POLYGON</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>base_size</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>base_size</name> <operator>/</operator> <name>npts</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>size</name> <operator>&lt;=</operator> <name>base_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many points requested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>poly</name> <operator>=</operator> <operator>(</operator><name>POLYGON</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* zero any holes */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>poly</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>=</operator> <name>npts</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>anglestep</name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><literal type="number">2.0</literal> <operator>*</operator> <name>M_PI</name></expr></argument>, <argument><expr><name>npts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>float8_mul</name><argument_list>(<argument><expr><name>anglestep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>,
								 <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><name><name>circle</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>make_bound_box</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POLYGON_P</name><argument_list>(<argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert polygon to circle
 *
 * The result must be preallocated.
 *
 * XXX This algorithm should use weighted means of line segments
 *	rather than straight average values of points - tgl 97/01/21.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>poly_to_circle</name><parameter_list>(<parameter><decl><type><name>CIRCLE</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>POLYGON</name> <modifier>*</modifier></type><name>poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>point_add_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>center</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>float8_pl</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>,
								   <argument><expr><call><name>point_dt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>poly</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>center</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name> <operator>=</operator> <call><name>float8_div</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>radius</name></name></expr></argument>, <argument><expr><name><name>poly</name><operator>-&gt;</operator><name>npts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>poly_circle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>POLYGON</name>    <modifier>*</modifier></type><name>poly</name> <init>= <expr><call><name>PG_GETARG_POLYGON_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CIRCLE</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>CIRCLE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CIRCLE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>poly_to_circle</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>poly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CIRCLE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 **
 **		Private routines for multiple types.
 **
 ***********************************************************************/</comment>

<comment type="block">/*
 *	Test to see if the point is inside the polygon, returns 1/0, or 2 if
 *	the point is on the polygon.
 *	Code adapted but not copied from integer-based routines in WN: A
 *	Server for the HTTP
 *	version 1.15.1, file wn/image.c
 *	http://hopf.math.northwestern.edu/index.html
 *	Description of algorithm:  http://www.linuxjournal.com/article/2197
 *							   http://www.linuxjournal.com/article/2029
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POINT_ON_POLYGON</name></cpp:macro> <cpp:value>INT_MAX</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>point_inside</name><parameter_list>(<parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x0</name></decl>,
				<decl><type ref="prev"/><name>y0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>prev_x</name></decl>,
				<decl><type ref="prev"/><name>prev_y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>x</name></decl>,
				<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cross</name></decl>,
				<decl><type ref="prev"/><name>total_cross</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute first polygon point relative to single point */</comment>
	<expr_stmt><expr><name>x0</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>plist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y0</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>plist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_x</name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_y</name> <operator>=</operator> <name>y0</name></expr>;</expr_stmt>
	<comment type="block">/* loop over polygon points and aggregate total_cross */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* compute next polygon point relative to single point */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>plist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><name><name>plist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* compute previous to current point crossing */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cross</name> <operator>=</operator> <call><name>lseg_crossing</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>prev_x</name></expr></argument>, <argument><expr><name>prev_y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>POINT_ON_POLYGON</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>total_cross</name> <operator>+=</operator> <name>cross</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>prev_x</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_y</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* now do the first point */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cross</name> <operator>=</operator> <call><name>lseg_crossing</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>prev_x</name></expr></argument>, <argument><expr><name>prev_y</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>POINT_ON_POLYGON</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>total_cross</name> <operator>+=</operator> <name>cross</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_cross</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* lseg_crossing()
 * Returns +/-2 if line segment crosses the positive X-axis in a +/- direction.
 * Returns +/-1 if one point is on the positive X-axis.
 * Returns 0 if both points are on the positive X-axis, or there is no crossing.
 * Returns POINT_ON_POLYGON if the segment contains (0,0).
 * Wow, that is one confusing API, but it is used above, and when summed,
 * can tell is if a point is in a polygon.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lseg_crossing</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>prev_x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>prev_y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>y_sign</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* y == 0, on X axis */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* (x,y) is (0,0)? */</comment>
			<return>return <expr><name>POINT_ON_POLYGON</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>FPgt</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* x &gt; 0 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* y and prev_y are zero */</comment>
				<comment type="block">/* prev_x &gt; 0? */</comment>
				<return>return <expr><ternary><condition><expr><call><name>FPgt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>POINT_ON_POLYGON</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>						<comment type="block">/* x &lt; 0, x not on positive X axis */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* prev_x &lt; 0? */</comment>
				<return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>POINT_ON_POLYGON</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>							<comment type="block">/* y != 0 */</comment>
		<comment type="block">/* compute y crossing direction from previous point */</comment>
		<expr_stmt><expr><name>y_sign</name> <operator>=</operator> <ternary><condition><expr><call><name>FPgt</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* previous point was on X axis, so new point is either off or on */</comment>
			<return>return <expr><ternary><condition><expr><call><name>FPlt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>y_sign</name></expr></else></ternary></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>y_sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FPlt</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><name>y_sign</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name>prev_y</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* both above or below X axis */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* same sign */</comment>
		<else>else
		<block>{<block_content>						<comment type="block">/* y and prev_y cross X-axis */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FPge</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* both non-negative so cross positive X-axis */</comment>
				<return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>y_sign</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FPlt</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FPle</name><argument_list>(<argument><expr><name>prev_x</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* both non-positive so do not cross positive X-axis */</comment>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* x and y cross axes, see URL above point_inside() */</comment>
			<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>float8_mi</name><argument_list>(<argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>prev_x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>float8_mul</name><argument_list>(<argument><expr><call><name>float8_mi</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>prev_y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FPzero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>POINT_ON_POLYGON</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>y_sign</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FPlt</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name>y_sign</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FPgt</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>y_sign</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>plist_same</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>npts</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ii</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* find match for first point */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/* match found? then look forward through remaining points */</comment>
			<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* match not found forwards? then look backwards */</comment>
			<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>npts</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>npts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>point_eq_point</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p2</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p1</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>ii</name> <operator>==</operator> <name>npts</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 * Determine the hypotenuse.
 *
 * If required, x and y are swapped to make x the larger number. The
 * traditional formula of x^2+y^2 is rearranged to factor x outside the
 * sqrt. This allows computation of the hypotenuse for significantly
 * larger values, and with a higher precision than when using the naive
 * formula.  In particular, this cannot overflow unless the final result
 * would be out-of-range.
 *
 * sqrt( x^2 + y^2 ) = sqrt( x^2( 1 + y^2/x^2) )
 *					 = x * sqrt( 1 + y^2/x^2 )
 *					 = x * sqrt( 1 + y/x * y/x )
 *
 * It is expected that this routine will eventually be replaced with the
 * C99 hypot() function.
 *
 * This implementation conforms to IEEE Std 1003.1 and GLIBC, in that the
 * case of hypot(inf,nan) results in INF, and not NAN.
 *-----------------------------------------------------------------------
 */</comment>
<function><type><name>float8</name></type>
<name>pg_hypot</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>yx</name></decl>,
				<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Handle INF and NaN properly */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else, drop any minus signs */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Swap x and y if needed to make x the larger one */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>y</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float8</name></type>		<name>temp</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If y is zero, the hypotenuse is x.  This test saves a few cycles in
	 * such cases, but more importantly it also protects against
	 * divide-by-zero errors, since now x &gt;= y.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Determine the hypotenuse */</comment>
	<expr_stmt><expr><name>yx</name> <operator>=</operator> <name>y</name> <operator>/</operator> <name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>x</name> <operator>*</operator> <call><name>sqrt</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>yx</name> <operator>*</operator> <name>yx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>float_overflow_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>float_underflow_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
