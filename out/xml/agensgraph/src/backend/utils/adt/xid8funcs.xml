<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/xid8funcs.c"><comment type="block">/*-------------------------------------------------------------------------
 * xid8funcs.c
 *
 *	Export internal transaction IDs to user level.
 *
 * Note that only top-level transaction IDs are exposed to user sessions.
 * This is important because xid8s frequently persist beyond the global
 * xmin horizon, or may even be shipped to other machines, so we cannot
 * rely on being able to correlate subtransaction IDs with their parents
 * via functions such as SubTransGetTopmostTransaction().
 *
 * These functions are used to support the txid_XXX functions and the newer
 * pg_current_xact, pg_current_snapshot and related fmgr functions, since the
 * only difference between them is whether they expose xid8 or int8 values to
 * users.  The txid_XXX variants should eventually be dropped.
 *
 *
 *	Copyright (c) 2003-2020, PostgreSQL Global Development Group
 *	Author: Jan Wieck, Afilias USA INC.
 *	64-bit txids: Marko Kreen, Skype Technologies
 *
 *	src/backend/utils/adt/xid8funcs.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/qunique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xid8.h"</cpp:file></cpp:include>


<comment type="block">/*
 * If defined, use bsearch() function for searching for xid8s in snapshots
 * that have more than the specified number of values.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_BSEARCH_IF_NXIP_GREATER</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>


<comment type="block">/*
 * Snapshot containing FullTransactionIds.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * 4-byte length hdr, should not be touched directly.
	 *
	 * Explicit embedding is ok as we want always correct alignment anyway.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>__varsz</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type>		<name>nxip</name></decl>;</decl_stmt>			<comment type="block">/* number of fxids in xip array */</comment>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
	<comment type="block">/* in-progress fxids, xmin &lt;= xip[i] &lt; xmax: */</comment>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name><name>xip</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>pg_snapshot</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_SNAPSHOT_SIZE</name><parameter_list>(<parameter><type><name>nxip</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(offsetof(pg_snapshot, xip) + sizeof(FullTransactionId) * (nxip))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_SNAPSHOT_MAX_NXIP</name></cpp:macro> \
	<cpp:value>((MaxAllocSize - offsetof(pg_snapshot, xip)) / sizeof(FullTransactionId))</cpp:value></cpp:define>

<comment type="block">/*
 * Helper to get a TransactionId from a 64-bit xid with wraparound detection.
 *
 * It is an ERROR if the xid is in the future.  Otherwise, returns true if
 * the transaction is still new enough that we can determine whether it
 * committed and false otherwise.  If *extracted_xid is not NULL, it is set
 * to the low 32 bits of the transaction ID (i.e. the actual XID, without the
 * epoch).
 *
 * The caller must hold XactTruncationLock since it's dealing with arbitrary
 * XIDs, and must continue to hold it until it's done with any clog lookups
 * relating to those XIDs.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionIdInRecentPast</name><parameter_list>(<parameter><decl><type><name>FullTransactionId</name></type> <name>fxid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>extracted_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>xid_epoch</name> <init>= <expr><call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name>fxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>fxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>now_epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>now_epoch_next_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>now_fullxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>now_fullxid</name> <operator>=</operator> <call><name>ReadNextFullTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now_epoch_next_xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now_epoch</name> <operator>=</operator> <call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>extracted_xid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>extracted_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* For non-normal transaction IDs, we can ignore the epoch. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the transaction ID is in the future, throw an error. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>fxid</name></expr></argument>, <argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction ID %s is in the future"</literal></expr></argument>,
						<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><name>UINT64_FORMAT</name></expr></argument>,
								 <argument><expr><call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name>fxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ShmemVariableCache-&gt;oldestClogXid is protected by XactTruncationLock,
	 * but we don't acquire that lock here.  Instead, we require the caller to
	 * acquire it, because the caller is presumably going to look up the
	 * returned XID.  If we took and released the lock within this function, a
	 * CLOG truncation could occur before the caller finished with the XID.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>XactTruncationLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the transaction ID has wrapped around, it's definitely too old to
	 * determine the commit status.  Otherwise, we can compare it to
	 * ShmemVariableCache-&gt;oldestClogXid to determine whether the relevant
	 * CLOG entry is guaranteed to still exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid_epoch</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>now_epoch</name>
		<operator>||</operator> <operator>(</operator><name>xid_epoch</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>now_epoch</name> <operator>&amp;&amp;</operator> <name>xid</name> <operator>&lt;</operator> <name>now_epoch_next_xid</name><operator>)</operator>
		<operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a TransactionId obtained from a snapshot held by the caller to a
 * FullTransactionId.  Use next_fxid as a reference FullTransactionId, so that
 * we can compute the high order bits.  It must have been obtained by the
 * caller with ReadNextFullTransactionId() after the snapshot was created.
 */</comment>
<function><type><specifier>static</specifier> <name>FullTransactionId</name></type>
<name>widen_snapshot_xid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>FullTransactionId</name></type> <name>next_fxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>next_xid</name> <init>= <expr><call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>next_fxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>epoch</name> <init>= <expr><call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name>next_fxid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Special transaction ID. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>FullTransactionIdFromEpochAndXid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The 64 bit result must be &lt;= next_fxid, since next_fxid hadn't been
	 * issued yet when the snapshot was created.  Every TransactionId in the
	 * snapshot must therefore be from the same epoch as next_fxid, or the
	 * epoch before.  We know this because next_fxid is never allow to get
	 * more than one epoch ahead of the TransactionIds in any snapshot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>&gt;</operator> <name>next_xid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>FullTransactionIdFromEpochAndXid</name><argument_list>(<argument><expr><name>epoch</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * txid comparator for qsort/bsearch
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_fxid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>FullTransactionId</name> <operator>*</operator><operator>)</operator> <name>aa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>FullTransactionId</name> <operator>*</operator><operator>)</operator> <name>bb</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort a snapshot's txids, so we can use bsearch() later.  Also remove
 * any duplicates.
 *
 * For consistency of on-disk representation, we always sort even if bsearch
 * will not be used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_snapshot</name><parameter_list>(<parameter><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FullTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>=</operator> <call><name>qunique</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FullTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>cmp_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check fxid visibility.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_visible_fxid</name><parameter_list>(<parameter><decl><type><name>FullTransactionId</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSEARCH_IF_NXIP_GREATER</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>&gt;</operator> <name>USE_BSEARCH_IF_NXIP_GREATER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FullTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>cmp_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if found, transaction is still in progress */</comment>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>res</name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdEquals</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * helper functions to use StringInfo for pg_snapshot creation.
 */</comment>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>buf_init</name><parameter_list>(<parameter><decl><type><name>FullTransactionId</name></type> <name>xmin</name></decl></parameter>, <parameter><decl><type><name>FullTransactionId</name></type> <name>xmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name></type> <name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>nxip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>snap</name></expr></argument>, <argument><expr><call><name>PG_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>buf_add_txid</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>FullTransactionId</name></type> <name>fxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do this before possible realloc */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>fxid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fxid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pg_snapshot</name> <modifier>*</modifier></type>
<name>buf_finalize</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* buf is not needed anymore */</comment>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse snapshot from cstring
 */</comment>
<function><type><specifier>static</specifier> <name>pg_snapshot</name> <modifier>*</modifier></type>
<name>parse_snapshot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>last_val</name> <init>= <expr><name>InvalidFullTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_start</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* it should look sane */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>FullTransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* allocate buffer */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buf_init</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop over values */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read next value */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>

		<comment type="block">/* require the input to be in order */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>FullTransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>last_val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip duplicates */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdEquals</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>last_val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>buf_add_txid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>last_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><call><name>buf_finalize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>bad_format</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
					<argument><expr><literal type="string">"pg_snapshot"</literal></expr></argument>, <argument><expr><name>str_start</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_current_xact_id() returns xid8
 *
 *	Return the current toplevel full transaction ID.
 *	If the current transaction does not have one, one is assigned.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_current_xact_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must prevent during recovery because if an xid is not assigned we try
	 * to assign one, which would fail. Programs already rely on this function
	 * to always return a valid current xid, so we should not change this to
	 * return NULL or similar invalid xid.
	 */</comment>
	<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"pg_current_xact_id()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FULLTRANSACTIONID</name><argument_list>(<argument><expr><call><name>GetTopFullTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Same as pg_current_xact_if_assigned() but doesn't assign a new xid if there
 * isn't one yet.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_current_xact_id_if_assigned</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>topfxid</name> <init>= <expr><call><name>GetTopFullTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdIsValid</name><argument_list>(<argument><expr><name>topfxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FULLTRANSACTIONID</name><argument_list>(<argument><expr><name>topfxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_current_snapshot() returns pg_snapshot
 *
 *		Return current snapshot
 *
 * Note that only top-transaction XIDs are included in the snapshot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_current_snapshot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nxip</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>next_fxid</name> <init>= <expr><call><name>ReadNextFullTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no active snapshot set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compile-time limits on the procarray (MAX_BACKENDS processes plus
	 * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>MAX_BACKENDS</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>PG_SNAPSHOT_MAX_NXIP</name></expr></argument>,
					 <argument><expr><literal type="string">"possible overflow in pg_current_snapshot()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate */</comment>
	<expr_stmt><expr><name>nxip</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>PG_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <call><name>widen_snapshot_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>next_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>widen_snapshot_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><name>next_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>=</operator> <name>nxip</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>widen_snapshot_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>next_fxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * We want them guaranteed to be in ascending order.  This also removes
	 * any duplicate xids.  Normally, an XID can only be assigned to one
	 * backend, but when preparing a transaction for two-phase commit, there
	 * is a transient state when both the original backend and the dummy
	 * PGPROC entry reserved for the prepared transaction hold the same XID.
	 */</comment>
	<expr_stmt><expr><call><name>sort_snapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set size after sorting, because it may have removed duplicate xips */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><call><name>PG_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_in(cstring) returns pg_snapshot
 *
 *		input function for type pg_snapshot
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>parse_snapshot</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_out(pg_snapshot) returns cstring
 *
 *		output function for type pg_snapshot
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name> <literal type="string">":"</literal></expr></argument>,
					 <argument><expr><call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name> <literal type="string">":"</literal></expr></argument>,
					 <argument><expr><call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
						 <argument><expr><call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_recv(internal) returns pg_snapshot
 *
 *		binary input function for type pg_snapshot
 *
 *		format: int4 nxip, int8 xmin, int8 xmax, int8 xip
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>last</name> <init>= <expr><name>InvalidFullTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nxip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>

	<comment type="block">/* load and validate nxip */</comment>
	<expr_stmt><expr><name>nxip</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nxip</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nxip</name></expr></argument> &gt;</argument_list></name> <name>PG_SNAPSHOT_MAX_NXIP</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FullTransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>FullTransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>PG_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>cur</name> <init>=
		<expr><call><name>FullTransactionIdFromU64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>FullTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip duplicate xips */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FullTransactionIdEquals</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nxip</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>=</operator> <name>nxip</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><call><name>PG_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>bad_format</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid external pg_snapshot data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_send(pg_snapshot) returns bytea
 *
 *		binary output function for type pg_snapshot
 *
 *		format: int4 nxip, u64 xmin, u64 xmax, u64 xip...
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_visible_in_snapshot(xid8, pg_snapshot) returns bool
 *
 *		is txid visible in snapshot ?
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_visible_in_snapshot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>value</name> <init>= <expr><call><name>PG_GETARG_FULLTRANSACTIONID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>is_visible_fxid</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_xmin(pg_snapshot) returns xid8
 *
 *		return snapshot's xmin
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_xmin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FULLTRANSACTIONID</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_xmax(pg_snapshot) returns xid8
 *
 *		return snapshot's xmax
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_xmax</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FULLTRANSACTIONID</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_snapshot_xip(pg_snapshot) returns setof xid8
 *
 *		return in-progress xid8s in snapshot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_snapshot_xip</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>value</name></decl>;</decl_stmt>

	<comment type="block">/* on first call initialize fctx and get copy of snapshot */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_snapshot</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>pg_snapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make a copy of user snapshot */</comment>
		<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* return values one-by-one */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>snap</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name><name>fctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>, <argument><expr><call><name>FullTransactionIdGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report the status of a recent transaction ID, or null for wrapped,
 * truncated away or otherwise too old XIDs.
 *
 * The passed epoch-qualified xid is treated as a normal xid, not a
 * multixact id.
 *
 * If it points to a committed subxact the result is the subxact status even
 * though the parent xact may still be in progress or may have aborted.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_xact_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>fxid</name> <init>= <expr><call><name>PG_GETARG_FULLTRANSACTIONID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must protect against concurrent truncation of clog entries to avoid
	 * an I/O error on SLRU lookup.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XactTruncationLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdInRecentPast</name><argument_list>(<argument><expr><name>fxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Like when doing visiblity checks on a row, check whether the
		 * transaction is still in progress before looking into the CLOG.
		 * Otherwise we would incorrectly return "committed" for a transaction
		 * that is committing and has already updated the CLOG, but hasn't
		 * removed its XID from the proc array yet. (See comment on that race
		 * condition at the top of heapam_visibility.c)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"in progress"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"committed"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* it must have aborted or crashed */</comment>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"aborted"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
