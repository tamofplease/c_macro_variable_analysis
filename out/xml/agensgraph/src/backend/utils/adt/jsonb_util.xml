<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/jsonb_util.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * jsonb_util.c
 *	  converting between Jsonb and JsonbValues, and iterating.
 *
 * Copyright (c) 2014-2020, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/jsonb_util.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/jsonapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Maximum number of elements in an array (or key/value pairs in an object).
 * This is limited by two things: the size of the JEntry array must fit
 * in MaxAllocSize, and the number of elements (or pairs) must fit in the bits
 * reserved for that in the JsonbContainer.header field.
 *
 * (The total size of an array's or object's elements is also limited by
 * JENTRY_OFFLENMASK, but we're not concerned about that here.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSONB_MAX_ELEMS</name></cpp:macro> <cpp:value>(Min(MaxAllocSize / sizeof(JsonbValue), JB_CMASK))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSONB_MAX_PAIRS</name></cpp:macro> <cpp:value>(Min(MaxAllocSize / sizeof(JsonbPair), JB_CMASK))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fillJsonbValue</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
						   <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>equalsJsonbScalarValue</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compareJsonbScalarValue</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type><name>convertToJsonb</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convertJsonbValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convertJsonbArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convertJsonbObject</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convertJsonbScalar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>reserveFromBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendToBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copyToBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>short</name></type> <name>padBufferToInt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>JsonbIterator</name> <modifier>*</modifier></type><name>iteratorFromContainer</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JsonbIterator</name> <modifier>*</modifier></type><name>freeAndGetParent</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JsonbParseState</name> <modifier>*</modifier></type><name>pushState</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendKey</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendValue</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendElement</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lengthCompareJsonbStringValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lengthCompareJsonbString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lengthCompareJsonbPair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>uniqueifyJsonbObject</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>pushJsonbValueScalar</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>,
										<parameter><decl><type><name>JsonbIteratorToken</name></type> <name>seq</name></decl></parameter>,
										<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Turn an in-memory JsonbValue into a Jsonb for on-disk storage.
 *
 * There isn't a JsonbToJsonbValue(), because generally we find it more
 * convenient to directly iterate through the Jsonb representation and only
 * really convert nested scalar values.  JsonbIteratorNext() does this, so that
 * clients of the iteration code don't have to directly deal with the binary
 * representation (JsonbDeepContains() is a notable exception, although all
 * exceptions are internal to this module).  In general, functions that accept
 * a JsonbValue argument are concerned with the manipulation of scalar values,
 * or simple containers of scalar values, where it would be inconvenient to
 * deal with a great amount of other state.
 */</comment>
<function><type><name>Jsonb</name> <modifier>*</modifier></type>
<name>JsonbValueToJsonb</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scalar value */</comment>
		<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>scalarArray</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>scalarArray</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvArray</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scalarArray</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scalarArray</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WJB_BEGIN_ARRAY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scalarArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WJB_ELEM</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WJB_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>convertToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name> <operator>||</operator> <name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>convertToJsonb</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the offset of the variable-length portion of a Jsonb node within
 * the variable-length-data part of its container.  The node is identified
 * by index within the container's JEntry array.
 */</comment>
<function><type><name>uint32</name></type>
<name>getJsonbOffset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonbContainer</name> <modifier>*</modifier></type><name>jc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start offset of this entry is equal to the end offset of the previous
	 * entry.  Walk backwards to the most recent entry stored as an end
	 * offset, returning that offset plus any lengths in between.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>jc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>JBE_HAS_OFF</name><argument_list>(<argument><expr><name><name>jc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the length of the variable-length portion of a Jsonb node.
 * The node is identified by index within the container's JEntry array.
 */</comment>
<function><type><name>uint32</name></type>
<name>getJsonbLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonbContainer</name> <modifier>*</modifier></type><name>jc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the length is stored directly in the JEntry, just return it.
	 * Otherwise, get the begin offset of the entry, and subtract that from
	 * the stored end+1 offset.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>JBE_HAS_OFF</name><argument_list>(<argument><expr><name><name>jc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>getJsonbOffset</name><argument_list>(<argument><expr><name>jc</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>jc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>off</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>jc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BT comparator worker function.  Returns an integer less than, equal to, or
 * greater than zero, indicating whether a is less than, equal to, or greater
 * than b.  Consistent with the requirements for a B-Tree operator class
 *
 * Strings are compared lexically, in contrast with other places where we use a
 * much simpler comparator logic for searching through Strings.  Since this is
 * called from B-Tree support function 1, we're careful about not leaking
 * memory here.
 */</comment>
<function><type><name>int</name></type>
<name>compareJsonbContainers</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>ita</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>itb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ita</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itb</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>va</name></decl>,
					<decl><type ref="prev"/><name>vb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>ra</name></decl>,
					<decl><type ref="prev"/><name>rb</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ita</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>rb</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>WJB_DONE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Decisively equal */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>WJB_END_ARRAY</name> <operator>||</operator> <name>ra</name> <operator>==</operator> <name>WJB_END_OBJECT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * There is no array or object to compare at this stage of
				 * processing.  jbvArray/jbvObject values are compared
				 * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT
				 * tokens.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>vb</name><operator>.</operator><name>type</name></name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>va</name><operator>.</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>jbvString</name></expr>:</case>
					<case>case <expr><name>jbvNull</name></expr>:</case>
					<case>case <expr><name>jbvNumeric</name></expr>:</case>
					<case>case <expr><name>jbvBool</name></expr>:</case>
						<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compareJsonbScalarValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>jbvArray</name></expr>:</case>

						<comment type="block">/*
						 * This could be a "raw scalar" pseudo array.  That's
						 * a special case here though, since we still want the
						 * general type-based comparisons to apply, and as far
						 * as we're concerned a pseudo array is just a scalar.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>&gt;</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>jbvObject</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>&gt;</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>jbvBinary</name></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected jbvBinary value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>jbvDatetime</name></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected jbvDatetime value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Type-defined order */</comment>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>.</operator><name>type</name></name> <operator>&gt;</operator> <name><name>vb</name><operator>.</operator><name>type</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * It's safe to assume that the types differed, and that the va
			 * and vb values passed were set.
			 *
			 * If the two values were of the same container type, then there'd
			 * have been a chance to observe the variation in the number of
			 * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're
			 * either two heterogeneously-typed containers, or a container and
			 * some scalar type.
			 *
			 * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT
			 * cases here, because we would have seen the corresponding
			 * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and
			 * concluded that they don't match.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ra</name> <operator>!=</operator> <name>WJB_END_ARRAY</name> <operator>&amp;&amp;</operator> <name>ra</name> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rb</name> <operator>!=</operator> <name>WJB_END_ARRAY</name> <operator>&amp;&amp;</operator> <name>rb</name> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Type-defined order */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>.</operator><name>type</name></name> <operator>&gt;</operator> <name><name>vb</name><operator>.</operator><name>type</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<while>while <condition>(<expr><name>ita</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name><name>ita</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ita</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ita</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>itb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name><name>itb</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itb</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find value in object (i.e. the "value" part of some key/value pair in an
 * object), or find a matching element if we're looking through an array.  Do
 * so on the basis of equality of the object keys only, or alternatively
 * element values only, with a caller-supplied value "key".  The "flags"
 * argument allows the caller to specify which container types are of interest.
 *
 * This exported utility function exists to facilitate various cases concerned
 * with "containment".  If asked to look through an object, the caller had
 * better pass a Jsonb String, because their keys can only be strings.
 * Otherwise, for an array, any type of JsonbValue will do.
 *
 * In order to proceed with the search, it is necessary for callers to have
 * both specified an interest in exactly one particular container type with an
 * appropriate flag, as well as having the pointed-to Jsonb container be of
 * one of those same container types at the top level. (Actually, we just do
 * whichever makes sense to save callers the trouble of figuring it out - at
 * most one can make sense, because the container either points to an array
 * (possibly a "raw scalar" pseudo array) or an object.)
 *
 * Note that we can return a jbvBinary JsonbValue if this is called on an
 * object, but we never do so on an array.  If the caller asks to look through
 * a container type that is not of the type pointed to by the container,
 * immediately fall through and return NULL.  If we cannot find the value,
 * return NULL.  Otherwise, return palloc()'d copy of value.
 */</comment>
<function><type><name>JsonbValue</name> <modifier>*</modifier></type>
<name>findJsonbValueFromContainer</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
							<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JEntry</name>	   <modifier>*</modifier></type><name>children</name> <init>= <expr><name><name>container</name><operator>-&gt;</operator><name>children</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><call><name>JsonContainerSize</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>JB_FARRAY</name> <operator>|</operator> <name>JB_FOBJECT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick out without a palloc cycle if object/array is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>JB_FARRAY</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>JsonContainerIsArray</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base_addr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>children</name> <operator>+</operator> <name>count</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>base_addr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>result</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>equalsJsonbScalarValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>JBE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>JB_FOBJECT</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>JsonContainerIsObject</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Object key passed by caller must be a string */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>getKeyJsonValueFromContainer</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
											<argument><expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Not found */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find value by key in Jsonb object and fetch it into 'res', which is also
 * returned.
 *
 * 'res' can be passed in as NULL, in which case it's newly palloc'ed here.
 */</comment>
<function><type><name>JsonbValue</name> <modifier>*</modifier></type>
<name>getKeyJsonValueFromContainer</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keyLen</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JEntry</name>	   <modifier>*</modifier></type><name>children</name> <init>= <expr><name><name>container</name><operator>-&gt;</operator><name>children</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><call><name>JsonContainerSize</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>baseAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>stopLow</name></decl>,
				<decl><type ref="prev"/><name>stopHigh</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>JsonContainerIsObject</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick out without a palloc cycle if object is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Binary search the container. Since we know this is an object, account
	 * for *Pairs* of Jentrys
	 */</comment>
	<expr_stmt><expr><name>baseAddr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>children</name> <operator>+</operator> <name>count</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>stopLow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>stopHigh</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>stopLow</name> <operator>&lt;</operator> <name>stopHigh</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>stopMiddle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>difference</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>candidateVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>candidateLen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stopMiddle</name> <operator>=</operator> <name>stopLow</name> <operator>+</operator> <operator>(</operator><name>stopHigh</name> <operator>-</operator> <name>stopLow</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>candidateVal</name> <operator>=</operator> <name>baseAddr</name> <operator>+</operator> <call><name>getJsonbOffset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>stopMiddle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>candidateLen</name> <operator>=</operator> <call><name>getJsonbLength</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>stopMiddle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>lengthCompareJsonbString</name><argument_list>(<argument><expr><name>candidateVal</name></expr></argument>, <argument><expr><name>candidateLen</name></expr></argument>,
											  <argument><expr><name>keyVal</name></expr></argument>, <argument><expr><name>keyLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found our key, return corresponding value */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>index</name> <init>= <expr><name>stopMiddle</name> <operator>+</operator> <name>count</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>baseAddr</name></expr></argument>,
						   <argument><expr><call><name>getJsonbOffset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stopLow</name> <operator>=</operator> <name>stopMiddle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stopHigh</name> <operator>=</operator> <name>stopMiddle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Not found */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get i-th value of a Jsonb array.
 *
 * Returns palloc()'d copy of the value, or NULL if it does not exist.
 */</comment>
<function><type><name>JsonbValue</name> <modifier>*</modifier></type>
<name>getIthJsonbValueFromContainer</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base_addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nelements</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JsonContainerIsArray</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not a jsonb array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nelements</name> <operator>=</operator> <call><name>JsonContainerSize</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>base_addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>container</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>nelements</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>base_addr</name></expr></argument>,
				   <argument><expr><call><name>getJsonbOffset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A helper function to fill in a JsonbValue to represent an element of an
 * array, or a key or value of an object.
 *
 * The node's JEntry is at container-&gt;children[index], and its variable-length
 * data is at base_addr + offset.  We make the caller determine the offset
 * since in many cases the caller can amortize that work across multiple
 * children.  When it can't, it can just call getJsonbOffset().
 *
 * A nested array or object will be returned as jbvBinary, ie. it won't be
 * expanded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fillJsonbValue</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
			   <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JEntry</name></type>		<name>entry</name> <init>= <expr><name><name>container</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JBE_ISNULL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvNull</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>JBE_ISSTRING</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvString</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>base_addr</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>getJsonbLength</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>JBE_ISNUMERIC</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvNumeric</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <operator>(</operator><name>base_addr</name> <operator>+</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>JBE_ISBOOL_TRUE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvBool</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>JBE_ISBOOL_FALSE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvBool</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>JBE_ISCONTAINER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvBinary</name></expr>;</expr_stmt>
		<comment type="block">/* Remove alignment padding from data pointer and length */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>JsonbContainer</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>base_addr</name> <operator>+</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>getJsonbLength</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<operator>(</operator><call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push JsonbValue into JsonbParseState.
 *
 * Used when parsing JSON tokens to form Jsonb, or when converting an in-memory
 * JsonbValue to a Jsonb.
 *
 * Initial state of *JsonbParseState is NULL, since it'll be allocated here
 * originally (caller will get JsonbParseState back by reference).
 *
 * Only sequential tokens pertaining to non-container types should pass a
 * JsonbValue.  There is one exception -- WJB_BEGIN_ARRAY callers may pass a
 * "raw scalar" pseudo array to append it - the actual scalar should be passed
 * next and it will be added as the only member of the array.
 *
 * Values of type jbvBinary, which are rolled up arrays and objects,
 * are unpacked before being added to the result.
 */</comment>
<function><type><name>JsonbValue</name> <modifier>*</modifier></type>
<name>pushJsonbValue</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbIteratorToken</name></type> <name>seq</name></decl></parameter>,
			   <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>tok</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>jbval</name> <operator>||</operator> <operator>(</operator><name>seq</name> <operator>!=</operator> <name>WJB_ELEM</name> <operator>&amp;&amp;</operator> <name>seq</name> <operator>!=</operator> <name>WJB_VALUE</name><operator>)</operator> <operator>||</operator>
		<name><name>jbval</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* drop through */</comment>
		<return>return <expr><call><name>pushJsonbValueScalar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>jbval</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* unpack the binary and add each piece to the pstate */</comment>
	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name><name>jbval</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tok</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValueScalar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name>tok</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do the actual pushing, with only scalar or pseudo-scalar-array values
 * accepted.
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type>
<name>pushJsonbValueScalar</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbIteratorToken</name></type> <name>seq</name></decl></parameter>,
					 <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>seq</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WJB_BEGIN_ARRAY</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalarVal</name> <operator>||</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <call><name>pushState</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>contVal</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>type</name></name></name> <operator>=</operator> <name>jbvArray</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name></name> <operator>=</operator> <operator>(</operator><name>scalarVal</name> <operator>&amp;&amp;</operator>
													  <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>scalarVal</name> <operator>&amp;&amp;</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Assume that this array is still really a scalar */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														<name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_BEGIN_OBJECT</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalarVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <call><name>pushState</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>contVal</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>type</name></name></name> <operator>=</operator> <name>jbvObject</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbPair</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_KEY</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendKey</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalarVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_VALUE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>scalarVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendValue</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalarVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_ELEM</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>scalarVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendElement</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalarVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_END_OBJECT</name></expr>:</case>
			<expr_stmt><expr><call><name>uniqueifyJsonbObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>contVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* fall through! */</comment>
		<case>case <expr><name>WJB_END_ARRAY</name></expr>:</case>
			<comment type="block">/* Steps here common to WJB_END_OBJECT case */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalarVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>contVal</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Pop stack and push current array/object as value in parent
			 * array/object
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pstate</name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>contVal</name><operator>.</operator><name>type</name></name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>jbvArray</name></expr>:</case>
						<expr_stmt><expr><call><name>appendElement</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>jbvObject</name></expr>:</case>
						<expr_stmt><expr><call><name>appendValue</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb container type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized jsonb sequential processing token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pushJsonbValue() worker:  Iteration-like forming of Jsonb
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbParseState</name> <modifier>*</modifier></type>
<name>pushState</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbParseState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>pstate</name></expr>;</expr_stmt>
	<return>return <expr><name>ns</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pushJsonbValue() worker:  Append a pair key to state when generating a Jsonb
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendKey</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>contVal</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>string</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>&gt;=</operator> <name>JSONB_MAX_PAIRS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of jsonb object pairs exceeds the maximum allowed (%zu)"</literal></expr></argument>,
						<argument><expr><name>JSONB_MAX_PAIRS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>&gt;=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></argument>,
											<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbPair</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <operator>*</operator><name>string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pushJsonbValue() worker:  Append a pair value to state when generating a
 * Jsonb
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendValue</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>contVal</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>*</operator><name>scalarVal</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pushJsonbValue() worker:  Append an element to state when generating a Jsonb
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendElement</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>contVal</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>&gt;=</operator> <name>JSONB_MAX_ELEMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of jsonb array elements exceeds the maximum allowed (%zu)"</literal></expr></argument>,
						<argument><expr><name>JSONB_MAX_ELEMS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>&gt;=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name></expr></argument>,
										  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>scalarVal</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a JsonbContainer, expand to JsonbIterator to iterate over items
 * fully expanded to in-memory representation for manipulation.
 *
 * See JsonbIteratorNext() for notes on memory management.
 */</comment>
<function><type><name>JsonbIterator</name> <modifier>*</modifier></type>
<name>JsonbIteratorInit</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>iteratorFromContainer</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get next JsonbValue while iterating
 *
 * Caller should initially pass their own, original iterator.  They may get
 * back a child iterator palloc()'d here instead.  The function can be relied
 * on to free those child iterators, lest the memory allocated for highly
 * nested objects become unreasonable, but only if callers don't end iteration
 * early (by breaking upon having found something in a search, for example).
 *
 * Callers in such a scenario, that are particularly sensitive to leaking
 * memory in a long-lived context may walk the ancestral tree from the final
 * iterator we left them with to its oldest ancestor, pfree()ing as they go.
 * They do not have to free any other memory previously allocated for iterators
 * but not accessible as direct ancestors of the iterator they're last passed
 * back.
 *
 * Returns "Jsonb sequential processing" token value.  Iterator "state"
 * reflects the current stage of the process in a less granular fashion, and is
 * mostly used here to track things internally with respect to particular
 * iterators.
 *
 * Clients of this function should not have to handle any jbvBinary values
 * (since recursive calls will deal with this), provided skipNested is false.
 * It is our job to expand the jbvBinary representation without bothering them
 * with it.  However, clients should not take it upon themselves to touch array
 * or Object element/pair buffers, since their element/pair pointers are
 * garbage.  Also, *val will not be set when returning WJB_END_ARRAY or
 * WJB_END_OBJECT, on the assumption that it's only useful to access values
 * when recursing in.
 */</comment>
<function><type><name>JsonbIteratorToken</name></type>
<name>JsonbIteratorNext</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipNested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>it</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WJB_DONE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When stepping into a nested container, we jump back here to start
	 * processing the child. We will not recurse further in one call, because
	 * processing the child will always begin in JBI_ARRAY_START or
	 * JBI_OBJECT_START state.
	 */</comment>
<label><name>recurse</name>:</label>
	<switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JBI_ARRAY_START</name></expr>:</case>
			<comment type="block">/* Set v to array on first array call */</comment>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvArray</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * v-&gt;val.array.elems is not actually set, because we aren't doing
			 * a full conversion
			 */</comment>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>isScalar</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curValueOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* not actually used */</comment>
			<comment type="block">/* Set state for next call */</comment>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_ARRAY_ELEM</name></expr>;</expr_stmt>
			<return>return <expr><name>WJB_BEGIN_ARRAY</name></expr>;</return>

		<case>case <expr><name>JBI_ARRAY_ELEM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>&gt;=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * All elements within array already processed.  Report this
				 * to caller, and give it back original parent iterator (which
				 * independently tracks iteration progress at its level of
				 * nesting).
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>freeAndGetParent</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>WJB_END_ARRAY</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name></expr></argument>,
						   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>dataProper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name></expr></argument>,
						   <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>JBE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>skipNested</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Recurse into container. */</comment>
				<expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>iteratorFromContainer</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>recurse</name>;</goto>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Scalar item in array, or a container and caller didn't want
				 * us to recurse into it.
				 */</comment>
				<return>return <expr><name>WJB_ELEM</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

		<case>case <expr><name>JBI_OBJECT_START</name></expr>:</case>
			<comment type="block">/* Set v to object on first object call */</comment>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>jbvObject</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * v-&gt;val.object.pairs is not actually set, because we aren't
			 * doing a full conversion
			 */</comment>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curValueOffset</name></name> <operator>=</operator> <call><name>getJsonbOffset</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
												   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set state for next call */</comment>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_OBJECT_KEY</name></expr>;</expr_stmt>
			<return>return <expr><name>WJB_BEGIN_OBJECT</name></expr>;</return>

		<case>case <expr><name>JBI_OBJECT_KEY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>&gt;=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * All pairs within object already processed.  Report this to
				 * caller, and give it back original containing iterator
				 * (which independently tracks iteration progress at its level
				 * of nesting).
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>freeAndGetParent</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>WJB_END_OBJECT</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Return key of a key/value pair.  */</comment>
				<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>dataProper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name></expr></argument>,
							   <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jbvString</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected jsonb type as object key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Set state for next call */</comment>
				<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_OBJECT_VALUE</name></expr>;</expr_stmt>
				<return>return <expr><name>WJB_KEY</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

		<case>case <expr><name>JBI_OBJECT_VALUE</name></expr>:</case>
			<comment type="block">/* Set state for next call */</comment>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_OBJECT_KEY</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>fillJsonbValue</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>+</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr></argument>,
						   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>dataProper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curValueOffset</name></name></expr></argument>,
						   <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>JBE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curDataOffset</name></name></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>JBE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curValueOffset</name></name></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name> <operator>+</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>nElems</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curIndex</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Value may be a container, in which case we recurse with new,
			 * child iterator (unless the caller asked not to, by passing
			 * skipNested).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>skipNested</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>iteratorFromContainer</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>recurse</name>;</goto>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>WJB_VALUE</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid iterator state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize an iterator for iterating all elements in a container.
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbIterator</name> <modifier>*</modifier></type>
<name>iteratorFromContainer</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbIterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>container</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>nElems</name></name> <operator>=</operator> <call><name>JsonContainerSize</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Array starts just after header */</comment>
	<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name><name>container</name><operator>-&gt;</operator><name>children</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>container</name><operator>-&gt;</operator><name>header</name></name> <operator>&amp;</operator> <operator>(</operator><name>JB_FARRAY</name> <operator>|</operator> <name>JB_FOBJECT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JB_FARRAY</name></expr>:</case>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>dataProper</name></name> <operator>=</operator>
				<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>+</operator> <name><name>it</name><operator>-&gt;</operator><name>nElems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>isScalar</name></name> <operator>=</operator> <call><name>JsonContainerIsScalar</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This is either a "raw scalar", or an array */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>isScalar</name></name> <operator>||</operator> <name><name>it</name><operator>-&gt;</operator><name>nElems</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_ARRAY_START</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JB_FOBJECT</name></expr>:</case>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>dataProper</name></name> <operator>=</operator>
				<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>+</operator> <name><name>it</name><operator>-&gt;</operator><name>nElems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>JBI_OBJECT_START</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown type of jsonb container"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * JsonbIteratorNext() worker:	Return parent, while freeing memory for current
 * iterator
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbIterator</name> <modifier>*</modifier></type>
<name>freeAndGetParent</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Worker for "contains" operator's function
 *
 * Formally speaking, containment is top-down, unordered subtree isomorphism.
 *
 * Takes iterators that belong to some container type.  These iterators
 * "belong" to those values in the sense that they've just been initialized in
 * respect of them by the caller (perhaps in a nested fashion).
 *
 * "val" is lhs Jsonb, and mContained is rhs Jsonb when called from top level.
 * We determine if mContained is contained within val.
 */</comment>
<function><type><name>bool</name></type>
<name>JsonbDeepContains</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>mContained</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>vval</name></decl>,
				<decl><type ref="prev"/><name>vcontained</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>rval</name></decl>,
				<decl><type ref="prev"/><name>rcont</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Guard against stack overflow due to overly complex Jsonb.
	 *
	 * Functions called here independently take this precaution, but that
	 * might not be sufficient since this is also a recursive function.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>mContained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <name>rcont</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The differing return values can immediately be taken as indicating
		 * two differing container types at this nesting level, which is
		 * sufficient reason to give up entirely (but it should be the case
		 * that they're both some container type).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rval</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name> <operator>||</operator> <name>rval</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name> <operator>||</operator> <name>rcont</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the lhs has fewer pairs than the rhs, it can't possibly contain
		 * the rhs.  (This conclusion is safe only because we de-duplicate
		 * keys in all Jsonb objects; thus there can be no corresponding
		 * optimization in the array case.)  The case probably won't arise
		 * often, but since it's such a cheap check we may as well make it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>&lt;</operator> <name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Work through rhs "is it contained within?" object */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>lhsVal</name></decl>;</decl_stmt> <comment type="block">/* lhsVal is from pair in lhs object */</comment>
			<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>lhsValBuf</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>mContained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * When we get through caller's rhs "is it contained within?"
			 * object without failing to find one of its values, it's
			 * contained.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WJB_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WJB_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* First, find value by key... */</comment>
			<expr_stmt><expr><name>lhsVal</name> <operator>=</operator>
				<call><name>getKeyJsonValueFromContainer</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>val</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
											 <argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
											 <argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>lhsValBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lhsVal</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * ...at this stage it is apparent that there is at least a key
			 * match for this rhs pair.
			 */</comment>
			<expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>mContained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WJB_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Compare rhs pair's value with lhs pair's value just found using
			 * key
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lhsVal</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>vcontained</name><operator>.</operator><name>type</name></name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>lhsVal</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equalsJsonbScalarValue</name><argument_list>(<argument><expr><name>lhsVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Nested container value (object or array) */</comment>
				<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>nestval</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>nestContained</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lhsVal</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>nestval</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name><name>lhsVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nestContained</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Match "value" side of rhs datum object's pair recursively.
				 * It's a nested structure.
				 *
				 * Note that nesting still has to "match up" at the right
				 * nesting sub-levels.  However, there need only be zero or
				 * more matching pairs (or elements) at each nesting level
				 * (provided the *rhs* pairs/elements *all* match on each
				 * level), which enables searching nested structures for a
				 * single String or other primitive type sub-datum quite
				 * effectively (provided the user constructed the rhs nested
				 * structure such that we "know where to look").
				 *
				 * In other words, the mapping of container nodes in the rhs
				 * "vcontained" Jsonb to internal nodes on the lhs is
				 * injective, and parent-child edges on the rhs must be mapped
				 * to parent-child edges on the lhs to satisfy the condition
				 * of containment (plus of course the mapped nodes must be
				 * equal).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JsonbDeepContains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nestval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nestContained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>lhsConts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>nLhsElems</name> <init>= <expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Handle distinction between "raw scalar" pseudo arrays, and real
		 * arrays.
		 *
		 * A raw scalar may contain another raw scalar, and an array may
		 * contain a raw scalar, but a raw scalar may not contain an array. We
		 * don't do something like this for the object case, since objects can
		 * only contain pairs, never raw scalars (a pair is represented by an
		 * rhs object argument with a single contained pair).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Work through rhs "is it contained within?" array */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>mContained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * When we get through caller's rhs "is it contained within?"
			 * array without failing to find one of its values, it's
			 * contained.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WJB_END_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WJB_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>findJsonbValueFromContainer</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>val</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
												 <argument><expr><name>JB_FARRAY</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If this is first container found in rhs array (at this
				 * depth), initialize temp lhs array of containers
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>lhsConts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Make room for all possible values */</comment>
					<expr_stmt><expr><name>lhsConts</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nLhsElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLhsElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<comment type="block">/* Store all lhs elements in temp array */</comment>
						<expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WJB_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>lhsConts</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></for>

					<comment type="block">/* No container elements in temp array, so give up now */</comment>
					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* We may have only partially filled array */</comment>
					<expr_stmt><expr><name>nLhsElems</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* XXX: Nested array containment is O(N^2) */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLhsElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* Nested container value (object or array) */</comment>
					<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>nestval</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>nestContained</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>contains</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>nestval</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name><name>lhsConts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nestContained</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>contains</name> <operator>=</operator> <call><name>JsonbDeepContains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nestval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nestContained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>nestval</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nestval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>nestContained</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nestContained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>contains</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Report rhs container value is not contained if couldn't
				 * match rhs container to *some* lhs cont
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nLhsElems</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb container type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpectedly fell off end of jsonb container"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash a JsonbValue scalar value, mixing the hash value into an existing
 * hash provided by the caller.
 *
 * Some callers may wish to independently XOR in JB_FOBJECT and JB_FARRAY
 * flags.
 */</comment>
<function><type><name>void</name></type>
<name>JsonbHashScalarValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/* Compute hash value for scalarVal */</comment>
	<switch>switch <condition>(<expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>jbvNull</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvString</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
										  <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvNumeric</name></expr>:</case>
			<comment type="block">/* Must hash equal numerics to equal hash codes */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hash_numeric</name></expr></argument>,
													 <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvBool</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="number">0x02</literal></expr> </then><else>: <expr><literal type="number">0x04</literal></expr></else></ternary></expr>;</expr_stmt>

			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Combine hash values of successive keys, values and elements by rotating
	 * the previous value left 1 bit, then XOR'ing in the new
	 * key/value/element's hash value.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>hash</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hash</name> <operator>^=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hash a value to a 64-bit value, with a seed. Otherwise, similar to
 * JsonbHashScalarValue.
 */</comment>
<function><type><name>void</name></type>
<name>JsonbHashScalarValueExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name></type> <name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>tmp</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>jbvNull</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>seed</name> <operator>+</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvString</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
												   <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
												   <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvNumeric</name></expr>:</case>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>hash_numeric_extended</name></expr></argument>,
													 <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>jbvBool</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>seed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>hashcharextended</name></expr></argument>,
														 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="number">0x02</literal></expr> </then><else>: <expr><literal type="number">0x04</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>hash</name> <operator>=</operator> <call><name>ROTATE_HIGH_AND_LOW_32BITS</name><argument_list>(<argument><expr><operator>*</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hash</name> <operator>^=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Are two scalar JsonbValues of the same type a and b equal?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>equalsJsonbScalarValue</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>aScalar</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>bScalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>bScalar</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvNull</name></expr>:</case>
				<return>return <expr><name>true</name></expr>;</return>
			<case>case <expr><name>jbvString</name></expr>:</case>
				<return>return <expr><call><name>lengthCompareJsonbStringValue</name><argument_list>(<argument><expr><name>aScalar</name></expr></argument>, <argument><expr><name>bScalar</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
			<case>case <expr><name>jbvNumeric</name></expr>:</case>
				<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_eq</name></expr></argument>,
														<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>jbvBool</name></expr>:</case>
				<return>return <expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>==</operator> <name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"jsonb scalar type mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two scalar JsonbValues, returning -1, 0, or 1.
 *
 * Strings are compared using the default collation.  Used by B-tree
 * operators, where a lexical sort order is generally expected.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compareJsonbScalarValue</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>aScalar</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>bScalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>bScalar</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvNull</name></expr>:</case>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			<case>case <expr><name>jbvString</name></expr>:</case>
				<return>return <expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
								  <argument><expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
								  <argument><expr><name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
								  <argument><expr><name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
								  <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>jbvNumeric</name></expr>:</case>
				<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_cmp</name></expr></argument>,
														 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>jbvBool</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>==</operator> <name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>aScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>&gt;</operator> <name><name>bScalar</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"jsonb scalar type mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for manipulating the resizable buffer used by convertJsonb and
 * its subroutines.
 */</comment>

<comment type="block">/*
 * Reserve 'len' bytes, at the end of the buffer, enlarging it if necessary.
 * Returns the offset to the reserved area. The caller is expected to fill
 * the reserved area later with copyToBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>reserveFromBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>

	<comment type="block">/* Make more room if needed */</comment>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remember current offset */</comment>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* reserve the space */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep a trailing null in place, even though it's not useful for us; it
	 * seems best to preserve the invariants of StringInfos.
	 */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy 'len' bytes to a previously reserved area in buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copyToBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A shorthand for reserveFromBuffer + copyToBuffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendToBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>reserveFromBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Append padding, so that the length of the StringInfo is int-aligned.
 * Returns the number of padding bytes appended.
 */</comment>
<function><type><specifier>static</specifier> <name>short</name></type>
<name>padBufferToInt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>,
				<decl><type ref="prev"/><name>p</name></decl>,
				<decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>reserveFromBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>padlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* padlen must be small, so this is probably faster than a memset */</comment>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>padlen</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>offset</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>padlen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a JsonbValue, convert to Jsonb. The result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>convertToJsonb</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JEntry</name></type>		<name>jentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Should not already have binary representation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate an output buffer. It will be enlarged as needed */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make room for the varlena header */</comment>
	<expr_stmt><expr><call><name>reserveFromBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>convertJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jentry</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: the JEntry of the root is discarded. Therefore the root
	 * JsonbContainer struct must contain enough information to tell what kind
	 * of value it is.
	 */</comment>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Jsonb</name> <operator>*</operator><operator>)</operator> <name><name>buffer</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of convertJsonb: serialize a single JsonbValue into buffer.
 *
 * The JEntry header for this node is returned in *header.  It is filled in
 * with the length of this value and appropriate type bits.  If we wish to
 * store an end offset rather than a length, it is the caller's responsibility
 * to adjust for that.
 *
 * If the value is an array or an object, this recurses. 'level' is only used
 * for debugging purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convertJsonbValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A JsonbValue passed as val should never have a type of jbvBinary, and
	 * neither should any of its sub-components. Those values will be produced
	 * by convertJsonbArray and convertJsonbObject, the results of which will
	 * not be passed back to this function as an argument.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>convertJsonbScalar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>convertJsonbArray</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>convertJsonbObject</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown type of jsonb container to convert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convertJsonbArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jentry_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nElems</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Remember where in the buffer this array starts. */</comment>
	<expr_stmt><expr><name>base_offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Align to 4-byte boundary (any padding counts as part of my data) */</comment>
	<expr_stmt><expr><call><name>padBufferToInt</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct the header Jentry and store it in the beginning of the
	 * variable-length payload.
	 */</comment>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <name>nElems</name> <operator>|</operator> <name>JB_FARRAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nElems</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>header</name> <operator>|=</operator> <name>JB_FSCALAR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reserve space for the JEntries of the elements. */</comment>
	<expr_stmt><expr><name>jentry_offset</name> <operator>=</operator> <call><name>reserveFromBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JEntry</name></type>		<name>meta</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Convert element, producing a JEntry and appending its
		 * variable-length data to buffer
		 */</comment>
		<expr_stmt><expr><call><name>convertJsonbValue</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Bail out if total variable-length data exceeds what will fit in a
		 * JEntry length field.  We check this in each iteration, not just
		 * once at the end, to forestall possible integer overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>JENTRY_OFFLENMASK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total size of jsonb array elements exceeds the maximum of %u bytes"</literal></expr></argument>,
							<argument><expr><name>JENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Convert each JB_OFFSET_STRIDE'th length to an offset.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>%</operator> <name>JB_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>JENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>JENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>copyToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>jentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Total data size is everything we've appended to buffer */</comment>
	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>base_offset</name></expr>;</expr_stmt>

	<comment type="block">/* Check length again, since we didn't include the metadata above */</comment>
	<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>JENTRY_OFFLENMASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total size of jsonb array elements exceeds the maximum of %u bytes"</literal></expr></argument>,
						<argument><expr><name>JENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the header of this node in the container's JEntry array */</comment>
	<expr_stmt><expr><operator>*</operator><name>pheader</name> <operator>=</operator> <name>JENTRY_ISCONTAINER</name> <operator>|</operator> <name>totallen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convertJsonbObject</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jentry_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nPairs</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Remember where in the buffer this object starts. */</comment>
	<expr_stmt><expr><name>base_offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Align to 4-byte boundary (any padding counts as part of my data) */</comment>
	<expr_stmt><expr><call><name>padBufferToInt</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct the header Jentry and store it in the beginning of the
	 * variable-length payload.
	 */</comment>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <name>nPairs</name> <operator>|</operator> <name>JB_FOBJECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reserve space for the JEntries of the keys and values. */</comment>
	<expr_stmt><expr><name>jentry_offset</name> <operator>=</operator> <call><name>reserveFromBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nPairs</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate over the keys, then over the values, since that is the ordering
	 * we want in the on-disk representation.
	 */</comment>
	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nPairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbPair</name>  <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JEntry</name></type>		<name>meta</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Convert key, producing a JEntry and appending its variable-length
		 * data to buffer
		 */</comment>
		<expr_stmt><expr><call><name>convertJsonbScalar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Bail out if total variable-length data exceeds what will fit in a
		 * JEntry length field.  We check this in each iteration, not just
		 * once at the end, to forestall possible integer overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>JENTRY_OFFLENMASK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total size of jsonb object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
							<argument><expr><name>JENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Convert each JB_OFFSET_STRIDE'th length to an offset.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>%</operator> <name>JB_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>JENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>JENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>copyToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>jentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nPairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbPair</name>  <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JEntry</name></type>		<name>meta</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Convert value, producing a JEntry and appending its variable-length
		 * data to buffer
		 */</comment>
		<expr_stmt><expr><call><name>convertJsonbValue</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pair</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>JBE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Bail out if total variable-length data exceeds what will fit in a
		 * JEntry length field.  We check this in each iteration, not just
		 * once at the end, to forestall possible integer overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>JENTRY_OFFLENMASK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total size of jsonb object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
							<argument><expr><name>JENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Convert each JB_OFFSET_STRIDE'th length to an offset.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <name>nPairs</name><operator>)</operator> <operator>%</operator> <name>JB_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>JENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>JENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>copyToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>jentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Total data size is everything we've appended to buffer */</comment>
	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>base_offset</name></expr>;</expr_stmt>

	<comment type="block">/* Check length again, since we didn't include the metadata above */</comment>
	<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>JENTRY_OFFLENMASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total size of jsonb object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
						<argument><expr><name>JENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the header of this node in the container's JEntry array */</comment>
	<expr_stmt><expr><operator>*</operator><name>pheader</name> <operator>=</operator> <name>JENTRY_ISCONTAINER</name> <operator>|</operator> <name>totallen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convertJsonbScalar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>JEntry</name> <modifier>*</modifier></type><name>jentry</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name></type>		<name>padlen</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>jbvNull</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>jentry</name> <operator>=</operator> <name>JENTRY_ISNULL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>jbvString</name></expr>:</case>
			<expr_stmt><expr><call><name>appendToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>jentry</name> <operator>=</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>jbvNumeric</name></expr>:</case>
			<expr_stmt><expr><name>numlen</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>padBufferToInt</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>, <argument><expr><name>numlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>jentry</name> <operator>=</operator> <name>JENTRY_ISNUMERIC</name> <operator>|</operator> <operator>(</operator><name>padlen</name> <operator>+</operator> <name>numlen</name><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>jbvBool</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>jentry</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name><operator>)</operator></expr> ?</condition><then>
				<expr><name>JENTRY_ISBOOL_TRUE</name></expr> </then><else>: <expr><name>JENTRY_ISBOOL_FALSE</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>jbvDatetime</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JsonEncodeDateTime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
								   <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>datetime</name><operator>.</operator><name>value</name></name></expr></argument>,
								   <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>datetime</name><operator>.</operator><name>typid</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>datetime</name><operator>.</operator><name>tz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendToBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>jentry</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid jsonb scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two jbvString JsonbValue values, a and b.
 *
 * This is a special qsort() comparator used to sort strings in certain
 * internal contexts where it is sufficient to have a well-defined sort order.
 * In particular, object pair keys are sorted according to this criteria to
 * facilitate cheap binary searches where we don't care about lexical sort
 * order.
 *
 * a and b are first sorted based on their length.  If a tie-breaker is
 * required, only then do we consider string binary equality.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lengthCompareJsonbStringValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>va</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>JsonbValue</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>vb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>JsonbValue</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vb</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>lengthCompareJsonbString</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
									<argument><expr><name><name>vb</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>vb</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for lengthCompareJsonbStringValue
 *
 * This is also useful separately to implement binary search on
 * JsonbContainers.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lengthCompareJsonbString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg() comparator to compare JsonbPair values.
 *
 * Third argument 'binequal' may point to a bool. If it's set, *binequal is set
 * to true iff a and b have full binary equality, since some callers have an
 * interest in whether the two values are equal or merely equivalent.
 *
 * N.B: String comparisons here are "length-wise"
 *
 * Pairs with equals keys are ordered such that the order field is respected.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lengthCompareJsonbPair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>binequal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>JsonbPair</name> <modifier>*</modifier></type><name>pa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>JsonbPair</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>JsonbPair</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>JsonbPair</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lengthCompareJsonbStringValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pa</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pb</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>binequal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>binequal</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Guarantee keeping order of equal pair.  Unique algorithm will prefer
	 * first element as value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pa</name><operator>-&gt;</operator><name>order</name></name> <operator>&gt;</operator> <name><name>pb</name><operator>-&gt;</operator><name>order</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort and unique-ify pairs in JsonbValue object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>uniqueifyJsonbObject</name><parameter_list>(<parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasNonUniq</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbPair</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>lengthCompareJsonbPair</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasNonUniq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasNonUniq</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbPair</name>  <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>ptr</name> <operator>-</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>&lt;</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Avoid copying over duplicate */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>lengthCompareJsonbStringValue</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>res</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name> <operator>=</operator> <name>res</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
