<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/array_selfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * array_selfuncs.c
 *	  Functions for selectivity estimation of array operators
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/array_selfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* Default selectivity constant for "@&gt;" and "&lt;@" operators */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CONTAIN_SEL</name></cpp:macro> <cpp:value>0.005</cpp:value></cpp:define>

<comment type="block">/* Default selectivity constant for "&amp;&amp;" operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_OVERLAP_SEL</name></cpp:macro> <cpp:value>0.01</cpp:value></cpp:define>

<comment type="block">/* Default selectivity for given operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SEL</name><parameter_list>(<parameter><type><name>operator</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((operator) == OID_ARRAY_OVERLAP_OP ? \
		DEFAULT_OVERLAP_SEL : DEFAULT_CONTAIN_SEL)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>calc_arraycontsel</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>mcelem_array_selec</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
									  <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
									  <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
									  <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>mcelem_array_contain_overlap_selec</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
													  <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
													  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
													  <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>mcelem_array_contained_selec</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
												<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
												<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
												<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>,
												<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float</name> <modifier>*</modifier></type><name>calc_hist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float</name> <modifier>*</modifier></type><name>calc_distr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>rest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>floor_log2</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_next_mcelem</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>element_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>float_compare_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * scalararraysel_containment
 *		Estimate selectivity of ScalarArrayOpExpr via array containment.
 *
 * If we have const =/&lt;&gt; ANY/ALL (array_var) then we can estimate the
 * selectivity as though this were an array containment operator,
 * array_var op ARRAY[const].
 *
 * scalararraysel() has already verified that the ScalarArrayOpExpr's operator
 * is the array element type's default equality or inequality operator, and
 * has aggressively simplified both inputs to constants.
 *
 * Returns selectivity (0..1), or -1 if we fail to estimate selectivity.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>scalararraysel_containment</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isEquality</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useOr</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>constval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>cmpfunc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * rightop must be a variable, else punt.
	 */</comment>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vardata</name><operator>.</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * leftop must be a constant, else punt.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* qual can't succeed if null on left */</comment>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>constval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>

	<comment type="block">/* Get element type's default comparison function */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cmpfunc</name> <operator>=</operator> <operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the operator is &lt;&gt;, swap ANY/ALL, then invert the result later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isEquality</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>useOr</name> <operator>=</operator> <operator>!</operator><name>useOr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get array element stats for var, if available */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name><name>cmpfunc</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* MCELEM will be an array of same type as element */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCELEM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* For ALL case, also get histogram of distinct-element counts */</comment>
			<if_stmt><if>if <condition>(<expr><name>useOr</name> <operator>||</operator>
				<operator>!</operator><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
								  <argument><expr><name>STATISTIC_KIND_DECHIST</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hslot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For = ANY, estimate as var @&gt; ARRAY[const].
			 *
			 * For = ALL, estimate as var &lt;@ ARRAY[const].
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contain_overlap_selec</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name></name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>numbers</name></name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
														   <argument><expr><name>OID_ARRAY_CONTAINS_OP</name></expr></argument>,
														   <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contained_selec</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name></name></expr></argument>,
													 <argument><expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
													 <argument><expr><name><name>sslot</name><operator>.</operator><name>numbers</name></name></expr></argument>,
													 <argument><expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><name><name>hslot</name><operator>.</operator><name>numbers</name></name></expr></argument>,
													 <argument><expr><name><name>hslot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>,
													 <argument><expr><name>OID_ARRAY_CONTAINED_OP</name></expr></argument>,
													 <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No most-common-elements info, so do without */</comment>
			<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contain_overlap_selec</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
														   <argument><expr><name>OID_ARRAY_CONTAINS_OP</name></expr></argument>,
														   <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contained_selec</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><name>OID_ARRAY_CONTAINED_OP</name></expr></argument>,
													 <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * MCE stats count only non-null rows, so adjust for null rows.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No stats at all, so do without */</comment>
		<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contain_overlap_selec</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
													   <argument><expr><name>OID_ARRAY_CONTAINS_OP</name></expr></argument>,
													   <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contained_selec</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>constval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name>OID_ARRAY_CONTAINED_OP</name></expr></argument>,
												 <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* we assume no nulls here, so no stanullfrac correction */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the operator is &lt;&gt;, invert the results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isEquality</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * arraycontsel -- restriction selectivity for array @&gt;, &amp;&amp;, &lt;@ operators
 */</comment>
<function><type><name>Datum</name></type>
<name>arraycontsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_typeid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If expression is not (variable op something) or (something op
	 * variable), then punt and return a default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do anything useful if the something is not a constant, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The "&amp;&amp;", "@&gt;" and "&lt;@" operators are strict, so we can cope with a
	 * NULL constant right away.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If var is on the right, commute the operator, so that we can assume the
	 * var is on the left in what follows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varonleft</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINS_OP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>operator</name> <operator>=</operator> <name>OID_ARRAY_CONTAINED_OP</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINED_OP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>operator</name> <operator>=</operator> <name>OID_ARRAY_CONTAINS_OP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, there's a Var and a Const we're dealing with here.  We need the
	 * Const to be an array with same element type as column, else we can't do
	 * anything useful.  (Such cases will likely fail at runtime, but here
	 * we'd rather just return a default estimate.)
	 */</comment>
	<expr_stmt><expr><name>element_typeid</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>element_typeid</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name>element_typeid</name> <operator>==</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>calc_arraycontsel</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>,
								  <argument><expr><name>element_typeid</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * arraycontjoinsel -- join selectivity for array @&gt;, &amp;&amp;, &lt;@ operators
 */</comment>
<function><type><name>Datum</name></type>
<name>arraycontjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* For the moment this is just a stub */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate selectivity for "arraycolumn @&gt; const", "arraycolumn &amp;&amp; const"
 * or "arraycolumn &lt;@ const" based on the statistics
 *
 * This function is mainly responsible for extracting the pg_statistic data
 * to be used; we then pass the problem on to mcelem_array_selec().
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>calc_arraycontsel</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>cmpfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>

	<comment type="block">/* Get element type's default comparison function */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cmpfunc</name> <operator>=</operator> <operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The caller made sure the const is an array with same element type, so
	 * get it now
	 */</comment>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name><name>cmpfunc</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* MCELEM will be an array of same type as column */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCELEM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For "array &lt;@ const" case we also need histogram of distinct
			 * element counts.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>!=</operator> <name>OID_ARRAY_CONTAINED_OP</name> <operator>||</operator>
				<operator>!</operator><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
								  <argument><expr><name>STATISTIC_KIND_DECHIST</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hslot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Use the most-common-elements slot for the array Var. */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_selec</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>,
									   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
									   <argument><expr><name><name>sslot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>,
									   <argument><expr><name><name>hslot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name><name>hslot</name><operator>.</operator><name>nnumbers</name></name></expr></argument>,
									   <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No most-common-elements info, so do without */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_selec</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									   <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * MCE stats count only non-null rows, so adjust for null rows.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No stats at all, so do without */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_selec</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we assume no nulls here, so no stanullfrac correction */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If constant was toasted, release the copy we made */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>constval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Array selectivity estimation based on most common elements statistics
 *
 * This function just deconstructs and sorts the array constant's contents,
 * and then passes the problem on to mcelem_array_contain_overlap_selec or
 * mcelem_array_contained_selec depending on the operator.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>mcelem_array_selec</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
				   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
				   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>null_present</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Prepare constant array data for sorting.  Sorting lets us find unique
	 * elements and efficiently merge with the MCELEM array.
	 */</comment>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>,
					  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
					  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
					  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
					  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collapse out any null elements */</comment>
	<expr_stmt><expr><name>nonnull_nitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>null_present</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>null_present</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elem_values</name><index>[<expr><name>nonnull_nitems</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Query "column @&gt; '{anything, null}'" matches nothing.  For the other
	 * two operators, presence of a null in the constant can be ignored.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>null_present</name> <operator>&amp;&amp;</operator> <name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINS_OP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sort extracted elements using their default comparison function. */</comment>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>nonnull_nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>element_compare</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Separate cases according to operator */</comment>
	<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINS_OP</name> <operator>||</operator> <name>operator</name> <operator>==</operator> <name>OID_ARRAY_OVERLAP_OP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contain_overlap_selec</name><argument_list>(<argument><expr><name>mcelem</name></expr></argument>, <argument><expr><name>nmcelem</name></expr></argument>,
												   <argument><expr><name>numbers</name></expr></argument>, <argument><expr><name>nnumbers</name></expr></argument>,
												   <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>nonnull_nitems</name></expr></argument>,
												   <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINED_OP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>mcelem_array_contained_selec</name><argument_list>(<argument><expr><name>mcelem</name></expr></argument>, <argument><expr><name>nmcelem</name></expr></argument>,
											 <argument><expr><name>numbers</name></expr></argument>, <argument><expr><name>nnumbers</name></expr></argument>,
											 <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>nonnull_nitems</name></expr></argument>,
											 <argument><expr><name>hist</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>,
											 <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"arraycontsel called for unrecognized operator %u"</literal></expr></argument>,
			 <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate selectivity of "column @&gt; const" and "column &amp;&amp; const" based on
 * most common element statistics.  This estimation assumes element
 * occurrences are independent.
 *
 * mcelem (of length nmcelem) and numbers (of length nnumbers) are from
 * the array column's MCELEM statistics slot, or are NULL/0 if stats are
 * not available.  array_data (of length nitems) is the constant's elements.
 *
 * Both the mcelem and array_data arrays are assumed presorted according
 * to the element type's cmpfunc.  Null elements are not present.
 *
 * TODO: this estimate probably could be improved by using the distinct
 * elements count histogram.  For example, excepting the special case of
 * "column @&gt; '{}'", we can multiply the calculated selectivity by the
 * fraction of nonempty arrays in the column.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>mcelem_array_contain_overlap_selec</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
								   <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
								   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>,
				<decl><type ref="prev"/><name>elem_selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mcelem_index</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_bsearch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>minfreq</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There should be three more Numbers than Values, because the last three
	 * cells should hold minimal and maximal frequency among the non-null
	 * elements, and then the frequency of null elements.  Ignore the Numbers
	 * if not right.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nnumbers</name> <operator>!=</operator> <name>nmcelem</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numbers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nnumbers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numbers</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Grab the lowest observed frequency */</comment>
		<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name><name>numbers</name><index>[<expr><name>nmcelem</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Without statistics make some default assumptions */</comment>
		<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>DEFAULT_CONTAIN_SEL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Decide whether it is faster to use binary search or not. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>*</operator> <call><name>floor_log2</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>nmcelem</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nmcelem</name> <operator>+</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_bsearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_bsearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINS_OP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initial selectivity for "column @&gt; const" query is 1.0, and it will
		 * be decreased with each element of constant array.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Initial selectivity for "column &amp;&amp; const" query is 0.0, and it will
		 * be increased with each element of constant array.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Scan mcelem and array in parallel. */</comment>
	<expr_stmt><expr><name>mcelem_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore any duplicates in the array data. */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Find the smallest MCELEM &gt;= this array item. */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_bsearch</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>find_next_mcelem</name><argument_list>(<argument><expr><name>mcelem</name></expr></argument>, <argument><expr><name>nmcelem</name></expr></argument>, <argument><expr><name><name>array_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>mcelem_index</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<while>while <condition>(<expr><name>mcelem_index</name> <operator>&lt;</operator> <name>nmcelem</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcelem</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												  <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>mcelem_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* mcelem is found */</comment>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>match</name> <operator>&amp;&amp;</operator> <name>numbers</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* MCELEM matches the array item; use its frequency. */</comment>
			<expr_stmt><expr><name>elem_selec</name> <operator>=</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcelem_index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The element is not in MCELEM.  Punt, but assume that the
			 * selectivity cannot be more than minfreq / 2.
			 */</comment>
			<expr_stmt><expr><name>elem_selec</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>DEFAULT_CONTAIN_SEL</name></expr></argument>, <argument><expr><name>minfreq</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Update overall selectivity using the current element's selectivity
		 * and an assumption of element occurrence independence.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_ARRAY_CONTAINS_OP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>*=</operator> <name>elem_selec</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>selec</name> <operator>+</operator> <name>elem_selec</name> <operator>-</operator> <name>selec</name> <operator>*</operator> <name>elem_selec</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Clamp intermediate results to stay sane despite roundoff error */</comment>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate selectivity of "column &lt;@ const" based on most common element
 * statistics.
 *
 * mcelem (of length nmcelem) and numbers (of length nnumbers) are from
 * the array column's MCELEM statistics slot, or are NULL/0 if stats are
 * not available.  array_data (of length nitems) is the constant's elements.
 * hist (of length nhist) is from the array column's DECHIST statistics slot,
 * or is NULL/0 if those stats are not available.
 *
 * Both the mcelem and array_data arrays are assumed presorted according
 * to the element type's cmpfunc.  Null elements are not present.
 *
 * Independent element occurrence would imply a particular distribution of
 * distinct element counts among matching rows.  Real data usually falsifies
 * that assumption.  For example, in a set of 11-element integer arrays having
 * elements in the range [0..10], element occurrences are typically not
 * independent.  If they were, a sufficiently-large set would include all
 * distinct element counts 0 through 11.  We correct for this using the
 * histogram of distinct element counts.
 *
 * In the "column @&gt; const" and "column &amp;&amp; const" cases, we usually have a
 * "const" with low number of elements (otherwise we have selectivity close
 * to 0 or 1 respectively).  That's why the effect of dependence related
 * to distinct element count distribution is negligible there.  In the
 * "column &lt;@ const" case, number of elements is usually high (otherwise we
 * have selectivity close to 0).  That's why we should do a correction with
 * the array distinct element count distribution here.
 *
 * Using the histogram of distinct element counts produces a different
 * distribution law than independent occurrences of elements.  This
 * distribution law can be described as follows:
 *
 * P(o1, o2, ..., on) = f1^o1 * (1 - f1)^(1 - o1) * f2^o2 *
 *	  (1 - f2)^(1 - o2) * ... * fn^on * (1 - fn)^(1 - on) * hist[m] / ind[m]
 *
 * where:
 * o1, o2, ..., on - occurrences of elements 1, 2, ..., n
 *		(1 - occurrence, 0 - no occurrence) in row
 * f1, f2, ..., fn - frequencies of elements 1, 2, ..., n
 *		(scalar values in [0..1]) according to collected statistics
 * m = o1 + o2 + ... + on = total number of distinct elements in row
 * hist[m] - histogram data for occurrence of m elements.
 * ind[m] - probability of m occurrences from n events assuming their
 *	  probabilities to be equal to frequencies of array elements.
 *
 * ind[m] = sum(f1^o1 * (1 - f1)^(1 - o1) * f2^o2 * (1 - f2)^(1 - o2) *
 * ... * fn^on * (1 - fn)^(1 - on), o1, o2, ..., on) | o1 + o2 + .. on = m
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>mcelem_array_contained_selec</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>,
							 <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnumbers</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
							 <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>mcelem_index</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>unique_nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>selec</name></decl>,
				<decl><type ref="prev"/><name>minfreq</name></decl>,
				<decl><type ref="prev"/><name>nullelem_freq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>dist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>mcelem_dist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>hist_part</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>avg_count</name></decl>,
				<decl><type ref="prev"/><name>mult</name></decl>,
				<decl><type ref="prev"/><name>rest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>elem_selec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There should be three more Numbers than Values in the MCELEM slot,
	 * because the last three cells should hold minimal and maximal frequency
	 * among the non-null elements, and then the frequency of null elements.
	 * Punt if not right, because we can't do much without the element freqs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numbers</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nnumbers</name> <operator>!=</operator> <name>nmcelem</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DEFAULT_CONTAIN_SEL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Can't do much without a count histogram, either */</comment>
	<if_stmt><if>if <condition>(<expr><name>hist</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nhist</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DEFAULT_CONTAIN_SEL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Grab some of the summary statistics that compute_array_stats() stores:
	 * lowest frequency, frequency of null elements, and average distinct
	 * element count.
	 */</comment>
	<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name><name>numbers</name><index>[<expr><name>nmcelem</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullelem_freq</name> <operator>=</operator> <name><name>numbers</name><index>[<expr><name>nmcelem</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>avg_count</name> <operator>=</operator> <name><name>hist</name><index>[<expr><name>nhist</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * "rest" will be the sum of the frequencies of all elements not
	 * represented in MCELEM.  The average distinct element count is the sum
	 * of the frequencies of *all* elements.  Begin with that; we will proceed
	 * to subtract the MCELEM frequencies.
	 */</comment>
	<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>avg_count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * mult is a multiplier representing estimate of probability that each
	 * mcelem that is not present in constant doesn't occur.
	 */</comment>
	<expr_stmt><expr><name>mult</name> <operator>=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * elem_selec is array of estimated frequencies for elements in the
	 * constant.
	 */</comment>
	<expr_stmt><expr><name>elem_selec</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan mcelem and array in parallel. */</comment>
	<expr_stmt><expr><name>mcelem_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore any duplicates in the array data. */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Iterate over MCELEM until we find an entry greater than or equal to
		 * this element of the constant.  Update "rest" and "mult" for mcelem
		 * entries skipped over.
		 */</comment>
		<while>while <condition>(<expr><name>mcelem_index</name> <operator>&lt;</operator> <name>nmcelem</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcelem</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>array_data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mult</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>-</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>rest</name> <operator>-=</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>mcelem_index</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* mcelem is found */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* MCELEM matches the array item. */</comment>
			<expr_stmt><expr><name><name>elem_selec</name><index>[<expr><name>unique_nitems</name></expr>]</index></name> <operator>=</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* "rest" is decremented for all mcelems, matched or not */</comment>
			<expr_stmt><expr><name>rest</name> <operator>-=</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcelem_index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The element is not in MCELEM.  Punt, but assume that the
			 * selectivity cannot be more than minfreq / 2.
			 */</comment>
			<expr_stmt><expr><name><name>elem_selec</name><index>[<expr><name>unique_nitems</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>DEFAULT_CONTAIN_SEL</name></expr></argument>,
											<argument><expr><name>minfreq</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>unique_nitems</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we handled all constant elements without exhausting the MCELEM
	 * array, finish walking it to complete calculation of "rest" and "mult".
	 */</comment>
	<while>while <condition>(<expr><name>mcelem_index</name> <operator>&lt;</operator> <name>nmcelem</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mult</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>-</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>rest</name> <operator>-=</operator> <name><name>numbers</name><index>[<expr><name>mcelem_index</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mcelem_index</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * The presence of many distinct rare elements materially decreases
	 * selectivity.  Use the Poisson distribution to estimate the probability
	 * of a column value having zero occurrences of such elements.  See above
	 * for the definition of "rest".
	 */</comment>
	<expr_stmt><expr><name>mult</name> <operator>*=</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Using the distinct element count histogram requires
	 *		O(unique_nitems * (nmcelem + unique_nitems))
	 * operations.  Beyond a certain computational cost threshold, it's
	 * reasonable to sacrifice accuracy for decreased planning time.  We limit
	 * the number of operations to EFFORT * nmcelem; since nmcelem is limited
	 * by the column's statistics target, the work done is user-controllable.
	 *
	 * If the number of operations would be too large, we can reduce it
	 * without losing all accuracy by reducing unique_nitems and considering
	 * only the most-common elements of the constant array.  To make the
	 * results exactly match what we would have gotten with only those
	 * elements to start with, we'd have to remove any discarded elements'
	 * frequencies from "mult", but since this is only an approximation
	 * anyway, we don't bother with that.  Therefore it's sufficient to qsort
	 * elem_selec[] and take the largest elements.  (They will no longer match
	 * up with the elements of array_data[], but we don't care.)
	 *----------
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EFFORT</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nmcelem</name> <operator>+</operator> <name>unique_nitems</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>unique_nitems</name> <operator>&gt;</operator> <name>EFFORT</name> <operator>*</operator> <name>nmcelem</name> <operator>/</operator> <operator>(</operator><name>nmcelem</name> <operator>+</operator> <name>unique_nitems</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Use the quadratic formula to solve for largest allowable N.  We
		 * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>b</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>nmcelem</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><call><name>sqrt</name><argument_list>(<argument><expr><name>b</name> <operator>*</operator> <name>b</name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name>EFFORT</name> <operator>*</operator> <name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>b</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Sort, then take just the first n elements */</comment>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>elem_selec</name></expr></argument>, <argument><expr><name>unique_nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>float_compare_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>unique_nitems</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Calculate probabilities of each distinct element count for both mcelems
	 * and constant elements.  At this point, assume independent element
	 * occurrence.
	 */</comment>
	<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>calc_distr</name><argument_list>(<argument><expr><name>elem_selec</name></expr></argument>, <argument><expr><name>unique_nitems</name></expr></argument>, <argument><expr><name>unique_nitems</name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mcelem_dist</name> <operator>=</operator> <call><name>calc_distr</name><argument_list>(<argument><expr><name>numbers</name></expr></argument>, <argument><expr><name>nmcelem</name></expr></argument>, <argument><expr><name>unique_nitems</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ignore hist[nhist-1], which is the average not a histogram member */</comment>
	<expr_stmt><expr><name>hist_part</name> <operator>=</operator> <call><name>calc_hist</name><argument_list>(<argument><expr><name>hist</name></expr></argument>, <argument><expr><name>nhist</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>unique_nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>unique_nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * mult * dist[i] / mcelem_dist[i] gives us probability of qual
		 * matching from assumption of independent element occurrence with the
		 * condition that distinct element count = i.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mcelem_dist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name><name>hist_part</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>mult</name> <operator>*</operator> <name><name>dist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <name><name>mcelem_dist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mcelem_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hist_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Take into account occurrence of NULL element. */</comment>
	<expr_stmt><expr><name>selec</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>-</operator> <name>nullelem_freq</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the first n distinct element count probabilities from a
 * histogram of distinct element counts.
 *
 * Returns a palloc'd array of n+1 entries, with array[k] being the
 * probability of element count k, k in [0..n].
 *
 * We assume that a histogram box with bounds a and b gives 1 / ((b - a + 1) *
 * (nhist - 1)) probability to each value in (a,b) and an additional half of
 * that to a and b themselves.
 */</comment>
<function><type><specifier>static</specifier> <name>float</name> <modifier>*</modifier></type>
<name>calc_hist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float4</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>hist_part</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>,
				<decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>prev_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>next_interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>frac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hist_part</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * frac is a probability contribution for each interval between histogram
	 * values.  We have nhist - 1 intervals, so contribution of each one will
	 * be 1 / (nhist - 1).
	 */</comment>
	<expr_stmt><expr><name>frac</name> <operator>=</operator> <literal type="number">1.0f</literal> <operator>/</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>nhist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Count the histogram boundaries equal to k.  (Although the histogram
		 * should theoretically contain only exact integers, entries are
		 * floats so there could be roundoff error in large values.  Treat any
		 * fractional value as equal to the next larger k.)
		 */</comment>
		<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nhist</name> <operator>&amp;&amp;</operator> <name><name>hist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>k</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* k is an exact bound for at least one histogram box. */</comment>
			<decl_stmt><decl><type><name>float</name></type>		<name>val</name></decl>;</decl_stmt>

			<comment type="block">/* Find length between current histogram value and the next one */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nhist</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>next_interval</name> <operator>=</operator> <name><name>hist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>hist</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>next_interval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * count - 1 histogram boxes contain k exclusively.  They
			 * contribute a total of (count - 1) * frac probability.  Also
			 * factor in the partial histogram boxes on either side.
			 */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>next_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>+=</operator> <literal type="number">0.5f</literal> <operator>/</operator> <name>next_interval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>prev_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>+=</operator> <literal type="number">0.5f</literal> <operator>/</operator> <name>prev_interval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>hist_part</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>frac</name> <operator>*</operator> <name>val</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>prev_interval</name> <operator>=</operator> <name>next_interval</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* k does not appear as an exact histogram bound. */</comment>
			<if_stmt><if>if <condition>(<expr><name>prev_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>hist_part</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>frac</name> <operator>/</operator> <name>prev_interval</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>hist_part</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>hist_part</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Consider n independent events with probabilities p[].  This function
 * calculates probabilities of exact k of events occurrence for k in [0..m].
 * Returns a palloc'd array of size m+1.
 *
 * "rest" is the sum of the probabilities of all low-probability events not
 * included in p.
 *
 * Imagine matrix M of size (n + 1) x (m + 1).  Element M[i,j] denotes the
 * probability that exactly j of first i events occur.  Obviously M[0,0] = 1.
 * For any constant j, each increment of i increases the probability iff the
 * event occurs.  So, by the law of total probability:
 *	M[i,j] = M[i - 1, j] * (1 - p[i]) + M[i - 1, j - 1] * p[i]
 *		for i &gt; 0, j &gt; 0.
 *	M[i,0] = M[i - 1, 0] * (1 - p[i]) for i &gt; 0.
 */</comment>
<function><type><specifier>static</specifier> <name>float</name> <modifier>*</modifier></type>
<name>calc_distr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>rest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>row</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev_row</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we return only the last row of the matrix and need only the
	 * current and previous row for calculations, allocate two rows.
	 */</comment>
	<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>m</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_row</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>m</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* M[0,0] = 1 */</comment>
	<expr_stmt><expr><name><name>row</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float</name></type>		<name>t</name> <init>= <expr><name><name>p</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Swap rows */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>row</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>row</name> <operator>=</operator> <name>prev_row</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_row</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

		<comment type="block">/* Calculate next row */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;=</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>float</name></type>		<name>val</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>+=</operator> <name><name>prev_row</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><literal type="number">1.0f</literal> <operator>-</operator> <name>t</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>+=</operator> <name><name>prev_row</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>row</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The presence of many distinct rare (not in "p") elements materially
	 * decreases selectivity.  Model their collective occurrence with the
	 * Poisson distribution.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rest</name> <operator>&gt;</operator> <name>DEFAULT_CONTAIN_SEL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float</name></type>		<name>t</name></decl>;</decl_stmt>

		<comment type="block">/* Swap rows */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>row</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>row</name> <operator>=</operator> <name>prev_row</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_row</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>m</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>row</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* Value of Poisson distribution for 0 occurrences */</comment>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Calculate convolution of previously computed distribution and the
		 * Poisson distribution.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>m</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>m</name> <operator>-</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>row</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>prev_row</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>t</name></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* Get Poisson distribution value for (i + 1) occurrences */</comment>
			<expr_stmt><expr><name>t</name> <operator>*=</operator> <name>rest</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prev_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>row</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fast function for floor value of 2 based logarithm calculation. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>floor_log2</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>logval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>logval</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>logval</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>logval</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>logval</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logval</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>logval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_next_mcelem binary-searches a most common elements array, starting
 * from *index, for the first member &gt;= value.  It saves the position of the
 * match into *index and returns true if it's an exact match.  (Note: we
 * assume the mcelem elements are distinct so there can't be more than one
 * exact match.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_next_mcelem</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmcelem</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
				 <parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><operator>*</operator><name>index</name></expr></init></decl>,
				<decl><type ref="prev"/><name>r</name> <init>= <expr><name>nmcelem</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>l</name> <operator>&lt;=</operator> <name>r</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>l</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcelem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>index</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for elements.
 *
 * We use the element type's default btree opclass, and its default collation
 * if the type is collation-sensitive.
 *
 * XXX consider using SortSupport infrastructure
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>element_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>key1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>key2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>cmpfunc</name> <init>= <expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>cmpfunc</name></expr></argument>, <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for sorting floats into descending order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>float_compare_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float</name></type>		<name>d1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>float</name> <operator>*</operator><operator>)</operator> <name>key1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>d2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>float</name> <operator>*</operator><operator>)</operator> <name>key2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&gt;</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>d1</name> <operator>&lt;</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
