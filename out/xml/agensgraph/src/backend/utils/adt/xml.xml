<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/xml.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xml.c
 *	  XML data type support.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/utils/adt/xml.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Generally, XML type support is only available when libxml use was
 * configured during the build.  But even if that is not done, the
 * type and all the functions are available, but most of them will
 * fail.  For one thing, this avoids having to manage variant catalog
 * installations.  But it also has nice effects such as that you can
 * dump a database containing XML type data even if the server is not
 * linked with libxml.  Thus, make sure xml_out() works even if nothing
 * else does.
 */</comment>

<comment type="block">/*
 * Notes on memory management:
 *
 * Sometimes libxml allocates global structures in the hope that it can reuse
 * them later on.  This makes it impractical to change the xmlMemSetup
 * functions on-the-fly; that is likely to lead to trying to pfree() chunks
 * allocated with malloc() or vice versa.  Since libxml might be used by
 * loadable modules, eg libperl, our only safe choices are to change the
 * functions at postmaster/backend launch or not at all.  Since we'd rather
 * not activate libxml in sessions that might never use it, the latter choice
 * is the preferred one.  However, for debugging purposes it can be awfully
 * handy to constrain libxml's allocations to be done in a specific palloc
 * context, where they're easy to track.  Therefore there is code here that
 * can be enabled in debug builds to redirect libxml's allocations into a
 * special context LibxmlContext.  It's not recommended to turn this on in
 * a production build because of the possibility of bad interactions with
 * external modules.
 */</comment>
<comment type="block">/* #define USE_LIBXMLCONTEXT */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/chvalid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/parser.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/parserInternals.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/tree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/uri.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/xmlerror.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/xmlversion.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/xmlwriter.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/xpath.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libxml/xpathInternals.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * We used to check for xmlStructuredErrorContext via a configure test; but
 * that doesn't work on Windows, so instead use this grottier method of
 * testing the library version number.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LIBXML_VERSION</name> <operator>&gt;=</operator> <literal type="number">20704</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_XMLSTRUCTUREDERRORCONTEXT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXML */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tablefunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>xmlbinary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>xmloption</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>

<comment type="block">/* random number to identify PgXmlErrorContext */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCXT_MAGIC</name></cpp:macro>	<cpp:value>68275028</cpp:value></cpp:define>

<struct>struct <name>PgXmlErrorContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>magic</name></decl>;</decl_stmt>
	<comment type="block">/* strictness argument passed to pg_xml_init */</comment>
	<decl_stmt><decl><type><name>PgXmlStrictness</name></type> <name>strictness</name></decl>;</decl_stmt>
	<comment type="block">/* current error status and accumulated message, if any */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>err_occurred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>err_buf</name></decl>;</decl_stmt>
	<comment type="block">/* previous libxml error handling state (saved by pg_xml_init) */</comment>
	<decl_stmt><decl><type><name>xmlStructuredErrorFunc</name></type> <name>saved_errfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>saved_errcxt</name></decl>;</decl_stmt>
	<comment type="block">/* previous libxml entity handler (saved by pg_xml_init) */</comment>
	<decl_stmt><decl><type><name>xmlExternalEntityLoader</name></type> <name>saved_entityfunc</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>xmlParserInputPtr</name></type> <name>xmlPgEntityLoader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>URL</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>,
										   <parameter><decl><type><name>xmlParserCtxtPtr</name></type> <name>ctxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xml_errorHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>xmlErrorPtr</name></type> <name>error</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xml_ereport_by_code</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlcode</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chopStringInfoNewlines</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendStringInfoLineSeparator</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXMLCONTEXT</name></cpp:ifdef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>LibxmlContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xml_memory_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>xml_palloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>xml_repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xml_pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xml_pstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXMLCONTEXT */</comment>

<function_decl><type><specifier>static</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>xml_text2xmlChar</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>parse_xml_decl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>,
						   <parameter><decl><type><name>xmlChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>version</name></decl></parameter>, <parameter><decl><type><name>xmlChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>standalone</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>print_xml_decl</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
						   <parameter><decl><type><name>pg_enc</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>xml_doctype_in_content</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>xmlDocPtr</name></type> <name>xml_parse</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>XmlOptionType</name></type> <name>xmloption_arg</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>preserve_whitespace</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>xml_xmlnodetoxmltype</name><parameter_list>(<parameter><decl><type><name>xmlNodePtr</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>xml_xpathobjtoxmlarray</name><parameter_list>(<parameter><decl><type><name>xmlXPathObjectPtr</name></type> <name>xpathobj</name></decl></parameter>,
								   <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
								   <parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>pg_xmlCharStrndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXML */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xmldata_root_element_start</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eltname</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>xmldata_root_element_end</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eltname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>query_to_xml_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_table_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_schema_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>,
													 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relid_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_catalog_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspid_list</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
													  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_type_to_xml_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_typecoll_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tupdesc_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>map_sql_type_to_xmlschema_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SPI_sql_row_to_xmlelement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
									  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* XMLTABLE support */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
<comment type="block">/* random number to identify XmlTableContext */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XMLTABLE_CONTEXT_MAGIC</name></cpp:macro>	<cpp:value>46922182</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>XmlTableBuilderData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>int</name></type>	<name>row_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlParserCtxtPtr</name></type> <name>ctxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlDocPtr</name></type>	<name>doc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlXPathContextPtr</name></type> <name>xpathcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlXPathCompExprPtr</name></type> <name>xpathcomp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlXPathObjectPtr</name></type> <name>xpathobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlXPathCompExprPtr</name> <modifier>*</modifier></type><name>xpathscomp</name></decl>;</decl_stmt>
}</block></struct></type> <name>XmlTableBuilderData</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableInitOpaque</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableSetDocument</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableSetNamespace</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableSetRowFilter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableSetColumnFilter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>XmlTableFetchRow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>XmlTableGetValue</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colnum</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XmlTableDestroyOpaque</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>TableFuncScanState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>TableFuncRoutine</name></type> <name>XmlTableRoutine</name> <init>=
<expr><block>{
	<expr><name>XmlTableInitOpaque</name></expr>,
	<expr><name>XmlTableSetDocument</name></expr>,
	<expr><name>XmlTableSetNamespace</name></expr>,
	<expr><name>XmlTableSetRowFilter</name></expr>,
	<expr><name>XmlTableSetColumnFilter</name></expr>,
	<expr><name>XmlTableFetchRow</name></expr>,
	<expr><name>XmlTableGetValue</name></expr>,
	<expr><name>XmlTableDestroyOpaque</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_XML_SUPPORT</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>ereport(ERROR, \
			(errcode(ERRCODE_FEATURE_NOT_SUPPORTED), \
			 errmsg("unsupported XML feature"), \
			 errdetail("This functionality requires the server to be built with libxml support."), \
			 errhint("You need to rebuild PostgreSQL using --with-libxml.")))</cpp:value></cpp:define>


<comment type="block">/* from SQL/XML:2008 section 4.9 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMESPACE_XSD</name></cpp:macro> <cpp:value>"http://www.w3.org/2001/XMLSchema"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMESPACE_XSI</name></cpp:macro> <cpp:value>"http://www.w3.org/2001/XMLSchema-instance"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMESPACE_SQLXML</name></cpp:macro> <cpp:value>"http://standards.iso.org/iso/9075/2003/sqlxml"</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xmlChar_to_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>encoding_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name> <init>= <expr><call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>encoding_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid encoding name \"%s\""</literal></expr></argument>,
						<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>encoding_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>encoding</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * xml_in uses a plain C string to VARDATA conversion, so for the time being
 * we use the conversion function for the text datatype.
 *
 * This is only acceptable so long as xmltype and text use the same
 * representation.
 */</comment>
<function><type><name>Datum</name></type>
<name>xml_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlDocPtr</name></type>	<name>doc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>vardata</name> <operator>=</operator> <operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the data to check if it is well-formed XML data.  Assume that
	 * ERROR occurred if parsing failed.
	 */</comment>
	<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xml_parse</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_XML_DEFAULT_VERSION</name></cpp:macro> <cpp:value>"1.0"</cpp:value></cpp:define>


<comment type="block">/*
 * xml_out_internal uses a plain VARDATA to C string conversion, so for the
 * time being we use the conversion function for the text datatype.
 *
 * This is only acceptable so long as xmltype and text use the same
 * representation.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>xml_out_internal</name><parameter_list>(<parameter><decl><type><name>xmltype</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>pg_enc</name></type> <name>target_encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>standalone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_code</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res_code</name> <operator>=</operator> <call><name>parse_xml_decl</name><argument_list>(<argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>standalone</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_xml_decl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>target_encoding</name></expr></argument>, <argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are not going to produce an XML declaration, eat a single
			 * newline in the original string to prevent empty first lines in
			 * the output.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>xml_ereport_by_code</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
						<argument><expr><literal type="string">"could not parse XML declaration in stored value"</literal></expr></argument>,
						<argument><expr><name>res_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>xml_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * xml_out removes the encoding property in all cases.  This is because we
	 * cannot control from here whether the datum will be converted to a
	 * different client encoding, so we'd do more harm than good by including
	 * it.
	 */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>xml_out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>xml_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlDocPtr</name></type>	<name>doc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>encodingStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Read the data in raw format. We don't know yet what the encoding is, as
	 * that information is embedded in the xml declaration; so we have to
	 * parse that before converting to server encoding.
	 */</comment>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need a null-terminated string to pass to parse_xml_decl().  Rather
	 * than make a separate copy, make the temporary result one byte bigger
	 * than it needs to be.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>str</name><index>[<expr><name>nbytes</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parse_xml_decl</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encodingStr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If encoding wasn't explicitly specified in the XML header, treat it as
	 * UTF-8, as that's the default in XML. This is different from xml_in(),
	 * where the input has to go through the normal client to server encoding
	 * conversion.
	 */</comment>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <ternary><condition><expr><name>encodingStr</name></expr> ?</condition><then> <expr><call><name>xmlChar_to_encoding</name><argument_list>(<argument><expr><name>encodingStr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>PG_UTF8</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the data to check if it is well-formed XML data.  Assume that
	 * xml_parse will throw ERROR if not.
	 */</comment>
	<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xml_parse</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now that we know what we're dealing with, convert to server encoding */</comment>
	<expr_stmt><expr><name>newstr</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newstr</name> <operator>!=</operator> <name>str</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>xml_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * xml_out_internal doesn't convert the encoding, it just prints the right
	 * declaration. pq_sendtext will do the conversion.
	 */</comment>
	<expr_stmt><expr><name>outval</name> <operator>=</operator> <call><name>xml_out_internal</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>outval</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendStringInfoText</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>xmltype</name> <modifier>*</modifier></type>
<name>stringinfo_to_xmltype</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>xmltype</name> <modifier>*</modifier></type>
<name>cstring_to_xmltype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>xmltype</name> <modifier>*</modifier></type>
<name>xmlBuffer_to_xmltype</name><parameter_list>(<parameter><decl><type><name>xmlBufferPtr</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>xmlBufferContent</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>xmlBufferLength</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>Datum</name></type>
<name>xmlcomment</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argdata</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* check for "--" in string or "-" at the end */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>argdata</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>argdata</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_XML_COMMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid XML comment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>argdata</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_XML_COMMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid XML comment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"--&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<comment type="block">/*
 * TODO: xmlconcat needs to merge the notations and unparsed entities
 * of the argument values.  Not very important in practice, though.
 */</comment>
<function><type><name>xmltype</name> <modifier>*</modifier></type>
<name>xmlconcat</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>global_standalone</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>global_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>global_version_no_value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>v</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>DatumGetXmlP</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>standalone</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>parse_xml_decl</name><argument_list>(<argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>standalone</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>global_standalone</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>global_standalone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>standalone</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>global_standalone</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>global_version_no_value</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>global_version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>global_version</name> <operator>=</operator> <name>version</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>xmlStrcmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>global_version</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>global_version_no_value</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>global_version_no_value</name> <operator>||</operator> <name>global_standalone</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>print_xml_decl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf2</name></expr></argument>,
					   <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>global_version_no_value</name><operator>)</operator></expr> ?</condition><then> <expr><name>global_version</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name>global_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf2</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>buf2</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * XMLAGG support
 */</comment>
<function><type><name>Datum</name></type>
<name>xmlconcat2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>xmlconcat</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>texttoxml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>xmlparse</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>xmltotext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* It's actually binary compatible. */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>text</name> <modifier>*</modifier></type>
<name>xmltotext_with_xmloption</name><parameter_list>(<parameter><decl><type><name>xmltype</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>XmlOptionType</name></type> <name>xmloption_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>xmloption_arg</name> <operator>==</operator> <name>XMLOPTION_DOCUMENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>xml_is_document</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_AN_XML_DOCUMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not an XML document"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* It's actually binary compatible, save for the above check. */</comment>
	<return>return <expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>xmltype</name> <modifier>*</modifier></type>
<name>xmlelement</name><parameter_list>(<parameter><decl><type><name>XmlExpr</name> <modifier>*</modifier></type><name>xexpr</name></decl></parameter>,
		   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>named_argvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>named_argnull</name></decl></parameter>,
		   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>argnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>named_arg_strings</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arg_strings</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>narg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlBufferPtr</name></type> <name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlTextWriterPtr</name></type> <name>writer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * All arguments are already evaluated, and their values are passed in the
	 * named_argvalue/named_argnull or argvalue/argnull arrays.  This avoids
	 * issues if one of the arguments involves a call to some other function
	 * or subsystem that wants to use libxml on its own terms.  We examine the
	 * original XmlExpr to identify the numbers and types of the arguments.
	 */</comment>
	<expr_stmt><expr><name>named_arg_strings</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;named_args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>named_argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name><name>named_argvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>named_arg_strings</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>named_arg_strings</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>arg_strings</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<comment type="block">/* here we can just forget NULL elements immediately */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name><name>argvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg_strings</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>arg_strings</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>xmlerrcxt</name> <operator>=</operator> <call><name>pg_xml_init</name><argument_list>(<argument><expr><name>PG_XML_STRICTNESS_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmlBufferCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate xmlBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>writer</name> <operator>=</operator> <call><name>xmlNewTextWriterMemory</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate xmlTextWriter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>xmlTextWriterStartElement</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>forboth</name><argument_list>(<argument>arg</argument>, <argument>named_arg_strings</argument>, <argument>narg</argument>, <argument>xexpr-&gt;arg_names</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xmlTextWriterWriteAttribute</name><argument_list>(<argument><expr><name>writer</name></expr></argument>,
											<argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>argname</name></expr></argument>,
											<argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>arg_strings</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>xmlTextWriterWriteRaw</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>xmlTextWriterEndElement</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we MUST do this now to flush data out to the buffer ... */</comment>
		<expr_stmt><expr><call><name>xmlFreeTextWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>xmlBuffer_to_xmltype</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>writer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeTextWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlBufferFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmlBufferFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>xmltype</name> <modifier>*</modifier></type>
<name>xmlparse</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>XmlOptionType</name></type> <name>xmloption_arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_whitespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>xmlDocPtr</name></type>	<name>doc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xml_parse</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>xmloption_arg</name></expr></argument>, <argument><expr><name>preserve_whitespace</name></expr></argument>,
					<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>xmltype</name> <modifier>*</modifier></type>
<name>xmlpi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>arg_is_null</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result_is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"xml"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <comment type="block">/* really */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid XML processing instruction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"XML processing instruction target name cannot be \"%s\"."</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Following the SQL standard, the null check comes after the syntax check
	 * above.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>result_is_null</name> <operator>=</operator> <name>arg_is_null</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result_is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;?%s"</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid XML processing instruction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"XML processing instruction cannot contain \"?&gt;\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <call><name>strspn</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>xmltype</name> <modifier>*</modifier></type>
<name>xmlroot</name><parameter_list>(<parameter><decl><type><name>xmltype</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>version</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>orig_version</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>orig_standalone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parse_xml_decl</name><argument_list>(<argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>orig_version</name> <operator>=</operator> <call><name>xml_text2xmlChar</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>orig_version</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<switch>switch <condition>(<expr><name>standalone</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XML_STANDALONE_YES</name></expr>:</case>
			<expr_stmt><expr><name>orig_standalone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_STANDALONE_NO</name></expr>:</case>
			<expr_stmt><expr><name>orig_standalone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_STANDALONE_NO_VALUE</name></expr>:</case>
			<expr_stmt><expr><name>orig_standalone</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_STANDALONE_OMITTED</name></expr>:</case>
			<comment type="block">/* leave original value */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>print_xml_decl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>orig_version</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>orig_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Validate document (given as string) against DTD (given as external link)
 *
 * This has been removed because it is a security hole: unprivileged users
 * should not be able to use Postgres to fetch arbitrary external files,
 * which unfortunately is exactly what libxml is willing to do with the DTD
 * parameter.
 */</comment>
<function><type><name>Datum</name></type>
<name>xmlvalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"xmlvalidate is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>xml_is_document</name><parameter_list>(<parameter><decl><type><name>xmltype</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlDocPtr</name></type> <name>doc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ccxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We want to catch ereport(INVALID_XML_DOCUMENT) and return false */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xml_parse</name><argument_list>(<argument><expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>, <argument><expr><name>XMLOPTION_DOCUMENT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>errdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ecxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ecxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ccxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>errdata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_INVALID_XML_DOCUMENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>doc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not USE_LIBXML */</comment>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>

<comment type="block">/*
 * pg_xml_init_library --- set up for use of libxml
 *
 * This should be called by each function that is about to use libxml
 * facilities but doesn't require error handling.  It initializes libxml
 * and verifies compatibility with the loaded libxml version.  These are
 * once-per-session activities.
 *
 * TODO: xmlChar is utf8-char, make proper tuning (initdb with enc!=utf8 and
 * check)
 */</comment>
<function><type><name>void</name></type>
<name>pg_xml_init_library</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>first_time</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>first_time</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Stuff we need do only once per session */</comment>

		<comment type="block">/*
		 * Currently, we have no pure UTF-8 support for internals -- check if
		 * we can work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmlChar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not initialize XML library"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u."</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmlChar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXMLCONTEXT</name></cpp:ifdef>
		<comment type="block">/* Set up libxml's memory allocation our way */</comment>
		<expr_stmt><expr><call><name>xml_memory_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Check library compatibility */</comment>
		<expr_stmt><expr><name>LIBXML_TEST_VERSION</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>first_time</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_xml_init --- set up for use of libxml and register an error handler
 *
 * This should be called by each function that is about to use libxml
 * facilities and requires error handling.  It initializes libxml with
 * pg_xml_init_library() and establishes our libxml error handler.
 *
 * strictness determines which errors are reported and which are ignored.
 *
 * Calls to this function MUST be followed by a PG_TRY block that guarantees
 * that pg_xml_done() is called during either normal or error exit.
 *
 * This is exported for use by contrib/xml2, as well as other code that might
 * wish to share use of this module's libxml error handler.
 */</comment>
<function><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type>
<name>pg_xml_init</name><parameter_list>(<parameter><decl><type><name>PgXmlStrictness</name></type> <name>strictness</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>errcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>new_errcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Do one-time setup if needed */</comment>
	<expr_stmt><expr><call><name>pg_xml_init_library</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create error handling context structure */</comment>
	<expr_stmt><expr><name>errcxt</name> <operator>=</operator> <operator>(</operator><name>PgXmlErrorContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgXmlErrorContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>ERRCXT_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>strictness</name></name> <operator>=</operator> <name>strictness</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>err_occurred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>errcxt</name><operator>-&gt;</operator><name>err_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save original error handler and install ours. libxml originally didn't
	 * distinguish between the contexts for generic and for structured error
	 * handlers.  If we're using an old libxml version, we must thus save the
	 * generic error context, even though we're using a structured error
	 * handler.
	 */</comment>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_errfunc</name></name> <operator>=</operator> <name>xmlStructuredError</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_XMLSTRUCTUREDERRORCONTEXT</name></cpp:ifdef>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_errcxt</name></name> <operator>=</operator> <name>xmlStructuredErrorContext</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_errcxt</name></name> <operator>=</operator> <name>xmlGenericErrorContext</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>xmlSetStructuredErrorFunc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>errcxt</name></expr></argument>, <argument><expr><name>xml_errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that xmlSetStructuredErrorFunc set the context variable we
	 * expected it to.  If not, the error context pointer we just saved is not
	 * the correct thing to restore, and since that leaves us without a way to
	 * restore the context in pg_xml_done, we must fail.
	 *
	 * The only known situation in which this test fails is if we compile with
	 * headers from a libxml2 that doesn't track the structured error context
	 * separately (&lt; 2.7.4), but at runtime use a version that does, or vice
	 * versa.  The libxml2 authors did not treat that change as constituting
	 * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library
	 * fails to protect us from this.
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_XMLSTRUCTUREDERRORCONTEXT</name></cpp:ifdef>
	<expr_stmt><expr><name>new_errcxt</name> <operator>=</operator> <name>xmlStructuredErrorContext</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>new_errcxt</name> <operator>=</operator> <name>xmlGenericErrorContext</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>new_errcxt</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>errcxt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set up XML error handler"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This probably indicates that the version of libxml2"</literal>
						 <literal type="string">" being used is not compatible with the libxml2"</literal>
						 <literal type="string">" header files that PostgreSQL was built with."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also, install an entity loader to prevent unwanted fetches of external
	 * files and URLs.
	 */</comment>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_entityfunc</name></name> <operator>=</operator> <call><name>xmlGetExternalEntityLoader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlSetExternalEntityLoader</name><argument_list>(<argument><expr><name>xmlPgEntityLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>errcxt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_xml_done --- restore previous libxml error handling
 *
 * Resets libxml's global error-handling state to what it was before
 * pg_xml_init() was called.
 *
 * This routine verifies that all pending errors have been dealt with
 * (in assert-enabled builds, anyway).
 */</comment>
<function><type><name>void</name></type>
<name>pg_xml_done</name><parameter_list>(<parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>errcxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>cur_errcxt</name></decl>;</decl_stmt>

	<comment type="block">/* An assert seems like enough protection here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>errcxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>ERRCXT_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a normal exit, there should be no un-handled libxml errors.  But we
	 * shouldn't try to enforce this during error recovery, since the longjmp
	 * could have been thrown before xml_ereport had a chance to run.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>errcxt</name><operator>-&gt;</operator><name>err_occurred</name></name> <operator>||</operator> <name>isError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that libxml's global state is correct, warn if not.  This is a
	 * real test and not an Assert because it has a higher probability of
	 * happening.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_XMLSTRUCTUREDERRORCONTEXT</name></cpp:ifdef>
	<expr_stmt><expr><name>cur_errcxt</name> <operator>=</operator> <name>xmlStructuredErrorContext</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>cur_errcxt</name> <operator>=</operator> <name>xmlGenericErrorContext</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>cur_errcxt</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>errcxt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"libxml error handling state is out of sync with xml.c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Restore the saved handlers */</comment>
	<expr_stmt><expr><call><name>xmlSetStructuredErrorFunc</name><argument_list>(<argument><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_errcxt</name></name></expr></argument>, <argument><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_errfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlSetExternalEntityLoader</name><argument_list>(<argument><expr><name><name>errcxt</name><operator>-&gt;</operator><name>saved_entityfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the struct as invalid, just in case somebody somehow manages to
	 * call xml_errorHandler or xml_ereport with it.
	 */</comment>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Release memory */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>errcxt</name><operator>-&gt;</operator><name>err_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>errcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_xml_error_occurred() --- test the error flag
 */</comment>
<function><type><name>bool</name></type>
<name>pg_xml_error_occurred</name><parameter_list>(<parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>errcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>errcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SQL/XML allows storing "XML documents" or "XML content".  "XML
 * documents" are specified by the XML specification and are parsed
 * easily by libxml.  "XML content" is specified by SQL/XML as the
 * production "XMLDecl? content".  But libxml can only parse the
 * "content" part, so we have to parse the XML declaration ourselves
 * to complete this.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_XML_SPACE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!xmlIsBlank_ch(*(p))) \
			return XML_ERR_SPACE_REQUIRED; \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_XML_SPACE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>while (xmlIsBlank_ch(*(p))) (p)++</cpp:value></cpp:define>

<comment type="block">/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */</comment>
<comment type="block">/* Beware of multiple evaluations of argument! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_XMLISNAMECHAR</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(xmlIsBaseChar_ch(c) || xmlIsIdeographicQ(c) \
			|| xmlIsDigit_ch(c) \
			|| c == '.' || c == '-' || c == '_' || c == ':' \
			|| xmlIsCombiningQ(c) \
			|| xmlIsExtender_ch(c))</cpp:value></cpp:define>

<comment type="block">/* pnstrdup, but deal with xmlChar not char; len is measured in xmlChars */</comment>
<function><type><specifier>static</specifier> <name>xmlChar</name> <modifier>*</modifier></type>
<name>xml_pnstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmlChar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmlChar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Ditto, except input is char* */</comment>
<function><type><specifier>static</specifier> <name>xmlChar</name> <modifier>*</modifier></type>
<name>pg_xmlCharStrndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xmlChar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy xmlChar string to PostgreSQL-owned memory, freeing the input.
 *
 * The input xmlChar is freed regardless of success of the copy.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>xml_pstrdup_and_free</name><parameter_list>(<parameter><decl><type><name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>xmlFree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * str is the null-terminated input string.  Remaining arguments are
 * output arguments; each can be NULL if value is not wanted.
 * version and encoding are returned as locally-palloc'd strings.
 * Result is 0 if OK, an error code if not.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_xml_decl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>,
			   <parameter><decl><type><name>xmlChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>version</name></decl></parameter>, <parameter><decl><type><name>xmlChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>standalone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>save_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>utf8char</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>utf8len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only initialize libxml.  We don't need error handling here, but we do
	 * need to make sure libxml is initialized before calling any of its
	 * functions.  Note that this is safe (and a no-op) if caller has already
	 * done pg_xml_init().
	 */</comment>
	<expr_stmt><expr><call><name>pg_xml_init_library</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize output arguments to "not present" */</comment>
	<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>version</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>standalone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>standalone</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"&lt;?xml"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If next char is a name char, it's a PI like &lt;?xml-stylesheet ...?&gt;
	 * rather than an XMLDecl, so we have done what we came to do and found no
	 * XMLDecl.
	 *
	 * We need an input length value for xmlGetUTF8Char, but there's no need
	 * to count the whole document size, so use strnlen not strlen.
	 */</comment>
	<expr_stmt><expr><name>utf8len</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator></expr></argument>, <argument><expr><name>MAX_MULTIBYTE_CHAR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>utf8char</name> <operator>=</operator> <call><name>xmlGetUTF8Char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>utf8len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PG_XMLISNAMECHAR</name><argument_list>(<argument><expr><name>utf8char</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

	<comment type="block">/* version */</comment>
	<expr_stmt><expr><call><name>CHECK_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"version"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XML_ERR_VERSION_MISSING</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XML_ERR_VERSION_MISSING</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>xmlStrchr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_VERSION_MISSING</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>version</name> <operator>=</operator> <call><name>xml_pnstrdup</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>q</name> <operator>-</operator> <name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>XML_ERR_VERSION_MISSING</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* encoding */</comment>
	<expr_stmt><expr><name>save_p</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"encoding"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_XML_SPACE</name><argument_list>(<argument><expr><name>save_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_MISSING_ENCODING</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>xmlStrchr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>XML_ERR_MISSING_ENCODING</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <call><name>xml_pnstrdup</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>q</name> <operator>-</operator> <name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_MISSING_ENCODING</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>save_p</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* standalone */</comment>
	<expr_stmt><expr><name>save_p</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"standalone"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_XML_SPACE</name><argument_list>(<argument><expr><name>save_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_STANDALONE_VALUE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"'yes'"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"\"yes\""</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>standalone</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>standalone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"'no'"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"\"no\""</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>standalone</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>standalone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_STANDALONE_VALUE</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>save_p</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"?&gt;"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XML_ERR_XMLDECL_NOT_FINISHED</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<label><name>finished</name>:</label>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>str</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>str</name> <operator>+</operator> <name>len</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>XML_ERR_INVALID_CHAR</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>lenp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lenp</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>XML_ERR_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Write an XML declaration.  On output, we adjust the XML declaration
 * as follows.  (These rules are the moral equivalent of the clause
 * "Serialization of an XML value" in the SQL standard.)
 *
 * We try to avoid generating an XML declaration if possible.  This is
 * so that you don't get trivial things like xml '&lt;foo/&gt;' resulting in
 * '&lt;?xml version="1.0"?&gt;&lt;foo/&gt;', which would surely be annoying.  We
 * must provide a declaration if the standalone property is specified
 * or if we include an encoding declaration.  If we have a
 * declaration, we must specify a version (XML requires this).
 * Otherwise we only make a declaration if the version is not "1.0",
 * which is the default version specified in SQL:2003.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>print_xml_decl</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
			   <parameter><decl><type><name>pg_enc</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>version</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>version</name></expr></argument>, <argument><expr><name>PG_XML_DEFAULT_VERSION</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator>
		<operator>||</operator> <operator>(</operator><name>encoding</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>!=</operator> <name>PG_UTF8</name><operator>)</operator>
		<operator>||</operator> <name>standalone</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;?xml"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" version=\"%s\""</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" version=\"%s\""</literal></expr></argument>, <argument><expr><name>PG_XML_DEFAULT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>!=</operator> <name>PG_UTF8</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * XXX might be useful to convert this to IANA names (ISO-8859-1
			 * instead of LATIN1 etc.); needs field experience
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" encoding=\"%s\""</literal></expr></argument>,
							 <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>standalone</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" standalone=\"yes\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>standalone</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" standalone=\"no\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an input that is to be parsed as CONTENT contains a DTD.
 *
 * The SQL/XML:2003 definition of CONTENT ("XMLDecl? content") is not
 * satisfied by a document with a DTD, which is a bit of a wart, as it means
 * the CONTENT type is not a proper superset of DOCUMENT.  SQL/XML:2006 and
 * later fix that, by redefining content with reference to the "more
 * permissive" Document Node of the XQuery/XPath Data Model, such that any
 * DOCUMENT value is indeed also a CONTENT value.  That definition is more
 * useful, as CONTENT becomes usable for parsing input of unknown form (think
 * pg_restore).
 *
 * As used below in parse_xml when parsing for CONTENT, libxml does not give
 * us the 2006+ behavior, but only the 2003; it will choke if the input has
 * a DTD.  But we can provide the 2006+ definition of CONTENT easily enough,
 * by detecting this case first and simply doing the parse as DOCUMENT.
 *
 * A DTD can be found arbitrarily far in, but that would be a contrived case;
 * it will ordinarily start within a few dozen characters.  The only things
 * that can precede it are an XMLDecl (here, the caller will have called
 * parse_xml_decl already), whitespace, comments, and processing instructions.
 * This function need only return true if it sees a valid sequence of such
 * things leading to &lt;!DOCTYPE.  It can simply return false in any other
 * cases, including malformed input; that will mean the input gets parsed as
 * CONTENT as originally planned, with libxml reporting any errors.
 *
 * This is only to be called from xml_parse, when pg_xml_init has already
 * been called.  The input is already in UTF8 encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>xml_doctype_in_content</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SKIP_XML_SPACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* if we see &lt;!DOCTYPE, we can return true */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"DOCTYPE"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* otherwise, if it's not a comment, fail */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xmlStrncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* find end of comment: find -- and a &gt; must follow */</comment>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>xmlStrstr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* advance over comment, and keep scanning */</comment>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* otherwise, if it's not a PI &lt;?target something?&gt;, fail */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* find end of PI (the string ?&gt; is forbidden within a PI) */</comment>
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>xmlStrstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"?&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* advance over PI, keep scanning */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Convert a C string to XML internal representation
 *
 * Note: it is caller's responsibility to xmlFreeDoc() the result,
 * else a permanent memory leak will ensue!
 *
 * TODO maybe libxml2's xmlreader is better? (do not construct DOM,
 * yet do not use SAX - see xmlreader.c)
 */</comment>
<function><type><specifier>static</specifier> <name>xmlDocPtr</name></type>
<name>xml_parse</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>XmlOptionType</name></type> <name>xmloption_arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_whitespace</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>utf8string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlParserCtxtPtr</name></type> <name>ctxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlDocPtr</name></type> <name>doc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* will be useful later */</comment>
	<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>xml_text2xmlChar</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>utf8string</name> <operator>=</operator> <call><name>pg_do_encoding_conversion</name><argument_list>(<argument><expr><name>string</name></expr></argument>,
										   <argument><expr><name>len</name></expr></argument>,
										   <argument><expr><name>encoding</name></expr></argument>,
										   <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start up libxml and its parser */</comment>
	<expr_stmt><expr><name>xmlerrcxt</name> <operator>=</operator> <call><name>pg_xml_init</name><argument_list>(<argument><expr><name>PG_XML_STRICTNESS_WELLFORMED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use a TRY block to ensure we clean up correctly */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>parse_as_document</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>res_code</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>standalone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>xmlInitParser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctxt</name> <operator>=</operator> <call><name>xmlNewParserCtxt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate parser context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Decide whether to parse as document or content */</comment>
		<if_stmt><if>if <condition>(<expr><name>xmloption_arg</name> <operator>==</operator> <name>XMLOPTION_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parse_as_document</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Parse and skip over the XML declaration, if any */</comment>
			<expr_stmt><expr><name>res_code</name> <operator>=</operator> <call><name>parse_xml_decl</name><argument_list>(<argument><expr><name>utf8string</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res_code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xml_ereport_by_code</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_CONTENT</name></expr></argument>,
									<argument><expr><literal type="string">"invalid XML content: invalid XML declaration"</literal></expr></argument>,
									<argument><expr><name>res_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Is there a DOCTYPE element? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xml_doctype_in_content</name><argument_list>(<argument><expr><name>utf8string</name> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>parse_as_document</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>parse_as_document</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note, that here we try to apply DTD defaults
			 * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:
			 * 'Default values defined by internal DTD are applied'. As for
			 * external DTDs, we try to support them too, (see SQL/XML:2008 GR
			 * 10.16.7.e)
			 */</comment>
			<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xmlCtxtReadDoc</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>utf8string</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>,
								 <argument><expr><name>XML_PARSE_NOENT</name> <operator>|</operator> <name>XML_PARSE_DTDATTR</name>
								 <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>preserve_whitespace</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>XML_PARSE_NOBLANKS</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>doc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Use original option to decide which error code to throw */</comment>
				<if_stmt><if>if <condition>(<expr><name>xmloption_arg</name> <operator>==</operator> <name>XMLOPTION_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_DOCUMENT</name></expr></argument>,
								<argument><expr><literal type="string">"invalid XML document"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_CONTENT</name></expr></argument>,
								<argument><expr><literal type="string">"invalid XML content"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xmlNewDoc</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>xmlStrdup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>standalone</name></name> <operator>=</operator> <name>standalone</name></expr>;</expr_stmt>

			<comment type="block">/* allow empty content */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>utf8string</name> <operator>+</operator> <name>count</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>res_code</name> <operator>=</operator> <call><name>xmlParseBalancedChunkMemory</name><argument_list>(<argument><expr><name>doc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													   <argument><expr><name>utf8string</name> <operator>+</operator> <name>count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>res_code</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_CONTENT</name></expr></argument>,
								<argument><expr><literal type="string">"invalid XML content"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>doc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>doc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * xmlChar&lt;-&gt;text conversions
 */</comment>
<function><type><specifier>static</specifier> <name>xmlChar</name> <modifier>*</modifier></type>
<name>xml_text2xmlChar</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXMLCONTEXT</name></cpp:ifdef>

<comment type="block">/*
 * Manage the special context used for all libxml allocations (but only
 * in special debug builds; see notes at top of file)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_memory_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create memory context if not there already */</comment>
	<if_stmt><if>if <condition>(<expr><name>LibxmlContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>LibxmlContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											  <argument><expr><literal type="string">"Libxml context"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Re-establish the callbacks even if already set */</comment>
	<expr_stmt><expr><call><name>xmlMemSetup</name><argument_list>(<argument><expr><name>xml_pfree</name></expr></argument>, <argument><expr><name>xml_palloc</name></expr></argument>, <argument><expr><name>xml_repalloc</name></expr></argument>, <argument><expr><name>xml_pstrdup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrappers for memory management functions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>xml_palloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>LibxmlContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>xml_repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>repalloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* At least some parts of libxml assume xmlFree(NULL) is allowed */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>xml_pstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>LibxmlContext</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXMLCONTEXT */</comment>


<comment type="block">/*
 * xmlPgEntityLoader --- entity loader callback function
 *
 * Silently prevent any external entity URL from being loaded.  We don't want
 * to throw an error, so instead make the entity appear to expand to an empty
 * string.
 *
 * We would prefer to allow loading entities that exist in the system's
 * global XML catalog; but the available libxml2 APIs make that a complex
 * and fragile task.  For now, just shut down all external access.
 */</comment>
<function><type><specifier>static</specifier> <name>xmlParserInputPtr</name></type>
<name>xmlPgEntityLoader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>URL</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>,
				  <parameter><decl><type><name>xmlParserCtxtPtr</name></type> <name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>xmlNewStringInputStream</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>xmlChar</name> <operator>*</operator><operator>)</operator> <literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * xml_ereport --- report an XML-related error
 *
 * The "msg" is the SQL-level message; some can be adopted from the SQL/XML
 * standard.  This function adds libxml's native error message, if any, as
 * detail.
 *
 * This is exported for modules that want to share the core libxml error
 * handler.  Note that pg_xml_init() *must* have been called previously.
 */</comment>
<function><type><name>void</name></type>
<name>xml_ereport</name><parameter_list>(<parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>errcxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>detail</name></decl>;</decl_stmt>

	<comment type="block">/* Defend against someone passing us a bogus context struct */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>errcxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>ERRCXT_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"xml_ereport called with invalid PgXmlErrorContext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Flag that the current libxml error has been reported */</comment>
	<expr_stmt><expr><name><name>errcxt</name><operator>-&gt;</operator><name>err_occurred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Include detail only if we have some text from libxml */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>errcxt</name><operator>-&gt;</operator><name>err_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>detail</name> <operator>=</operator> <name><name>errcxt</name><operator>-&gt;</operator><name>err_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>detail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>level</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>sqlcode</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><name>detail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Error handler for libxml errors and warnings
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_errorHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>xmlErrorPtr</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name> <init>= <expr><operator>(</operator><name>PgXmlErrorContext</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlParserCtxtPtr</name></type> <name>ctxt</name> <init>= <expr><operator>(</operator><name>xmlParserCtxtPtr</name><operator>)</operator> <name><name>error</name><operator>-&gt;</operator><name>ctxt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlParserInputPtr</name></type> <name>input</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ctxt</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>ctxt</name><operator>-&gt;</operator><name>input</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlNodePtr</name></type>	<name>node</name> <init>= <expr><name><name>error</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>xmlChar</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						   <name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XML_ELEMENT_NODE</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>domain</name> <init>= <expr><name><name>error</name><operator>-&gt;</operator><name>domain</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><name><name>error</name><operator>-&gt;</operator><name>level</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>errorBuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Defend against someone passing us a bogus context struct.
	 *
	 * We force a backend exit if this check fails because longjmp'ing out of
	 * libxml would likely render it unsafe to use further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>ERRCXT_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"xml_errorHandler called with invalid PgXmlErrorContext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * Older libxml versions report some errors differently.
	 * First, some errors were previously reported as coming from the parser
	 * domain but are now reported as coming from the namespace domain.
	 * Second, some warnings were upgraded to errors.
	 * We attempt to compensate for that here.
	 *----------
	 */</comment>
	<switch>switch <condition>(<expr><name><name>error</name><operator>-&gt;</operator><name>code</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XML_WAR_NS_URI</name></expr>:</case>
			<expr_stmt><expr><name>level</name> <operator>=</operator> <name>XML_ERR_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>domain</name> <operator>=</operator> <name>XML_FROM_NAMESPACE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XML_ERR_NS_DECL_ERROR</name></expr>:</case>
		<case>case <expr><name>XML_WAR_NS_URI_RELATIVE</name></expr>:</case>
		<case>case <expr><name>XML_WAR_NS_COLUMN</name></expr>:</case>
		<case>case <expr><name>XML_NS_ERR_XML_NAMESPACE</name></expr>:</case>
		<case>case <expr><name>XML_NS_ERR_UNDEFINED_NAMESPACE</name></expr>:</case>
		<case>case <expr><name>XML_NS_ERR_QNAME</name></expr>:</case>
		<case>case <expr><name>XML_NS_ERR_ATTRIBUTE_REDEFINED</name></expr>:</case>
		<case>case <expr><name>XML_NS_ERR_EMPTY</name></expr>:</case>
			<expr_stmt><expr><name>domain</name> <operator>=</operator> <name>XML_FROM_NAMESPACE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Decide whether to act on the error or not */</comment>
	<switch>switch <condition>(<expr><name>domain</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XML_FROM_PARSER</name></expr>:</case>
		<case>case <expr><name>XML_FROM_NONE</name></expr>:</case>
		<case>case <expr><name>XML_FROM_MEMORY</name></expr>:</case>
		<case>case <expr><name>XML_FROM_IO</name></expr>:</case>

			<comment type="block">/*
			 * Suppress warnings about undeclared entities.  We need to do
			 * this to avoid problems due to not loading DTD definitions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>error</name><operator>-&gt;</operator><name>code</name></name> <operator>==</operator> <name>XML_WAR_UNDECLARED_ENTITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Otherwise, accept error regardless of the parsing purpose */</comment>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Ignore error if only doing well-formedness check */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>strictness</name></name> <operator>==</operator> <name>PG_XML_STRICTNESS_WELLFORMED</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Prepare error message in errorBuf */</comment>
	<expr_stmt><expr><name>errorBuf</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>error</name><operator>-&gt;</operator><name>line</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>, <argument><expr><literal type="string">"line %d: "</literal></expr></argument>, <argument><expr><name><name>error</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>, <argument><expr><literal type="string">"element %s: "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>error</name><operator>-&gt;</operator><name>message</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>, <argument><expr><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>, <argument><expr><literal type="string">"(no message provided)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Append context information to errorBuf.
	 *
	 * xmlParserPrintFileContext() uses libxml's "generic" error handler to
	 * write the context.  Since we don't want to duplicate libxml
	 * functionality here, we set up a generic error handler temporarily.
	 *
	 * We use appendStringInfo() directly as libxml's generic error handler.
	 * This should work because it has essentially the same signature as
	 * libxml expects, namely (void *ptr, const char *msg, ...).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>input</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xmlGenericErrorFunc</name></type> <name>errFuncSaved</name> <init>= <expr><name>xmlGenericError</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>errCtxSaved</name> <init>= <expr><name>xmlGenericErrorContext</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>xmlSetGenericErrorFunc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>errorBuf</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>xmlGenericErrorFunc</name><operator>)</operator> <name>appendStringInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add context information to errorBuf */</comment>
		<expr_stmt><expr><call><name>appendStringInfoLineSeparator</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>xmlParserPrintFileContext</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore generic error func */</comment>
		<expr_stmt><expr><call><name>xmlSetGenericErrorFunc</name><argument_list>(<argument><expr><name>errCtxSaved</name></expr></argument>, <argument><expr><name>errFuncSaved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get rid of any trailing newlines in errorBuf */</comment>
	<expr_stmt><expr><call><name>chopStringInfoNewlines</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Legacy error handling mode.  err_occurred is never set, we just add the
	 * message to err_buf.  This mode exists because the xml2 contrib module
	 * uses our error-handling infrastructure, but we don't want to change its
	 * behaviour since it's deprecated anyway.  This is also why we don't
	 * distinguish between notices, warnings and errors here --- the old-style
	 * generic error handler wouldn't have done that either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>strictness</name></name> <operator>==</operator> <name>PG_XML_STRICTNESS_LEGACY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoLineSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_buf</name></name></expr></argument>, <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							   <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't want to ereport() here because that'd probably leave libxml in
	 * an inconsistent state.  Instead, we remember the error and ereport()
	 * from xml_ereport().
	 *
	 * Warnings and notices can be reported immediately since they won't cause
	 * a longjmp() out of libxml.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name>XML_ERR_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoLineSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_buf</name></name></expr></argument>, <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							   <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name>XML_ERR_WARNING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>errorBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Wrapper for "ereport" function for XML-related errors.  The "msg"
 * is the SQL-level message; some can be adopted from the SQL/XML
 * standard.  This function uses "code" to create a textual detail
 * message.  At the moment, we only need to cover those codes that we
 * may raise in this file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_ereport_by_code</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqlcode</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>det</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>code</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XML_ERR_INVALID_CHAR</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Invalid character value."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_ERR_SPACE_REQUIRED</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Space required."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_ERR_STANDALONE_VALUE</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"standalone accepts only 'yes' or 'no'."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_ERR_VERSION_MISSING</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Malformed declaration: missing version."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_ERR_MISSING_ENCODING</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Missing encoding in text declaration."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XML_ERR_XMLDECL_NOT_FINISHED</name></expr>:</case>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parsing XML declaration: '?&gt;' expected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>det</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unrecognized libxml error code: %d."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>level</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>sqlcode</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><name>det</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove all trailing newlines from a StringInfo string
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chopStringInfoNewlines</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Append a newline after removing any existing trailing newlines
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendStringInfoLineSeparator</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>chopStringInfoNewlines</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convert one char in the current server encoding to a Unicode codepoint.
 */</comment>
<function><type><specifier>static</specifier> <name>pg_wchar</name></type>
<name>sqlchar_to_unicode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>utf8string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_wchar</name></type>	<name><name>ret</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>			<comment type="block">/* need space for trailing zero */</comment>

	<comment type="block">/* note we're not assuming s is null-terminated */</comment>
	<expr_stmt><expr><name>utf8string</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_encoding_mb2wchar_with_len</name><argument_list>(<argument><expr><name>PG_UTF8</name></expr></argument>, <argument><expr><name>utf8string</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>,
								  <argument><expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>PG_UTF8</name></expr></argument>, <argument><expr><name>utf8string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>utf8string</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>utf8string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>ret</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_xml_namefirst</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* (Letter | '_' | ':') */</comment>
	<return>return <expr><operator>(</operator><call><name>xmlIsBaseCharQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>xmlIsIdeographicQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_xml_namechar</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */</comment>
	<return>return <expr><operator>(</operator><call><name>xmlIsBaseCharQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>xmlIsIdeographicQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>xmlIsDigitQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">':'</literal>
			<operator>||</operator> <call><name>xmlIsCombiningQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>xmlIsExtenderQ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXML */</comment>


<comment type="block">/*
 * Map SQL identifier to XML name; see SQL/XML:2008 section 9.1.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>map_sql_identifier_to_xml_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fully_escaped</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>escape_period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SQL/XML doesn't make use of this case anywhere, so it's probably a
	 * mistake.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fully_escaped</name> <operator>||</operator> <operator>!</operator><name>escape_period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>ident</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>==</operator> <name>ident</name> <operator>||</operator> <name>fully_escaped</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x003A_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x005F_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>fully_escaped</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>==</operator> <name>ident</name> <operator>&amp;&amp;</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"xml"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x0078_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x0058_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>escape_period</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x002E_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>pg_wchar</name></type>	<name>u</name> <init>= <expr><call><name>sqlchar_to_unicode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>p</name> <operator>==</operator> <name>ident</name><operator>)</operator></expr>
				?</condition><then> <expr><operator>!</operator><call><name>is_valid_xml_namefirst</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><operator>!</operator><call><name>is_valid_xml_namechar</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"_x%04X_"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not USE_LIBXML */</comment>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Map XML name to SQL identifier; see SQL/XML:2008 section 9.3.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>map_xml_name_to_sql_identifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'x'</literal>
			<operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>cbuf</name><index>[<expr><name>MAX_UNICODE_EQUIVALENT_STRING</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>u</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_unicode_to_server</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Map SQL value to XML value; see SQL/XML:2008 section 9.8.
 *
 * When xml_escape_strings is true, then certain characters in string
 * values are replaced by entity references (&amp;lt; etc.), as specified
 * in SQL/XML:2008 section 9.8 GR 9) a) iii).   This is normally what is
 * wanted.  The false case is mainly useful when the resulting value
 * is used with xmlTextWriterWriteAttribute() to write out an
 * attribute, because that function does the escaping itself.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>map_sql_value_to_xml_value</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>xml_escape_strings</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elmtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elmtype</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elmtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>elmtype</name></expr></argument>,
						  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;element&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								   <argument><expr><call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
															  <argument><expr><name>elmtype</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;/element&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOut</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Flatten domains; the special-case treatments below should apply to,
		 * eg, domains over boolean not just boolean.
		 */</comment>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Special XSD formatting for some data types
		 */</comment>
		<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BOOLOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="string">"true"</literal></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><literal type="string">"false"</literal></expr>;</return></block_content></block></else></if_stmt>

			<case>case <expr><name>DATEOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* XSD doesn't support infinite values */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"XML does not support infinite date values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EncodeDateOnly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block>

			<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* XSD doesn't support infinite values */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"XML does not support infinite timestamp values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block>

			<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* XSD doesn't support infinite values */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"XML does not support infinite timestamp values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
			<case>case <expr><name>BYTEAOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlBufferPtr</name></type> <name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlTextWriterPtr</name></type> <name>writer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>xmlerrcxt</name> <operator>=</operator> <call><name>pg_xml_init</name><argument_list>(<argument><expr><name>PG_XML_STRICTNESS_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmlBufferCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
										<argument><expr><literal type="string">"could not allocate xmlBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>writer</name> <operator>=</operator> <call><name>xmlNewTextWriterMemory</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>writer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
										<argument><expr><literal type="string">"could not allocate xmlTextWriter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>xmlbinary</name> <operator>==</operator> <name>XMLBINARY_BASE64</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xmlTextWriterWriteBase64</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xmlTextWriterWriteBinHex</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

						<comment type="block">/* we MUST do this now to flush data out to the buffer */</comment>
						<expr_stmt><expr><call><name>xmlFreeTextWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>writer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>xmlBufferContent</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>writer</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xmlFreeTextWriter</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>xmlBufferFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>xmlBufferFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXML */</comment>

		</block_content>}</block></switch>

		<comment type="block">/*
		 * otherwise, just use the type's native text representation
		 */</comment>
		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typeOut</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... exactly as-is for XML, and when escaping is not wanted */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>XMLOID</name> <operator>||</operator> <operator>!</operator><name>xml_escape_strings</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* otherwise, translate special characters as needed */</comment>
		<return>return <expr><call><name>escape_xml</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Escape characters in text that have special meanings in XML.
 *
 * Returns a palloc'd string.
 *
 * NB: this is intentionally not dependent on libxml.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>escape_xml</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&amp;#x0d;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_SPI_strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>SPI_palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SQL to XML mapping functions
 *
 * What follows below was at one point intentionally organized so that
 * you can read along in the SQL/XML standard. The functions are
 * mostly split up the way the clauses lay out in the standards
 * document, and the identifiers are also aligned with the standard
 * text.  Unfortunately, SQL/XML:2006 reordered the clauses
 * differently than SQL/XML:2003, so the order below doesn't make much
 * sense anymore.
 *
 * There are many things going on there:
 *
 * There are two kinds of mappings: Mapping SQL data (table contents)
 * to XML documents, and mapping SQL structure (the "schema") to XML
 * Schema.  And there are functions that do both at the same time.
 *
 * Then you can map a database, a schema, or a table, each in both
 * ways.  This breaks down recursively: Mapping a database invokes
 * mapping schemas, which invokes mapping tables, which invokes
 * mapping rows, which invokes mapping columns, although you can't
 * call the last two from the outside.  Because of this, there are a
 * number of xyz_internal() functions which are to be called both from
 * the function manager wrapper and from some upper layer in a
 * recursive call.
 *
 * See the documentation about what the common function arguments
 * nulls, tableforest, and targetns mean.
 *
 * Some style guidelines for XML output: Use double quotes for quoting
 * XML attributes.  Indent XML elements by two spaces, but remember
 * that a lot of code is called recursively at different levels, so
 * it's better not to indent rather than create output that indents
 * and outdents weirdly.  Add newlines to make the output look nice.
 */</comment>


<comment type="block">/*
 * Visibility of objects for XML mappings; see SQL/XML:2008 section
 * 4.10.8.
 */</comment>

<comment type="block">/*
 * Given a query, which must return type oid as first column, produce
 * a list of Oids with the query results.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>query_to_oid_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>spi_result</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>spi_result</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute returned %s for %s"</literal></expr></argument>,
			 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>spi_result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
							<argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>schema_get_xml_visible_tables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid FROM pg_catalog.pg_class"</literal>
					 <literal type="string">" WHERE relnamespace = %u AND relkind IN ("</literal>
					 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
					 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
					 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal>
					 <literal type="string">" AND pg_catalog.has_table_privilege (oid, 'SELECT')"</literal>
					 <literal type="string">" ORDER BY relname;"</literal></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>query_to_oid_list</name><argument_list>(<argument><expr><name><name>query</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Including the system schemas is probably not useful for a database
 * mapping.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_VISIBLE_SCHEMAS_EXCLUDE</name></cpp:macro> <cpp:value>"(nspname ~ '^pg_' OR nspname = 'information_schema')"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_VISIBLE_SCHEMAS</name></cpp:macro> <cpp:value>"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT " XML_VISIBLE_SCHEMAS_EXCLUDE</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>database_get_xml_visible_schemas</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>query_to_oid_list</name><argument_list>(<argument><expr><name>XML_VISIBLE_SCHEMAS</name> <literal type="string">" ORDER BY nspname;"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>database_get_xml_visible_tables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* At the moment there is no order required here. */</comment>
	<return>return <expr><call><name>query_to_oid_list</name><argument_list>(<argument><expr><literal type="string">"SELECT oid FROM pg_catalog.pg_class"</literal>
							 <literal type="string">" WHERE relkind IN ("</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal>
							 <literal type="string">" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')"</literal>
							 <literal type="string">" AND relnamespace IN ("</literal> <name>XML_VISIBLE_SCHEMAS</name> <literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map SQL table to XML and/or XML Schema document; see SQL/XML:2008
 * section 9.11.
 */</comment>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>table_to_xml_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>query</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM %s"</literal></expr></argument>,
					 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>regclassout</name></expr></argument>,
														 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>query_to_xml_internal</name><argument_list>(<argument><expr><name><name>query</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>xmlschema</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
								 <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>table_to_xml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>table_to_xml_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
																<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
																<argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>query_to_xml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>query_to_xml_internal</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
																<argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cursor_to_xml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>count</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_sql_row_to_xmlelement</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								  <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write the start tag of the root element of a data mapping.
 *
 * top_level means that this is the very top level of the eventual
 * output.  For example, when the user calls table_to_xml, then a call
 * with a table name to this function is the top level.  When the user
 * calls database_to_xml, then a call with a schema name to this
 * function is not the top level.  If top_level is false, then the XML
 * namespace declarations are omitted, because they supposedly already
 * appeared earlier in the output.  Repeating them is not wrong, but
 * it looks ugly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xmldata_root_element_start</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eltname</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This isn't really wrong but currently makes no sense. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>top_level</name> <operator>||</operator> <operator>!</operator><name>xmlschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;%s"</literal></expr></argument>, <argument><expr><name>eltname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>top_level</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" xmlns:xsi=\""</literal> <name>NAMESPACE_XSI</name> <literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>targetns</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" xmlns=\"%s\""</literal></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>xmlschema</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* FIXME: better targets */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>targetns</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" xsi:schemaLocation=\"%s #\""</literal></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" xsi:noNamespaceSchemaLocation=\"#\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>xmldata_root_element_end</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eltname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;/%s&gt;\n"</literal></expr></argument>, <argument><expr><name>eltname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>query_to_xml_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmltn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <literal type="string">"table"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>,
								   <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>xmlschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_sql_row_to_xmlelement</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								  <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmltn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>table_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>map_sql_table_to_xmlschema</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
										<argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>cstring_to_xmltype</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>query_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_SPI_strdup</name><argument_list>(<argument><expr><call><name>map_sql_table_to_xmlschema</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
													<argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>cstring_to_xmltype</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>cursor_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xmlschema</name> <operator>=</operator> <call><name>_SPI_strdup</name><argument_list>(<argument><expr><call><name>map_sql_table_to_xmlschema</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
													   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
													   <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>cstring_to_xmltype</name><argument_list>(<argument><expr><name>xmlschema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>table_to_xml_and_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xmlschema</name> <operator>=</operator> <call><name>map_sql_table_to_xmlschema</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
										   <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>table_to_xml_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
																<argument><expr><name>xmlschema</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
																<argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>query_to_xml_and_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xmlschema</name> <operator>=</operator> <call><name>_SPI_strdup</name><argument_list>(<argument><expr><call><name>map_sql_table_to_xmlschema</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
													   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>query_to_xml_internal</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
																<argument><expr><name>xmlschema</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
																<argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Map SQL schema to XML and/or XML Schema document; see SQL/XML:2008
 * sections 9.13, 9.14.
 */</comment>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>schema_to_xml_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmlsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmlsn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmldata_root_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmlsn</name></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xmlschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid_list</name> <operator>=</operator> <call><name>schema_get_xml_visible_tables</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>subres</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subres</name> <operator>=</operator> <call><name>table_to_xml_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>,
									   <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>subres</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>subres</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmldata_root_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>schema_to_xml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>schema_to_xml_internal</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
																 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write the start element of the root element of an XML Schema mapping.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xsd_schema_element_start</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"&lt;xsd:schema\n"</literal>
						   <literal type="string">"    xmlns:xsd=\""</literal> <name>NAMESPACE_XSD</name> <literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>targetns</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"\n"</literal>
						 <literal type="string">"    targetNamespace=\"%s\"\n"</literal>
						 <literal type="string">"    elementFormDefault=\"qualified\""</literal></expr></argument>,
						 <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"&gt;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>xsd_schema_element_end</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;/xsd:schema&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>schema_to_xmlschema_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tupdesc_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid_list</name> <operator>=</operator> <call><name>schema_get_xml_visible_tables</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tupdesc_list</name></expr></argument>, <argument><expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><call><name>map_sql_typecoll_to_xmlschema_types</name><argument_list>(<argument><expr><name>tupdesc_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><call><name>map_sql_schema_to_xmlschema_types</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>relid_list</name></expr></argument>,
															 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>schema_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>schema_to_xmlschema_internal</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
																	   <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>schema_to_xml_and_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>xmlschema</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmlschema</name> <operator>=</operator> <call><name>schema_to_xmlschema_internal</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
											 <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>schema_to_xml_internal</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>,
																 <argument><expr><name><name>xmlschema</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
																 <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Map SQL database to XML and/or XML Schema document; see SQL/XML:2008
 * sections 9.16, 9.17.
 */</comment>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>database_to_xml_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xmlschema</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nspid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmlcn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmlcn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmldata_root_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmlcn</name></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xmlschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name>xmlschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspid_list</name> <operator>=</operator> <call><name>database_get_xml_visible_schemas</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nspid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>subres</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subres</name> <operator>=</operator> <call><name>schema_to_xml_internal</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
										<argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>subres</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>subres</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmldata_root_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmlcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>database_to_xml</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>database_to_xml_internal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
																   <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>database_to_xmlschema_internal</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nspid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tupdesc_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid_list</name> <operator>=</operator> <call><name>database_get_xml_visible_tables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspid_list</name> <operator>=</operator> <call><name>database_get_xml_visible_schemas</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tupdesc_list</name></expr></argument>, <argument><expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><call><name>map_sql_typecoll_to_xmlschema_types</name><argument_list>(<argument><expr><name>tupdesc_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						   <argument><expr><call><name>map_sql_catalog_to_xmlschema_types</name><argument_list>(<argument><expr><name>nspid_list</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>database_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>database_to_xmlschema_internal</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,
																		 <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>database_to_xml_and_xmlschema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nulls</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tableforest</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>xmlschema</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmlschema</name> <operator>=</operator> <call><name>database_to_xmlschema_internal</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_XML_P</name><argument_list>(<argument><expr><call><name>stringinfo_to_xmltype</name><argument_list>(<argument><expr><call><name>database_to_xml_internal</name><argument_list>(<argument><expr><name><name>xmlschema</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
																   <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tableforest</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Map a multi-part SQL name to an XML name; see SQL/XML:2008 section
 * 9.2.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_multipart_sql_identifier_to_xml_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>,
						 <argument><expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>,
						 <argument><expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>,
						 <argument><expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL table to an XML Schema document; see SQL/XML:2008
 * section 9.11.
 *
 * Map an SQL table to XML Schema data types; see SQL/XML:2008 section
 * 9.9.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_table_to_xmlschema</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmltn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tabletypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rowtypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reltuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tabletypename</name> <operator>=</operator> <call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><literal type="string">"TableType"</literal></expr></argument>,
																 <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rowtypename</name> <operator>=</operator> <call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><literal type="string">"RowType"</literal></expr></argument>,
															   <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <literal type="string">"row"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <literal type="string">"table"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>tabletypename</name> <operator>=</operator> <literal type="string">"TableType"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rowtypename</name> <operator>=</operator> <literal type="string">"RowType"</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><call><name>map_sql_typecoll_to_xmlschema_types</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
					 <argument><expr><literal type="string">"&lt;xsd:complexType name=\"%s\"&gt;\n"</literal>
					 <literal type="string">"  &lt;xsd:sequence&gt;\n"</literal></expr></argument>,
					 <argument><expr><name>rowtypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"    &lt;xsd:element name=\"%s\" type=\"%s\"%s&gt;&lt;/xsd:element&gt;\n"</literal></expr></argument>,
						 <argument><expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>map_sql_type_to_xml_name</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>nulls</name></expr> ?</condition><then> <expr><literal type="string">" nillable=\"true\""</literal></expr> </then><else>: <expr><literal type="string">" minOccurs=\"0\""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"  &lt;/xsd:sequence&gt;\n"</literal>
						   <literal type="string">"&lt;/xsd:complexType&gt;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"&lt;xsd:complexType name=\"%s\"&gt;\n"</literal>
						 <literal type="string">"  &lt;xsd:sequence&gt;\n"</literal>
						 <literal type="string">"    &lt;xsd:element name=\"row\" type=\"%s\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;\n"</literal>
						 <literal type="string">"  &lt;/xsd:sequence&gt;\n"</literal>
						 <literal type="string">"&lt;/xsd:complexType&gt;\n\n"</literal></expr></argument>,
						 <argument><expr><name>tabletypename</name></expr></argument>, <argument><expr><name>rowtypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"&lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n\n"</literal></expr></argument>,
						 <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>tabletypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"&lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n\n"</literal></expr></argument>,
						 <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>rowtypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>xsd_schema_element_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL schema to XML Schema data types; see SQL/XML:2008
 * section 9.12.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_schema_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relid_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmlsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schematypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmlsn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>schematypename</name> <operator>=</operator> <call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><literal type="string">"SchemaType"</literal></expr></argument>,
															  <argument><expr><name>dbname</name></expr></argument>,
															  <argument><expr><name>nspname</name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
					 <argument><expr><literal type="string">"&lt;xsd:complexType name=\"%s\"&gt;\n"</literal></expr></argument>, <argument><expr><name>schematypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><literal type="string">"  &lt;xsd:all&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><literal type="string">"  &lt;xsd:sequence&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmltn</name> <init>= <expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tabletypename</name> <init>= <expr><call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><ternary><condition><expr><name>tableforest</name></expr> ?</condition><then> <expr><literal type="string">"RowType"</literal></expr> </then><else>: <expr><literal type="string">"TableType"</literal></expr></else></ternary></expr></argument>,
																			 <argument><expr><name>dbname</name></expr></argument>,
																			 <argument><expr><name>nspname</name></expr></argument>,
																			 <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							 <argument><expr><literal type="string">"    &lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n"</literal></expr></argument>,
							 <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>tabletypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							 <argument><expr><literal type="string">"    &lt;xsd:element name=\"%s\" type=\"%s\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;\n"</literal></expr></argument>,
							 <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>tabletypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><literal type="string">"  &lt;/xsd:all&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><literal type="string">"  &lt;/xsd:sequence&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"&lt;/xsd:complexType&gt;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
					 <argument><expr><literal type="string">"&lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n\n"</literal></expr></argument>,
					 <argument><expr><name>xmlsn</name></expr></argument>, <argument><expr><name>schematypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL catalog to XML Schema data types; see SQL/XML:2008
 * section 9.15.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_catalog_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspid_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmlcn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catalogtypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmlcn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>catalogtypename</name> <operator>=</operator> <call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><literal type="string">"CatalogType"</literal></expr></argument>,
															   <argument><expr><name>dbname</name></expr></argument>,
															   <argument><expr><name>NULL</name></expr></argument>,
															   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
					 <argument><expr><literal type="string">"&lt;xsd:complexType name=\"%s\"&gt;\n"</literal></expr></argument>, <argument><expr><name>catalogtypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"  &lt;xsd:all&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nspid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmlsn</name> <init>= <expr><call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schematypename</name> <init>= <expr><call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><literal type="string">"SchemaType"</literal></expr></argument>,
																			  <argument><expr><name>dbname</name></expr></argument>,
																			  <argument><expr><name>nspname</name></expr></argument>,
																			  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"    &lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n"</literal></expr></argument>,
						 <argument><expr><name>xmlsn</name></expr></argument>, <argument><expr><name>schematypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"  &lt;/xsd:all&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						   <argument><expr><literal type="string">"&lt;/xsd:complexType&gt;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
					 <argument><expr><literal type="string">"&lt;xsd:element name=\"%s\" type=\"%s\"/&gt;\n\n"</literal></expr></argument>,
					 <argument><expr><name>xmlcn</name></expr></argument>, <argument><expr><name>catalogtypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL data type to an XML name; see SQL/XML:2008 section 9.4.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_type_to_xml_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>typeoid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"CHAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"CHAR_%d"</literal></expr></argument>, <argument><expr><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"VARCHAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"VARCHAR_%d"</literal></expr></argument>, <argument><expr><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"NUMERIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"NUMERIC_%d_%d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"INTEGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"SMALLINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"BIGINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"REAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"DOUBLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"BOOLEAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMEOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIME_%d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMETZOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIME_WTZ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIME_WTZ_%d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIMESTAMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIMESTAMP_%d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIMESTAMP_WTZ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"TIMESTAMP_WTZ_%d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"DATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XMLOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"XML"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><call><name>map_multipart_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>typtuple</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Domain"</literal></expr> </then><else>: <expr><literal type="string">"UDT"</literal></expr></else></ternary></expr></argument>,
																				<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
																				<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>typtuple</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
																				<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtuple</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map a collection of SQL data types to XML Schema data types; see
 * SQL/XML:2008 section 9.7.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_typecoll_to_xmlschema_types</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tupdesc_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>uniquetypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell0</name></decl>;</decl_stmt>

	<comment type="block">/* extract all column types used in the set of TupleDescs */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell0</argument>, <argument>tupdesc_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>uniquetypes</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>uniquetypes</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/* add base types of domains */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell0</argument>, <argument>uniquetypes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>basetypid</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>basetypid</name> <operator>!=</operator> <name>typid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>uniquetypes</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>uniquetypes</name></expr></argument>, <argument><expr><name>basetypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Convert to textual form */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell0</argument>, <argument>uniquetypes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>,
						 <argument><expr><call><name>map_sql_type_to_xmlschema_type</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell0</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL data type to a named XML Schema data type; see
 * SQL/XML:2008 sections 9.5 and 9.6.
 *
 * (The distinction between 9.5 and 9.6 is basically that 9.6 adds
 * a name attribute, which this function does.  The name-less version
 * 9.5 doesn't appear to be required anywhere.)
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>map_sql_type_to_xmlschema_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typename</name> <init>= <expr><call><name>map_sql_type_to_xml_name</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeoid</name> <operator>==</operator> <name>XMLOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
							   <argument><expr><literal type="string">"&lt;xsd:complexType mixed=\"true\"&gt;\n"</literal>
							   <literal type="string">"  &lt;xsd:sequence&gt;\n"</literal>
							   <literal type="string">"    &lt;xsd:any name=\"element\" minOccurs=\"0\" maxOccurs=\"unbounded\" processContents=\"skip\"/&gt;\n"</literal>
							   <literal type="string">"  &lt;/xsd:sequence&gt;\n"</literal>
							   <literal type="string">"&lt;/xsd:complexType&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
						 <argument><expr><literal type="string">"&lt;xsd:simpleType name=\"%s\"&gt;\n"</literal></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>typeoid</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BPCHAROID</name></expr>:</case>
			<case>case <expr><name>VARCHAROID</name></expr>:</case>
			<case>case <expr><name>TEXTOID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:string\"&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									 <argument><expr><literal type="string">"    &lt;xsd:maxLength value=\"%d\"/&gt;\n"</literal></expr></argument>,
									 <argument><expr><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>BYTEAOID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
								 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:%s\"&gt;\n"</literal>
								 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>,
								 <argument><expr><ternary><condition><expr><name>xmlbinary</name> <operator>==</operator> <name>XMLBINARY_BASE64</name></expr> ?</condition><then> <expr><literal type="string">"base64Binary"</literal></expr> </then><else>: <expr><literal type="string">"hexBinary"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>NUMERICOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:decimal\"&gt;\n"</literal>
									 <literal type="string">"    &lt;xsd:totalDigits value=\"%d\"/&gt;\n"</literal>
									 <literal type="string">"    &lt;xsd:fractionDigits value=\"%d\"/&gt;\n"</literal>
									 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>,
									 <argument><expr><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>INT2OID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
								 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:short\"&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:maxInclusive value=\"%d\"/&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:minInclusive value=\"%d\"/&gt;\n"</literal>
								 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>,
								 <argument><expr><name>SHRT_MAX</name></expr></argument>, <argument><expr><name>SHRT_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT4OID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
								 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:int\"&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:maxInclusive value=\"%d\"/&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:minInclusive value=\"%d\"/&gt;\n"</literal>
								 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>,
								 <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><name>INT_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>INT8OID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
								 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:long\"&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:maxInclusive value=\""</literal> <name>INT64_FORMAT</name> <literal type="string">"\"/&gt;\n"</literal>
								 <literal type="string">"    &lt;xsd:minInclusive value=\""</literal> <name>INT64_FORMAT</name> <literal type="string">"\"/&gt;\n"</literal>
								 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>FLOAT4OID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:float\"&gt;&lt;/xsd:restriction&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>FLOAT8OID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:double\"&gt;&lt;/xsd:restriction&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>BOOLOID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:boolean\"&gt;&lt;/xsd:restriction&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>TIMEOID</name></expr>:</case>
			<case>case <expr><name>TIMETZOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>typeoid</name> <operator>==</operator> <name>TIMETZOID</name></expr> ?</condition><then> <expr><literal type="string">"(\\+|-)\\p{Nd}{2}:\\p{Nd}{2}"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:time\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}(.\\p{Nd}+)?%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>typmod</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:time\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:time\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}.\\p{Nd}{%d}%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>typeoid</name> <operator>==</operator> <name>TIMESTAMPTZOID</name></expr> ?</condition><then> <expr><literal type="string">"(\\+|-)\\p{Nd}{2}:\\p{Nd}{2}"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:dateTime\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{4}-\\p{Nd}{2}-\\p{Nd}{2}T\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}(.\\p{Nd}+)?%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>typmod</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:dateTime\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{4}-\\p{Nd}{2}-\\p{Nd}{2}T\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
										 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:dateTime\"&gt;\n"</literal>
										 <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{4}-\\p{Nd}{2}-\\p{Nd}{2}T\\p{Nd}{2}:\\p{Nd}{2}:\\p{Nd}{2}.\\p{Nd}{%d}%s\"/&gt;\n"</literal>
										 <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>, <argument><expr><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>DATEOID</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									   <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"xsd:date\"&gt;\n"</literal>
									   <literal type="string">"    &lt;xsd:pattern value=\"\\p{Nd}{4}-\\p{Nd}{2}-\\p{Nd}{2}\"/&gt;\n"</literal>
									   <literal type="string">"  &lt;/xsd:restriction&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typeoid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>base_typmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>base_typeoid</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
									 <argument><expr><literal type="string">"  &lt;xsd:restriction base=\"%s\"/&gt;\n"</literal></expr></argument>,
									 <argument><expr><call><name>map_sql_type_to_xml_name</name><argument_list>(<argument><expr><name>base_typeoid</name></expr></argument>, <argument><expr><name>base_typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;/xsd:simpleType&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map an SQL row to an XML element, taking the row from the active
 * SPI cursor.  See also SQL/XML:2008 section 9.10.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SPI_sql_row_to_xmlelement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tableforest</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>top_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xmltn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tablename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <literal type="string">"row"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmltn</name> <operator>=</operator> <literal type="string">"table"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableforest</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_start</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmltn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>targetns</name></expr></argument>, <argument><expr><name>top_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;row&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>colval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>SPI_fname</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colval</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>rownum</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
							   <argument><expr><name>i</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nulls</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"  &lt;%s xsi:nil=\"true\"/&gt;\n"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"  &lt;%s&gt;%s&lt;/%s&gt;\n"</literal></expr></argument>,
							 <argument><expr><name>colname</name></expr></argument>,
							 <argument><expr><call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name>colval</name></expr></argument>,
														<argument><expr><call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>tableforest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xmldata_root_element_end</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>xmltn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"&lt;/row&gt;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * XPath related functions
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>

<comment type="block">/*
 * Convert XML node to text.
 *
 * For attribute and text nodes, return the escaped text.  For anything else,
 * dump the whole subtree.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>xml_xmlnodetoxmltype</name><parameter_list>(<parameter><decl><type><name>xmlNodePtr</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>XML_ATTRIBUTE_NODE</name> <operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>XML_TEXT_NODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><call><name>void</name>		<argument_list>(<argument><expr><operator>*</operator><specifier>volatile</specifier> <name>nodefree</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>xmlNodePtr</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlBufferPtr</name></type> <name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlNodePtr</name></type> <name>cur_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>bytes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmlBufferCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
							<argument><expr><literal type="string">"could not allocate xmlBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Produce a dump of the node that we can serialize.  xmlNodeDump
			 * does that, but the result of that function won't contain
			 * namespace definitions from ancestor nodes, so we first do a
			 * xmlCopyNode() which duplicates the node along with its required
			 * namespace definitions.
			 *
			 * Some old libxml2 versions such as 2.7.6 produce partially
			 * broken XML_DOCUMENT_NODE nodes (unset content field) when
			 * copying them.  xmlNodeDump of such a node works fine, but
			 * xmlFreeNode crashes; set us up to call xmlFreeDoc instead.
			 */</comment>
			<expr_stmt><expr><name>cur_copy</name> <operator>=</operator> <call><name>xmlCopyNode</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cur_copy</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
							<argument><expr><literal type="string">"could not copy node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nodefree</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cur_copy</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XML_DOCUMENT_NODE</name><operator>)</operator></expr> ?</condition><then>
				<expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>xmlNodePtr</name></expr></argument>)</argument_list></call><operator>)</operator> <name>xmlFreeDoc</name></expr> </then><else>: <expr><name>xmlFreeNode</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>xmlNodeDump</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cur_copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
							<argument><expr><literal type="string">"could not dump node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>xmlBuffer_to_xmltype</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nodefree</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>nodefree</name><argument_list>(<argument><expr><name>cur_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xmlBufferFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmlXPathCastNodeToString</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/* Here we rely on XML having the same representation as TEXT */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>escaped</name> <init>= <expr><call><name>escape_xml</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>xmltype</name> <operator>*</operator><operator>)</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>xmlFree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an XML XPath object (the result of evaluating an XPath expression)
 * to an array of xml values, which are appended to astate.  The function
 * result value is the number of elements in the array.
 *
 * If "astate" is NULL then we don't generate the array value, but we still
 * return the number of elements it would have had.
 *
 * Nodesets are converted to an array containing the nodes' textual
 * representations.  Primitive values (float, double, string) are converted
 * to a single-element array containing the value's string representation.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>xml_xpathobjtoxmlarray</name><parameter_list>(<parameter><decl><type><name>xmlXPathObjectPtr</name></type> <name>xpathobj</name></decl></parameter>,
					   <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
					   <parameter><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datumtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result_str</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XPATH_NODESET</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeNr</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>result</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>xml_xmlnodetoxmltype</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeTab</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
																	 <argument><expr><name>xmlerrcxt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>XMLOID</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>

		<case>case <expr><name>XPATH_BOOLEAN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>datumtype</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XPATH_NUMBER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>floatval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>datumtype</name> <operator>=</operator> <name>FLOAT8OID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XPATH_STRING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>astate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>xpathobj</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>datumtype</name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"xpath expression result type %d is unsupported"</literal></expr></argument>,
				 <argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* Common code for scalar-value cases */</comment>
	<expr_stmt><expr><name>result_str</name> <operator>=</operator> <call><name>map_sql_value_to_xml_value</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>datumtype</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_xmltype</name><argument_list>(<argument><expr><name>result_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>XMLOID</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Common code for xpath() and xmlexists()
 *
 * Evaluate XPath expression and return number of nodes in res_nitems
 * and array of XML values in astate.  Either of those pointers can be
 * NULL if the corresponding result isn't wanted.
 *
 * It is up to the user to ensure that the XML passed is in fact
 * an XML document - XPath doesn't work easily on fragments without
 * a context node being known.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xpath_internal</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>xpath_expr_text</name></decl></parameter>, <parameter><decl><type><name>xmltype</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_nitems</name></decl></parameter>, <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlParserCtxtPtr</name></type> <name>ctxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlDocPtr</name></type> <name>doc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlXPathContextPtr</name></type> <name>xpathctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlXPathCompExprPtr</name></type> <name>xpathcomp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlXPathObjectPtr</name></type> <name>xpathobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>datastr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>xpath_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>xpath_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>xmldecl_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>ns_names_uris</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>ns_names_uris_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ns_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Namespace mappings are passed as text[].  If an empty array is passed
	 * (ndim = 0, "0-dimensional"), then there are no namespace mappings.
	 * Else, a 2-dimensional array with length of the second axis being equal
	 * to 2 should be passed, i.e., every subarray contains 2 elements, the
	 * first element defining the name, the second one the URI.  Example:
	 * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',
	 * 'http://example2.com']].
	 */</comment>
	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <ternary><condition><expr><name>namespaces</name></expr> ?</condition><then> <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid array for XML namespace mapping"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The array must be two-dimensional with length of the second axis equal to 2."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>ns_names_uris</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ns_names_uris_nulls</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>ns_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ns_count</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* checked above */</comment>
		<expr_stmt><expr><name>ns_count</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>			<comment type="block">/* count pairs only */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ns_names_uris</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns_names_uris_nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>datastr</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xpath_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>xpath_expr_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xpath_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty XPath expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>datastr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xpath_expr</name> <operator>=</operator> <call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>xpath_expr_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xpath_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a UTF8 database, skip any xml declaration, which might assert
	 * another encoding.  Ignore parse_xml_decl() failure, letting
	 * xmlCtxtReadMemory() report parse errors.  Documentation disclaims
	 * xpath() support for non-ASCII data in non-UTF8 databases, so leave
	 * those scenarios bug-compatible with historical behavior.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parse_xml_decl</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xmldecl_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xmlerrcxt</name> <operator>=</operator> <call><name>pg_xml_init</name><argument_list>(<argument><expr><name>PG_XML_STRICTNESS_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xmlInitParser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * redundant XML parsing (two parsings for the same value during one
		 * command execution are possible)
		 */</comment>
		<expr_stmt><expr><name>ctxt</name> <operator>=</operator> <call><name>xmlNewParserCtxt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate parser context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xmlCtxtReadMemory</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>string</name> <operator>+</operator> <name>xmldecl_len</name></expr></argument>,
								<argument><expr><name>len</name> <operator>-</operator> <name>xmldecl_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>doc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_DOCUMENT</name></expr></argument>,
						<argument><expr><literal type="string">"could not parse XML document"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>xpathctx</name> <operator>=</operator> <call><name>xmlXPathNewContext</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathctx</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate XPath context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>xpathctx</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>xmlNodePtr</name><operator>)</operator> <name>doc</name></expr>;</expr_stmt>

		<comment type="block">/* register namespaces, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>ns_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ns_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ns_name</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ns_uri</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ns_names_uris_nulls</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>||</operator>
					<name><name>ns_names_uris_nulls</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"neither namespace name nor URI may be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ns_name</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>ns_names_uris</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns_uri</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>ns_names_uris</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>xmlXPathRegisterNs</name><argument_list>(<argument><expr><name>xpathctx</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>ns_name</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>xmlChar</name> <operator>*</operator><operator>)</operator> <name>ns_uri</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,	<comment type="block">/* is this an internal error??? */</comment>
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not register XML namespace with name \"%s\" and URI \"%s\""</literal></expr></argument>,
									<argument><expr><name>ns_name</name></expr></argument>, <argument><expr><name>ns_uri</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>xpathcomp</name> <operator>=</operator> <call><name>xmlXPathCompile</name><argument_list>(<argument><expr><name>xpath_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathcomp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
						<argument><expr><literal type="string">"invalid XPath expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Version 2.6.27 introduces a function named
		 * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,
		 * but we can derive the existence by whether any nodes are returned,
		 * thereby preventing a library version upgrade and keeping the code
		 * the same.
		 */</comment>
		<expr_stmt><expr><name>xpathobj</name> <operator>=</operator> <call><name>xmlXPathCompiledEval</name><argument_list>(<argument><expr><name>xpathcomp</name></expr></argument>, <argument><expr><name>xpathctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
						<argument><expr><literal type="string">"could not create XPath object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Extract the results as requested.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>res_nitems</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>res_nitems</name> <operator>=</operator> <call><name>xml_xpathobjtoxmlarray</name><argument_list>(<argument><expr><name>xpathobj</name></expr></argument>, <argument><expr><name>astate</name></expr></argument>, <argument><expr><name>xmlerrcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>xml_xpathobjtoxmlarray</name><argument_list>(<argument><expr><name>xpathobj</name></expr></argument>, <argument><expr><name>astate</name></expr></argument>, <argument><expr><name>xmlerrcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xpathobj</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlXPathFreeObject</name><argument_list>(<argument><expr><name>xpathobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathcomp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlXPathFreeCompExpr</name><argument_list>(<argument><expr><name>xpathcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathctx</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlXPathFreeContext</name><argument_list>(<argument><expr><name>xpathctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>doc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>xmlXPathFreeObject</name><argument_list>(<argument><expr><name>xpathobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlXPathFreeCompExpr</name><argument_list>(<argument><expr><name>xpathcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlXPathFreeContext</name><argument_list>(<argument><expr><name>xpathctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LIBXML */</comment>

<comment type="block">/*
 * Evaluate XPath expression and return array of XML values.
 *
 * As we have no support of XQuery sequences yet, this function seems
 * to be the most useful one (array of XML functions plays a role of
 * some kind of substitution for XQuery sequences).
 */</comment>
<function><type><name>Datum</name></type>
<name>xpath</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>xpath_expr_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>namespaces</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResult</name><argument_list>(<argument><expr><name>XMLOID</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xpath_internal</name><argument_list>(<argument><expr><name>xpath_expr_text</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>namespaces</name></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>makeArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Determines if the node specified by the supplied XPath exists
 * in a given XML document, returning a boolean.
 */</comment>
<function><type><name>Datum</name></type>
<name>xmlexists</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>xpath_expr_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_nitems</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>xpath_internal</name><argument_list>(<argument><expr><name>xpath_expr_text</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>res_nitems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res_nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Determines if the node specified by the supplied XPath exists
 * in a given XML document, returning a boolean. Differs from
 * xmlexists as it supports namespaces and is not defined in SQL/XML.
 */</comment>
<function><type><name>Datum</name></type>
<name>xpath_exists</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>xpath_expr_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_XML_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>namespaces</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_nitems</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>xpath_internal</name><argument_list>(<argument><expr><name>xpath_expr_text</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>namespaces</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>res_nitems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res_nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Functions for checking well-formed-ness
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>wellformed_xml</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>XmlOptionType</name></type> <name>xmloption_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlDocPtr</name></type> <name>doc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We want to catch any exceptions and return false */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xml_parse</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>xmloption_arg</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>doc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>xml_is_well_formed</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>wellformed_xml</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>xmloption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>xml_is_well_formed_document</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>wellformed_xml</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>XMLOPTION_DOCUMENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>xml_is_well_formed_content</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>wellformed_xml</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>XMLOPTION_CONTENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * support functions for XMLTABLE
 *
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>

<comment type="block">/*
 * Returns private data from executor state. Ensure validity by check with
 * MAGIC number.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>XmlTableBuilderData</name> <modifier>*</modifier></type>
<name>GetXmlTableBuilderPrivateData</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>TableFuncScanState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s called with invalid TableFuncScanState"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>XmlTableBuilderData</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>XMLTABLE_CONTEXT_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s called with invalid TableFuncScanState"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * XmlTableInitOpaque
 *		Fill in TableFuncScanState-&gt;opaque for XmlTable processor; initialize
 *		the XML parser.
 *
 * Note: Because we call pg_xml_init() here and pg_xml_done() in
 * XmlTableDestroyOpaque, it is critical for robustness that no other
 * executor nodes run until this node is processed to completion.  Caller
 * must execute this to completion (probably filling a tuplestore to exhaust
 * this node in a single pass) instead of using row-per-call mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableInitOpaque</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlParserCtxtPtr</name></type> <name>ctxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgXmlErrorContext</name> <modifier>*</modifier></type><name>xmlerrcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XmlTableBuilderData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>XMLTABLE_CONTEXT_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xmlXPathCompExprPtr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmlerrcxt</name> <operator>=</operator> <call><name>pg_xml_init</name><argument_list>(<argument><expr><name>PG_XML_STRICTNESS_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xmlInitParser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctxt</name> <operator>=</operator> <call><name>xmlNewParserCtxt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate parser context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ctxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name>xmlerrcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name> <operator>=</operator> <name>xmlerrcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>ctxt</name></name> <operator>=</operator> <name>ctxt</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>xtCxt</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableSetDocument
 *		Install the input document
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableSetDocument</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmltype</name>    <modifier>*</modifier></type><name>xmlval</name> <init>= <expr><call><name>DatumGetXmlP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>xstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlDocPtr</name></type> <name>doc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlXPathContextPtr</name></type> <name>xpathcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableSetDocument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use out function for casting to string (remove encoding property). See
	 * comment in xml_out.
	 */</comment>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xml_out_internal</name><argument_list>(<argument><expr><name>xmlval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xstr</name> <operator>=</operator> <call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name>xmlCtxtReadMemory</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>ctxt</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xstr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>doc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_XML_DOCUMENT</name></expr></argument>,
						<argument><expr><literal type="string">"could not parse XML document"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>xpathcxt</name> <operator>=</operator> <call><name>xmlXPathNewContext</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathcxt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>,
						<argument><expr><literal type="string">"could not allocate XPath context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>xpathcxt</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>xmlNodePtr</name><operator>)</operator> <name>doc</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xpathcxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlXPathFreeContext</name><argument_list>(<argument><expr><name>xpathcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>doc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>doc</name></name> <operator>=</operator> <name>doc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name> <operator>=</operator> <name>xpathcxt</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableSetNamespace
 *		Add a namespace declaration
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableSetNamespace</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DEFAULT namespace is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableSetNamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>xmlXPathRegisterNs</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name></expr></argument>,
						   <argument><expr><call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>,
					<argument><expr><literal type="string">"could not set XML namespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableSetRowFilter
 *		Install the row-filter Xpath expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableSetRowFilter</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>xstr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableSetRowFilter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row path filter must not be empty string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xstr</name> <operator>=</operator> <call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcomp</name></name> <operator>=</operator> <call><name>xmlXPathCompile</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcomp</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>,
					<argument><expr><literal type="string">"invalid XPath expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableSetColumnFilter
 *		Install the column-filter Xpath expression, for the given column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableSetColumnFilter</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>xstr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableSetColumnFilter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column path filter must not be empty string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xstr</name> <operator>=</operator> <call><name>pg_xmlCharStrndup</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>colnum</name></expr>]</index></name> <operator>=</operator> <call><name>xmlXPathCompile</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>colnum</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>,
					<argument><expr><literal type="string">"invalid XPath expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableFetchRow
 *		Prepare the next "current" tuple for upcoming GetValue calls.
 *		Returns false if the row-filter expression returned no more rows.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>XmlTableFetchRow</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableFetchRow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XmlTable returns table - set of composite values. The error context, is
	 * used for producement more values, between two calls, there can be
	 * created and used another libxml2 error context. It is libxml2 global
	 * value, so it should be refreshed any time before any libxml2 usage,
	 * that is finished by returning some value.
	 */</comment>
	<expr_stmt><expr><call><name>xmlSetStructuredErrorFunc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>xml_errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name> <operator>=</operator> <call><name>xmlXPathCompiledEval</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcomp</name></name></expr></argument>, <argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
						<argument><expr><literal type="string">"could not create XPath object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>row_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_NODESET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>row_count</name></name><operator>++</operator> <operator>&lt;</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeNr</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableGetValue
 *		Return the value for column number 'colnum' for the current row.  If
 *		column -1 is requested, return representation of the whole row.
 *
 * This leaks memory, so be sure to reset often the context in which it's
 * called.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>XmlTableGetValue</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colnum</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xmlNodePtr</name></type>	<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>xmlXPathObjectPtr</name></type> <name>xpathobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableGetValue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name> <operator>&amp;&amp;</operator>
		   <name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_NODESET</name> <operator>&amp;&amp;</operator>
		   <name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Propagate context related error context to libxml2 */</comment>
	<expr_stmt><expr><call><name>xmlSetStructuredErrorFunc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>xml_errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeTab</name><index>[<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>row_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>colnum</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Set current node as entry point for XPath evaluation */</comment>
		<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>

		<comment type="block">/* Evaluate column path */</comment>
		<expr_stmt><expr><name>xpathobj</name> <operator>=</operator> <call><name>xmlXPathCompiledEval</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>colnum</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xpathobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name><operator>-&gt;</operator><name>err_occurred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xml_ereport</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>,
						<argument><expr><literal type="string">"could not create XPath object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * There are four possible cases, depending on the number of nodes
		 * returned by the XPath expression and the type of the target column:
		 * a) XPath returns no nodes.  b) The target type is XML (return all
		 * as XML).  For non-XML return types:  c) One node (return content).
		 * d) Multiple nodes (error).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_NODESET</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeNr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>XMLOID</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>textstr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

					<comment type="block">/* Concatenate serialized values */</comment>
					<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>textstr</name> <operator>=</operator>
							<call><name>xml_xmlnodetoxmltype</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name><operator>-&gt;</operator><name>nodeTab</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><name>cstr</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one value returned by column XPath expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmlXPathCastNodeSetToString</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>nodesetval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cstr</name> <operator>=</operator> <ternary><condition><expr><name>str</name></expr> ?</condition><then> <expr><call><name>xml_pstrdup_and_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_STRING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Content should be escaped when target will be XML */</comment>
			<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>XMLOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>escape_xml</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>xpathobj</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>xpathobj</name><operator>-&gt;</operator><name>stringval</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_BOOLEAN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>typcategory</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typispreferred</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

			<comment type="block">/* Allow implicit casting from boolean to numbers */</comment>
			<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>typcategory</name> <operator>!=</operator> <name>TYPCATEGORY_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmlXPathCastBooleanToString</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmlXPathCastNumberToString</name><argument_list>(<argument><expr><call><name>xmlXPathCastBooleanToNumber</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>xml_pstrdup_and_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XPATH_NUMBER</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xmlChar</name>    <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmlXPathCastNumberToString</name><argument_list>(<argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>floatval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>xml_pstrdup_and_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected XPath object type %u"</literal></expr></argument>, <argument><expr><name><name>xpathobj</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * By here, either cstr contains the result value, or the isnull flag
		 * has been set.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cstr</name> <operator>||</operator> <operator>*</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>in_functions</name><index>[<expr><name>colnum</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>cstr</name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>typioparams</name><index>[<expr><name>colnum</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xpathobj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xmlXPathFreeObject</name><argument_list>(<argument><expr><name>xpathobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * XmlTableDestroyOpaque
 *		Release all libxml2 resources
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XmlTableDestroyOpaque</name><parameter_list>(<parameter><decl><type><name>TableFuncScanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LIBXML</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XmlTableBuilderData</name> <modifier>*</modifier></type><name>xtCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xtCxt</name> <operator>=</operator> <call><name>GetXmlTableBuilderPrivateData</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"XmlTableDestroyOpaque"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Propagate context related error context to libxml2 */</comment>
	<expr_stmt><expr><call><name>xmlSetStructuredErrorFunc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>xml_errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xtCxt</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>xmlXPathFreeCompExpr</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathscomp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlXPathFreeObject</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcomp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlXPathFreeCompExpr</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcomp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlXPathFreeContext</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xpathcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>doc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlFreeDoc</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>doc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xtCxt</name><operator>-&gt;</operator><name>ctxt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xmlFreeParserCtxt</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>ctxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_xml_done</name><argument_list>(<argument><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>xmlerrcxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* not valid anymore */</comment>
	<expr_stmt><expr><name><name>xtCxt</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>NO_XML_SUPPORT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_LIBXML */</comment>
</block_content>}</block></function>
</unit>
