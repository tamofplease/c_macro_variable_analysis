<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/adt/timestamp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * timestamp.c
 *	  Functions for the built-in SQL types "timestamp" and "interval".
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/timestamp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int128.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/supportnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>

<comment type="block">/*
 * gcc's -ffast-math switch breaks routines that expect exact results from
 * expressions like timeval / SECS_PER_HOUR, where timeval is double.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FAST_MATH__</name></cpp:ifdef>
<cpp:error>#<cpp:directive>error</cpp:directive> -ffast-math is known to break this code</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAMESIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((a) &lt; 0) == ((b) &lt; 0))</cpp:value></cpp:define>

<comment type="block">/* Set at postmaster start */</comment>
<decl_stmt><decl><type><name>TimestampTz</name></type> <name>PgStartTime</name></decl>;</decl_stmt>

<comment type="block">/* Set at configuration reload */</comment>
<decl_stmt><decl><type><name>TimestampTz</name></type> <name>PgReloadTime</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>finish</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>step_sign</name></decl>;</decl_stmt>
}</block></struct></type> <name>generate_series_timestamp_fctx</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>finish</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>step_sign</name></decl>;</decl_stmt>
}</block></struct></type> <name>generate_series_timestamptz_fctx</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>TimeOffset</name></type> <name>time2t</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>fsec_t</name></type> <name>fsec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Timestamp</name></type> <name>dt2local</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timezone</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustIntervalForTypmod</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>timestamp2timestamptz</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Timestamp</name></type> <name>timestamptz2timestamp</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* common code for timestamptypmodin and timestamptztypmodin */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>anytimestamp_typmodin</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>ta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>ArrayGetIntegerTypmods</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we're not too tense about good error message here because grammar
	 * shouldn't allow wrong number of modifiers for TIMESTAMP
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>anytimestamp_typmod_check</name><argument_list>(<argument><expr><name>istz</name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* exported so parse_expr.c can use it */</comment>
<function><type><name>int32</name></type>
<name>anytimestamp_typmod_check</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TIMESTAMP(%d)%s precision must not be negative"</literal></expr></argument>,
						<argument><expr><name>typmod</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" WITH TIME ZONE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;</operator> <name>MAX_TIMESTAMP_PRECISION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TIMESTAMP(%d)%s precision reduced to maximum allowed, %d"</literal></expr></argument>,
						<argument><expr><name>typmod</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" WITH TIME ZONE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><name>MAX_TIMESTAMP_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <name>MAX_TIMESTAMP_PRECISION</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typmod</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* common code for timestamptypmodout and timestamptztypmodout */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>anytimestamp_typmodout</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz</name> <init>= <expr><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" with time zone"</literal></expr> </then><else>: <expr><literal type="string">" without time zone"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%d)%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>typmod</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 USER I/O ROUTINES														 *
 *****************************************************************************/</comment>

<comment type="block">/* timestamp_in()
 * Convert a string to internal form.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDateTime</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SetEpochTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_LATE</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EARLY</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dtype %d while parsing timestamp \"%s\""</literal></expr></argument>,
				 <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamp_out()
 * Convert a timestamp to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timestamp_recv			- converts external binary format to timestamp
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>Timestamp</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* range check: see if timestamp_out would like it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			 <operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timestamp_send			- converts timestamp to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anytimestamp_typmodin</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anytimestamp_typmodout</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * timestamp_support()
 *
 * Planner support function for the timestamp_scale() and timestamptz_scale()
 * length coercion functions (we need not distinguish them here).
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>SupportRequestSimplify</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SupportRequestSimplify</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>SupportRequestSimplify</name> <operator>*</operator><operator>)</operator> <name>rawreq</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>TemporalSimplify</name><argument_list>(<argument><expr><name>MAX_TIMESTAMP_PRECISION</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>fcall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamp_scale()
 * Adjust time type for specified scale factor.
 * Used by PostgreSQL type system to stuff columns.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AdjustTimestampForTypmodError --- round off a timestamp to suit given typmod
 * Works for either timestamp or timestamptz.
 */</comment>
<function><type><name>bool</name></type>
<name>AdjustTimestampForTypmodError</name><parameter_list>(<parameter><decl><type><name>Timestamp</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>TimestampScales</name><index>[<expr><name>MAX_TIMESTAMP_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>TimestampOffsets</name><index>[<expr><name>MAX_TIMESTAMP_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><operator>*</operator><name>time</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>typmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>typmod</name> <operator>!=</operator> <name>MAX_TIMESTAMP_PRECISION</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>typmod</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>typmod</name></expr></argument> &gt;</argument_list></name> <name>MAX_TIMESTAMP_PRECISION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp(%d) precision must be between %d and %d"</literal></expr></argument>,
							<argument><expr><name>typmod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_TIMESTAMP_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>time</name> <operator>&gt;=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>time</name> <operator>+</operator> <name><name>TimestampOffsets</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <name><name>TimestampScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>*</operator>
				<name><name>TimestampScales</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>-</operator><operator>*</operator><name>time</name><operator>)</operator> <operator>+</operator> <name><name>TimestampOffsets</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <name><name>TimestampScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator>
					  <operator>*</operator> <name><name>TimestampScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AdjustTimestampForTypmod</name><parameter_list>(<parameter><decl><type><name>Timestamp</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>AdjustTimestampForTypmodError</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_in()
 * Convert a string to internal form.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDateTime</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"timestamp with time zone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SetEpochTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_LATE</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EARLY</name></expr>:</case>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dtype %d while parsing timestamptz \"%s\""</literal></expr></argument>,
				 <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Try to parse a timezone specification, and return its timezone offset value
 * if it's acceptable.  Otherwise, an error is thrown.
 *
 * Note: some code paths update tm-&gt;tm_isdst, and some don't; current callers
 * don't care, so we don't bother being consistent.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_sane_timezone</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>zone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tzname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the requested timezone.  First we try to interpret it as a
	 * numeric timezone specification; if DecodeTimezone decides it doesn't
	 * like the format, we look in the timezone abbreviation table (to handle
	 * cases like "EST"), and if that also fails, we look in the timezone
	 * database (to handle cases like "America/New_York").  (This matches the
	 * order in which timestamp input checks the cases; it's important because
	 * the timezone database unwisely uses a few zone names that are identical
	 * to offset abbreviations.)
	 *
	 * Note pg_tzset happily parses numeric input that DecodeTimezone would
	 * reject.  To avoid having it accept input that would otherwise be seen
	 * as invalid, it's enough to disallow having a digit in the first
	 * position of our input string.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>tzname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"numeric time zone"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Numeric time zones must have \"-\" or \"+\" as first character."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rt</name> <operator>=</operator> <call><name>DecodeTimezone</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowzone</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
					<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rt</name> <operator>==</operator> <name>DTERR_TZDISP_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"numeric time zone \"%s\" out of range"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>rt</name> <operator>!=</operator> <name>DTERR_BAD_FORMAT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* DecodeTimezoneAbbrev requires lowercase input */</comment>
		<expr_stmt><expr><name>lowzone</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>,
											   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowzone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TZ</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>DTZ</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fixed-offset abbreviation */</comment>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* dynamic-offset abbreviation, resolve using specified time */</comment>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneAbbrevOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* try it as a full zone name */</comment>
			<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tzp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_timestamp_internal
 *		workhorse for make_timestamp and make_timestamptz
 */</comment>
<function><type><specifier>static</specifier> <name>Timestamp</name></type>
<name>make_timestamp_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>month</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>day</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>sec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <name>year</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <name>month</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <name>day</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we'll reject zero or negative year values.  Perhaps negatives
	 * should be allowed to represent BC years?
	 */</comment>
	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ValidateDate</name><argument_list>(<argument><expr><name>DTK_DATE_M</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date field value out of range: %d-%02d-%02d"</literal></expr></argument>,
						<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: %d-%02d-%02d"</literal></expr></argument>,
						<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* Check for time overflow */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>float_time_overflows</name><argument_list>(<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time field value out of range: %d:%02d:%02g"</literal></expr></argument>,
						<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This should match tm2time */</comment>
	<expr_stmt><expr><name>time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name>min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator>
			<operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>date</name> <operator>*</operator> <name>USECS_PER_DAY</name> <operator>+</operator> <name>time</name></expr>;</expr_stmt>
	<comment type="block">/* check for major overflow */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>-</operator> <name>time</name><operator>)</operator> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>!=</operator> <name>date</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: %d-%02d-%02d %d:%02d:%02g"</literal></expr></argument>,
						<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>,
						<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check for just-barely overflow (okay except time-of-day wraps) */</comment>
	<comment type="block">/* caution: we want to allow 1999-12-31 24:00:00 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>date</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>date</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: %d-%02d-%02d %d:%02d:%02g"</literal></expr></argument>,
						<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>,
						<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* final range check catches just-out-of-range timestamps */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: %d-%02d-%02d %d:%02d:%02g"</literal></expr></argument>,
						<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>,
						<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_timestamp() - timestamp constructor
 */</comment>
<function><type><name>Datum</name></type>
<name>make_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>year</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>month</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mday</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hour</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>min</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>sec</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_timestamp_internal</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>,
									 <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_timestamptz() - timestamp with time zone constructor
 */</comment>
<function><type><name>Datum</name></type>
<name>make_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>year</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>month</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mday</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hour</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>min</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>sec</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_timestamp_internal</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>,
									 <argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><call><name>timestamp2timestamptz</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a timestamp with time zone.
 *		As above, but the time zone is specified as seventh argument.
 */</comment>
<function><type><name>Datum</name></type>
<name>make_timestamptz_at_timezone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>year</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>month</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mday</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hour</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>min</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>sec</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>make_timestamp_internal</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>,
										<argument><expr><name>hour</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>parse_sane_timezone</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>, <argument><expr><name>zone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>-</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * to_timestamp(double precision)
 * Convert UNIX epoch to timestamptz.
 */</comment>
<function><type><name>Datum</name></type>
<name>float8_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>seconds</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Deal with NaN and infinite inputs ... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Out of range? */</comment>
		<if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>&lt;</operator>
			<operator>(</operator><name>float8</name><operator>)</operator> <name>SECS_PER_DAY</name> <operator>*</operator> <operator>(</operator><name>DATETIME_MIN_JULIAN</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator>
			<operator>||</operator> <name>seconds</name> <operator>&gt;=</operator>
			<operator>(</operator><name>float8</name><operator>)</operator> <name>SECS_PER_DAY</name> <operator>*</operator> <operator>(</operator><name>TIMESTAMP_END_JULIAN</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: \"%g\""</literal></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Convert UNIX epoch to Postgres epoch */</comment>
		<expr_stmt><expr><name>seconds</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>seconds</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>seconds</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>seconds</name></expr>;</expr_stmt>

		<comment type="block">/* Recheck in case roundoff produces something just out of range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range: \"%g\""</literal></expr></argument>,
							<argument><expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_out()
 * Convert a timestamp to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timestamptz_recv			- converts external binary format to timestamptz
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* range check: see if timestamptz_out would like it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			 <operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timestamptz_send			- converts timestamptz to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptztypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anytimestamp_typmodin</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptztypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anytimestamp_typmodout</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamptz_scale()
 * Adjust time type for specified scale factor.
 * Used by PostgreSQL type system to stuff columns.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* interval_in()
 * Convert a string to internal form.
 *
 * External format(s):
 *	Uses the generic date/time parsing and decoding routines.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>INTERVAL_RANGE</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>range</name> <operator>=</operator> <name>INTERVAL_FULL_RANGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>field</name></expr></argument>,
						  <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeInterval</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><name>range</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if those functions think it's a bad format, try ISO8601 style */</comment>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <name>DTERR_BAD_FORMAT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeISO8601Interval</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <name>DTERR_FIELD_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dterr</name> <operator>=</operator> <name>DTERR_INTERVAL_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DELTA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>tm2interval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dtype %d while parsing interval \"%s\""</literal></expr></argument>,
				 <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>AdjustIntervalForTypmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* interval_out()
 * Convert a time span to external form.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>interval2tm</name><argument_list>(<argument><expr><operator>*</operator><name>span</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert interval to tm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>EncodeInterval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>IntervalStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		interval_recv			- converts external binary format to interval
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>interval</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AdjustIntervalForTypmod</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		interval_send			- converts interval to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The interval typmod stores a "range" in its high 16 bits and a "precision"
 * in its low 16 bits.  Both contribute to defining the resolution of the
 * type.  Range addresses resolution granules larger than one second, and
 * precision specifies resolution below one second.  This representation can
 * express all SQL standard resolutions, but we implement them all in terms of
 * truncating rightward from some position.  Range is a bitmap of permitted
 * fields, but only the temporally-smallest such field is significant to our
 * calculations.  Precision is a count of sub-second decimal places to retain.
 * Setting all bits (INTERVAL_FULL_PRECISION) gives the same truncation
 * semantics as choosing MAX_INTERVAL_PRECISION.
 */</comment>
<function><type><name>Datum</name></type>
<name>intervaltypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>ArrayGetIntegerTypmods</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tl[0] - interval range (fields bitmask)	tl[1] - precision (optional)
	 *
	 * Note we must validate tl[0] even though it's normally guaranteed
	 * correct by the grammar --- consider SELECT 'foo'::"interval"(1000).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<case>case <expr><name>INTERVAL_FULL_RANGE</name></expr>:</case>
				<comment type="block">/* all OK */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid INTERVAL type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INTERVAL_FULL_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>INTERVAL_TYPMOD</name><argument_list>(<argument><expr><name>INTERVAL_FULL_PRECISION</name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTERVAL(%d) precision must not be negative"</literal></expr></argument>,
							<argument><expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>MAX_INTERVAL_PRECISION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTERVAL(%d) precision reduced to maximum allowed, %d"</literal></expr></argument>,
							<argument><expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>INTERVAL_TYPMOD</name><argument_list>(<argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>INTERVAL_TYPMOD</name><argument_list>(<argument><expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid INTERVAL type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>intervaltypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>precision</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldstr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>INTERVAL_RANGE</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <call><name>INTERVAL_PRECISION</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>fields</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" year"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" month"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" day"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" hour"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" minute"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" second"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" year to month"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" day to hour"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" day to minute"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" day to second"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" hour to minute"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" hour to second"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">" minute to second"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INTERVAL_FULL_RANGE</name></expr>:</case>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid INTERVAL typmod: 0x%x"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fieldstr</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>!=</operator> <name>INTERVAL_FULL_PRECISION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s(%d)"</literal></expr></argument>, <argument><expr><name>fieldstr</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fieldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given an interval typmod value, return a code for the least-significant
 * field that the typmod allows to be nonzero, for instance given
 * INTERVAL DAY TO HOUR we want to identify "hour".
 *
 * The results should be ordered by field significance, which means
 * we can't use the dt.h macros YEAR etc, because for some odd reason
 * they aren't ordered that way.  Instead, arbitrarily represent
 * SECOND = 0, MINUTE = 1, HOUR = 2, DAY = 3, MONTH = 4, YEAR = 5.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>intervaltypmodleastfield</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* SECOND */</comment>

	<switch>switch <condition>(<expr><call><name>INTERVAL_RANGE</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">5</literal></expr>;</return>			<comment type="block">/* YEAR */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">4</literal></expr>;</return>			<comment type="block">/* MONTH */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">3</literal></expr>;</return>			<comment type="block">/* DAY */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">2</literal></expr>;</return>			<comment type="block">/* HOUR */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return>			<comment type="block">/* MINUTE */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* SECOND */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">4</literal></expr>;</return>			<comment type="block">/* MONTH */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">2</literal></expr>;</return>			<comment type="block">/* HOUR */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return>			<comment type="block">/* MINUTE */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* SECOND */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return>			<comment type="block">/* MINUTE */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* SECOND */</comment>
		<case>case <expr><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* SECOND */</comment>
		<case>case <expr><name>INTERVAL_FULL_RANGE</name></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* SECOND */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid INTERVAL typmod: 0x%x"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * interval_support()
 *
 * Planner support function for interval_scale().
 *
 * Flatten superfluous calls to interval_scale().  The interval typmod is
 * complex to permit accepting and regurgitating all SQL standard variations.
 * For truncation purposes, it boils down to a single, simple granularity.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>SupportRequestSimplify</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SupportRequestSimplify</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>SupportRequestSimplify</name> <operator>*</operator><operator>)</operator> <name>rawreq</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>req</name><operator>-&gt;</operator><name>fcall</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>typmod</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>source</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>new_typmod</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>noop</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>new_typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>noop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>old_typmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>old_least_field</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>new_least_field</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>old_precis</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>new_precis</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>old_least_field</name> <operator>=</operator> <call><name>intervaltypmodleastfield</name><argument_list>(<argument><expr><name>old_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_least_field</name> <operator>=</operator> <call><name>intervaltypmodleastfield</name><argument_list>(<argument><expr><name>new_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>old_typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>old_precis</name> <operator>=</operator> <name>INTERVAL_FULL_PRECISION</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>old_precis</name> <operator>=</operator> <call><name>INTERVAL_PRECISION</name><argument_list>(<argument><expr><name>old_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>new_precis</name> <operator>=</operator> <call><name>INTERVAL_PRECISION</name><argument_list>(<argument><expr><name>new_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Cast is a no-op if least field stays the same or decreases
				 * while precision stays the same or increases.  But
				 * precision, which is to say, sub-second precision, only
				 * affects ranges that include SECOND.
				 */</comment>
				<expr_stmt><expr><name>noop</name> <operator>=</operator> <operator>(</operator><name>new_least_field</name> <operator>&lt;=</operator> <name>old_least_field</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>old_least_field</name> <operator>&gt;</operator> <literal type="number">0</literal> <comment type="block">/* SECOND */</comment> <operator>||</operator>
					 <name>new_precis</name> <operator>&gt;=</operator> <name>MAX_INTERVAL_PRECISION</name> <operator>||</operator>
					 <name>new_precis</name> <operator>&gt;=</operator> <name>old_precis</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>noop</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>relabel_to_typmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>new_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* interval_scale()
 * Adjust interval type for specified fields.
 * Used by PostgreSQL type system to stuff columns.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>*</operator><name>interval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AdjustIntervalForTypmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Adjust interval for specified precision, in both YEAR to SECOND
 *	range and sub-second precision.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustIntervalForTypmod</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>IntervalScales</name><index>[<expr><name>MAX_INTERVAL_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>IntervalOffsets</name><index>[<expr><name>MAX_INTERVAL_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unspecified range and precision? Then not necessary to adjust. Setting
	 * typmod to -1 is the convention for all data types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>range</name> <init>= <expr><call><name>INTERVAL_RANGE</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>precision</name> <init>= <expr><call><name>INTERVAL_PRECISION</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Our interpretation of intervals with a limited set of fields is
		 * that fields to the right of the last one specified are zeroed out,
		 * but those to the left of it remain valid.  Thus for example there
		 * is no operational difference between INTERVAL YEAR TO MONTH and
		 * INTERVAL MONTH.  In some cases we could meaningfully enforce that
		 * higher-order fields are zero; for example INTERVAL DAY could reject
		 * nonzero "month" field.  However that seems a bit pointless when we
		 * can't do it consistently.  (We cannot enforce a range limit on the
		 * highest expected field, since we do not have any equivalent of
		 * SQL's &lt;interval leading field precision&gt;.)  If we ever decide to
		 * revisit this, interval_support will likely require adjusting.
		 *
		 * Note: before PG 8.4 we interpreted a limited set of fields as
		 * actually causing a "modulo" operation on a given value, potentially
		 * losing high-order as well as low-order information.  But there is
		 * no support for such behavior in the standard, and it seems fairly
		 * undesirable on data consistency grounds anyway.  Now we only
		 * perform truncation or rounding of low-order fields.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>range</name> <operator>==</operator> <name>INTERVAL_FULL_RANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do nothing... */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator> <operator>*</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* YEAR TO MONTH */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_HOUR</name><operator>)</operator> <operator>*</operator>
				<name>USECS_PER_HOUR</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator> <operator>*</operator>
				<name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fractional-second rounding will be dealt with below */</comment>
		</block_content>}</block></if>
		<comment type="block">/* DAY TO HOUR */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_HOUR</name><operator>)</operator> <operator>*</operator>
				<name>USECS_PER_HOUR</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* DAY TO MINUTE */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator> <operator>*</operator>
				<name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* DAY TO SECOND */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fractional-second rounding will be dealt with below */</comment>
		</block_content>}</block></if>
		<comment type="block">/* HOUR TO MINUTE */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_MINUTE</name><operator>)</operator> <operator>*</operator>
				<name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* HOUR TO SECOND */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>HOUR</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fractional-second rounding will be dealt with below */</comment>
		</block_content>}</block></if>
		<comment type="block">/* MINUTE TO SECOND */</comment>
		<if type="elseif">else if <condition>(<expr><name>range</name> <operator>==</operator> <operator>(</operator><call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>MINUTE</name></expr></argument>)</argument_list></call> <operator>|</operator>
						   <call><name>INTERVAL_MASK</name><argument_list>(<argument><expr><name>SECOND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fractional-second rounding will be dealt with below */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized interval typmod: %d"</literal></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Need to adjust sub-second precision? */</comment>
		<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>!=</operator> <name>INTERVAL_FULL_PRECISION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>precision</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>precision</name></expr></argument> &gt;</argument_list></name> <name>MAX_INTERVAL_PRECISION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval(%d) precision must be between %d and %d"</literal></expr></argument>,
								<argument><expr><name>precision</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAX_INTERVAL_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator>
								   <name><name>IntervalOffsets</name><index>[<expr><name>precision</name></expr>]</index></name><operator>)</operator> <operator>/</operator>
								  <name><name>IntervalScales</name><index>[<expr><name>precision</name></expr>]</index></name><operator>)</operator> <operator>*</operator>
					<name><name>IntervalScales</name><index>[<expr><name>precision</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>-</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator>
									 <name><name>IntervalOffsets</name><index>[<expr><name>precision</name></expr>]</index></name><operator>)</operator> <operator>/</operator>
									<name><name>IntervalScales</name><index>[<expr><name>precision</name></expr>]</index></name><operator>)</operator> <operator>*</operator>
								   <name><name>IntervalScales</name><index>[<expr><name>precision</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_interval - numeric Interval constructor
 */</comment>
<function><type><name>Datum</name></type>
<name>make_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>years</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>months</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>weeks</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>days</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hours</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mins</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>secs</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject out-of-range inputs.  We really ought to check the integer
	 * inputs as well, but it's not entirely clear what limits to apply.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>secs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name>years</name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>months</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name>weeks</name> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <name>days</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>secs</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>secs</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>hours</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>SECS_PER_HOUR</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator>
		<name>mins</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>SECS_PER_MINUTE</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator>
		<operator>(</operator><name>int64</name><operator>)</operator> <name>secs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* EncodeSpecialTimestamp()
 * Convert reserved timestamp data type to string.
 */</comment>
<function><type><name>void</name></type>
<name>EncodeSpecialTimestamp</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>EARLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>LATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid argument for EncodeSpecialTimestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>now</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>statement_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>clock_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_postmaster_start_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>PgStartTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_conf_load_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>PgReloadTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetCurrentTimestamp -- get the current operating system time
 *
 * Result is in the form of a TimestampTz value, and is expressed to the
 * full precision of the gettimeofday() syscall
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetCurrentTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <name><name>tp</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator>
		<operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name><name>tp</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSQLCurrentTimestamp -- implements CURRENT_TIMESTAMP, CURRENT_TIMESTAMP(n)
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetSQLCurrentTimestamp</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSQLLocalTimestamp -- implements LOCALTIMESTAMP, LOCALTIMESTAMP(n)
 */</comment>
<function><type><name>Timestamp</name></type>
<name>GetSQLLocalTimestamp</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>ts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>timestamptz2timestamp</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AdjustTimestampForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * timeofday(*) -- returns the current time as a text.
 */</comment>
<function><type><name>Datum</name></type>
<name>timeofday</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>templ</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>tt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>tp</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>templ</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>templ</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%a %b %d %H:%M:%S.%%06d %Y %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tt</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>templ</name></expr></argument>, <argument><expr><name><name>tp</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TimestampDifference -- convert the difference between two timestamps
 *		into integer seconds and microseconds
 *
 * This is typically used to calculate a wait timeout for select(2),
 * which explains the otherwise-odd choice of output format.
 *
 * Both inputs must be ordinary finite timestamps (in current usage,
 * they'll be results from GetCurrentTimestamp()).
 *
 * We expect start_time &lt;= stop_time.  If not, we return zeros,
 * since then we're already past the previously determined stop_time.
 */</comment>
<function><type><name>void</name></type>
<name>TimestampDifference</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stop_time</name></decl></parameter>,
					<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>secs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>microsecs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>diff</name> <init>= <expr><name>stop_time</name> <operator>-</operator> <name>start_time</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>secs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>microsecs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>secs</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>diff</name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>microsecs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>diff</name> <operator>%</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TimestampDifferenceMilliseconds -- convert the difference between two
 * 		timestamps into integer milliseconds
 *
 * This is typically used to calculate a wait timeout for WaitLatch()
 * or a related function.  The choice of "long" as the result type
 * is to harmonize with that.  It is caller's responsibility that the
 * input timestamps not be so far apart as to risk overflow of "long"
 * (which'd happen at about 25 days on machines with 32-bit "long").
 *
 * Both inputs must be ordinary finite timestamps (in current usage,
 * they'll be results from GetCurrentTimestamp()).
 *
 * We expect start_time &lt;= stop_time.  If not, we return zero,
 * since then we're already past the previously determined stop_time.
 *
 * Note we round up any fractional millisecond, since waiting for just
 * less than the intended timeout is undesirable.
 */</comment>
<function><type><name>long</name></type>
<name>TimestampDifferenceMilliseconds</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stop_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>diff</name> <init>= <expr><name>stop_time</name> <operator>-</operator> <name>start_time</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>diff</name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TimestampDifferenceExceeds -- report whether the difference between two
 *		timestamps is &gt;= a threshold (expressed in milliseconds)
 *
 * Both inputs must be ordinary finite timestamps (in current usage,
 * they'll be results from GetCurrentTimestamp()).
 */</comment>
<function><type><name>bool</name></type>
<name>TimestampDifferenceExceeds</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>,
						   <parameter><decl><type><name>TimestampTz</name></type> <name>stop_time</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>msec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>diff</name> <init>= <expr><name>stop_time</name> <operator>-</operator> <name>start_time</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>diff</name> <operator>&gt;=</operator> <name>msec</name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a time_t to TimestampTz.
 *
 * We do not use time_t internally in Postgres, but this is provided for use
 * by functions that need to interpret, say, a stat(2) result.
 *
 * To avoid having the function's ABI vary depending on the width of time_t,
 * we declare the argument as pg_time_t, which is cast-compatible with
 * time_t but always 64 bits wide (unless the platform has no 64-bit type).
 * This detail should be invisible to callers, at least at source code level.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>time_t_to_timestamptz</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <name>tm</name> <operator>-</operator>
		<operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>*=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a TimestampTz to time_t.
 *
 * This too is just marginally useful, but some places need it.
 *
 * To avoid having the function's ABI vary depending on the width of time_t,
 * we declare the result as pg_time_t, which is cast-compatible with
 * time_t but always 64 bits wide (unless the platform has no 64-bit type).
 * This detail should be invisible to callers, at least at source code level.
 */</comment>
<function><type><name>pg_time_t</name></type>
<name>timestamptz_to_time_t</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <operator>(</operator><name>t</name> <operator>/</operator> <name>USECS_PER_SEC</name> <operator>+</operator>
						  <operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Produce a C-string representation of a TimestampTz.
 *
 * This is mostly for use in emitting messages.  The primary difference
 * from timestamptz_out is that we force the output format to ISO.  Note
 * also that the result is in a static buffer, not pstrdup'd.
 *
 * See also pg_strftime.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>timestamptz_to_str</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>USE_ISO_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(timestamp out of range)"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>dt2time</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>jd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hour</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sec</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>time</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>time</name> <operator>=</operator> <name>jd</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>hour</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <operator>(</operator><operator>*</operator><name>hour</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <operator>(</operator><operator>*</operator><name>min</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sec</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <name>time</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* dt2time() */</comment>


<comment type="block">/*
 * timestamp2tm() - Convert timestamp data type to POSIX time structure.
 *
 * Note that year is _not_ 1900-based, but is an explicit full value.
 * Also, month is one-based, _not_ zero-based.
 * Returns:
 *	 0 on success
 *	-1 on out of range
 *
 * If attimezone is NULL, the global timezone setting will be used.
 */</comment>
<function><type><name>int</name></type>
<name>timestamp2tm</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tzn</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>attimezone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>utime</name></decl>;</decl_stmt>

	<comment type="block">/* Use session timezone if caller asks for default */</comment>
	<if_stmt><if>if <condition>(<expr><name>attimezone</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attimezone</name> <operator>=</operator> <name>session_timezone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>time</name> <operator>=</operator> <name>dt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TMODULO</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>time</name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>time</name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>date</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add offset to go from J2000 back to standard Julian date */</comment>
	<expr_stmt><expr><name>date</name> <operator>+=</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* Julian day routine does not work for negative Julian days */</comment>
	<if_stmt><if>if <condition>(<expr><macro><name>date</name></macro> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>date</name> <operator>&gt;</operator> <operator>(</operator><name>Timestamp</name><operator>)</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>date</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dt2time</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done if no TZ conversion wanted */</comment>
	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tzn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the time falls within the range of pg_time_t, use pg_localtime() to
	 * rotate to the local time zone.
	 *
	 * First, convert to an integral timestamp, avoiding possibly
	 * platform-specific roundoff-in-wrong-direction errors, and adjust to
	 * Unix epoch.  Then see if we can convert to pg_time_t without loss. This
	 * coding avoids hardwiring any assumptions about the width of pg_time_t,
	 * so it should behave sanely on machines without int64.
	 */</comment>
	<expr_stmt><expr><name>dt</name> <operator>=</operator> <operator>(</operator><name>dt</name> <operator>-</operator> <operator>*</operator><name>fsec</name><operator>)</operator> <operator>/</operator> <name>USECS_PER_SEC</name> <operator>+</operator>
		<operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>utime</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name>dt</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Timestamp</name><operator>)</operator> <name>utime</name> <operator>==</operator> <name>dt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tx</name> <init>= <expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>utime</name></expr></argument>, <argument><expr><name>attimezone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name><name>tx</name><operator>-&gt;</operator><name>tm_zone</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tzn</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * When out of range of pg_time_t, treat as GMT
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Mark this as *no* time zone available */</comment>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tzn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* tm2timestamp()
 * Convert a tm structure to a timestamp data type.
 * Note that year is _not_ 1900-based, but is an explicit full value.
 * Also, month is one-based, _not_ zero-based.
 *
 * Returns -1 on failure (value out of range).
 */</comment>
<function><type><name>int</name></type>
<name>tm2timestamp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>, <parameter><decl><type><name>Timestamp</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>time</name></decl>;</decl_stmt>

	<comment type="block">/* Prevent overflow in Julian-day routines */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>=</operator> <call><name>time2t</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>date</name> <operator>*</operator> <name>USECS_PER_DAY</name> <operator>+</operator> <name>time</name></expr>;</expr_stmt>
	<comment type="block">/* check for major overflow */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>result</name> <operator>-</operator> <name>time</name><operator>)</operator> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>!=</operator> <name>date</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* check for just-barely overflow (okay except time-of-day wraps) */</comment>
	<comment type="block">/* caution: we want to allow 1999-12-31 24:00:00 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>date</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>*</operator><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>date</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>*</operator><name>tzp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* final range check catches just-out-of-range timestamps */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* interval2tm()
 * Convert an interval data type to a tm structure.
 */</comment>
<function><type><name>int</name></type>
<name>interval2tm</name><parameter_list>(<parameter><decl><type><name>Interval</name></type> <name>span</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>tfrac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>month</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>month</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>span</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tfrac</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name>tfrac</name> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>tfrac</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name>tfrac</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tfrac</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name>tfrac</name> <operator>*</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>tfrac</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tfrac</name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <name>time</name> <operator>-</operator> <operator>(</operator><name>tfrac</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>tfrac</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>tm2interval</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>span</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_months</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_months</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>total_months</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name>total_months</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
					 <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator>
				   <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimeOffset</name></type>
<name>time2t</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>fsec_t</name></type> <name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name><operator>)</operator> <operator>+</operator> <name>min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name>sec</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Timestamp</name></type>
<name>dt2local</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dt</name> <operator>-=</operator> <operator>(</operator><name>tz</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>dt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 PUBLIC ROUTINES														 *
 *****************************************************************************/</comment>


<function><type><name>Datum</name></type>
<name>timestamp_finite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_finite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Relational operators for timestamp.
 *---------------------------------------------------------*/</comment>

<function><type><name>void</name></type>
<name>GetEpochTime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>t0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>epoch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>t0</name> <operator>=</operator> <call><name>pg_gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>t0</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert epoch to timestamp: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>t0</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Timestamp</name></type>
<name>SetEpochTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetEpochTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't bother to test for failure ... */</comment>
	<expr_stmt><expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dt</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* SetEpochTimestamp() */</comment>

<comment type="block">/*
 * We are currently sharing some code between timestamp and timestamptz.
 * The comparison functions are among them. - thomas 2001-09-25
 *
 *		timestamp_relop - is timestamp1 relop timestamp2
 */</comment>
<function><type><name>int</name></type>
<name>timestamp_cmp_internal</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>dt1</name></decl></parameter>, <parameter><decl><type><name>Timestamp</name></type> <name>dt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>dt1</name> <operator>&lt;</operator> <name>dt2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>dt1</name> <operator>&gt;</operator> <name>dt2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* note: this is used for timestamptz also */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>timestamp_fastcmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>a</name> <init>= <expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>b</name> <init>= <expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>timestamp_fastcmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>hashint8</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_hash_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>hashint8extended</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cross-type comparison functions for timestamp vs timestamptz
 */</comment>

<function><type><name>int32</name></type>
<name>timestamp_cmp_timestamptz_internal</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>timestampVal</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>overflow</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>timestamp2timestamptz_opt_overflow</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>overflow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dt1 is larger than any finite timestamp, but less than infinity */</comment>
		<return>return <expr><ternary><condition><expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>overflow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dt1 is less than any finite timestamp, but more than -infinity */</comment>
		<return>return <expr><ternary><condition><expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_eq_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ne_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_lt_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_gt_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_le_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ge_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_cmp_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_eq_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_ne_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_lt_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_gt_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_le_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_ge_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_cmp_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestampVal</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><call><name>timestamp_cmp_timestamptz_internal</name><argument_list>(<argument><expr><name>timestampVal</name></expr></argument>, <argument><expr><name>dt1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		interval_relop	- is interval1 relop interval2
 *
 * Interval comparison is based on converting interval values to a linear
 * representation expressed in the units of the time field (microseconds,
 * in the case of integer timestamps) with days assumed to be always 24 hours
 * and months assumed to be always 30 days.  To avoid overflow, we need a
 * wider-than-int64 datatype for the linear representation, so use INT128.
 */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>INT128</name></type>
<name>interval_cmp_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>INT128</name></type>		<name>span</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>dayfraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>days</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Separate time field into days and dayfraction, then add the month and
	 * day fields to the days part.  We cannot overflow int64 days here.
	 */</comment>
	<expr_stmt><expr><name>dayfraction</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>%</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>days</name> <operator>+=</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>

	<comment type="block">/* Widen dayfraction to 128 bits */</comment>
	<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>int64_to_int128</name><argument_list>(<argument><expr><name>dayfraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scale up days to microseconds, forming a 128-bit product */</comment>
	<expr_stmt><expr><call><name>int128_add_int64_mul_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>span</name></expr></argument>, <argument><expr><name>days</name></expr></argument>, <argument><expr><name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>span</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval_cmp_internal</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval1</name></decl></parameter>, <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>INT128</name></type>		<name>span1</name> <init>= <expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>INT128</name></type>		<name>span2</name> <init>= <expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>interval2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>int128_compare</name><argument_list>(<argument><expr><name>span1</name></expr></argument>, <argument><expr><name>span2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hashing for intervals
 *
 * We must produce equal hashvals for values that interval_cmp_internal()
 * considers equal.  So, compute the net span the same way it does,
 * and then hash that.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>INT128</name></type>		<name>span</name> <init>= <expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>span64</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use only the least significant 64 bits for hashing.  The upper 64 bits
	 * seldom add any useful information, and besides we must do it like this
	 * for compatibility with hashes calculated before use of INT128 was
	 * introduced.
	 */</comment>
	<expr_stmt><expr><name>span64</name> <operator>=</operator> <call><name>int128_to_int64</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashint8</name></expr></argument>, <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>span64</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_hash_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>INT128</name></type>		<name>span</name> <init>= <expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>span64</name></decl>;</decl_stmt>

	<comment type="block">/* Same approach as interval_hash */</comment>
	<expr_stmt><expr><name>span64</name> <operator>=</operator> <call><name>int128_to_int64</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>hashint8extended</name></expr></argument>, <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>span64</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* overlaps_timestamp() --- implements the SQL OVERLAPS operator.
 *
 * Algorithm is per SQL spec.  This is much harder than you'd think
 * because the spec requires us to deliver a non-null answer in some cases
 * where some of the inputs are null.
 */</comment>
<function><type><name>Datum</name></type>
<name>overlaps_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The arguments are Timestamps, but we leave them as generic Datums to
	 * avoid unnecessary conversions between value and reference forms --- not
	 * to mention possible dereferences of null pointers.
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_GT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>DatumGetBool(DirectFunctionCall2(timestamp_gt,t1,t2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_LT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>DatumGetBool(DirectFunctionCall2(timestamp_lt,t1,t2))</cpp:value></cpp:define>

	<comment type="block">/*
	 * If both endpoints of interval 1 are null, the result is null (unknown).
	 * If just one endpoint is null, take ts1 as the non-null one. Otherwise,
	 * take ts1 as the lesser endpoint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te1IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts1</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te1</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Likewise for interval 2. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te2IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_GT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts2</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te2</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point neither ts1 nor ts2 is null, so we can consider three
	 * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but
		 * in the presence of nulls it's not quite completely so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te1 is not null then we had ts1 &lt;= te1 above, and we just found
		 * ts1 &gt;= te2, hence te1 &gt;= te2.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_LT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te2 is not null then we had ts2 &lt;= te2 above, and we just found
		 * ts2 &gt;= te1, hence te2 &gt;= te1.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a
		 * rather silly way of saying "true if both are non-null, else null".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name> <operator>||</operator> <name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMESTAMP_GT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMESTAMP_LT</name></cpp:undef>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	"Arithmetic" operators on date/times.
 *---------------------------------------------------------*/</comment>

<function><type><name>Datum</name></type>
<name>timestamp_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* use timestamp_cmp_internal to be sure this agrees with comparisons */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dt1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dt2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dt1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dt2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>timestamp_mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot subtract infinite timestamps"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>dt1</name> <operator>-</operator> <name>dt2</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*----------
	 *	This is wrong, but removing it breaks a lot of regression tests.
	 *	For example:
	 *
	 *	test=&gt; SET timezone = 'EST5EDT';
	 *	test=&gt; SELECT
	 *	test-&gt; ('2005-10-30 13:22:00-05'::timestamptz -
	 *	test(&gt;	'2005-10-29 13:22:00-04'::timestamptz);
	 *	?column?
	 *	----------------
	 *	 1 day 01:00:00
	 *	 (1 row)
	 *
	 *	so adding that to the first timestamp gets:
	 *
	 *	 test=&gt; SELECT
	 *	 test-&gt; ('2005-10-29 13:22:00-04'::timestamptz +
	 *	 test(&gt; ('2005-10-30 13:22:00-05'::timestamptz -
	 *	 test(&gt;  '2005-10-29 13:22:00-04'::timestamptz)) at time zone 'EST';
	 *		timezone
	 *	--------------------
	 *	2005-10-30 14:22:00
	 *	(1 row)
	 *----------
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_justify_hours</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	interval_justify_interval()
 *
 *	Adjust interval so 'month', 'day', and 'time' portions are within
 *	customary bounds.  Specifically:
 *
 *		0 &lt;= abs(time) &lt; 24 hours
 *		0 &lt;= abs(day)  &lt; 30 days
 *
 *	Also, the sign bit on all three fields is made equal, so either
 *	all three fields are negative or all are positive.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_justify_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>wholeday</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>wholemonth</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TMODULO</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name>wholeday</name></expr></argument>, <argument><expr><name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <name>wholeday</name></expr>;</expr_stmt>	<comment type="block">/* could overflow... */</comment>

	<expr_stmt><expr><name>wholemonth</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>/</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>-=</operator> <name>wholemonth</name> <operator>*</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>+=</operator> <name>wholemonth</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>-=</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	interval_justify_hours()
 *
 *	Adjust interval so 'time' contains less than a whole day, adding
 *	the excess to 'day'.  This is useful for
 *	situations (such as non-TZ) where '1 day' = '24 hours' is valid,
 *	e.g. interval subtraction and division.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_justify_hours</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>wholeday</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TMODULO</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name>wholeday</name></expr></argument>, <argument><expr><name>USECS_PER_DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <name>wholeday</name></expr>;</expr_stmt>	<comment type="block">/* could overflow... */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	interval_justify_days()
 *
 *	Adjust interval so 'day' contains less than 30 days, adding
 *	the excess to 'month'.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_justify_days</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>wholemonth</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>wholemonth</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>/</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>-=</operator> <name>wholemonth</name> <operator>*</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>+=</operator> <name>wholemonth</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>-=</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamp_pl_interval()
 * Add an interval to a timestamp data type.
 * Note that interval has provisions for qualitative year/month and day
 *	units, so try to do the right thing with them.
 * To add a month, increment the month, and use the same day of month.
 * Then, if the next month has fewer days, set the day of month
 *	to the last day of month.
 * To add a day, increment the mday, and use the same time of day.
 * Lastly, add in the "quantitative time".
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_pl_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* adjust for end of month boundary problems... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>(</operator><name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>julian</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add days by converting to and from Julian */</comment>
			<expr_stmt><expr><name>julian</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>julian</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>timestamp</name> <operator>+=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_mi_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>tspan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>month</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>day</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tspan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* timestamptz_pl_interval()
 * Add an interval to a timestamp with time zone data type.
 * Note that interval has provisions for qualitative year/month
 *	units, so try to do the right thing with them.
 * To add a month, increment the month, and use the same day of month.
 * Then, if the next month has fewer days, set the day of month
 *	to the last day of month.
 * Lastly, add in the "quantitative time".
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_pl_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* adjust for end of month boundary problems... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&gt;</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>(</operator><name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>julian</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add days by converting to and from Julian */</comment>
			<expr_stmt><expr><name>julian</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>julian</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>timestamp</name> <operator>+=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_mi_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>tspan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>month</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>day</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tspan</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>-</operator><name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tspan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>interval_um</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>-</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<comment type="block">/* overflow check copied from int4um */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <operator>-</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <operator>-</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>interval_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* use interval_cmp_internal to be sure this agrees with comparisons */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>interval1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>interval2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>interval1</name></expr></argument>, <argument><expr><name>interval2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>interval1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>interval2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>month</name></name> <operator>+</operator> <name><name>span2</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<comment type="block">/* overflow check copied from int4pl */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator> <name><name>span2</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>day</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>span2</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span1</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span2</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>month</name></name> <operator>-</operator> <name><name>span2</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<comment type="block">/* overflow check copied from int4mi */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>day</name></name> <operator>-</operator> <name><name>span2</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>day</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>day</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>span1</name><operator>-&gt;</operator><name>time</name></name> <operator>-</operator> <name><name>span2</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>span1</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>span2</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SAMESIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>span1</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	There is no interval_abs():  it is unclear what value to return:
 *	  http://archives.postgresql.org/pgsql-general/2009-10/msg01031.php
 *	  http://archives.postgresql.org/pgsql-general/2009-11/msg00041.php
 */</comment>

<function><type><name>Datum</name></type>
<name>interval_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>factor</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>month_remainder_days</name></decl>,
				<decl><type ref="prev"/><name>sec_remainder</name></decl>,
				<decl><type ref="prev"/><name>result_double</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>orig_month</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>orig_day</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result_double</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>result_double</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name>result_double</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>result_double</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>result_double</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result_double</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>result_double</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name>result_double</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>result_double</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>result_double</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The above correctly handles the whole-number part of the month and day
	 * products, but we have to do something with any fractional part
	 * resulting when the factor is non-integral.  We cascade the fractions
	 * down to lower units using the conversion factors DAYS_PER_MONTH and
	 * SECS_PER_DAY.  Note we do NOT cascade up, since we are not forced to do
	 * so by the representation.  The user can choose to cascade up later,
	 * using justify_hours and/or justify_days.
	 */</comment>

	<comment type="block">/*
	 * Fractional months full days into days.
	 *
	 * Floating point calculation are inherently imprecise, so these
	 * calculations are crafted to produce the most reliable result possible.
	 * TSROUND() is needed to more accurately produce whole numbers where
	 * appropriate.
	 */</comment>
	<expr_stmt><expr><name>month_remainder_days</name> <operator>=</operator> <operator>(</operator><name>orig_month</name> <operator>*</operator> <name>factor</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>)</operator> <operator>*</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>month_remainder_days</name> <operator>=</operator> <call><name>TSROUND</name><argument_list>(<argument><expr><name>month_remainder_days</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec_remainder</name> <operator>=</operator> <operator>(</operator><name>orig_day</name> <operator>*</operator> <name>factor</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator>
					 <name>month_remainder_days</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>month_remainder_days</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec_remainder</name> <operator>=</operator> <call><name>TSROUND</name><argument_list>(<argument><expr><name>sec_remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Might have 24:00:00 hours due to rounding, or &gt;24 hours because of time
	 * cascade from months and days.  It might still be &gt;24 if the combination
	 * of cascade and the seconds factor operation itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>sec_remainder</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>SECS_PER_DAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>sec_remainder</name> <operator>/</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>sec_remainder</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>sec_remainder</name> <operator>/</operator> <name>SECS_PER_DAY</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* cascade units down */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>month_remainder_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_double</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>time</name></name> <operator>*</operator> <name>factor</name> <operator>+</operator> <name>sec_remainder</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>result_double</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FLOAT8_FITS_IN_INT64</name><argument_list>(<argument><expr><name>result_double</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>result_double</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>mul_d_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Args are float8 and Interval *, but leave them as generic Datum */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>factor</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>span</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mul</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>factor</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>month_remainder_days</name></decl>,
				<decl><type ref="prev"/><name>sec_remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>orig_month</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>month</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>orig_day</name> <init>= <expr><name><name>span</name><operator>-&gt;</operator><name>day</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>factor</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name><name>span</name><operator>-&gt;</operator><name>month</name></name> <operator>/</operator> <name>factor</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name><name>span</name><operator>-&gt;</operator><name>day</name></name> <operator>/</operator> <name>factor</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fractional months full days into days.  See comment in interval_mul().
	 */</comment>
	<expr_stmt><expr><name>month_remainder_days</name> <operator>=</operator> <operator>(</operator><name>orig_month</name> <operator>/</operator> <name>factor</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>month</name></name><operator>)</operator> <operator>*</operator> <name>DAYS_PER_MONTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>month_remainder_days</name> <operator>=</operator> <call><name>TSROUND</name><argument_list>(<argument><expr><name>month_remainder_days</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec_remainder</name> <operator>=</operator> <operator>(</operator><name>orig_day</name> <operator>/</operator> <name>factor</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+</operator>
					 <name>month_remainder_days</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>month_remainder_days</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sec_remainder</name> <operator>=</operator> <call><name>TSROUND</name><argument_list>(<argument><expr><name>sec_remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>sec_remainder</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>SECS_PER_DAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>sec_remainder</name> <operator>/</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>sec_remainder</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>sec_remainder</name> <operator>/</operator> <name>SECS_PER_DAY</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* cascade units down */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>+=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>month_remainder_days</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>factor</name> <operator>+</operator> <name>sec_remainder</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * in_range support functions for timestamps and intervals.
 *
 * Per SQL spec, we support these with interval as the offset type.
 * The spec's restriction that the offset not be negative is a bit hard to
 * decipher for intervals, but we choose to interpret it the same as our
 * interval comparison operators would.
 */</comment>

<function><type><name>Datum</name></type>
<name>in_range_timestamptz_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>val</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>base</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>sum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>int128_compare</name><argument_list>(<argument><expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int64_to_int128</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't currently bother to avoid overflow hazards here */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_mi_interval</name></expr></argument>,
													  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
													  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&lt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>in_range_timestamp_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>val</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>base</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>sum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>int128_compare</name><argument_list>(<argument><expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int64_to_int128</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't currently bother to avoid overflow hazards here */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>,
													<argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>,
													<argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&lt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>in_range_interval_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>sum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>int128_compare</name><argument_list>(<argument><expr><call><name>interval_cmp_value</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int64_to_int128</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't currently bother to avoid overflow hazards here */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mi</name></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>interval_cmp_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * interval_accum, interval_accum_inv, and interval_avg implement the
 * AVG(interval) aggregate.
 *
 * The transition datatype for this aggregate is a 2-element array of
 * intervals, where the first is the running sum and the second contains
 * the number of values so far in its 'time' field.  This is a bit ugly
 * but it beats inventing a specialized datatype for the purpose.
 */</comment>

<function><type><name>Datum</name></type>
<name>interval_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>newval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transdatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>sumX</name></decl>,
				<decl><type ref="prev"/><name>N</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>newsum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>,
					  <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>transdatums</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element interval array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsum</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>N</name><operator>.</operator><name>time</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>newsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transdatums1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transdatums2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>sum1</name></decl>,
				<decl><type ref="prev"/><name>N1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>sum2</name></decl>,
				<decl><type ref="prev"/><name>N2</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>newsum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>,
					  <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>transdatums1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatums1</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element interval array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sum1</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>N1</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>,
					  <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>transdatums2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatums2</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element interval array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sum2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>N2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsum</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum1</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>N1</name><operator>.</operator><name>time</name></name> <operator>+=</operator> <name><name>N2</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transdatums1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>newsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdatums1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>N1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>newval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transdatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>sumX</name></decl>,
				<decl><type ref="prev"/><name>N</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>newsum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>,
					  <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>transdatums</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element interval array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsum</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mi</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>N</name><operator>.</operator><name>time</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>newsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							 <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>interval_avg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>transdatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type>	<name>sumX</name></decl>,
				<decl><type ref="prev"/><name>N</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>,
					  <argument><expr><name>INTERVALOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_DOUBLE</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>transdatums</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element interval array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* SQL defines AVG of no values to be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>N</name><operator>.</operator><name>time</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_div</name></expr></argument>,
							   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>N</name><operator>.</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* timestamp_age()
 * Calculate time difference while retaining year/month fields.
 * Note that this does not result in an accurate absolute time span
 *	since year and month are out of context once the arithmetic
 *	is done.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_age</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>,
				<decl><type ref="prev"/><name>fsec1</name></decl>,
				<decl><type ref="prev"/><name>fsec2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm1</name> <init>= <expr><operator>&amp;</operator><name>tt1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm2</name> <init>= <expr><operator>&amp;</operator><name>tt2</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* form the symbolic difference */</comment>
		<expr_stmt><expr><name>fsec</name> <operator>=</operator> <name>fsec1</name> <operator>-</operator> <name>fsec2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>

		<comment type="block">/* flip sign if necessary... */</comment>
		<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* propagate any negative fields into the next higher field */</comment>
		<while>while <condition>(<expr><name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>+=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>MINS_PER_HOUR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>HOURS_PER_DAY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm1</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm1</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm2</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm2</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* recover sign if necessary... */</comment>
		<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>tm2interval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamptz_age()
 * Calculate time difference while retaining year/month fields.
 * Note that this does not result in an accurate absolute time span
 *	since year and month are out of context once the arithmetic
 *	is done.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_age</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>,
				<decl><type ref="prev"/><name>fsec1</name></decl>,
				<decl><type ref="prev"/><name>fsec2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm1</name> <init>= <expr><operator>&amp;</operator><name>tt1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm2</name> <init>= <expr><operator>&amp;</operator><name>tt2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz1</name></expr></argument>, <argument><expr><name>tm1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz2</name></expr></argument>, <argument><expr><name>tm2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* form the symbolic difference */</comment>
		<expr_stmt><expr><name>fsec</name> <operator>=</operator> <name>fsec1</name> <operator>-</operator> <name>fsec2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tm1</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <name><name>tm2</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>

		<comment type="block">/* flip sign if necessary... */</comment>
		<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* propagate any negative fields into the next higher field */</comment>
		<while>while <condition>(<expr><name>fsec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>+=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>+=</operator> <name>MINS_PER_HOUR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>HOURS_PER_DAY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm1</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm1</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>+=</operator> <name><name>day_tab</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm2</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>tm2</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+=</operator> <name>MONTHS_PER_YEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Note: we deliberately ignore any difference between tz1 and tz2.
		 */</comment>

		<comment type="block">/* recover sign if necessary... */</comment>
		<if_stmt><if>if <condition>(<expr><name>dt1</name> <operator>&lt;</operator> <name>dt2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>-</operator><name>fsec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>tm2interval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------
 *	Conversion operators.
 *---------------------------------------------------------*/</comment>


<comment type="block">/* timestamp_trunc()
 * Truncate timestamp to specified units.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_WEEK</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>woy</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>woy</name> <operator>=</operator> <call><name>date2isoweek</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If it is week 52/53 and the month is January, then the
					 * week must belong to the previous year. Also, some
					 * December dates belong to the next year.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>woy</name> <operator>&gt;=</operator> <literal type="number">52</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>--</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>woy</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>==</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>++</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>isoweek2date</name><argument_list>(<argument><expr><name>woy</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
				<comment type="block">/* see comments in timestamptz_trunc */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>-</operator> <literal type="number">999</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">999</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
				<comment type="block">/* see comments in timestamptz_trunc */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">99</literal><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>-</operator> <literal type="number">99</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">99</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_DECADE</name></expr>:</case>
				<comment type="block">/* see comments in timestamptz_trunc */</comment>
				<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>DTK_MILLENNIUM</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>!=</operator> <name>DTK_CENTURY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_DAY</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>(</operator><name>fsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for timestamptz_trunc() and timestamptz_trunc_zone().
 *
 * tzp identifies the zone to truncate with respect to.  We assume
 * infinite timestamps have already been rejected.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>timestamptz_trunc_internal</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>units</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>redotz</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_WEEK</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>woy</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>woy</name> <operator>=</operator> <call><name>date2isoweek</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If it is week 52/53 and the month is January, then the
					 * week must belong to the previous year. Also, some
					 * December dates belong to the next year.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>woy</name> <operator>&gt;=</operator> <literal type="number">52</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>--</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>woy</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>==</operator> <name>MONTHS_PER_YEAR</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>++</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>isoweek2date</name><argument_list>(<argument><expr><name>woy</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>redotz</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
				<comment type="block">/* one may consider DTK_THOUSAND and DTK_HUNDRED... */</comment>
			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>

				<comment type="block">/*
				 * truncating to the millennium? what is this supposed to
				 * mean? let us put the first year of the millennium... i.e.
				 * -1000, 1, 1001, 2001...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>-</operator> <literal type="number">999</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">999</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
				<comment type="block">/* truncating to the century? as above: -100, 1, 101... */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">99</literal><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>-</operator> <literal type="number">99</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">99</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_DECADE</name></expr>:</case>

				<comment type="block">/*
				 * truncating to the decade? first year of the decade. must
				 * not be applied if year was truncated before!
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>DTK_MILLENNIUM</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>!=</operator> <name>DTK_CENTURY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_DAY</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>redotz</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* for all cases &gt;= DAY */</comment>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>(</operator><name>fsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not "</literal>
								<literal type="string">"supported"</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>redotz</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* timestamptz_trunc()
 * Truncate timestamptz to specified units in session timezone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timestamptz_trunc_internal</name><argument_list>(<argument><expr><name>units</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_trunc_zone()
 * Truncate timestamptz to specified units in specified timezone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_trunc_zone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tzname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowzone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * timestamptz_zone() doesn't look up the zone for infinite inputs, so we
	 * don't do so here either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the requested timezone (see notes in timestamptz_zone()).
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DecodeTimezoneAbbrev requires lowercase input */</comment>
	<expr_stmt><expr><name>lowzone</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>,
										   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowzone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TZ</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>DTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fixed-offset abbreviation, get a pg_tz descriptor for that */</comment>
		<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset_offset</name><argument_list>(<argument><expr><operator>-</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dynamic-offset abbreviation, use its referenced timezone */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* try it as a full zone name */</comment>
		<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tzp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timestamptz_trunc_internal</name><argument_list>(<argument><expr><name>units</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* interval_trunc()
 * Extract specified field from interval.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>interval2tm</name><argument_list>(<argument><expr><operator>*</operator><name>interval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_DECADE</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_YEAR</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>/</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_MONTH</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_DAY</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_HOUR</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* FALL THRU */</comment>
				<case>case <expr><name>DTK_SECOND</name></expr>:</case>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
					<expr_stmt><expr><name>fsec</name> <operator>=</operator> <operator>(</operator><name>fsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>DTK_WEEK</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval units \"%s\" not supported "</literal>
										<literal type="string">"because months usually have fractional weeks"</literal></expr></argument>,
										<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval units \"%s\" not supported"</literal></expr></argument>,
										<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><call><name>tm2interval</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert interval to tm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* isoweek2j()
 *
 *	Return the Julian day which corresponds to the first day (Monday) of the given ISO 8601 year and week.
 *	Julian days are used to convert between ISO week dates and Gregorian dates.
 */</comment>
<function><type><name>int</name></type>
<name>isoweek2j</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>week</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>day0</name></decl>,
				<decl><type ref="prev"/><name>day4</name></decl>;</decl_stmt>

	<comment type="block">/* fourth day of current year */</comment>
	<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
	<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name>week</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>day4</name> <operator>-</operator> <name>day0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* isoweek2date()
 * Convert ISO week of year number to date.
 * The year field must be specified with the ISO year!
 * karel 2000/08/07
 */</comment>
<function><type><name>void</name></type>
<name>isoweek2date</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>woy</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>year</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mon</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mday</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><call><name>isoweek2j</name><argument_list>(<argument><expr><operator>*</operator><name>year</name></expr></argument>, <argument><expr><name>woy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* isoweekdate2date()
 *
 *	Convert an ISO 8601 week date (ISO year, ISO week) into a Gregorian date.
 *	Gregorian day of week sent so weekday strings can be supplied.
 *	Populates year, mon, and mday with the correct Gregorian values.
 *	year must be passed in as the ISO year.
 */</comment>
<function><type><name>void</name></type>
<name>isoweekdate2date</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isoweek</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wday</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>year</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mon</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mday</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>jday</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>jday</name> <operator>=</operator> <call><name>isoweek2j</name><argument_list>(<argument><expr><operator>*</operator><name>year</name></expr></argument>, <argument><expr><name>isoweek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */</comment>
	<if_stmt><if>if <condition>(<expr><name>wday</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>jday</name> <operator>+=</operator> <name>wday</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>jday</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>jday</name></expr></argument>, <argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* date2isoweek()
 *
 *	Returns ISO week number of year.
 */</comment>
<function><type><name>int</name></type>
<name>date2isoweek</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mon</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mday</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>day0</name></decl>,
				<decl><type ref="prev"/><name>day4</name></decl>,
				<decl><type ref="prev"/><name>dayn</name></decl>;</decl_stmt>

	<comment type="block">/* current day */</comment>
	<expr_stmt><expr><name>dayn</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fourth day of current year */</comment>
	<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
	<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need the first week containing a Thursday, otherwise this day falls
	 * into the previous year for purposes of counting weeks
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dayn</name> <operator>&lt;</operator> <name>day4</name> <operator>-</operator> <name>day0</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
		<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>dayn</name> <operator>-</operator> <operator>(</operator><name>day4</name> <operator>-</operator> <name>day0</name><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sometimes the last few days in a year will fall into the first week of
	 * the next year, so check for this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">52</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
		<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dayn</name> <operator>&gt;=</operator> <name>day4</name> <operator>-</operator> <name>day0</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>dayn</name> <operator>-</operator> <operator>(</operator><name>day4</name> <operator>-</operator> <name>day0</name><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* date2isoyear()
 *
 *	Returns ISO 8601 year number.
 *	Note: zero or negative results follow the year-zero-exists convention.
 */</comment>
<function><type><name>int</name></type>
<name>date2isoyear</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mon</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mday</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>day0</name></decl>,
				<decl><type ref="prev"/><name>day4</name></decl>,
				<decl><type ref="prev"/><name>dayn</name></decl>;</decl_stmt>

	<comment type="block">/* current day */</comment>
	<expr_stmt><expr><name>dayn</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fourth day of current year */</comment>
	<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
	<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need the first week containing a Thursday, otherwise this day falls
	 * into the previous year for purposes of counting weeks
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dayn</name> <operator>&lt;</operator> <name>day4</name> <operator>-</operator> <name>day0</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
		<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>year</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>dayn</name> <operator>-</operator> <operator>(</operator><name>day4</name> <operator>-</operator> <name>day0</name><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sometimes the last few days in a year will fall into the first week of
	 * the next year, so check for this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">52</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>day4</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* day0 == offset to first day of week (Monday) */</comment>
		<expr_stmt><expr><name>day0</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><name>day4</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dayn</name> <operator>&gt;=</operator> <name>day4</name> <operator>-</operator> <name>day0</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>year</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>year</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* date2isoyearday()
 *
 *	Returns the ISO 8601 day-of-year, given a Gregorian year, month and day.
 *	Possible return values are 1 through 371 (364 in non-leap years).
 */</comment>
<function><type><name>int</name></type>
<name>date2isoyearday</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mon</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mday</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>isoweek2j</name><argument_list>(<argument><expr><call><name>date2isoyear</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>mon</name></expr></argument>, <argument><expr><name>mday</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * NonFiniteTimestampTzPart
 *
 *	Used by timestamp_part and timestamptz_part when extracting from infinite
 *	timestamp[tz].  Returns +/-Infinity if that is the appropriate result,
 *	otherwise returns zero (which should be taken as meaning to return NULL).
 *
 *	Errors thrown here for invalid units should exactly match those that
 *	would be thrown in the calling functions, else there will be unexpected
 *	discrepancies between finite- and infinite-input cases.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>NonFiniteTimestampTzPart</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unit</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lowunits</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>isNegative</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>!=</operator> <name>UNITS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <name>RESERV</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isTz</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>unit</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* Oscillating units */</comment>
		<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
		<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
		<case>case <expr><name>DTK_SECOND</name></expr>:</case>
		<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
		<case>case <expr><name>DTK_HOUR</name></expr>:</case>
		<case>case <expr><name>DTK_DAY</name></expr>:</case>
		<case>case <expr><name>DTK_MONTH</name></expr>:</case>
		<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
		<case>case <expr><name>DTK_WEEK</name></expr>:</case>
		<case>case <expr><name>DTK_DOW</name></expr>:</case>
		<case>case <expr><name>DTK_ISODOW</name></expr>:</case>
		<case>case <expr><name>DTK_DOY</name></expr>:</case>
		<case>case <expr><name>DTK_TZ</name></expr>:</case>
		<case>case <expr><name>DTK_TZ_MINUTE</name></expr>:</case>
		<case>case <expr><name>DTK_TZ_HOUR</name></expr>:</case>
			<return>return <expr><literal type="number">0.0</literal></expr>;</return>

			<comment type="block">/* Monotonically-increasing units */</comment>
		<case>case <expr><name>DTK_YEAR</name></expr>:</case>
		<case>case <expr><name>DTK_DECADE</name></expr>:</case>
		<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
		<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
		<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
		<case>case <expr><name>DTK_ISOYEAR</name></expr>:</case>
		<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isNegative</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>isTz</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><literal type="number">0.0</literal></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* timestamp_part()
 * Extract specified field from timestamp.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_part</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>NonFiniteTimestampTzPart</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>,
										  <argument><expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DAY</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_WEEK</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>date2isoweek</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/* there is no year 0, just 1 BC and 1 AD */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DECADE</name></expr>:</case>

				<comment type="block">/*
				 * what is a decade wrt dates? let us assume that decade 199
				 * is 1990 thru 1999... decade 0 starts on year 1 BC, and -1
				 * is 11 BC thru 2 BC...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>

				<comment type="block">/* ----
				 * centuries AD, c&gt;0: year in [ (c-1)* 100 + 1 : c*100 ]
				 * centuries BC, c&lt;0: year in [ c*100 : (c+1) * 100 - 1]
				 * there is no number 0 century.
				 * ----
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">99</literal><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">99</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
				<comment type="block">/* see comments above. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">999</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator>
						   <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <operator>(</operator><name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_ISOYEAR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Adjust BC years */</comment>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DOW</name></expr>:</case>
			<case>case <expr><name>DTK_ISODOW</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>DTK_ISODOW</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DOY</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call>
						  <operator>-</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>
			<case>case <expr><name>DTK_TZ_MINUTE</name></expr>:</case>
			<case>case <expr><name>DTK_TZ_HOUR</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RESERV</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
				<expr_stmt><expr><name>epoch</name> <operator>=</operator> <call><name>SetEpochTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* try to avoid precision loss in subtraction */</comment>
				<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>&lt;</operator> <operator>(</operator><name>PG_INT64_MAX</name> <operator>+</operator> <name>epoch</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>-</operator> <name>epoch</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>timestamp</name> <operator>-</operator> <name>epoch</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp units \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_part()
 * Extract specified field from timestamp with time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_part</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>NonFiniteTimestampTzPart</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>,
										  <argument><expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_TZ</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>/=</operator> <name>MINS_PER_HOUR</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>MINS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>dummy</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DAY</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_WEEK</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>date2isoweek</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/* there is no year 0, just 1 BC and 1 AD */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DECADE</name></expr>:</case>
				<comment type="block">/* see comments in timestamp_part */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">8</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
				<comment type="block">/* see comments in timestamp_part */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">99</literal><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">99</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
				<comment type="block">/* see comments in timestamp_part */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><literal type="number">999</literal> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_JULIAN</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator>
						   <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <operator>(</operator><name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_ISOYEAR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Adjust BC years */</comment>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DOW</name></expr>:</case>
			<case>case <expr><name>DTK_ISODOW</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>j2day</name><argument_list>(<argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>DTK_ISODOW</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DOY</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call>
						  <operator>-</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RESERV</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
				<expr_stmt><expr><name>epoch</name> <operator>=</operator> <call><name>SetEpochTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* try to avoid precision loss in subtraction */</comment>
				<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>&lt;</operator> <operator>(</operator><name>PG_INT64_MAX</name> <operator>+</operator> <name>epoch</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>timestamp</name> <operator>-</operator> <name>epoch</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>timestamp</name> <operator>-</operator> <name>epoch</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp with time zone units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* interval_part()
 * Extract specified field from interval.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_part</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>interval2tm</name><argument_list>(<argument><expr><operator>*</operator><name>interval</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_SECOND</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_HOUR</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_DAY</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_MONTH</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>/</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_YEAR</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_DECADE</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
					<comment type="block">/* caution: C division may have negative remainder */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval units \"%s\" not supported"</literal></expr></argument>,
									<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not convert interval to tm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RESERV</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>==</operator> <name>DTK_EPOCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>DAYS_PER_YEAR</name> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>/</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>DAYS_PER_MONTH</name> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>%</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_DAY</name><operator>)</operator> <operator>*</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*	timestamp_zone()
 *	Encode timestamp type with specified time zone.
 *	This function is just timestamp2timestamptz() except instead of
 *	shifting to the global timezone, we shift to the specified timezone.
 *	This is different from the other AT TIME ZONE cases because instead
 *	of shifting _to_ a new time zone, it sets the time to _be_ the
 *	specified timezone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_zone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tzname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowzone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the requested timezone.  First we look in the timezone
	 * abbreviation table (to handle cases like "EST"), and if that fails, we
	 * look in the timezone database (to handle cases like
	 * "America/New_York").  (This matches the order in which timestamp input
	 * checks the cases; it's important because the timezone database unwisely
	 * uses a few zone names that are identical to offset abbreviations.)
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DecodeTimezoneAbbrev requires lowercase input */</comment>
	<expr_stmt><expr><name>lowzone</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>,
										   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowzone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TZ</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>DTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fixed-offset abbreviation */</comment>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dynamic-offset abbreviation, resolve using specified time */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><call><name>DetermineTimeZoneAbbrevOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* try it as a full zone name */</comment>
		<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzp</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Apply the timezone change */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamp_izone()
 * Encode timestamp type with specified time interval as time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_izone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>zone</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zone</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval time zone \"%s\" must not include months or days"</literal></expr></argument>,
						<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>,
															<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>zone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tz</name> <operator>=</operator> <name><name>zone</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* timestamp_izone() */</comment>

<comment type="block">/* TimestampTimestampTzRequiresRewrite()
 *
 * Returns false if the TimeZone GUC setting causes timestamp_timestamptz and
 * timestamptz_timestamp to be no-ops, where the return value has the same
 * bits as the argument.  Since project convention is to assume a GUC changes
 * no more often than STABLE functions change, the answer is valid that long.
 */</comment>
<function><type><name>bool</name></type>
<name>TimestampTimestampTzRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>offset</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_get_timezone_offset</name><argument_list>(<argument><expr><name>session_timezone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* timestamp_timestamptz()
 * Convert local timestamp to timestamp at GMT
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><call><name>timestamp2timestamptz</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert timestamp to timestamp with time zone.
 *
 * On successful conversion, *overflow is set to zero if it's not NULL.
 *
 * If the timestamp is finite but out of the valid range for timestamptz, then:
 * if overflow is NULL, we throw an out-of-range error.
 * if overflow is not NULL, we store +1 or -1 there to indicate the sign
 * of the overflow, and return the appropriate timestamptz infinity.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>timestamp2timestamptz_opt_overflow</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>timestamp</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We don't expect this to fail, but check it pro forma */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>-</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>overflow</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <name>MIN_TIMESTAMP</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Promote timestamp to timestamptz, throwing error for overflow.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>timestamp2timestamptz</name><parameter_list>(<parameter><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>timestamp2timestamptz_opt_overflow</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* timestamptz_timestamp()
 * Convert timestamp at GMT to local timestamp
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><call><name>timestamptz2timestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Timestamp</name></type>
<name>timestamptz2timestamp</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* timestamptz_zone()
 * Evaluate timestamp with time zone type at the specified time zone.
 * Returns a timestamp without time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_zone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tzname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowzone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the requested timezone.  First we look in the timezone
	 * abbreviation table (to handle cases like "EST"), and if that fails, we
	 * look in the timezone database (to handle cases like
	 * "America/New_York").  (This matches the order in which timestamp input
	 * checks the cases; it's important because the timezone database unwisely
	 * uses a few zone names that are identical to offset abbreviations.)
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DecodeTimezoneAbbrev requires lowercase input */</comment>
	<expr_stmt><expr><name>lowzone</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>,
										   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowzone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TZ</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>DTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fixed-offset abbreviation */</comment>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dynamic-offset abbreviation, resolve using specified time */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>isdst</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneAbbrevOffsetTS</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* try it as a full zone name */</comment>
		<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzp</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Apply the timezone change */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_izone()
 * Encode timestamp with time zone type with specified time interval as time zone.
 * Returns a timestamp without time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_izone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>zone</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zone</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval time zone \"%s\" must not include months or days"</literal></expr></argument>,
						<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>,
															<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>zone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>zone</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dt2local</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* generate_series_timestamp()
 * Generate the set of timestamps from start to finish by step
 */</comment>
<function><type><name>Datum</name></type>
<name>generate_series_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>generate_series_timestamp_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Timestamp</name></type>	<name>start</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Timestamp</name></type>	<name>finish</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name></type>	<name>interval_zero</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>generate_series_timestamp_fctx</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generate_series_timestamp_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use fctx to keep state from call to call. Seed current with the
		 * original start value
		 */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>finish</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <operator>*</operator><name>step</name></expr>;</expr_stmt>

		<comment type="block">/* Determine sign of the interval */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interval_zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>=</operator> <call><name>interval_cmp_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"step size cannot equal zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get the saved state and use current as the result for this iteration
	 */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
		<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> </then><else>:
		<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* increment current in preparation for next iteration */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>,
															  <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* do when there is more left to send */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* generate_series_timestamptz()
 * Generate the set of timestamps from start to finish by step
 */</comment>
<function><type><name>Datum</name></type>
<name>generate_series_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>generate_series_timestamptz_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>start</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>finish</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name></type>	<name>interval_zero</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>generate_series_timestamptz_fctx</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generate_series_timestamptz_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use fctx to keep state from call to call. Seed current with the
		 * original start value
		 */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>finish</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <operator>*</operator><name>step</name></expr>;</expr_stmt>

		<comment type="block">/* Determine sign of the interval */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interval_zero</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>=</operator> <call><name>interval_cmp_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"step size cannot equal zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get the saved state and use current as the result for this iteration
	 */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>fctx</name><operator>-&gt;</operator><name>step_sign</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
		<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr> </then><else>:
		<expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>finish</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* increment current in preparation for next iteration */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
																<argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr></argument>,
																<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* do when there is more left to send */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
