<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/misc/ps_status.c"><comment type="block">/*--------------------------------------------------------------------
 * ps_status.c
 *
 * Routines to support changing the ps display of PostgreSQL backends
 * to contain some useful information. Mechanism differs wildly across
 * platforms.
 *
 * src/backend/utils/misc/ps_status.c
 *
 * Copyright (c) 2000-2020, PostgreSQL Global Development Group
 * various details abducted from various places
 *--------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PSTAT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/pstat.h&gt;</cpp:file></cpp:include>			<comment type="block">/* for HP-UX */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PS_STRINGS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;machine/vmparam.h&gt;</cpp:file></cpp:include>	<comment type="block">/* for old BSD */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/exec.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crt_externs.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>update_process_title</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Alternative ways of updating ps display:
 *
 * PS_USE_SETPROCTITLE_FAST
 *	   use the function setproctitle_fast(const char *, ...)
 *	   (newer FreeBSD systems)
 * PS_USE_SETPROCTITLE
 *	   use the function setproctitle(const char *, ...)
 *	   (newer BSD systems)
 * PS_USE_PSTAT
 *	   use the pstat(PSTAT_SETCMD, )
 *	   (HPUX)
 * PS_USE_PS_STRINGS
 *	   assign PS_STRINGS-&gt;ps_argvstr = "string"
 *	   (some BSD systems)
 * PS_USE_CHANGE_ARGV
 *	   assign argv[0] = "string"
 *	   (some other BSD systems)
 * PS_USE_CLOBBER_ARGV
 *	   write over the argv and environment area
 *	   (Linux and most SysV-like systems)
 * PS_USE_WIN32
 *	   push the string out as the name of a Windows event
 * PS_USE_NONE
 *	   don't update ps display
 *	   (This is the default, as it is safest.)
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPROCTITLE_FAST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_SETPROCTITLE_FAST</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETPROCTITLE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_SETPROCTITLE</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PSTAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PSTAT_SETCMD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_PSTAT</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PS_STRINGS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_PS_STRINGS</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>BSD</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__hurd__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_CHANGE_ARGV</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BSD</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__svr5__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_CLOBBER_ARGV</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_WIN32</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_USE_NONE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Different systems want the buffer padded differently */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_PADDING</name></cpp:macro> <cpp:value>'\0'</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_PADDING</name></cpp:macro> <cpp:value>' '</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_NONE</name></cpp:ifndef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifndef>
<comment type="block">/* all but one option need a buffer to write their ps line in */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS_BUFFER_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ps_buffer</name><index>[<expr><name>PS_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>ps_buffer_size</name> <init>= <expr><name>PS_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* PS_USE_CLOBBER_ARGV */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ps_buffer</name></decl>;</decl_stmt>			<comment type="block">/* will point to argv area */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ps_buffer_size</name></decl>;</decl_stmt>	<comment type="block">/* space determined at run time */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>last_status_len</name></decl>;</decl_stmt>	<comment type="block">/* use to minimize length of clobber */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CLOBBER_ARGV */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ps_buffer_cur_len</name></decl>;</decl_stmt>	<comment type="block">/* nominal strlen(ps_buffer) */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ps_buffer_fixed_size</name></decl>;</decl_stmt> <comment type="block">/* size of the constant prefix */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not PS_USE_NONE */</comment>

<comment type="block">/* save the original argv[] location here */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>save_argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>save_argv</name></decl>;</decl_stmt>


<comment type="block">/*
 * Call this early in startup to save the original argc/argv values.
 * If needed, we make a copy of the original argv[] array to preserve it
 * from being clobbered by subsequent ps_display actions.
 *
 * (The original argv[] will not be overwritten by this routine, but may be
 * overwritten during init_ps_display.  Also, the physical location of the
 * environment strings may be moved, so this should be called before any code
 * that might try to hang onto a getenv() result.)
 *
 * Note that in case of failure this cannot call elog() as that is not
 * initialized yet.  We rely on write_stderr() instead.
 */</comment>
<function><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type>
<name>save_ps_display_args</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>save_argc</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_argv</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_CLOBBER_ARGV</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/*
	 * If we're going to overwrite the argv area, count the available space.
	 * Also move the environment to make additional room.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end_of_area</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>new_environ</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * check for contiguous argv strings
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>end_of_area</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>end_of_area</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>end_of_area</name> <operator>==</operator> <name>NULL</name></expr>)</condition>	<comment type="block">/* probably can't happen? */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>ps_buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ps_buffer_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>argv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * check for contiguous environ strings following argv
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>end_of_area</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>end_of_area</name> <operator>=</operator> <name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>ps_buffer</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_status_len</name> <operator>=</operator> <name>ps_buffer_size</name> <operator>=</operator> <name>end_of_area</name> <operator>-</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * move the environment out of the way
		 */</comment>
		<expr_stmt><expr><name>new_environ</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_environ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>new_environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>new_environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>environ</name> <operator>=</operator> <name>new_environ</name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CLOBBER_ARGV */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_CHANGE_ARGV</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_CLOBBER_ARGV</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/*
	 * If we're going to change the original argv[] then make a copy for
	 * argument parsing purposes.
	 *
	 * (NB: do NOT think to remove the copying of argv[], even though
	 * postmaster.c finishes looking at argv[] long before we ever consider
	 * changing the ps display.  On some platforms, getopt() keeps pointers
	 * into the argv array, and will get horribly confused when it is
	 * re-called to analyze a subprocess' argument string if the argv storage
	 * has been clobbered meanwhile.  Other platforms have other dependencies
	 * on argv[].
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>new_argv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_argv</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>argc</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_argv</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>new_argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>new_argv</name><index>[<expr><name>argc</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>

		<comment type="block">/*
		 * macOS (and perhaps other NeXT-derived platforms?) has a static copy
		 * of the argv pointer, which we may fix like so:
		 */</comment>
		<expr_stmt><expr><operator>*</operator><call><name>_NSGetArgv</name><argument_list>()</argument_list></call> <operator>=</operator> <name>new_argv</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>argv</name> <operator>=</operator> <name>new_argv</name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CHANGE_ARGV or PS_USE_CLOBBER_ARGV */</comment>

	<return>return <expr><name>argv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call this once during subprocess startup to set the identification
 * values.
 *
 * If fixed_part is NULL, a default will be obtained from MyBackendType.
 *
 * At this point, the original argv[] array may be overwritten.
 */</comment>
<function><type><name>void</name></type>
<name>init_ps_display</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fixed_part</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_NONE</name></cpp:ifndef>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_update_process_title</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fixed_part</name> <operator>||</operator> <name>MyBackendType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fixed_part</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fixed_part</name> <operator>=</operator> <call><name>GetBackendTypeDesc</name><argument_list>(<argument><expr><name>MyBackendType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_NONE</name></cpp:ifndef>
	<comment type="block">/* no ps display for stand-alone backend */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no ps display if you didn't call save_ps_display_args() */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save_argv</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifdef>
	<comment type="block">/* If ps_buffer is a pointer, it might still be null */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ps_buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Overwrite argv[] to point at appropriate space, if needed
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CHANGE_ARGV</name></cpp:ifdef>
	<expr_stmt><expr><name><name>save_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ps_buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>save_argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CHANGE_ARGV */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* make extra argv slots point at end_of_area (a NUL) */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>save_argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>save_argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ps_buffer</name> <operator>+</operator> <name>ps_buffer_size</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CLOBBER_ARGV */</comment>

	<comment type="block">/*
	 * Make fixed prefix of ps display.
	 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_SETPROCTITLE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_SETPROCTITLE_FAST</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/*
	 * apparently setproctitle() already adds a `progname:' prefix to the ps
	 * line
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROGRAM_NAME_PREFIX</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROGRAM_NAME_PREFIX</name></cpp:macro> <cpp:value>"postgres: "</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cluster_name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ps_buffer</name></expr></argument>, <argument><expr><name>ps_buffer_size</name></expr></argument>,
				 <argument><expr><name>PROGRAM_NAME_PREFIX</name> <literal type="string">"%s "</literal></expr></argument>,
				 <argument><expr><name>fixed_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ps_buffer</name></expr></argument>, <argument><expr><name>ps_buffer_size</name></expr></argument>,
				 <argument><expr><name>PROGRAM_NAME_PREFIX</name> <literal type="string">"%s: %s "</literal></expr></argument>,
				 <argument><expr><name>cluster_name</name></expr></argument>, <argument><expr><name>fixed_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ps_buffer_cur_len</name> <operator>=</operator> <name>ps_buffer_fixed_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On the first run, force the update.
	 */</comment>
	<expr_stmt><expr><name>save_update_process_title</name> <operator>=</operator> <name>update_process_title</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>update_process_title</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>update_process_title</name> <operator>=</operator> <name>save_update_process_title</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not PS_USE_NONE */</comment>
</block_content>}</block></function>



<comment type="block">/*
 * Call this to update the ps status display to a fixed prefix plus an
 * indication of what you're currently doing passed in the argument.
 */</comment>
<function><type><name>void</name></type>
<name>set_ps_display</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>activity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_NONE</name></cpp:ifndef>
	<comment type="block">/* update_process_title=off disables updates */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update_process_title</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no ps display for stand-alone backend */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifdef>
	<comment type="block">/* If ps_buffer is a pointer, it might still be null */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ps_buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Update ps_buffer to contain both fixed part and activity */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ps_buffer</name> <operator>+</operator> <name>ps_buffer_fixed_size</name></expr></argument>, <argument><expr><name>activity</name></expr></argument>,
			<argument><expr><name>ps_buffer_size</name> <operator>-</operator> <name>ps_buffer_fixed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ps_buffer_cur_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transmit new setting to kernel, if necessary */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_SETPROCTITLE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>setproctitle</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_USE_SETPROCTITLE_FAST</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>setproctitle_fast</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_PSTAT</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>union</name> <name>pstun</name></name></type> <name>pst</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pst</name><operator>.</operator><name>pst_command</name></name> <operator>=</operator> <name>ps_buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pstat</name><argument_list>(<argument><expr><name>PSTAT_SETCMD</name></expr></argument>, <argument><expr><name>pst</name></expr></argument>, <argument><expr><name>ps_buffer_cur_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_PSTAT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_PS_STRINGS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>PS_STRINGS</name><operator>-&gt;</operator><name>ps_nargvstr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>PS_STRINGS</name><operator>-&gt;</operator><name>ps_argvstr</name></name> <operator>=</operator> <name>ps_buffer</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_PS_STRINGS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifdef>
	<comment type="block">/* pad unused memory; need only clobber remainder of old status string */</comment>
	<if_stmt><if>if <condition>(<expr><name>last_status_len</name> <operator>&gt;</operator> <name>ps_buffer_cur_len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ps_buffer</name> <operator>+</operator> <name>ps_buffer_cur_len</name></expr></argument>, <argument><expr><name>PS_PADDING</name></expr></argument>,
			   <argument><expr><name>last_status_len</name> <operator>-</operator> <name>ps_buffer_cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>last_status_len</name> <operator>=</operator> <name>ps_buffer_cur_len</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_CLOBBER_ARGV */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_WIN32</name></cpp:ifdef>
	<block>{<block_content>
		<comment type="block">/*
		 * Win32 does not support showing any changed arguments. To make it at
		 * all possible to track which backend is doing what, we create a
		 * named object that can be viewed with for example Process Explorer.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>ident_handle</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>PS_BUFFER_SIZE</name> <operator>+</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ident_handle</name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>ident_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pgident(%d): %s"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>ps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ident_handle</name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* PS_USE_WIN32 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not PS_USE_NONE */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Returns what's currently in the ps display, in case someone needs
 * it.  Note that only the activity part is returned.  On some platforms
 * the string will not be null-terminated, so return the effective
 * length into *displen.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_ps_display</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>displen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_USE_CLOBBER_ARGV</name></cpp:ifdef>
	<comment type="block">/* If ps_buffer is a pointer, it might still be null */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ps_buffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>displen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PS_USE_NONE</name></cpp:ifndef>
	<expr_stmt><expr><operator>*</operator><name>displen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ps_buffer_cur_len</name> <operator>-</operator> <name>ps_buffer_fixed_size</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>ps_buffer</name> <operator>+</operator> <name>ps_buffer_fixed_size</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>*</operator><name>displen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="string">""</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
