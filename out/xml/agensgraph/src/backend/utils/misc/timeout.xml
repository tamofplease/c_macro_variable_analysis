<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/misc/timeout.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * timeout.c
 *	  Routines to multiplex SIGALRM interrupts for multiple timeout reasons.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/misc/timeout.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/* Data about any one timeout reason */</comment>
<typedef>typedef <type><struct>struct <name>timeout_params</name>
<block>{
	<decl_stmt><decl><type><name>TimeoutId</name></type>	<name>index</name></decl>;</decl_stmt>			<comment type="block">/* identifier of timeout reason */</comment>

	<comment type="block">/* volatile because these may be changed from the signal handler */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>active</name></decl>;</decl_stmt>		<comment type="block">/* true if timeout is in active_timeouts[] */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>indicator</name></decl>;</decl_stmt>	<comment type="block">/* true if timeout has occurred */</comment>

	<comment type="block">/* callback function for timeout, or NULL if timeout not registered */</comment>
	<decl_stmt><decl><type><name>timeout_handler_proc</name></type> <name>timeout_handler</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl>;</decl_stmt>		<comment type="block">/* time that timeout was last activated */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>fin_time</name></decl>;</decl_stmt>		<comment type="block">/* time it is, or was last, due to fire */</comment>
}</block></struct></type> <name>timeout_params</name>;</typedef>

<comment type="block">/*
 * List of possible timeout reasons in the order of enum TimeoutId.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>timeout_params</name></type> <name><name>all_timeouts</name><index>[<expr><name>MAX_TIMEOUTS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>all_timeouts_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of active timeouts ordered by their fin_time and priority.
 * This list is subject to change by the interrupt handler, so it's volatile.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>num_active_timeouts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>timeout_params</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name><name>active_timeouts</name><index>[<expr><name>MAX_TIMEOUTS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Flag controlling whether the signal handler is allowed to do anything.
 * We leave this "false" when we're not expecting interrupts, just in case.
 *
 * Note that we don't bother to reset any pending timer interrupt when we
 * disable the signal handler; it's not really worth the cycles to do so,
 * since the probability of the interrupt actually occurring while we have
 * it disabled is low.  See comments in schedule_alarm() about that.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>alarm_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>disable_alarm</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(alarm_enabled = false)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enable_alarm</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(alarm_enabled = true)</cpp:value></cpp:define>


<comment type="block" format="doxygen">/*****************************************************************************
 * Internal helper functions
 *
 * For all of these, it is caller's responsibility to protect them from
 * interruption by the signal handler.  Generally, call disable_alarm()
 * first to prevent interruption, then update state, and last call
 * schedule_alarm(), which will re-enable the signal handler if needed.
 *****************************************************************************/</comment>

<comment type="block">/*
 * Find the index of a given timeout reason in the active array.
 * If it's not there, return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_active_timeout</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_active_timeouts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>active_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert specified timeout reason into the list of active timeouts
 * at the given index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insert_timeout</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>index</name></expr></argument> &gt;</argument_list></name> <name>num_active_timeouts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"timeout index %d out of range 0..%d"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>,
			 <argument><expr><name>num_active_timeouts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_active_timeouts</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>index</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>active_timeouts</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>active_timeouts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>active_timeouts</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_active_timeouts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the index'th element from the timeout list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_timeout_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>index</name> <operator>&gt;=</operator> <name>num_active_timeouts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"timeout index %d out of range 0..%d"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>,
			 <argument><expr><name>num_active_timeouts</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>active_timeouts</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>active_timeouts</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_active_timeouts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>active_timeouts</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>active_timeouts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>num_active_timeouts</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enable the specified timeout reason
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_timeout</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>fin_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Assert request is sane */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>all_timeouts_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this timeout was already active, momentarily disable it.  We
	 * interpret the call as a directive to reschedule the timeout.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remove_timeout_index</name><argument_list>(<argument><expr><call><name>find_active_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find out the index where to insert the new timeout.  We sort by
	 * fin_time, and for equal fin_time by priority.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_active_timeouts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>timeout_params</name> <modifier>*</modifier></type><name>old_timeout</name> <init>= <expr><name><name>active_timeouts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fin_time</name> <operator>&lt;</operator> <name><name>old_timeout</name><operator>-&gt;</operator><name>fin_time</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fin_time</name> <operator>==</operator> <name><name>old_timeout</name><operator>-&gt;</operator><name>fin_time</name></name> <operator>&amp;&amp;</operator> <name>id</name> <operator>&lt;</operator> <name><name>old_timeout</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Mark the timeout active, and insert it into the active list.
	 */</comment>
	<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>fin_time</name> <operator>=</operator> <name>fin_time</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>insert_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Schedule alarm for the next active timeout, if any
 *
 * We assume the caller has obtained the current time, or a close-enough
 * approximation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>schedule_alarm</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>itimerval</name></name></type> <name>timeval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timeval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>itimerval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the time remaining till the nearest pending timeout */</comment>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>active_timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>fin_time</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's possible that the difference is less than a microsecond;
		 * ensure we don't cancel, rather than set, the interrupt.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>usecs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>usecs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>timeval</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>secs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeval</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>usecs</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must enable the signal handler before calling setitimer(); if we
		 * did it in the other order, we'd have a race condition wherein the
		 * interrupt could occur before we can set alarm_enabled, so that the
		 * signal handler would fail to do anything.
		 *
		 * Because we didn't bother to reset the timer in disable_alarm(),
		 * it's possible that a previously-set interrupt will fire between
		 * enable_alarm() and setitimer().  This is safe, however.  There are
		 * two possible outcomes:
		 *
		 * 1. The signal handler finds nothing to do (because the nearest
		 * timeout event is still in the future).  It will re-set the timer
		 * and return.  Then we'll overwrite the timer value with a new one.
		 * This will mean that the timer fires a little later than we
		 * intended, but only by the amount of time it takes for the signal
		 * handler to do nothing useful, which shouldn't be much.
		 *
		 * 2. The signal handler executes and removes one or more timeout
		 * events.  When it returns, either the queue is now empty or the
		 * frontmost event is later than the one we looked at above.  So we'll
		 * overwrite the timer value with one that is too soon (plus or minus
		 * the signal handler's execution time), causing a useless interrupt
		 * to occur.  But the handler will then re-set the timer and
		 * everything will still work as expected.
		 *
		 * Since these cases are of very low probability (the window here
		 * being quite narrow), it's not worth adding cycles to the mainline
		 * code to prevent occasional wasted interrupts.
		 */</comment>
		<expr_stmt><expr><call><name>enable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set the alarm timer */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>setitimer</name><argument_list>(<argument><expr><name>ITIMER_REAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not enable SIGALRM timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 * Signal handler
 *****************************************************************************/</comment>

<comment type="block">/*
 * Signal handler for SIGALRM
 *
 * Process any active timeout reasons and then reschedule the interrupt
 * as needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sig_alarm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Bump the holdoff counter, to make sure nothing we call will process
	 * interrupts directly. No timeout handler should do that, but these
	 * failures are hard to debug, so better be sure.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SIGALRM is always cause for waking anything waiting on the process
	 * latch.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fire any pending timeouts, but only if we're enabled to do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>alarm_enabled</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Disable alarms, just in case this platform allows signal handlers
		 * to interrupt themselves.  schedule_alarm() will re-enable if
		 * appropriate.
		 */</comment>
		<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* While the first pending timeout has been reached ... */</comment>
			<while>while <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				   <name>now</name> <operator>&gt;=</operator> <name><name>active_timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>fin_time</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>timeout_params</name> <modifier>*</modifier></type><name>this_timeout</name> <init>= <expr><name><name>active_timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Remove it from the active list */</comment>
				<expr_stmt><expr><call><name>remove_timeout_index</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Mark it as fired */</comment>
				<expr_stmt><expr><name><name>this_timeout</name><operator>-&gt;</operator><name>indicator</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* And call its handler function */</comment>
				<expr_stmt><expr><call><name><name>this_timeout</name><operator>-&gt;</operator><name>timeout_handler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * The handler might not take negligible time (CheckDeadLock
				 * for instance isn't too cheap), so let's update our idea of
				 * "now" after each one.
				 */</comment>
				<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/* Done firing timeouts, so reschedule next interrupt if any */</comment>
			<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 * Public API
 *****************************************************************************/</comment>

<comment type="block">/*
 * Initialize timeout module.
 *
 * This must be called in every process that wants to use timeouts.
 *
 * If the process was forked from another one that was also using this
 * module, be sure to call this before re-enabling signals; else handlers
 * meant to run in the parent process might get invoked in this one.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeTimeouts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize, or re-initialize, all local state */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_active_timeouts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_TIMEOUTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fin_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>all_timeouts_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Now establish the signal handler */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>handle_sig_alarm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a timeout reason
 *
 * For predefined timeouts, this just registers the callback function.
 *
 * For user-defined timeouts, pass id == USER_TIMEOUT; we then allocate and
 * return a timeout ID.
 */</comment>
<function><type><name>TimeoutId</name></type>
<name>RegisterTimeout</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>timeout_handler_proc</name></type> <name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>all_timeouts_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There's no need to disable the signal handler here. */</comment>

	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;=</operator> <name>USER_TIMEOUT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate a user-defined timeout reason */</comment>
		<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <name>USER_TIMEOUT</name></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>MAX_TIMEOUTS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;=</operator> <name>MAX_TIMEOUTS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add more timeout reasons"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>

	<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reschedule any pending SIGALRM interrupt.
 *
 * This can be used during error recovery in case query cancel resulted in loss
 * of a SIGALRM event (due to longjmp'ing out of handle_sig_alarm before it
 * could do anything).  But note it's not necessary if any of the public
 * enable_ or disable_timeout functions are called in the same area, since
 * those all do schedule_alarm() internally if needed.
 */</comment>
<function><type><name>void</name></type>
<name>reschedule_timeouts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* For flexibility, allow this to be called before we're initialized. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_timeouts_initialized</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reschedule the interrupt, if any timeouts remain active. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enable the specified timeout to fire after the specified delay.
 *
 * Delay is given in milliseconds.
 */</comment>
<function><type><name>void</name></type>
<name>enable_timeout_after</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delay_ms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>fin_time</name></decl>;</decl_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Queue the timeout at the appropriate time. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fin_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>delay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enable_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>fin_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the timer interrupt. */</comment>
	<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enable the specified timeout to fire at the specified time.
 *
 * This is provided to support cases where there's a reason to calculate
 * the timeout by reference to some point other than "now".  If there isn't,
 * use enable_timeout_after(), to avoid calling GetCurrentTimestamp() twice.
 */</comment>
<function><type><name>void</name></type>
<name>enable_timeout_at</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>fin_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Queue the timeout at the appropriate time. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enable_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>fin_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the timer interrupt. */</comment>
	<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enable multiple timeouts at once.
 *
 * This works like calling enable_timeout_after() and/or enable_timeout_at()
 * multiple times.  Use this to reduce the number of GetCurrentTimestamp()
 * and setitimer() calls needed to establish multiple timeouts.
 */</comment>
<function><type><name>void</name></type>
<name>enable_timeouts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>EnableTimeoutParams</name> <modifier>*</modifier></type><name>timeouts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Queue the timeout(s) at the appropriate times. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeoutId</name></type>	<name>id</name> <init>= <expr><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>fin_time</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TMPARAM_AFTER</name></expr>:</case>
				<expr_stmt><expr><name>fin_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>now</name></expr></argument>,
													   <argument><expr><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>delay_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>enable_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>fin_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>TMPARAM_AT</name></expr>:</case>
				<expr_stmt><expr><call><name>enable_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fin_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized timeout type %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* Set the timer interrupt. */</comment>
	<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel the specified timeout.
 *
 * The timeout's I've-been-fired indicator is reset,
 * unless keep_indicator is true.
 *
 * When a timeout is canceled, any other active timeout remains in force.
 * It's not an error to disable a timeout that is not enabled.
 */</comment>
<function><type><name>void</name></type>
<name>disable_timeout</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep_indicator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Assert request is sane */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>all_timeouts_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the timeout and remove it from the active list. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remove_timeout_index</name><argument_list>(<argument><expr><call><name>find_active_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Mark it inactive, whether it was active or not. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keep_indicator</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reschedule the interrupt, if any timeouts remain active. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel multiple timeouts at once.
 *
 * The timeouts' I've-been-fired indicators are reset,
 * unless timeouts[i].keep_indicator is true.
 *
 * This works like calling disable_timeout() multiple times.
 * Use this to reduce the number of GetCurrentTimestamp()
 * and setitimer() calls needed to cancel multiple timeouts.
 */</comment>
<function><type><name>void</name></type>
<name>disable_timeouts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DisableTimeoutParams</name> <modifier>*</modifier></type><name>timeouts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>all_timeouts_initialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disable timeout interrupts for safety. */</comment>
	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel the timeout(s). */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeoutId</name></type>	<name>id</name> <init>= <expr><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>timeout_handler</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remove_timeout_index</name><argument_list>(<argument><expr><call><name>find_active_timeout</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>keep_indicator</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Reschedule the interrupt, if any timeouts remain active. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>schedule_alarm</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disable SIGALRM and remove all timeouts from the active list,
 * and optionally reset their timeout indicators.
 */</comment>
<function><type><name>void</name></type>
<name>disable_all_timeouts</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>keep_indicators</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>disable_alarm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only bother to reset the timer if we think it's active.  We could just
	 * let the interrupt happen anyway, but it's probably a bit cheaper to do
	 * setitimer() than to let the useless interrupt happen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_active_timeouts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>itimerval</name></name></type> <name>timeval</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timeval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>itimerval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>setitimer</name><argument_list>(<argument><expr><name>ITIMER_REAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not disable SIGALRM timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num_active_timeouts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_TIMEOUTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keep_indicators</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if the timeout is active (enabled and not yet fired)
 *
 * This is, of course, subject to race conditions, as the timeout could fire
 * immediately after we look.
 */</comment>
<function><type><name>bool</name></type>
<name>get_timeout_active</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>active</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the timeout's I've-been-fired indicator
 *
 * If reset_indicator is true, reset the indicator when returning true.
 * To avoid missing timeouts due to race conditions, we are careful not to
 * reset the indicator when returning false.
 */</comment>
<function><type><name>bool</name></type>
<name>get_timeout_indicator</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reset_indicator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>indicator</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>reset_indicator</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the time when the timeout was most recently activated
 *
 * Note: will return 0 if timeout has never been activated in this process.
 * However, we do *not* reset the start_time when a timeout occurs, so as
 * not to create a race condition if SIGALRM fires just as some code is
 * about to fetch the value.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>get_timeout_start_time</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>start_time</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the time when the timeout is, or most recently was, due to fire
 *
 * Note: will return 0 if timeout has never been activated in this process.
 * However, we do *not* reset the fin_time when a timeout occurs, so as
 * not to create a race condition if SIGALRM fires just as some code is
 * about to fetch the value.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>get_timeout_finish_time</name><parameter_list>(<parameter><decl><type><name>TimeoutId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>all_timeouts</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>fin_time</name></expr>;</return>
</block_content>}</block></function>
</unit>
