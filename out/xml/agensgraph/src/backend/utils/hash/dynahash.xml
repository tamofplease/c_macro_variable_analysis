<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/hash/dynahash.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dynahash.c
 *	  dynamic hash tables
 *
 * dynahash.c supports both local-to-a-backend hash tables and hash tables in
 * shared memory.  For shared hash tables, it is the caller's responsibility
 * to provide appropriate access interlocking.  The simplest convention is
 * that a single LWLock protects the whole hash table.  Searches (HASH_FIND or
 * hash_seq_search) need only shared lock, but any update requires exclusive
 * lock.  For heavily-used shared tables, the single-lock approach creates a
 * concurrency bottleneck, so we also support "partitioned" locking wherein
 * there are multiple LWLocks guarding distinct subsets of the table.  To use
 * a hash table in partitioned mode, the HASH_PARTITION flag must be given
 * to hash_create.  This prevents any attempt to split buckets on-the-fly.
 * Therefore, each hash bucket chain operates independently, and no fields
 * of the hash header change after init except nentries and freeList.
 * (A partitioned table uses multiple copies of those fields, guarded by
 * spinlocks, for additional concurrency.)
 * This lets any subset of the hash buckets be treated as a separately
 * lockable partition.  We expect callers to use the low-order bits of a
 * lookup key's hash value as a partition number --- this will work because
 * of the way calc_bucket() maps hash values to bucket numbers.
 *
 * For hash tables in shared memory, the memory allocator function should
 * match malloc's semantics of returning NULL on failure.  For hash tables
 * in local memory, we typically use palloc() which will throw error on
 * failure.  The code in this file has to cope with both cases.
 *
 * dynahash.c provides support for these types of lookup keys:
 *
 * 1. Null-terminated C strings (truncated if necessary to fit in keysize),
 * compared as though by strcmp().  This is the default behavior.
 *
 * 2. Arbitrary binary data of size keysize, compared as though by memcmp().
 * (Caller must ensure there are no undefined padding bits in the keys!)
 * This is selected by specifying HASH_BLOBS flag to hash_create.
 *
 * 3. More complex key behavior can be selected by specifying user-supplied
 * hashing, comparison, and/or key-copying functions.  At least a hashing
 * function must be supplied; comparison defaults to memcmp() and key copying
 * to memcpy() when a user-defined hashing function is selected.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/hash/dynahash.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Original comments:
 *
 * Dynamic hashing, after CACM April 1988 pp 446-457, by Per-Ake Larson.
 * Coded into C, with minor code improvements, and with hsearch(3) interface,
 * by ejp@ausmelb.oz, Jul 26, 1988: 13:16;
 * also, hcreate/hdestroy routines added to simulate hsearch(3).
 *
 * These routines simulate hsearch(3) and family, with the important
 * difference that the hash table is dynamic - can grow indefinitely
 * beyond its original size (as supplied to hcreate()).
 *
 * Performance appears to be comparable to that of hsearch(3).
 * The 'source-code' options referred to in hsearch(3)'s 'man' page
 * are not implemented; otherwise functionality is identical.
 *
 * Compilation controls:
 * HASH_DEBUG controls some informative traces, mainly for debugging.
 * HASH_STATISTICS causes HashAccesses and HashCollisions to be maintained;
 * when combined with HASH_DEBUG, these are displayed by hdestroy().
 *
 * Problems &amp; fixes to ejp@ausmelb.oz. WARNING: relies on pre-processor
 * concatenation property, in probably unnecessary code 'optimization'.
 *
 * Modified margo@postgres.berkeley.edu February 1990
 *		added multiple table interface
 * Modified by sullivan@postgres.berkeley.edu April 1990
 *		changed ctl structure for shared memory
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dynahash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Constants
 *
 * A hash table has a top-level "directory", each of whose entries points
 * to a "segment" of ssize bucket headers.  The maximum number of hash
 * buckets is thus dsize * ssize (but dsize may be expansible).  Of course,
 * the number of records in the table can be larger, but we don't want a
 * whole lot of records per bucket or performance goes down.
 *
 * In a hash table allocated in shared memory, the directory cannot be
 * expanded because it must stay at a fixed address.  The directory size
 * should be selected using hash_select_dirsize (and you'd better have
 * a good idea of the maximum number of entries!).  For non-shared hash
 * tables, the initial directory size can be left at the default.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_SEGSIZE</name></cpp:macro>			   <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_SEGSIZE_SHIFT</name></cpp:macro>	   <cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* must be log2(DEF_SEGSIZE) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_DIRSIZE</name></cpp:macro>			   <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_FFACTOR</name></cpp:macro>			   <cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* default fill factor */</comment>

<comment type="block">/* Number of freelists to be used for a partitioned hash table. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_FREELISTS</name></cpp:macro>			<cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* A hash bucket is a linked list of HASHELEMENTs */</comment>
<typedef>typedef <type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>HASHBUCKET</name>;</typedef>

<comment type="block">/* A hash segment is an array of bucket headers */</comment>
<typedef>typedef <type><name>HASHBUCKET</name> <modifier>*</modifier></type><name>HASHSEGMENT</name>;</typedef>

<comment type="block">/*
 * Per-freelist data.
 *
 * In a partitioned hash table, each freelist is associated with a specific
 * set of hashcodes, as determined by the FREELIST_IDX() macro below.
 * nentries tracks the number of live hashtable entries having those hashcodes
 * (NOT the number of entries in the freelist, as you might expect).
 *
 * The coverage of a freelist might be more or less than one partition, so it
 * needs its own lock rather than relying on caller locking.  Relying on that
 * wouldn't work even if the coverage was the same, because of the occasional
 * need to "borrow" entries from another freelist; see get_hash_entry().
 *
 * Using an array of FreeListData instead of separate arrays of mutexes,
 * nentries and freeLists helps to reduce sharing of cache lines between
 * different mutexes.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>			<comment type="block">/* spinlock for this freelist */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nentries</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in associated buckets */</comment>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>freeList</name></decl>;</decl_stmt>		<comment type="block">/* chain of free elements */</comment>
}</block></struct></type> <name>FreeListData</name>;</typedef>

<comment type="block">/*
 * Header structure for a hash table --- contains all changeable info
 *
 * In a shared-memory hash table, the HASHHDR is in shared memory, while
 * each backend has a local HTAB struct.  For a non-shared table, there isn't
 * any functional difference between HASHHDR and HTAB, but we separate them
 * anyway to share code between shared and non-shared tables.
 */</comment>
<struct>struct <name>HASHHDR</name>
<block>{
	<comment type="block">/*
	 * The freelist can become a point of contention in high-concurrency hash
	 * tables, so we use an array of freelists, each with its own mutex and
	 * nentries count, instead of just a single one.  Although the freelists
	 * normally operate independently, we will scavenge entries from freelists
	 * other than a hashcode's default freelist when necessary.
	 *
	 * If the hash table is not partitioned, only freeList[0] is used and its
	 * spinlock is not used at all; callers' locking is assumed sufficient.
	 */</comment>
	<decl_stmt><decl><type><name>FreeListData</name></type> <name><name>freeList</name><index>[<expr><name>NUM_FREELISTS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* These fields can change, but not in a partitioned table */</comment>
	<comment type="block">/* Also, dsize can't change in a shared table, even if unpartitioned */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>dsize</name></decl>;</decl_stmt>			<comment type="block">/* directory size */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nsegs</name></decl>;</decl_stmt>			<comment type="block">/* number of allocated segments (&lt;= dsize) */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>max_bucket</name></decl>;</decl_stmt>		<comment type="block">/* ID of maximum bucket in use */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>high_mask</name></decl>;</decl_stmt>		<comment type="block">/* mask to modulo into entire table */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>low_mask</name></decl>;</decl_stmt>		<comment type="block">/* mask to modulo into lower half of table */</comment>

	<comment type="block">/* These fields are fixed at hashtable creation */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>keysize</name></decl>;</decl_stmt>		<comment type="block">/* hash key length in bytes */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>entrysize</name></decl>;</decl_stmt>		<comment type="block">/* total user element size in bytes */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>num_partitions</name></decl>;</decl_stmt> <comment type="block">/* # partitions (must be power of 2), or 0 */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>ffactor</name></decl>;</decl_stmt>		<comment type="block">/* target fill factor */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_dsize</name></decl>;</decl_stmt>		<comment type="block">/* 'dsize' limit if directory is fixed size */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>ssize</name></decl>;</decl_stmt>			<comment type="block">/* segment size --- must be power of 2 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sshift</name></decl>;</decl_stmt>			<comment type="block">/* segment shift = log2(ssize) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelem_alloc</name></decl>;</decl_stmt>	<comment type="block">/* number of entries to allocate at once */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>

	<comment type="block">/*
	 * Count statistics here.  NB: stats code doesn't bother with mutex, so
	 * counts could be corrupted a bit in a partitioned table.
	 */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>accesses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>collisions</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PARTITIONED</name><parameter_list>(<parameter><type><name>hctl</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((hctl)-&gt;num_partitions != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREELIST_IDX</name><parameter_list>(<parameter><type><name>hctl</name></type></parameter>, <parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(IS_PARTITIONED(hctl) ? (hashcode) % NUM_FREELISTS : 0)</cpp:value></cpp:define>

<comment type="block">/*
 * Top control structure for a hashtable --- in a shared table, each backend
 * has its own copy (OK since no fields change at runtime)
 */</comment>
<struct>struct <name>HTAB</name>
<block>{
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name></decl>;</decl_stmt>			<comment type="block">/* =&gt; shared control information */</comment>
	<decl_stmt><decl><type><name>HASHSEGMENT</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>			<comment type="block">/* directory of segment starts */</comment>
	<decl_stmt><decl><type><name>HashValueFunc</name></type> <name>hash</name></decl>;</decl_stmt>			<comment type="block">/* hash function */</comment>
	<decl_stmt><decl><type><name>HashCompareFunc</name></type> <name>match</name></decl>;</decl_stmt>		<comment type="block">/* key comparison function */</comment>
	<decl_stmt><decl><type><name>HashCopyFunc</name></type> <name>keycopy</name></decl>;</decl_stmt>		<comment type="block">/* key copying function */</comment>
	<decl_stmt><decl><type><name>HashAllocFunc</name></type> <name>alloc</name></decl>;</decl_stmt>		<comment type="block">/* memory allocator */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>hcxt</name></decl>;</decl_stmt>			<comment type="block">/* memory context if default allocator used */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tabname</name></decl>;</decl_stmt>		<comment type="block">/* table name (for error messages) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isshared</name></decl>;</decl_stmt>		<comment type="block">/* true if table is in shared memory */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isfixed</name></decl>;</decl_stmt>		<comment type="block">/* if true, don't enlarge */</comment>

	<comment type="block">/* freezing a shared table isn't allowed, so we can keep state here */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>frozen</name></decl>;</decl_stmt>			<comment type="block">/* true = no more inserts allowed */</comment>

	<comment type="block">/* We keep local copies of these fixed values to reduce contention */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>keysize</name></decl>;</decl_stmt>		<comment type="block">/* hash key length in bytes */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>ssize</name></decl>;</decl_stmt>			<comment type="block">/* segment size --- must be power of 2 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sshift</name></decl>;</decl_stmt>			<comment type="block">/* segment shift = log2(ssize) */</comment>
}</block>;</struct>

<comment type="block">/*
 * Key (also entry) part of a HASHELEMENT
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELEMENTKEY</name><parameter_list>(<parameter><type><name>helem</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((char *)(helem)) + MAXALIGN(sizeof(HASHELEMENT)))</cpp:value></cpp:define>

<comment type="block">/*
 * Obtain element pointer given pointer to key
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELEMENT_FROM_KEY</name><parameter_list>(<parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((HASHELEMENT *) (((char *) (key)) - MAXALIGN(sizeof(HASHELEMENT))))</cpp:value></cpp:define>

<comment type="block">/*
 * Fast MOD arithmetic, assuming that y is a power of 2 !
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>			   <cpp:value>((x) &amp; ((y)-1))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>hash_accesses</name></decl>,
			<decl><type ref="prev"/><name>hash_collisions</name></decl>,
			<decl><type ref="prev"/><name>hash_expansions</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Private function prototypes
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>DynaHashAlloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HASHSEGMENT</name></type> <name>seg_alloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>element_alloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freelist_idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dir_realloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>expand_table</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HASHBUCKET</name></type> <name>get_hash_entry</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freelist_idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hdefault</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>choose_nelem_alloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>entrysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>init_htab</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nelem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_corrupted</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>next_pow2_long</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>next_pow2_int</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_seq_scan</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deregister_seq_scan</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_seq_scans</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * memory allocation support
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>CurrentDynaHashCxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>DynaHashAlloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>CurrentDynaHashCxt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CurrentDynaHashCxt</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HashCompareFunc for string keys
 *
 * Because we copy keys with strlcpy(), they will be truncated at keysize-1
 * bytes, so we can only compare that many ... hence strncmp is almost but
 * not quite the right thing.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>string_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><name>keysize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************************** CREATE ROUTINES **********************/</comment>

<comment type="block">/*
 * hash_create -- create a new dynamic hash table
 *
 *	tabname: a name for the table (for debugging purposes)
 *	nelem: maximum number of elements expected
 *	*info: additional table parameters, as indicated by flags
 *	flags: bitmask indicating which parameters to take from *info
 *
 * Note: for a shared-memory hashtable, nelem needs to be a pretty good
 * estimate, since we can't expand the table on the fly.  But an unshared
 * hashtable can be expanded on-the-fly, so it's better for nelem to be
 * on the small side and let the table grow if it's exceeded.  An overly
 * large nelem will penalize hash_seq_search speed without buying much.
 */</comment>
<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>hash_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nelem</name></decl></parameter>, <parameter><decl><type><name>HASHCTL</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hashp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For shared hash tables, we have a local hash header (HTAB struct) that
	 * we allocate in TopMemoryContext; all else is in shared memory.
	 *
	 * For non-shared hash tables, everything including the hash header is in
	 * a memory context created specially for the hash table --- this makes
	 * hash_destroy very simple.  The memory context is made a child of either
	 * a context specified by the caller, or TopMemoryContext if nothing is
	 * specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_SHARED_MEM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up to allocate the hash header */</comment>
		<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Create the hash table's private memory context */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_CONTEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>hcxt</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentDynaHashCxt</name></expr></argument>,
												   <argument><expr><literal type="string">"dynahash"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize the hash header, plus a copy of the table name */</comment>
	<expr_stmt><expr><name>hashp</name> <operator>=</operator> <operator>(</operator><name>HTAB</name> <operator>*</operator><operator>)</operator> <call><name>DynaHashAlloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HTAB</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HTAB</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>hashp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>, <argument><expr><name>tabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we have a private context, label it with hashtable's name */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>HASH_SHARED_MEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>CurrentDynaHashCxt</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Select the appropriate hash function (see comments at head of file).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>hash</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_BLOBS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can optimize hashing for common key sizes */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>keysize</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>uint32_hash</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>string_hash</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default hash function */</comment>

	<comment type="block">/*
	 * If you don't specify a match function, it defaults to string_compare if
	 * you used string_hash (either explicitly or by default) and to memcmp
	 * otherwise.
	 *
	 * Note: explicitly specifying string_hash is deprecated, because this
	 * might not work for callers in loadable modules on some platforms due to
	 * referencing a trampoline instead of the string_hash function proper.
	 * Just let it default, eh?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_COMPARE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>match</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>match</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>string_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>match</name></name> <operator>=</operator> <operator>(</operator><name>HashCompareFunc</name><operator>)</operator> <name>string_compare</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>match</name></name> <operator>=</operator> <name>memcmp</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Similarly, the key-copying function defaults to strlcpy or memcpy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_KEYCOPY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>keycopy</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>keycopy</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>string_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>keycopy</name></name> <operator>=</operator> <operator>(</operator><name>HashCopyFunc</name><operator>)</operator> <name>strlcpy</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>keycopy</name></name> <operator>=</operator> <name>memcpy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And select the entry allocation function, too. */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_ALLOC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>alloc</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>DynaHashAlloc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_SHARED_MEM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * ctl structure and directory are preallocated for shared memory
		 * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as
		 * well.
		 */</comment>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>hctl</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <operator>(</operator><name>HASHSEGMENT</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>hctl</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHHDR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>isshared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* hash table already exists, we're just attaching to it */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_ATTACH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make local copies of some heavily-used values */</comment>
			<expr_stmt><expr><name>hctl</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>

			<return>return <expr><name>hashp</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* setup hash table defaults */</comment>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentDynaHashCxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>isshared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name> <operator>=</operator> <operator>(</operator><name>HASHHDR</name> <operator>*</operator><operator>)</operator> <call><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHHDR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hdefault</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hctl</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_PARTITION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Doesn't make sense to partition a local hash table */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>HASH_SHARED_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The number of partitions had better be a power of 2. Also, it must
		 * be less than INT_MAX (see init_htab()), so call the int version of
		 * next_pow2.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>==</operator> <call><name>next_pow2_int</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_SEGMENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>ssize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name> <operator>=</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ssize had better be a power of 2 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name> <operator>==</operator> <operator>(</operator><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_FFACTOR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>ffactor</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>ffactor</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * SHM hash tables have fixed directory size passed by the caller.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_DIRSIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>max_dsize</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>max_dsize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>dsize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * hash table now allocates space for key and data but you have to say how
	 * much space to allocate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_ELEM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>entrysize</name></name> <operator>&gt;=</operator> <name><name>info</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>entrysize</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>entrysize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make local copies of heavily-used constant fields */</comment>
	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>

	<comment type="block">/* Build the hash directory structure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_htab</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>, <argument><expr><name>nelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize hash table \"%s\""</literal></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For a shared hash table, preallocate the requested number of elements.
	 * This reduces problems with run-time out-of-shared-memory conditions.
	 *
	 * For a non-shared hash table, preallocate the requested number of
	 * elements if it's less than our chosen nelem_alloc.  This avoids wasting
	 * space if the caller correctly estimates a small table size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>HASH_SHARED_MEM</name><operator>)</operator> <operator>||</operator>
		<name>nelem</name> <operator>&lt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>nelem_alloc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>freelist_partitions</name></decl>,
					<decl><type ref="prev"/><name>nelem_alloc</name></decl>,
					<decl><type ref="prev"/><name>nelem_alloc_first</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If hash table is partitioned, give each freelist an equal share of
		 * the initial allocation.  Otherwise only freeList[0] is used.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>freelist_partitions</name> <operator>=</operator> <name>NUM_FREELISTS</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>freelist_partitions</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>nelem_alloc</name> <operator>=</operator> <name>nelem</name> <operator>/</operator> <name>freelist_partitions</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nelem_alloc</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nelem_alloc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make sure we'll allocate all the requested elements; freeList[0]
		 * gets the excess if the request isn't divisible by NUM_FREELISTS.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nelem_alloc</name> <operator>*</operator> <name>freelist_partitions</name> <operator>&lt;</operator> <name>nelem</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nelem_alloc_first</name> <operator>=</operator>
				<name>nelem</name> <operator>-</operator> <name>nelem_alloc</name> <operator>*</operator> <operator>(</operator><name>freelist_partitions</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nelem_alloc_first</name> <operator>=</operator> <name>nelem_alloc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>freelist_partitions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>temp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>nelem_alloc_first</name></expr> </then><else>: <expr><name>nelem_alloc</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>element_alloc</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HASH_FIXED_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>isfixed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>hashp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set default HASHHDR parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hdefault</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHHDR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>=</operator> <name>DEF_DIRSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* rather pointless defaults for key &amp; entry size */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>entrysize</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* not partitioned */</comment>

	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>ffactor</name></name> <operator>=</operator> <name>DEF_FFACTOR</name></expr>;</expr_stmt>

	<comment type="block">/* table has no fixed maximum size */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>max_dsize</name></name> <operator>=</operator> <name>NO_MAX_DSIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name>DEF_SEGSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name> <operator>=</operator> <name>DEF_SEGSIZE_SHIFT</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>accesses</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>collisions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Given the user-specified entry size, choose nelem_alloc, ie, how many
 * elements to add to the hash table when we need more.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>choose_nelem_alloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>entrysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelem_alloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>elementSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>allocSize</name></decl>;</decl_stmt>

	<comment type="block">/* Each element has a HASHELEMENT header plus user data. */</comment>
	<comment type="block">/* NB: this had better match element_alloc() */</comment>
	<expr_stmt><expr><name>elementSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHELEMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>entrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The idea here is to choose nelem_alloc at least 32, but round up so
	 * that the allocation request will be a power of 2 or just less. This
	 * makes little difference for hash tables in shared memory, but for hash
	 * tables managed by palloc, the allocation request will be rounded up to
	 * a power of 2 anyway.  If we fail to take this into account, we'll waste
	 * as much as half the allocated space.
	 */</comment>
	<expr_stmt><expr><name>allocSize</name> <operator>=</operator> <literal type="number">32</literal> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>			<comment type="block">/* assume elementSize at least 8 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>allocSize</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nelem_alloc</name> <operator>=</operator> <name>allocSize</name> <operator>/</operator> <name>elementSize</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>nelem_alloc</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition>;</do>

	<return>return <expr><name>nelem_alloc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute derived fields of hctl and build the initial directory/segment
 * arrays
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>init_htab</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nelem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name> <modifier>*</modifier></type><name>segp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * initialize mutexes if it's a partitioned table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mutex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Divide number of elements by the fill factor to determine a desired
	 * number of buckets.  Allocate space for the next greater power of two
	 * number of buckets
	 */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>next_pow2_int</name><argument_list>(<argument><expr><operator>(</operator><name>nelem</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>hctl</name><operator>-&gt;</operator><name>ffactor</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a partitioned table, nbuckets must be at least equal to
	 * num_partitions; were it less, keys with apparently different partition
	 * numbers would map to the same bucket, breaking partition independence.
	 * (Normally nbuckets will be much bigger; this is just a safety check.)
	 */</comment>
	<while>while <condition>(<expr><name>nbuckets</name> <operator>&lt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbuckets</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name> <operator>=</operator> <name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name> <operator>=</operator> <operator>(</operator><name>nbuckets</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure number of directory segments needed, round up to a power of 2
	 */</comment>
	<expr_stmt><expr><name>nsegs</name> <operator>=</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsegs</name> <operator>=</operator> <call><name>next_pow2_int</name><argument_list>(<argument><expr><name>nsegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure directory is big enough. If pre-allocated directory is too
	 * small, choke (caller screwed up).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nsegs</name> <operator>&gt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>=</operator> <name>nsegs</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate a directory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <operator>(</operator><name>HASHSEGMENT</name> <operator>*</operator><operator>)</operator>
			<call><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate initial segments */</comment>
	<for>for <control>(<init><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name></expr>;</init> <condition><expr><name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>&lt;</operator> <name>nsegs</name></expr>;</condition> <incr><expr><name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name><operator>++</operator></expr><operator>,</operator> <expr><name>segp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>segp</name> <operator>=</operator> <call><name>seg_alloc</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>segp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Choose number of entries to allocate at a time */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>nelem_alloc</name></name> <operator>=</operator> <call><name>choose_nelem_alloc</name><argument_list>(<argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>entrysize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"init_htab:\n%s%p\n%s%ld\n%s%ld\n%s%d\n%s%ld\n%s%u\n%s%x\n%s%x\n%s%ld\n"</literal></expr></argument>,
			<argument><expr><literal type="string">"TABLE POINTER   "</literal></expr></argument>, <argument><expr><name>hashp</name></expr></argument>,
			<argument><expr><literal type="string">"DIRECTORY SIZE  "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name></expr></argument>,
			<argument><expr><literal type="string">"SEGMENT SIZE    "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>,
			<argument><expr><literal type="string">"SEGMENT SHIFT   "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>sshift</name></name></expr></argument>,
			<argument><expr><literal type="string">"FILL FACTOR     "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>ffactor</name></name></expr></argument>,
			<argument><expr><literal type="string">"MAX BUCKET      "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name></expr></argument>,
			<argument><expr><literal type="string">"HIGH MASK       "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name></expr></argument>,
			<argument><expr><literal type="string">"LOW  MASK       "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name></expr></argument>,
			<argument><expr><literal type="string">"NSEGS           "</literal></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the space needed for a hashtable containing the given number
 * of entries of given size.
 * NOTE: this is used to estimate the footprint of hashtables in shared
 * memory; therefore it does not count HTAB which is in local memory.
 * NB: assumes that all hash structure parameters have default values!
 */</comment>
<function><type><name>Size</name></type>
<name>hash_estimate_size</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num_entries</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>entrysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>nBuckets</name></decl>,
				<decl><type ref="prev"/><name>nSegments</name></decl>,
				<decl><type ref="prev"/><name>nDirEntries</name></decl>,
				<decl><type ref="prev"/><name>nElementAllocs</name></decl>,
				<decl><type ref="prev"/><name>elementSize</name></decl>,
				<decl><type ref="prev"/><name>elementAllocCnt</name></decl>;</decl_stmt>

	<comment type="block">/* estimate number of buckets wanted */</comment>
	<expr_stmt><expr><name>nBuckets</name> <operator>=</operator> <call><name>next_pow2_long</name><argument_list>(<argument><expr><operator>(</operator><name>num_entries</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEF_FFACTOR</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* # of segments needed for nBuckets */</comment>
	<expr_stmt><expr><name>nSegments</name> <operator>=</operator> <call><name>next_pow2_long</name><argument_list>(<argument><expr><operator>(</operator><name>nBuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEF_SEGSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* directory entries */</comment>
	<expr_stmt><expr><name>nDirEntries</name> <operator>=</operator> <name>DEF_DIRSIZE</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nDirEntries</name> <operator>&lt;</operator> <name>nSegments</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nDirEntries</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* dir_alloc doubles dsize at each call */</comment>

	<comment type="block">/* fixed control info */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHHDR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* but not HTAB, per above */</comment>
	<comment type="block">/* directory */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nDirEntries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* segments */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nSegments</name></expr></argument>,
								   <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>DEF_SEGSIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHBUCKET</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* elements --- allocated in groups of choose_nelem_alloc() entries */</comment>
	<expr_stmt><expr><name>elementAllocCnt</name> <operator>=</operator> <call><name>choose_nelem_alloc</name><argument_list>(<argument><expr><name>entrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nElementAllocs</name> <operator>=</operator> <operator>(</operator><name>num_entries</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>elementAllocCnt</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>elementSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHELEMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>entrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
					<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nElementAllocs</name></expr></argument>,
							 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>elementAllocCnt</name></expr></argument>, <argument><expr><name>elementSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select an appropriate directory size for a hashtable with the given
 * maximum number of entries.
 * This is only needed for hashtables in shared memory, whose directories
 * cannot be expanded dynamically.
 * NB: assumes that all hash structure parameters have default values!
 *
 * XXX this had better agree with the behavior of init_htab()...
 */</comment>
<function><type><name>long</name></type>
<name>hash_select_dirsize</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num_entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>nBuckets</name></decl>,
				<decl><type ref="prev"/><name>nSegments</name></decl>,
				<decl><type ref="prev"/><name>nDirEntries</name></decl>;</decl_stmt>

	<comment type="block">/* estimate number of buckets wanted */</comment>
	<expr_stmt><expr><name>nBuckets</name> <operator>=</operator> <call><name>next_pow2_long</name><argument_list>(<argument><expr><operator>(</operator><name>num_entries</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEF_FFACTOR</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* # of segments needed for nBuckets */</comment>
	<expr_stmt><expr><name>nSegments</name> <operator>=</operator> <call><name>next_pow2_long</name><argument_list>(<argument><expr><operator>(</operator><name>nBuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEF_SEGSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* directory entries */</comment>
	<expr_stmt><expr><name>nDirEntries</name> <operator>=</operator> <name>DEF_DIRSIZE</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nDirEntries</name> <operator>&lt;</operator> <name>nSegments</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nDirEntries</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* dir_alloc doubles dsize at each call */</comment>

	<return>return <expr><name>nDirEntries</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the required initial memory allocation for a shared-memory
 * hashtable with the given parameters.  We need space for the HASHHDR
 * and for the (non expansible) directory.
 */</comment>
<function><type><name>Size</name></type>
<name>hash_get_shared_size</name><parameter_list>(<parameter><decl><type><name>HASHCTL</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>HASH_DIRSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dsize</name></name> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>max_dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHHDR</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>info</name><operator>-&gt;</operator><name>dsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHSEGMENT</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/********************** DESTROY ROUTINES ************************/</comment>

<function><type><name>void</name></type>
<name>hash_destroy</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>hashp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allocation method must be one we know how to free, too */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name> <operator>==</operator> <name>DynaHashAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* so this hashtable must have its own context */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_stats</name><argument_list>(<argument><expr><literal type="string">"destroy"</literal></expr></argument>, <argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Free everything by destroying the hash table's memory context.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>hash_stats</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: this HTAB -- accesses %ld collisions %ld\n"</literal></expr></argument>,
			<argument><expr><name>where</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>accesses</name></name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>collisions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"hash_stats: entries %ld keysize %ld maxp %u segmentcount %ld\n"</literal></expr></argument>,
			<argument><expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>,
			<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: total accesses %ld total collisions %ld\n"</literal></expr></argument>,
			<argument><expr><name>where</name></expr></argument>, <argument><expr><name>hash_accesses</name></expr></argument>, <argument><expr><name>hash_collisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"hash_stats: total expansions %ld\n"</literal></expr></argument>,
			<argument><expr><name>hash_expansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************SEARCH ROUTINES *****************************/</comment>


<comment type="block">/*
 * get_hash_value -- exported routine to calculate a key's hash value
 *
 * We export this because for partitioned tables, callers need to compute
 * the partition number (from the low-order bits of the hash value) before
 * searching.
 */</comment>
<function><type><name>uint32</name></type>
<name>get_hash_value</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name><argument_list>(<argument><expr><name>keyPtr</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert a hash value to a bucket number */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>calc_bucket</name><parameter_list>(<parameter><decl><type><name>HASHHDR</name> <modifier>*</modifier></type><name>hctl</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bucket</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>hash_val</name> <operator>&amp;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bucket</name> <operator>&gt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>bucket</name> <operator>&amp;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>bucket</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hash_search -- look up key in table and perform action
 * hash_search_with_hash_value -- same, with key's hash value already computed
 *
 * action is one of:
 *		HASH_FIND: look up key in table
 *		HASH_ENTER: look up key in table, creating entry if not present
 *		HASH_ENTER_NULL: same, but return NULL if out of memory
 *		HASH_REMOVE: look up key in table, remove entry if present
 *
 * Return value is a pointer to the element found/entered/removed if any,
 * or NULL if no match was found.  (NB: in the case of the REMOVE action,
 * the result is a dangling pointer that shouldn't be dereferenced!)
 *
 * HASH_ENTER will normally ereport a generic "out of memory" error if
 * it is unable to create a new entry.  The HASH_ENTER_NULL operation is
 * the same except it will return NULL if out of memory.  Note that
 * HASH_ENTER_NULL cannot be used with the default palloc-based allocator,
 * since palloc internally ereports on out-of-memory.
 *
 * If foundPtr isn't NULL, then *foundPtr is set true if we found an
 * existing entry in the table, false otherwise.  This is needed in the
 * HASH_ENTER case, but is redundant with the return value otherwise.
 *
 * For hash_search_with_hash_value, the hashvalue parameter must have been
 * calculated with get_hash_value().
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>hash_search</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>,
			<parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>,
									   <argument><expr><name>keyPtr</name></expr></argument>,
									   <argument><expr><call><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name><argument_list>(<argument><expr><name>keyPtr</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>action</name></expr></argument>,
									   <argument><expr><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>hash_search_with_hash_value</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keyPtr</name></decl></parameter>,
							<parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
							<parameter><decl><type><name>HASHACTION</name></type> <name>action</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>freelist_idx</name> <init>= <expr><call><name>FREELIST_IDX</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>keysize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_ndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name></type> <name>segp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name></type>	<name>currBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name> <modifier>*</modifier></type><name>prevBucketPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashCompareFunc</name></type> <name>match</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
	<expr_stmt><expr><name>hash_accesses</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>accesses</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If inserting, check if it is time to split a bucket.
	 *
	 * NOTE: failure to expand table is not a fatal error, it just means we
	 * have to run at higher fill factor than we wanted.  However, if we're
	 * using the palloc allocator then it will throw error anyway on
	 * out-of-memory, so we must do this before modifying the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>HASH_ENTER</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>HASH_ENTER_NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't split if running in partitioned mode, nor if frozen, nor if
		 * table is the subject of any active hash_seq_search scans.  Strange
		 * order of these tests is to try to check cheaper conditions first.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name> <operator>&amp;&amp;</operator>
			<name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nentries</name> <operator>/</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>ffactor</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>has_seq_scans</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expand_table</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do the initial lookup
	 */</comment>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <call><name>calc_bucket</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segment_num</name> <operator>=</operator> <name>bucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_ndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>segment_num</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_corrupted</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>segp</name><index>[<expr><name>segment_ndx</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Follow collision chain looking for matching key
	 */</comment>
	<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>match</name></name></expr>;</expr_stmt>		<comment type="block">/* save one fetch in inner loop */</comment>
	<expr_stmt><expr><name>keysize</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>	<comment type="block">/* ditto */</comment>

	<while>while <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>currBucket</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>==</operator> <name>hashvalue</name> <operator>&amp;&amp;</operator>
			<call><name>match</name><argument_list>(<argument><expr><call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keyPtr</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
		<expr_stmt><expr><name>hash_collisions</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>collisions</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>foundPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <operator>(</operator><name>currBucket</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, now what?
	 */</comment>
	<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HASH_FIND</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>

		<case>case <expr><name>HASH_REMOVE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if partitioned, must lock to touch nentries and freeList */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* delete the record from the appropriate nentries counter. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>nentries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>nentries</name><operator>--</operator></expr>;</expr_stmt>

				<comment type="block">/* remove record from hash bucket's chain. */</comment>
				<expr_stmt><expr><operator>*</operator><name>prevBucketPtr</name> <operator>=</operator> <name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>

				<comment type="block">/* add the record to the appropriate freelist. */</comment>
				<expr_stmt><expr><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name> <operator>=</operator> <name>currBucket</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * better hope the caller is synchronizing access to this
				 * element, because someone else is going to reuse it the next
				 * time something is added to the table
				 */</comment>
				<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>

		<case>case <expr><name>HASH_ENTER_NULL</name></expr>:</case>
			<comment type="block">/* ENTER_NULL does not work with palloc-based allocator */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name> <operator>!=</operator> <name>DynaHashAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* FALL THRU */</comment>

		<case>case <expr><name>HASH_ENTER</name></expr>:</case>
			<comment type="block">/* Return existing element if found, else create one */</comment>
			<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* disallow inserts if frozen */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert into frozen hashtable \"%s\""</literal></expr></argument>,
					 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <call><name>get_hash_entry</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>, <argument><expr><name>freelist_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* out of memory */</comment>
				<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>HASH_ENTER_NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* report a generic message */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>isshared</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* link into hashbucket chain */</comment>
			<expr_stmt><expr><operator>*</operator><name>prevBucketPtr</name> <operator>=</operator> <name>currBucket</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* copy key into record */</comment>
			<expr_stmt><expr><name><name>currBucket</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>hashp</name><operator>-&gt;</operator><name>keycopy</name></name><argument_list>(<argument><expr><call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keyPtr</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Caller is expected to fill the data field on return.  DO NOT
			 * insert any code that could possibly throw error here, as doing
			 * so would leave the table entry incomplete and hence corrupt the
			 * caller's data structure.
			 */</comment>

			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized hash action code: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * hash_update_hash_key -- change the hash key of an existing table entry
 *
 * This is equivalent to removing the entry, making a new entry, and copying
 * over its data, except that the entry never goes to the table's freelist.
 * Therefore this cannot suffer an out-of-memory failure, even if there are
 * other processes operating in other partitions of the hashtable.
 *
 * Returns true if successful, false if the requested new hash key is already
 * present.  Throws error if the specified entry pointer isn't actually a
 * table member.
 *
 * NB: currently, there is no special case for old and new hash keys being
 * identical, which means we'll report false for that situation.  This is
 * preferable for existing uses.
 *
 * NB: for a partitioned hashtable, caller must hold lock on both relevant
 * partitions, if the new hash key would belong to a different partition.
 */</comment>
<function><type><name>bool</name></type>
<name>hash_update_hash_key</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>existingEntry</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>newKeyPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>existingElement</name> <init>= <expr><call><name>ELEMENT_FROM_KEY</name><argument_list>(<argument><expr><name>existingEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newhashvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>keysize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newbucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_ndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name></type> <name>segp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name></type>	<name>currBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name> <modifier>*</modifier></type><name>prevBucketPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name> <modifier>*</modifier></type><name>oldPrevPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashCompareFunc</name></type> <name>match</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
	<expr_stmt><expr><name>hash_accesses</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>accesses</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* disallow updates if frozen */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot update in frozen hashtable \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lookup the existing element using its saved hash value.  We need to do
	 * this to be able to unlink it from its hash chain, but as a side benefit
	 * we can verify the validity of the passed existingEntry pointer.
	 */</comment>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <call><name>calc_bucket</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><name><name>existingElement</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segment_num</name> <operator>=</operator> <name>bucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_ndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>segment_num</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_corrupted</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>segp</name><index>[<expr><name>segment_ndx</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>==</operator> <name>existingElement</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash_update_hash_key argument is not in hashtable \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldPrevPtr</name> <operator>=</operator> <name>prevBucketPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now perform the equivalent of a HASH_ENTER operation to locate the hash
	 * chain we want to put the entry into.
	 */</comment>
	<expr_stmt><expr><name>newhashvalue</name> <operator>=</operator> <call><name><name>hashp</name><operator>-&gt;</operator><name>hash</name></name><argument_list>(<argument><expr><name>newKeyPtr</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newbucket</name> <operator>=</operator> <call><name>calc_bucket</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><name>newhashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segment_num</name> <operator>=</operator> <name>newbucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_ndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>newbucket</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>segment_num</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_corrupted</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>segp</name><index>[<expr><name>segment_ndx</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Follow collision chain looking for matching key
	 */</comment>
	<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>match</name></name></expr>;</expr_stmt>		<comment type="block">/* save one fetch in inner loop */</comment>
	<expr_stmt><expr><name>keysize</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>keysize</name></name></expr>;</expr_stmt>	<comment type="block">/* ditto */</comment>

	<while>while <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>currBucket</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>==</operator> <name>newhashvalue</name> <operator>&amp;&amp;</operator>
			<call><name>match</name><argument_list>(<argument><expr><call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newKeyPtr</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prevBucketPtr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <operator>*</operator><name>prevBucketPtr</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
		<expr_stmt><expr><name>hash_collisions</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>collisions</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>currBucket</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* collision with an existing entry */</comment>

	<expr_stmt><expr><name>currBucket</name> <operator>=</operator> <name>existingElement</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If old and new hash values belong to the same bucket, we need not
	 * change any chain links, and indeed should not since this simplistic
	 * update will corrupt the list if currBucket is the last element.  (We
	 * cannot fall out earlier, however, since we need to scan the bucket to
	 * check for duplicate keys.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bucket</name> <operator>!=</operator> <name>newbucket</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK to remove record from old hash bucket's chain. */</comment>
		<expr_stmt><expr><operator>*</operator><name>oldPrevPtr</name> <operator>=</operator> <name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>

		<comment type="block">/* link into new hashbucket chain */</comment>
		<expr_stmt><expr><operator>*</operator><name>prevBucketPtr</name> <operator>=</operator> <name>currBucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currBucket</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy new key into record */</comment>
	<expr_stmt><expr><name><name>currBucket</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>newhashvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>hashp</name><operator>-&gt;</operator><name>keycopy</name></name><argument_list>(<argument><expr><call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>currBucket</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newKeyPtr</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rest of record is untouched */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new hashtable entry if possible; return NULL if out of memory.
 * (Or, if the underlying space allocator throws error for out-of-memory,
 * we won't return at all.)
 */</comment>
<function><type><specifier>static</specifier> <name>HASHBUCKET</name></type>
<name>get_hash_entry</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freelist_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name></type>	<name>newElement</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* if partitioned, must lock to touch nentries and freeList */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* try to get an entry from the freelist */</comment>
		<expr_stmt><expr><name>newElement</name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newElement</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * No free elements in this freelist.  In a partitioned table, there
		 * might be entries in other freelists, but to reduce contention we
		 * prefer to first try to get another chunk of buckets from the main
		 * shmem allocator.  If that fails, though, we *MUST* root through all
		 * the other freelists before giving up.  There are multiple callers
		 * that assume that they can allocate every element in the initially
		 * requested table size, or that deleting an element guarantees they
		 * can insert a new element, even if shared memory is entirely full.
		 * Failing because the needed element is in a different freelist is
		 * not acceptable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>element_alloc</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>, <argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>nelem_alloc</name></name></expr></argument>, <argument><expr><name>freelist_idx</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>borrow_from_idx</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of memory */</comment>

			<comment type="block">/* try to borrow element from another freelist */</comment>
			<expr_stmt><expr><name>borrow_from_idx</name> <operator>=</operator> <name>freelist_idx</name></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>borrow_from_idx</name> <operator>=</operator> <operator>(</operator><name>borrow_from_idx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>NUM_FREELISTS</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>borrow_from_idx</name> <operator>==</operator> <name>freelist_idx</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* examined all freelists, fail */</comment>

				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>borrow_from_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newElement</name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>borrow_from_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>newElement</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>borrow_from_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name> <operator>=</operator> <name><name>newElement</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>borrow_from_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* careful: count the new element in its proper freelist */</comment>
					<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>nentries</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return <expr><name>newElement</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>borrow_from_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* no elements available to borrow either, so out of memory */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* remove entry from freelist, bump nentries */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name> <operator>=</operator> <name><name>newElement</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>nentries</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>newElement</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hash_get_num_entries -- get the number of entries in a hashtable
 */</comment>
<function><type><name>long</name></type>
<name>hash_get_num_entries</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>sum</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nentries</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We currently don't bother with acquiring the mutexes; it's only
	 * sensible to call this function if you've got lock on all partitions of
	 * the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nentries</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hash_seq_init/_search/_term
 *			Sequentially search through hash table and return
 *			all the elements one by one, return NULL when no more.
 *
 * hash_seq_term should be called if and only if the scan is abandoned before
 * completion; if hash_seq_search returns NULL then it has already done the
 * end-of-scan cleanup.
 *
 * NOTE: caller may delete the returned element before continuing the scan.
 * However, deleting any other element while the scan is in progress is
 * UNDEFINED (it might be the one that curIndex is pointing at!).  Also,
 * if elements are added to the table while the scan is in progress, it is
 * unspecified whether they will be visited by the scan or not.
 *
 * NOTE: it is possible to use hash_seq_init/hash_seq_search without any
 * worry about hash_seq_term cleanup, if the hashtable is first locked against
 * further insertions by calling hash_freeze.
 *
 * NOTE: to use this with a partitioned hashtable, caller had better hold
 * at least shared lock on all partitions of the table throughout the scan!
 * We can cope with insertions or deletions by our own backend, but *not*
 * with concurrent insertions or deletions by another.
 */</comment>
<function><type><name>void</name></type>
<name>hash_seq_init</name><parameter_list>(<parameter><decl><type><name>HASH_SEQ_STATUS</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>hashp</name></name> <operator>=</operator> <name>hashp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curBucket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_seq_scan</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>hash_seq_search</name><parameter_list>(<parameter><decl><type><name>HASH_SEQ_STATUS</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hashp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>max_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>ssize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>segment_ndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name></type> <name>segp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>curBucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>curElem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>curElem</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Continuing scan of curBucket... */</comment>
		<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name> <operator>=</operator> <name><name>curElem</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* end of this bucket */</comment>
			<expr_stmt><expr><operator>++</operator><name><name>status</name><operator>-&gt;</operator><name>curBucket</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>curElem</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search for next nonempty bucket starting at curBucket.
	 */</comment>
	<expr_stmt><expr><name>curBucket</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>curBucket</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashp</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>hashp</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hctl</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ssize</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_bucket</name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>curBucket</name> <operator>&gt;</operator> <name>max_bucket</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* search is done */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * first find the right segment in the table directory.
	 */</comment>
	<expr_stmt><expr><name>segment_num</name> <operator>=</operator> <name>curBucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_ndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>curBucket</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>segment_num</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pick up the first item in this bucket's chain.  If chain is not empty
	 * we can begin searching it.  Otherwise we have to advance to find the
	 * next nonempty bucket.  We try to optimize that case since searching a
	 * near-empty hashtable has to iterate this loop a lot.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>curElem</name> <operator>=</operator> <name><name>segp</name><index>[<expr><name>segment_ndx</name></expr>]</index></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* empty bucket, advance to next */</comment>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>curBucket</name> <operator>&gt;</operator> <name>max_bucket</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curBucket</name></name> <operator>=</operator> <name>curBucket</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* search is done */</comment>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>segment_ndx</name> <operator>&gt;=</operator> <name>ssize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segment_num</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>segment_ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>segp</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>segment_num</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Begin scan of curBucket... */</comment>
	<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name> <operator>=</operator> <name><name>curElem</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>curEntry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* end of this bucket */</comment>
		<expr_stmt><expr><operator>++</operator><name>curBucket</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>curBucket</name></name> <operator>=</operator> <name>curBucket</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>ELEMENTKEY</name><argument_list>(<argument><expr><name>curElem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>hash_seq_term</name><parameter_list>(<parameter><decl><type><name>HASH_SEQ_STATUS</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>status</name><operator>-&gt;</operator><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deregister_seq_scan</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>hashp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * hash_freeze
 *			Freeze a hashtable against future insertions (deletions are
 *			still allowed)
 *
 * The reason for doing this is that by preventing any more bucket splits,
 * we no longer need to worry about registering hash_seq_search scans,
 * and thus caller need not be careful about ensuring hash_seq_term gets
 * called at the right times.
 *
 * Multiple calls to hash_freeze() are allowed, but you can't freeze a table
 * with active scans (since hash_seq_term would then do the wrong thing).
 */</comment>
<function><type><name>void</name></type>
<name>hash_freeze</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>isshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot freeze shared hashtable \"%s\""</literal></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name> <operator>&amp;&amp;</operator> <call><name>has_seq_scans</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot freeze hashtable \"%s\" because it has active scans"</literal></expr></argument>,
			 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/********************************* UTILITIES ************************/</comment>

<comment type="block">/*
 * Expand the table by adding one more hash bucket.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>expand_table</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name></type> <name>old_seg</name></decl>,
				<decl><type ref="prev"/><name>new_seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>old_bucket</name></decl>,
				<decl><type ref="prev"/><name>new_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>new_segnum</name></decl>,
				<decl><type ref="prev"/><name>new_segndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>old_segnum</name></decl>,
				<decl><type ref="prev"/><name>old_segndx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name> <modifier>*</modifier></type><name>oldlink</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>newlink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHBUCKET</name></type>	<name>currElement</name></decl>,
				<decl><type ref="prev"/><name>nextElement</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HASH_STATISTICS</name></cpp:ifdef>
	<expr_stmt><expr><name>hash_expansions</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>new_bucket</name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_segnum</name> <operator>=</operator> <name>new_bucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_segndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>new_bucket</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_segnum</name> <operator>&gt;=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate new segment if necessary -- could fail if dir full */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_segnum</name> <operator>&gt;=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dir_realloc</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>new_segnum</name></expr>]</index></name> <operator>=</operator> <call><name>seg_alloc</name><argument_list>(<argument><expr><name>hashp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>nsegs</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, we created a new bucket */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>max_bucket</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * *Before* changing masks, find old bucket corresponding to same hash
	 * values; values in that bucket may need to be relocated to new bucket.
	 * Note that new_bucket is certainly larger than low_mask at this point,
	 * so we can skip the first step of the regular hash mask calc.
	 */</comment>
	<expr_stmt><expr><name>old_bucket</name> <operator>=</operator> <operator>(</operator><name>new_bucket</name> <operator>&amp;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we crossed a power of 2, readjust masks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>new_bucket</name> <operator>&gt;</operator> <name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>high_mask</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>new_bucket</name> <operator>|</operator> <name><name>hctl</name><operator>-&gt;</operator><name>low_mask</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Relocate records to the new bucket.  NOTE: because of the way the hash
	 * masking is done in calc_bucket, only one old bucket can need to be
	 * split at this point.  With a different way of reducing the hash value,
	 * that might not be true!
	 */</comment>
	<expr_stmt><expr><name>old_segnum</name> <operator>=</operator> <name>old_bucket</name> <operator>&gt;&gt;</operator> <name><name>hashp</name><operator>-&gt;</operator><name>sshift</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_segndx</name> <operator>=</operator> <call><name>MOD</name><argument_list>(<argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_seg</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>old_segnum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_seg</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name><index>[<expr><name>new_segnum</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldlink</name> <operator>=</operator> <operator>&amp;</operator><name><name>old_seg</name><index>[<expr><name>old_segndx</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newlink</name> <operator>=</operator> <operator>&amp;</operator><name><name>new_seg</name><index>[<expr><name>new_segndx</name></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>currElement</name> <operator>=</operator> <operator>*</operator><name>oldlink</name></expr>;</init>
		 <condition><expr><name>currElement</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>currElement</name> <operator>=</operator> <name>nextElement</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nextElement</name> <operator>=</operator> <name><name>currElement</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>calc_bucket</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>, <argument><expr><name><name>currElement</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>old_bucket</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>oldlink</name> <operator>=</operator> <name>currElement</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldlink</name> <operator>=</operator> <operator>&amp;</operator><name><name>currElement</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>newlink</name> <operator>=</operator> <name>currElement</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newlink</name> <operator>=</operator> <operator>&amp;</operator><name><name>currElement</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* don't forget to terminate the rebuilt hash chains... */</comment>
	<expr_stmt><expr><operator>*</operator><name>oldlink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>newlink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dir_realloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHSEGMENT</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHSEGMENT</name> <modifier>*</modifier></type><name>old_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>new_dsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>old_dirsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>new_dirsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>max_dsize</name></name> <operator>!=</operator> <name>NO_MAX_DSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reallocate directory */</comment>
	<expr_stmt><expr><name>new_dsize</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_dirsize</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHSEGMENT</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_dirsize</name> <operator>=</operator> <name>new_dsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HASHSEGMENT</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_p</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>HASHSEGMENT</name> <operator>*</operator><operator>)</operator> <call><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>new_dirsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>old_p</name></expr></argument>, <argument><expr><name>old_dirsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name><operator>)</operator> <operator>+</operator> <name>old_dirsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_dirsize</name> <operator>-</operator> <name>old_dirsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name><operator>-&gt;</operator><name>dsize</name></name> <operator>=</operator> <name>new_dsize</name></expr>;</expr_stmt>

		<comment type="block">/* XXX assume the allocator is palloc, so we know how to free */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name> <operator>==</operator> <name>DynaHashAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>HASHSEGMENT</name></type>
<name>seg_alloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHSEGMENT</name></type> <name>segp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segp</name> <operator>=</operator> <operator>(</operator><name>HASHSEGMENT</name><operator>)</operator> <call><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHBUCKET</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>segp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>segp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHBUCKET</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashp</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>segp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * allocate some new elements and link them into the indicated free list
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>element_alloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>freelist_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHHDR</name>    <modifier>*</modifier></type><name>hctl</name> <init>= <expr><name><name>hashp</name><operator>-&gt;</operator><name>hctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>elementSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>firstElement</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>tmpElement</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHELEMENT</name> <modifier>*</modifier></type><name>prevElement</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>isfixed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Each element has a HASHELEMENT header plus user data. */</comment>
	<expr_stmt><expr><name>elementSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHELEMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hctl</name><operator>-&gt;</operator><name>entrysize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentDynaHashCxt</name> <operator>=</operator> <name><name>hashp</name><operator>-&gt;</operator><name>hcxt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstElement</name> <operator>=</operator> <operator>(</operator><name>HASHELEMENT</name> <operator>*</operator><operator>)</operator> <call><name><name>hashp</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>nelem</name> <operator>*</operator> <name>elementSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstElement</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* prepare to link all the new entries into the freelist */</comment>
	<expr_stmt><expr><name>prevElement</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmpElement</name> <operator>=</operator> <name>firstElement</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelem</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmpElement</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>prevElement</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prevElement</name> <operator>=</operator> <name>tmpElement</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmpElement</name> <operator>=</operator> <operator>(</operator><name>HASHELEMENT</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tmpElement</name><operator>)</operator> <operator>+</operator> <name>elementSize</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if partitioned, must lock to touch freeList */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* freelist could be nonempty if two backends did this concurrently */</comment>
	<expr_stmt><expr><name><name>firstElement</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>freeList</name> <operator>=</operator> <name>prevElement</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_PARTITIONED</name><argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hctl</name><operator>-&gt;</operator><name>freeList</name><index>[<expr><name>freelist_idx</name></expr>]</index></name><operator>.</operator><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* complain when we have detected a corrupted hashtable */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_corrupted</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the corruption is in a shared hashtable, we'd better force a
	 * systemwide restart.  Otherwise, just shut down this one backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashp</name><operator>-&gt;</operator><name>isshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"hash table \"%s\" corrupted"</literal></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"hash table \"%s\" corrupted"</literal></expr></argument>, <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* calculate ceil(log base 2) of num */</comment>
<function><type><name>int</name></type>
<name>my_log2</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * guard against too-large input, which would be invalid for
	 * pg_ceil_log2_*()
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>LONG_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <name>LONG_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&lt;</operator> <literal type="number">8</literal></expr></cpp:if>
	<return>return <expr><call><name>pg_ceil_log2_32</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>pg_ceil_log2_64</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* calculate first power of 2 &gt;= num, bounded to what will fit in a long */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>next_pow2_long</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* my_log2's internal range check is sufficient */</comment>
	<return>return <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* calculate first power of 2 &gt;= num, bounded to what will fit in an int */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>next_pow2_int</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************************* SEQ SCAN TRACKING ************************/</comment>

<comment type="block">/*
 * We track active hash_seq_search scans here.  The need for this mechanism
 * comes from the fact that a scan will get confused if a bucket split occurs
 * while it's in progress: it might visit entries twice, or even miss some
 * entirely (if it's partway through the same bucket that splits).  Hence
 * we want to inhibit bucket splits if there are any active scans on the
 * table being inserted into.  This is a fairly rare case in current usage,
 * so just postponing the split until the next insertion seems sufficient.
 *
 * Given present usages of the function, only a few scans are likely to be
 * open concurrently; so a finite-size stack of open scans seems sufficient,
 * and we don't worry that linear search is too slow.  Note that we do
 * allow multiple scans of the same hashtable to be open concurrently.
 *
 * This mechanism can support concurrent scan and insertion in a shared
 * hashtable if it's the same backend doing both.  It would fail otherwise,
 * but locking reasons seem to preclude any such scenario anyway, so we don't
 * worry.
 *
 * This arrangement is reasonably robust if a transient hashtable is deleted
 * without notifying us.  The absolute worst case is we might inhibit splits
 * in another table created later at exactly the same address.  We will give
 * a warning at transaction end for reference leaks, so any bugs leading to
 * lack of notification should be easy to catch.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SEQ_SCANS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name><name>seq_scan_tables</name><index>[<expr><name>MAX_SEQ_SCANS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* tables being scanned */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name><name>seq_scan_level</name><index>[<expr><name>MAX_SEQ_SCANS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* subtransaction nest level */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_seq_scans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* Register a table as having an active hash_seq_search scan */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_seq_scan</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num_seq_scans</name> <operator>&gt;=</operator> <name>MAX_SEQ_SCANS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many active hash_seq_search scans, cannot start one on \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>seq_scan_tables</name><index>[<expr><name>num_seq_scans</name></expr>]</index></name> <operator>=</operator> <name>hashp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seq_scan_level</name><index>[<expr><name>num_seq_scans</name></expr>]</index></name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_seq_scans</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Deregister an active scan */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deregister_seq_scan</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Search backward since it's most likely at the stack top */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>hashp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>seq_scan_tables</name><index>[<expr><name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seq_scan_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>seq_scan_level</name><index>[<expr><name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_seq_scans</name><operator>--</operator></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no hash_seq_search scan for hash table \"%s\""</literal></expr></argument>,
		 <argument><expr><name><name>hashp</name><operator>-&gt;</operator><name>tabname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if a table has any active scan */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_seq_scans</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_seq_scans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>hashp</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Clean up any open scans at end of transaction */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_HashTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * During abort cleanup, open scans are expected; just silently clean 'em
	 * out.  An open scan at commit means someone forgot a hash_seq_term()
	 * call, so complain.
	 *
	 * Note: it's tempting to try to print the tabname here, but refrain for
	 * fear of touching deallocated memory.  This isn't a user-facing message
	 * anyway, so it needn't be pretty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_seq_scans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked hash_seq_search scan for hash table %p"</literal></expr></argument>,
				 <argument><expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>num_seq_scans</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Clean up any open scans at end of subtransaction */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_HashTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nestDepth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search backward to make cleanup easy.  Note we must check all entries,
	 * not only those at the end of the array, because deletion technique
	 * doesn't keep them in order.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>seq_scan_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>nestDepth</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked hash_seq_search scan for hash table %p"</literal></expr></argument>,
					 <argument><expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>seq_scan_tables</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>seq_scan_tables</name><index>[<expr><name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seq_scan_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>seq_scan_level</name><index>[<expr><name>num_seq_scans</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_seq_scans</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
