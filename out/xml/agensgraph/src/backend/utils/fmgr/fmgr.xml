<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/fmgr/fmgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fmgr.c
 *	  The Postgres function manager.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/fmgr/fmgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrtab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Hooks for function calls
 */</comment>
<decl_stmt><decl><type><name>PGDLLIMPORT</name> <name>needs_fmgr_hook_type</name></type> <name>needs_fmgr_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PGDLLIMPORT</name> <name>fmgr_hook_type</name></type> <name>fmgr_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Hashtable for fast lookup of external C functions
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* fn_oid is the hash key and so must be first! */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fn_oid</name></decl>;</decl_stmt>			<comment type="block">/* OID of an external C function */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>fn_xmin</name></decl>;</decl_stmt>		<comment type="block">/* for checking up-to-dateness */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>fn_tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name></type>	<name>user_fn</name></decl>;</decl_stmt>		<comment type="block">/* the function's address */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type><name>inforec</name></decl>;</decl_stmt> <comment type="block">/* address of its info record */</comment>
}</block></struct></type> <name>CFuncHashTabEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>CFuncHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmgr_info_cxt_security</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>ignore_security</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmgr_info_C_lang</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmgr_info_other_lang</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CFuncHashTabEntry</name> <modifier>*</modifier></type><name>lookup_C_func</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>record_C_func</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>,
						  <parameter><decl><type><name>PGFunction</name></type> <name>user_fn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type><name>inforec</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* extern so it's callable via JIT */</comment>
<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>fmgr_security_definer</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Lookup routines for builtin-function table.  We can search by either Oid
 * or name, but search by Oid is much faster.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>FmgrBuiltin</name> <modifier>*</modifier></type>
<name>fmgr_isbuiltin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>index</name></decl>;</decl_stmt>

	<comment type="block">/* fast lookup only possible if original oid still assigned */</comment>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;</operator> <name>fmgr_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lookup function data. If there's a miss in that range it's likely a
	 * nonexistent function, returning NULL here will trigger an ERROR later.
	 */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>fmgr_builtin_oid_index</name><index>[<expr><name>id</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>InvalidOidBuiltinMapping</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>fmgr_builtins</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup a builtin by name.  Note there can be more than one entry in
 * the array with the same name, but they should all point to the same
 * routine.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>FmgrBuiltin</name> <modifier>*</modifier></type>
<name>fmgr_lookupByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fmgr_nbuiltins</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>fmgr_builtins</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>funcName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>fmgr_builtins</name> <operator>+</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This routine fills a FmgrInfo struct, given the OID
 * of the function to be called.
 *
 * The caller's CurrentMemoryContext is used as the fn_mcxt of the info
 * struct; this means that any subsidiary data attached to the info struct
 * (either by fmgr_info itself, or later on by a function call handler)
 * will be allocated in that context.  The caller must ensure that this
 * context is at least as long-lived as the info struct itself.  This is
 * not a problem in typical cases where the info struct is on the stack or
 * in freshly-palloc'd space.  However, if one intends to store an info
 * struct in a long-lived table, it's better to use fmgr_info_cxt.
 */</comment>
<function><type><name>void</name></type>
<name>fmgr_info</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fmgr_info_cxt_security</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fill a FmgrInfo struct, specifying a memory context in which its
 * subsidiary data should go.
 */</comment>
<function><type><name>void</name></type>
<name>fmgr_info_cxt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fmgr_info_cxt_security</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This one does the actual work.  ignore_security is ordinarily false
 * but is set to true when we need to avoid recursion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmgr_info_cxt_security</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>ignore_security</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>FmgrBuiltin</name> <modifier>*</modifier></type><name>fbp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcdatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is
	 * valid, the whole struct is valid.  Some FmgrInfo struct's do survive
	 * elogs.
	 */</comment>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name> <operator>=</operator> <name>mcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* caller may set this later */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fbp</name> <operator>=</operator> <call><name>fmgr_isbuiltin</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fast path for builtin functions: don't bother consulting pg_proc
		 */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_nargs</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>strict</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>retset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_ALL</name></expr>;</expr_stmt>	<comment type="block">/* ie, never track */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name>functionId</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise we need the pg_proc entry */</comment>
	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_nargs</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proisstrict</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it has prosecdef set, non-null proconfig, or if a plugin wants to
	 * hook function entry/exit, use fmgr_security_definer call handler ---
	 * unless we are being called again by fmgr_security_definer or
	 * fmgr_info_other_lang.
	 *
	 * When using fmgr_security_definer, function stats tracking is always
	 * disabled at the outer level, and instead we set the flag properly in
	 * fmgr_security_definer's private flinfo and implement the tracking
	 * inside fmgr_security_definer.  This loses the ability to charge the
	 * overhead of fmgr_security_definer to the function, but gains the
	 * ability to set the track_functions GUC as a local GUC parameter of an
	 * interesting function and have the right things happen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_security</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>procedureStruct</name><operator>-&gt;</operator><name>prosecdef</name></name> <operator>||</operator>
		 <operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>FmgrHookIsNeeded</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name>fmgr_security_definer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_ALL</name></expr>;</expr_stmt>	<comment type="block">/* ie, never track */</comment>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name>functionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INTERNALlanguageId</name></expr>:</case>

			<comment type="block">/*
			 * For an ordinary builtin function, we should never get here
			 * because the fmgr_isbuiltin() search above will have succeeded.
			 * However, if the user has done a CREATE FUNCTION to create an
			 * alias for a builtin function, we can end up here.  In that case
			 * we have to look up the function by name.  The name of the
			 * internal function is stored in prosrc (it doesn't have to be
			 * the same as the name of the alias!)
			 */</comment>
			<expr_stmt><expr><name>prosrcdatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
										  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fbp</name> <operator>=</operator> <call><name>fmgr_lookupByName</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal function \"%s\" is not in internal lookup table"</literal></expr></argument>,
								<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Should we check that nargs, strict, retset match the table? */</comment>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>fbp</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
			<comment type="block">/* note this policy is also assumed in fast path above */</comment>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_ALL</name></expr>;</expr_stmt>	<comment type="block">/* ie, never track */</comment>
			<break>break;</break>

		<case>case <expr><name>ClanguageId</name></expr>:</case>
			<expr_stmt><expr><call><name>fmgr_info_C_lang</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_PL</name></expr>;</expr_stmt>	<comment type="block">/* ie, track if ALL */</comment>
			<break>break;</break>

		<case>case <expr><name>SQLlanguageId</name></expr>:</case>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name>fmgr_sql</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_PL</name></expr>;</expr_stmt>	<comment type="block">/* ie, track if ALL */</comment>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>fmgr_info_other_lang</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_stats</name></name> <operator>=</operator> <name>TRACK_FUNC_OFF</name></expr>;</expr_stmt>	<comment type="block">/* ie, track if not OFF */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name>functionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return module and C function name providing implementation of functionId.
 *
 * If *mod == NULL and *fn == NULL, no C symbol is known to implement
 * function.
 *
 * If *mod == NULL and *fn != NULL, the function is implemented by a symbol in
 * the main binary.
 *
 * If *mod != NULL and *fn !=NULL the function is implemented in an extension
 * shared object.
 *
 * The returned module and function names are pstrdup'ed into the current
 * memory context.
 */</comment>
<function><type><name>void</name></type>
<name>fmgr_symbol</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>mod</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procedureTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>probinattr</name></decl>;</decl_stmt>

	<comment type="block">/* Otherwise we need the pg_proc entry */</comment>
	<expr_stmt><expr><name>procedureTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prosecdef</name></name> <operator>||</operator>
		<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>FmgrHookIsNeeded</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>mod</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* core binary */</comment>
		<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"fmgr_security_definer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* see fmgr_info_cxt_security for the individual cases */</comment>
	<switch>switch <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INTERNALlanguageId</name></expr>:</case>
			<expr_stmt><expr><name>prosrcattr</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
										 <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>mod</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* core binary */</comment>
			<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ClanguageId</name></expr>:</case>
			<expr_stmt><expr><name>prosrcattr</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
										 <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for C function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>probinattr</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
										 <argument><expr><name>Anum_pg_proc_probin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null probin for C function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * No need to check symbol presence / API version here, already
			 * checked in fmgr_info_cxt_security.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>mod</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>probinattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SQLlanguageId</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>mod</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* core binary */</comment>
			<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"fmgr_sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><operator>*</operator><name>mod</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* unknown, pass pointer */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Special fmgr_info processing for C-language functions.  Note that
 * finfo-&gt;fn_oid is not valid yet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmgr_info_C_lang</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CFuncHashTabEntry</name> <modifier>*</modifier></type><name>hashentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name></type>	<name>user_fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type><name>inforec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See if we have the function address cached already
	 */</comment>
	<expr_stmt><expr><name>hashentry</name> <operator>=</operator> <call><name>lookup_C_func</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hashentry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>user_fn</name> <operator>=</operator> <name><name>hashentry</name><operator>-&gt;</operator><name>user_fn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inforec</name> <operator>=</operator> <name><name>hashentry</name><operator>-&gt;</operator><name>inforec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcattr</name></decl>,
					<decl><type ref="prev"/><name>probinattr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrcstring</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>probinstring</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>libraryhandle</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get prosrc and probin strings (link symbol and library filename).
		 * While in general these columns might be null, that's not allowed
		 * for C-language functions.
		 */</comment>
		<expr_stmt><expr><name>prosrcattr</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for C function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prosrcstring</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>probinattr</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procedureTuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_probin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null probin for C function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>probinstring</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>probinattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Look up the function itself */</comment>
		<expr_stmt><expr><name>user_fn</name> <operator>=</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name>probinstring</name></expr></argument>, <argument><expr><name>prosrcstring</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>libraryhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the function information record (real or default) */</comment>
		<expr_stmt><expr><name>inforec</name> <operator>=</operator> <call><name>fetch_finfo_record</name><argument_list>(<argument><expr><name>libraryhandle</name></expr></argument>, <argument><expr><name>prosrcstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Cache the addresses for later calls */</comment>
		<expr_stmt><expr><call><name>record_C_func</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>, <argument><expr><name>user_fn</name></expr></argument>, <argument><expr><name>inforec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prosrcstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>probinstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>inforec</name><operator>-&gt;</operator><name>api_version</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<comment type="block">/* New style: call directly */</comment>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name>user_fn</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Shouldn't get here if fetch_finfo_record did its job */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized function API version: %d"</literal></expr></argument>,
				 <argument><expr><name><name>inforec</name><operator>-&gt;</operator><name>api_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Special fmgr_info processing for other-language functions.  Note
 * that finfo-&gt;fn_oid is not valid yet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmgr_info_other_lang</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>language</name> <init>= <expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>languageTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>languageStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>plfinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>languageTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>language</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>, <argument><expr><name>language</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>languageStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the language's call handler function, ignoring any attributes
	 * that would normally cause insertion of fmgr_security_definer.  We need
	 * to get back a bare pointer to the actual C-language function.
	 */</comment>
	<expr_stmt><expr><call><name>fmgr_info_cxt_security</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanplcallfoid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plfinfo</name></expr></argument>,
						   <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>plfinfo</name><operator>.</operator><name>fn_addr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch and validate the information record for the given external function.
 * The function is specified by a handle for the containing library
 * (obtained from load_external_function) as well as the function name.
 *
 * If no info function exists for the given name an error is raised.
 *
 * This function is broken out of fmgr_info_C_lang so that fmgr_c_validator
 * can validate the information record for a function not yet entered into
 * pg_proc.
 */</comment>
<function><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type>
<name>fetch_finfo_record</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>filehandle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>infofuncname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFInfoFunction</name></type> <name>infofunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type><name>inforec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>infofuncname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pg_finfo_%s"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to look up the info function */</comment>
	<expr_stmt><expr><name>infofunc</name> <operator>=</operator> <operator>(</operator><name>PGFInfoFunction</name><operator>)</operator> <call><name>lookup_external_function</name><argument_list>(<argument><expr><name>filehandle</name></expr></argument>,
														  <argument><expr><name>infofuncname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>infofunc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find function information for function \"%s\""</literal></expr></argument>,
						<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* silence compiler */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Found, so call it */</comment>
	<expr_stmt><expr><name>inforec</name> <operator>=</operator> <call>(<modifier>*</modifier><name>infofunc</name>) <argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Validate result as best we can */</comment>
	<if_stmt><if>if <condition>(<expr><name>inforec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null result from info function \"%s\""</literal></expr></argument>, <argument><expr><name>infofuncname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>inforec</name><operator>-&gt;</operator><name>api_version</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<comment type="block">/* OK, no additional fields to validate */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized API version %d reported by info function \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>inforec</name><operator>-&gt;</operator><name>api_version</name></name></expr></argument>, <argument><expr><name>infofuncname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>infofuncname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>inforec</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *		Routines for caching lookup information for external C functions.
 *
 * The routines in dfmgr.c are relatively slow, so we try to avoid running
 * them more than once per external function per session.  We use a hash table
 * with the function OID as the lookup key.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * lookup_C_func: try to find a C function in the hash table
 *
 * If an entry exists and is up to date, return it; else return NULL
 */</comment>
<function><type><specifier>static</specifier> <name>CFuncHashTabEntry</name> <modifier>*</modifier></type>
<name>lookup_C_func</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fn_oid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFuncHashTabEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>CFuncHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no table yet */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>CFuncHashTabEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>CFuncHash</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>fn_oid</name></expr></argument>,
					<argument><expr><name>HASH_FIND</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no such entry */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>==</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procedureTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>fn_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procedureTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>entry</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* OK */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* entry is out of date */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * record_C_func: enter (or update) info about a C function in the hash table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>record_C_func</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procedureTuple</name></decl></parameter>,
			  <parameter><decl><type><name>PGFunction</name></type> <name>user_fn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pg_finfo_record</name> <modifier>*</modifier></type><name>inforec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fn_oid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procedureTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFuncHashTabEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Create the hash table if it doesn't exist yet */</comment>
	<if_stmt><if>if <condition>(<expr><name>CFuncHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CFuncHashTabEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>CFuncHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"CFuncHash"</literal></expr></argument>,
								<argument><expr><literal type="number">100</literal></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>CFuncHashTabEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>CFuncHash</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>fn_oid</name></expr></argument>,
					<argument><expr><name>HASH_ENTER</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* OID is already filled in */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procedureTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>fn_tid</name></name> <operator>=</operator> <name><name>procedureTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>user_fn</name></name> <operator>=</operator> <name>user_fn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>inforec</name></name> <operator>=</operator> <name>inforec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * clear_external_function_hash: remove entries for a library being closed
 *
 * Presently we just zap the entire hash table, but later it might be worth
 * the effort to remove only the entries associated with the given handle.
 */</comment>
<function><type><name>void</name></type>
<name>clear_external_function_hash</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>filehandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CFuncHash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>CFuncHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>CFuncHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Copy an FmgrInfo struct
 *
 * This is inherently somewhat bogus since we can't reliably duplicate
 * language-dependent subsidiary info.  We cheat by zeroing fn_extra,
 * instead, meaning that subsidiary info will have to be recomputed.
 */</comment>
<function><type><name>void</name></type>
<name>fmgr_info_copy</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>dstinfo</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>srcinfo</name></decl></parameter>,
			   <parameter><decl><type><name>MemoryContext</name></type> <name>destcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dstinfo</name></expr></argument>, <argument><expr><name>srcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name> <operator>=</operator> <name>destcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Specialized lookup routine for fmgr_internal_validator: given the alleged
 * name of an internal function, return the OID of the function.
 * If the name is not recognized, return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>fmgr_internal_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>FmgrBuiltin</name> <modifier>*</modifier></type><name>fbp</name> <init>= <expr><call><name>fmgr_lookupByName</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>fbp</name><operator>-&gt;</operator><name>foid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Support for security-definer and proconfig-using functions.  We support
 * both of these features using the same call handler, because they are
 * often used together and it would be inefficient (as well as notationally
 * messy) to have two levels of call handler involved.
 */</comment>
<struct>struct <name>fmgr_security_definer_cache</name>
<block>{
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>			<comment type="block">/* lookup info for target function */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>			<comment type="block">/* userid to set, or InvalidOid */</comment>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>proconfig</name></decl>;</decl_stmt>		<comment type="block">/* GUC values to set, or NULL */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg</name></decl>;</decl_stmt>			<comment type="block">/* passthrough argument for plugin modules */</comment>
}</block>;</struct>

<comment type="block">/*
 * Function handler for security-definer/proconfig/plugin-hooked functions.
 * We extract the OID of the actual function and do a fmgr lookup again.
 * Then we fetch the pg_proc row and copy the owner ID and proconfig fields.
 * (All this info is cached for the duration of the current query.)
 * To execute a call, we temporarily replace the flinfo with the cached
 * and looked-up one, while keeping the outer fcinfo (which contains all
 * the actual arguments, etc.) intact.  This is not re-entrant, but then
 * the fcinfo itself can't be used reentrantly anyway.
 */</comment>
<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>fmgr_security_definer</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fmgr_security_definer_cache</name></name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>fcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>save_flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procedureStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fcache</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fcache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fmgr_info_cxt_security</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
							   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name><operator>.</operator><name>fn_expr</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
				 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>procedureStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>procedureStruct</name><operator>-&gt;</operator><name>prosecdef</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>procedureStruct</name><operator>-&gt;</operator><name>proowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>proconfig</name></name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>fcache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fcache</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* GetUserIdAndSecContext is cheap enough that no harm in a wasted call */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>proconfig</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* Need a new GUC nesting level */</comment>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* keep compiler quiet */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>,
							   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>proconfig</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ProcessGUCArray</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>proconfig</name></name></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><name>PGC_S_SESSION</name></expr></argument>,
						<argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* function manager hook */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmgr_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>fmgr_hook</name>) <argument_list>(<argument><expr><name>FHET_START</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to restore GUC or userid settings on error, because the
	 * ensuing xact or subxact abort will do that.  The PG_TRY block is only
	 * needed to clean up the flinfo link.
	 */</comment>
	<expr_stmt><expr><name>save_flinfo</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name></name></expr>;</expr_stmt>

		<comment type="block">/* See notes in fmgr_info_cxt_security */</comment>
		<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We could be calling either a regular or a set-returning function,
		 * so we have to test to see what finalize flag to use.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>,
								  <argument><expr><operator>(</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
								   <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
								   <operator>(</operator><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name><operator>)</operator><operator>-&gt;</operator><name>isDone</name> <operator>!=</operator> <name>ExprMultipleResult</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name> <operator>=</operator> <name>save_flinfo</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fmgr_hook</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>fmgr_hook</name>) <argument_list>(<argument><expr><name>FHET_ABORT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name> <operator>=</operator> <name>save_flinfo</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>proconfig</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fmgr_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>fmgr_hook</name>) <argument_list>(<argument><expr><name>FHET_END</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcache</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *		Support routines for callers of fmgr-compatible functions
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * These are for invocation of a specifically named function with a
 * directly-computed parameter list.  Note that neither arguments nor result
 * are allowed to be NULL.  Also, the function cannot be one that needs to
 * look at FmgrInfo, since there won't be any.
 */</comment>
<function><type><name>Datum</name></type>
<name>DirectFunctionCall1Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall2Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall3Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall4Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall5Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall6Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall7Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall8Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg8</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>DirectFunctionCall9Coll</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>arg9</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg8</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg9</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * These functions work like the DirectFunctionCall functions except that
 * they use the flinfo parameter to initialise the fcinfo for the call.
 * It's recommended that the callee only use the fn_extra and fn_mcxt
 * fields, as other fields will typically describe the calling function
 * not the callee.  Conversely, the calling function should not have
 * used fn_extra, unless its use is known to be compatible with the callee's.
 */</comment>

<function><type><name>Datum</name></type>
<name>CallerFInfoFunctionCall1</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>CallerFInfoFunctionCall2</name><parameter_list>(<parameter><decl><type><name>PGFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %p returned NULL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * These are for invocation of a previously-looked-up function with a
 * directly-computed parameter list.  Note that neither arguments nor result
 * are allowed to be NULL.
 */</comment>
<function><type><name>Datum</name></type>
<name>FunctionCall0Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall1Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall2Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall3Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall4Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall5Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall6Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall7Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall8Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg8</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>FunctionCall9Coll</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>arg9</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg5</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg6</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg7</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg8</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>arg9</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These are for invocation of a function identified by OID with a
 * directly-computed parameter list.  Note that neither arguments nor result
 * are allowed to be NULL.  These are essentially fmgr_info() followed
 * by FunctionCallN().  If the same function is to be invoked repeatedly,
 * do the fmgr_info() once and then use FunctionCallN().
 */</comment>
<function><type><name>Datum</name></type>
<name>OidFunctionCall0Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall0Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall1Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall2Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall3Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall3Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall4Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall5Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>, <argument><expr><name>arg5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall6Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall6Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>, <argument><expr><name>arg5</name></expr></argument>,
							 <argument><expr><name>arg6</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall7Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall7Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>, <argument><expr><name>arg5</name></expr></argument>,
							 <argument><expr><name>arg6</name></expr></argument>, <argument><expr><name>arg7</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall8Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall8Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>, <argument><expr><name>arg5</name></expr></argument>,
							 <argument><expr><name>arg6</name></expr></argument>, <argument><expr><name>arg7</name></expr></argument>, <argument><expr><name>arg8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidFunctionCall9Coll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg2</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg3</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg4</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg5</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg6</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg7</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg8</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name></type> <name>arg9</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionCall9Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>, <argument><expr><name>arg5</name></expr></argument>,
							 <argument><expr><name>arg6</name></expr></argument>, <argument><expr><name>arg7</name></expr></argument>, <argument><expr><name>arg8</name></expr></argument>, <argument><expr><name>arg9</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Special cases for convenient invocation of datatype I/O functions.
 */</comment>

<comment type="block">/*
 * Call a previously-looked-up datatype input function.
 *
 * "str" may be NULL to indicate we are reading a NULL.  In this case
 * the caller should assume the result is NULL, but we'll call the input
 * function anyway if it's not strict.  So this is almost but not quite
 * the same as FunctionCall3.
 */</comment>
<function><type><name>Datum</name></type>
<name>InputFunctionCall</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* just return null result */</comment>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Should get null result if and only if str is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"input function %u returned non-NULL"</literal></expr></argument>,
				 <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"input function %u returned NULL"</literal></expr></argument>,
				 <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call a previously-looked-up datatype output function.
 *
 * Do not call this on NULL datums.
 *
 * This is currently little more than window dressing for FunctionCall1.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>OutputFunctionCall</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call a previously-looked-up datatype binary-input function.
 *
 * "buf" may be NULL to indicate we are reading a NULL.  In this case
 * the caller should assume the result is NULL, but we'll call the receive
 * function anyway if it's not strict.  So this is almost but not quite
 * the same as FunctionCall3.
 */</comment>
<function><type><name>Datum</name></type>
<name>ReceiveFunctionCall</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* just return null result */</comment>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Should get null result if and only if buf is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"receive function %u returned non-NULL"</literal></expr></argument>,
				 <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"receive function %u returned NULL"</literal></expr></argument>,
				 <argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call a previously-looked-up datatype binary-output function.
 *
 * Do not call this on NULL datums.
 *
 * This is little more than window dressing for FunctionCall1, but it does
 * guarantee a non-toasted result, which strictly speaking the underlying
 * function doesn't.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>SendFunctionCall</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetByteaP</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><name>flinfo</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, for I/O functions identified by OID.  These are only to be used
 * in seldom-executed code paths.  They are not only slow but leak memory.
 */</comment>
<function><type><name>Datum</name></type>
<name>OidInputFunctionCall</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>OidOutputFunctionCall</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>OidReceiveFunctionCall</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>OidSendFunctionCall</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>SendFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *		Support routines for standard maybe-pass-by-reference datatypes
 *
 * int8 and float8 can be passed by value if Datum is wide enough.
 * (For backwards-compatibility reasons, we allow pass-by-ref to be chosen
 * at compile time even if pass-by-val is possible.)
 *
 * Note: there is only one switch controlling the pass-by-value option for
 * both int8 and float8; this is to avoid making things unduly complicated
 * for the timestamp types, which might have either representation.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>		<comment type="block">/* controls int8 too */</comment>

<function><type><name>Datum</name></type>
<name>Int64GetDatum</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>X</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name>X</name></expr>;</expr_stmt>
	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>Float8GetDatum</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>X</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name>X</name></expr>;</expr_stmt>
	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_FLOAT8_BYVAL */</comment>


<comment type="block">/*-------------------------------------------------------------------------
 *		Support routines for toastable datatypes
 *-------------------------------------------------------------------------
 */</comment>

<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>pg_detoast_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>detoast_attr</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>datum</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>pg_detoast_datum_copy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>detoast_attr</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Make a modifiable copy of the varlena object */</comment>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>pg_detoast_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only get the specified portion from the toast rel */</comment>
	<return>return <expr><call><name>detoast_attr_slice</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>pg_detoast_datum_packed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>detoast_attr</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>datum</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 *		Support routines for extracting info from fn_expr parse tree
 *
 * These are needed by polymorphic functions, which accept multiple possible
 * input types and need help from the parser to know what they've got.
 * Also, some functions might be interested in whether a parameter is constant.
 * Functions taking VARIADIC ANY also need to know about the VARIADIC keyword.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Get the actual type OID of the function return type
 *
 * Returns InvalidOid if information is not available
 */</comment>
<function><type><name>Oid</name></type>
<name>get_fn_expr_rettype</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * can't return anything useful if we have no FmgrInfo or if its fn_expr
	 * node has not been initialized
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flinfo</name> <operator>||</operator> <operator>!</operator><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the actual type OID of a specific function argument (counting from 0)
 *
 * Returns InvalidOid if information is not available
 */</comment>
<function><type><name>Oid</name></type>
<name>get_fn_expr_argtype</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * can't return anything useful if we have no FmgrInfo or if its fn_expr
	 * node has not been initialized
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flinfo</name> <operator>||</operator> <operator>!</operator><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the actual type OID of a specific function argument (counting from 0),
 * but working from the calling expression tree instead of FmgrInfo
 *
 * Returns InvalidOid if information is not available
 */</comment>
<function><type><name>Oid</name></type>
<name>get_call_expr_argtype</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>argnum</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>argnum</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * special hack for ScalarArrayOpExpr: what the underlying function will
	 * actually get passed is the element type of the array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>argnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>argtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find out whether a specific function argument is constant for the
 * duration of a query
 *
 * Returns false if information is not available
 */</comment>
<function><type><name>bool</name></type>
<name>get_fn_expr_arg_stable</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * can't return anything useful if we have no FmgrInfo or if its fn_expr
	 * node has not been initialized
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flinfo</name> <operator>||</operator> <operator>!</operator><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>get_call_expr_arg_stable</name><argument_list>(<argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find out whether a specific function argument is constant for the
 * duration of a query, but working from the calling expression tree
 *
 * Returns false if information is not available
 */</comment>
<function><type><name>bool</name></type>
<name>get_call_expr_arg_stable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>argnum</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>argnum</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Either a true Const or an external Param will have a value that doesn't
	 * change during the execution of the query.  In future we might want to
	 * consider other cases too, e.g. now().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXTERN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the VARIADIC flag from the function invocation
 *
 * Returns false (the default assumption) if information is not available
 *
 * Note this is generally only of interest to VARIADIC ANY functions
 */</comment>
<function><type><name>bool</name></type>
<name>get_fn_expr_variadic</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * can't return anything useful if we have no FmgrInfo or if its fn_expr
	 * node has not been initialized
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flinfo</name> <operator>||</operator> <operator>!</operator><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>funcvariadic</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set options to FmgrInfo of opclass support function.
 *
 * Opclass support functions are called outside of expressions.  Thanks to that
 * we can use fn_expr to store opclass options as bytea constant.
 */</comment>
<function><type><name>void</name></type>
<name>set_fn_opclass_options</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>options</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if options are defined for opclass support function.
 */</comment>
<function><type><name>bool</name></type>
<name>has_fn_opclass_options</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>flinfo</name> <operator>&amp;&amp;</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get options for opclass support function.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>get_fn_opclass_options</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>flinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>flinfo</name> <operator>&amp;&amp;</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class options info is absent in function call context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 *		Support routines for procedural language implementations
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Verify that a validator is actually associated with the language of a
 * particular function and that the user has access to both the language and
 * the function.  All validators should call this before doing anything
 * substantial.  Doing so ensures a user cannot achieve anything with explicit
 * calls to validators that he could not achieve with CREATE FUNCTION or by
 * simply calling an existing function.
 *
 * When this function returns false, callers should skip all validation work
 * and call PG_RETURN_VOID().  This never happens at present; it is reserved
 * for future expansion.
 *
 * In particular, checking that the validator corresponds to the function's
 * language allows untrusted language validators to assume they process only
 * superuser-chosen source code.  (Untrusted language call handlers, by
 * definition, do assume that.)  A user lacking the USAGE language privilege
 * would be unable to reach the validator through CREATE FUNCTION, so we check
 * that to block explicit calls as well.  Checking the EXECUTE privilege on
 * the function is often superfluous, because most users can clone the
 * function to get an executable copy.  It is meaningful against users with no
 * database TEMP right and no permanent schema CREATE right, thereby unable to
 * create any function.  Also, if the function tracks persistent state by
 * function OID or name, validating the original function might permit more
 * mischief than creating and validating a clone thereof.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckFunctionValidatorAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>validatorOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>langTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>langStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the function's pg_proc entry.  Throw a user-facing error for bad
	 * OID, because validators can be called with user-specified OIDs.
	 */</comment>
	<expr_stmt><expr><name>procTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>functionOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch pg_language entry to know if this is the correct validation
	 * function for that pg_proc entry.
	 */</comment>
	<expr_stmt><expr><name>langTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>, <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>langStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>langStruct</name><operator>-&gt;</operator><name>lanvalidator</name></name> <operator>!=</operator> <name>validatorOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language validation function %u called for language %u instead of %u"</literal></expr></argument>,
						<argument><expr><name>validatorOid</name></expr></argument>, <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>,
						<argument><expr><name><name>langStruct</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* first validate that we have permissions to use the language */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_language_aclcheck</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>langStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check whether we are allowed to execute the function itself. If we can
	 * execute it, there should be no possible side-effect of
	 * compiling/validation that execution can't have.
	 */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
