<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/fmgr/funcapi.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * funcapi.c
 *	  Utility and convenience functions for fmgr functions that return
 *	  sets and/or composite types, or deal with VARIADIC inputs.
 *
 * Copyright (c) 2002-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/utils/fmgr/funcapi.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>polymorphic_actuals</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anyelement_type</name></decl>;</decl_stmt>	<comment type="block">/* anyelement mapping, if known */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anyarray_type</name></decl>;</decl_stmt>	<comment type="block">/* anyarray mapping, if known */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anyrange_type</name></decl>;</decl_stmt>	<comment type="block">/* anyrange mapping, if known */</comment>
}</block></struct></type> <name>polymorphic_actuals</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shutdown_MultiFuncCall</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TypeFuncClass</name></type> <name>internal_get_result_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
											  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>,
											  <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>resultTypeId</name></decl></parameter>,
											  <parameter><decl><type><name>TupleDesc</name> <modifier>*</modifier></type><name>resultTupleDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolve_anyelement_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolve_anyarray_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolve_anyrange_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>resolve_polymorphic_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
										<parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>declared_args</name></decl></parameter>,
										<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TypeFuncClass</name></type> <name>get_type_func_class</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>base_typeid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * init_MultiFuncCall
 * Create an empty FuncCallContext data structure
 * and do some other basic Multi-function call setup
 * and error checking
 */</comment>
<function><type><name>FuncCallContext</name> <modifier>*</modifier></type>
<name>init_MultiFuncCall</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Bail if we're called in the wrong context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First call
		 */</comment>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>multi_call_ctx</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Create a suitably long-lived context to hold cross-call data
		 */</comment>
		<expr_stmt><expr><name>multi_call_ctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
											   <argument><expr><literal type="string">"SRF multi-call context"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Allocate suitably long-lived space and zero it
		 */</comment>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>FuncCallContext</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>multi_call_ctx</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncCallContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * initialize the elements
		 */</comment>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name> <operator>=</operator> <name>multi_call_ctx</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * save the pointer for cross-call use
		 */</comment>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>retval</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure we will get shut down cleanly if the exprcontext is not run
		 * to completion.
		 */</comment>
		<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
									<argument><expr><name>shutdown_MultiFuncCall</name></expr></argument>,
									<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* second and subsequent calls */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"init_MultiFuncCall cannot be called more than once"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* never reached, but keep compiler happy */</comment>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * per_MultiFuncCall
 *
 * Do Multi-function per-call setup
 */</comment>
<function><type><name>FuncCallContext</name> <modifier>*</modifier></type>
<name>per_MultiFuncCall</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><operator>(</operator><name>FuncCallContext</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * end_MultiFuncCall
 * Clean up after init_MultiFuncCall
 */</comment>
<function><type><name>void</name></type>
<name>end_MultiFuncCall</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Deregister the shutdown callback */</comment>
	<expr_stmt><expr><call><name>UnregisterExprContextCallback</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name></name></expr></argument>,
								  <argument><expr><name>shutdown_MultiFuncCall</name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* But use it to do the real work */</comment>
	<expr_stmt><expr><call><name>shutdown_MultiFuncCall</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shutdown_MultiFuncCall
 * Shutdown function to clean up after init_MultiFuncCall
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shutdown_MultiFuncCall</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>flinfo</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><operator>(</operator><name>FuncCallContext</name> <operator>*</operator><operator>)</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* unbind from flinfo */</comment>
	<expr_stmt><expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete context that holds all multi-call data, including the
	 * FuncCallContext itself
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_call_result_type
 *		Given a function's call info record, determine the kind of datatype
 *		it is supposed to return.  If resultTypeId isn't NULL, *resultTypeId
 *		receives the actual datatype OID (this is mainly useful for scalar
 *		result types).  If resultTupleDesc isn't NULL, *resultTupleDesc
 *		receives a pointer to a TupleDesc when the result is of a composite
 *		type, or NULL when it's a scalar result.
 *
 * One hard case that this handles is resolution of actual rowtypes for
 * functions returning RECORD (from either the function's OUT parameter
 * list, or a ReturnSetInfo context node).  TYPEFUNC_RECORD is returned
 * only when we couldn't resolve the actual rowtype for lack of information.
 *
 * The other hard case that this handles is resolution of polymorphism.
 * We will never return polymorphic pseudotypes (ANYELEMENT etc), either
 * as a scalar result type or as a component of a rowtype.
 *
 * This function is relatively expensive --- in a function returning set,
 * try to call it only the first time through.
 */</comment>
<function><type><name>TypeFuncClass</name></type>
<name>get_call_result_type</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>resultTypeId</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name> <modifier>*</modifier></type><name>resultTupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>internal_get_result_type</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>,
									<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
									<argument><expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>,
									<argument><expr><name>resultTypeId</name></expr></argument>,
									<argument><expr><name>resultTupleDesc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_expr_result_type
 *		As above, but work from a calling expression node tree
 */</comment>
<function><type><name>TypeFuncClass</name></type>
<name>get_expr_result_type</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>resultTypeId</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name> <modifier>*</modifier></type><name>resultTupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_get_result_type</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>,
										  <argument><expr><name>expr</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>resultTypeId</name></expr></argument>,
										  <argument><expr><name>resultTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_get_result_type</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>expr</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>resultTypeId</name></expr></argument>,
										  <argument><expr><name>resultTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>row_typeid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can resolve the record type by generating the tupdesc directly */</comment>
		<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lcn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lcc</argument>, <argument>rexpr-&gt;args</argument>, <argument>lcn</argument>, <argument>rexpr-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
							   <argument><expr><name>colname</name></expr></argument>,
							   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>resultTypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTypeId</name> <operator>=</operator> <name><name>rexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>TYPEFUNC_COMPOSITE</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* handle as a generic expression; no chance to resolve RECORD */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultTypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTypeId</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_type_func_class</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
			 <name>result</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name>base_typid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_result_type
 *		As above, but work from a function's OID only
 *
 * This will not be able to resolve pure-RECORD results nor polymorphism.
 */</comment>
<function><type><name>TypeFuncClass</name></type>
<name>get_func_result_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>resultTypeId</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name> <modifier>*</modifier></type><name>resultTupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>internal_get_result_type</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>resultTypeId</name></expr></argument>,
									<argument><expr><name>resultTupleDesc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * internal_get_result_type -- workhorse code implementing all the above
 *
 * funcid must always be supplied.  call_expr and rsinfo can be NULL if not
 * available.  We will return TYPEFUNC_RECORD, and store NULL into
 * *resultTupleDesc, if we cannot deduce the complete result rowtype from
 * the available information.
 */</comment>
<function><type><specifier>static</specifier> <name>TypeFuncClass</name></type>
<name>internal_get_result_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
						 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>,
						 <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>resultTypeId</name></decl></parameter>,
						 <parameter><decl><type><name>TupleDesc</name> <modifier>*</modifier></type><name>resultTupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>base_rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<comment type="block">/* First fetch the function's pg_proc row to inspect its rettype */</comment>
	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>

	<comment type="block">/* Check for OUT parameters defining a RECORD result */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>build_function_result_tupdesc_t</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tupdesc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It has OUT parameters, so it's basically like a regular composite
		 * type, except we have to be able to resolve any polymorphic OUT
		 * parameters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultTypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultTypeId</name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>resolve_polymorphic_tupdesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name></name></expr></argument>,
										<argument><expr><name>call_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
				<name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TYPEFUNC_RECORD</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If scalar polymorphic result, try to resolve it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newrettype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrettype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* this probably should not happen */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual result type for function \"%s\" declared to return type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name>newrettype</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>resultTypeId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>resultTypeId</name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* default result */</comment>

	<comment type="block">/* Classify the result type */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_type_func_class</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
		<case>case <expr><name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name>base_rettype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Named composite types can't have any polymorphic columns */</comment>
			<break>break;</break>
		<case>case <expr><name>TYPEFUNC_SCALAR</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>
			<comment type="block">/* We must get the tupledesc from call context */</comment>
			<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>resultTupleDesc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>resultTupleDesc</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Assume no polymorphic columns here, either */</comment>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_expr_result_tupdesc
 *		Get a tupdesc describing the result of a composite-valued expression
 *
 * If expression is not composite or rowtype can't be determined, returns NULL
 * if noError is true, else throws error.
 *
 * This is a simpler version of get_expr_result_type() for use when the caller
 * is only interested in determinate rowtype results.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>get_expr_result_tupdesc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
		<name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tupleDesc</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noError</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>exprTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>exprTypeId</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record type has not been registered"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Resolve actual type of ANYELEMENT from other polymorphic inputs
 *
 * Note: the error cases here and in the sibling functions below are not
 * really user-facing; they could only occur if the function signature is
 * incorrect or the parser failed to enforce consistency of the actual
 * argument types.  Hence, we don't sweat too much over the error messages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_anyelement_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the element type corresponding to actual type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>array_base_type</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typelem</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>array_base_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"anyarray"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_base_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name> <operator>=</operator> <name>array_typelem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the element type corresponding to actual type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>range_base_type</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>range_typelem</name> <init>= <expr><call><name>get_range_subtype</name><argument_list>(<argument><expr><name>range_base_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not a range type but type %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"anyrange"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_base_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name> <operator>=</operator> <name>range_typelem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine polymorphic type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Resolve actual type of ANYARRAY from other polymorphic inputs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_anyarray_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If we don't know ANYELEMENT, resolve that first */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyelement_from_others</name><argument_list>(<argument><expr><name>actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the array type corresponding to actual type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typeid</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>actuals</name><operator>-&gt;</operator><name>anyarray_type</name></name> <operator>=</operator> <name>array_typeid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine polymorphic type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Resolve actual type of ANYRANGE from other polymorphic inputs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_anyrange_from_others</name><parameter_list>(<parameter><decl><type><name>polymorphic_actuals</name> <modifier>*</modifier></type><name>actuals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We can't deduce a range type from other polymorphic inputs, because
	 * there may be multiple range types with the same subtype.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine polymorphic type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given the result tuple descriptor for a function with OUT parameters,
 * replace any polymorphic column types (ANYELEMENT etc) in the tupdesc
 * with concrete data types deduced from the input arguments.
 * declared_args is an oidvector of the function's declared input arg types
 * (showing which are polymorphic), and call_expr is the call expression.
 *
 * Returns true if able to deduce all types, false if necessary information
 * is not provided (call_expr is NULL or arg types aren't identifiable).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>resolve_polymorphic_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>declared_args</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>declared_args</name><operator>-&gt;</operator><name>dim1</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_polymorphic_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyelement_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyarray_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyrange_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_array_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_range_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polymorphic_actuals</name></type> <name>poly_actuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polymorphic_actuals</name></type> <name>anyc_actuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatcollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* See if there are any polymorphic outputs; quick out if not */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
			<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
			<case>case <expr><name>ANYENUMOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anyelement_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anyarray_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anyrange_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEOID</name></expr>:</case>
			<case>case <expr><name>ANYCOMPATIBLENONARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anycompatible_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anycompatible_array_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLERANGEOID</name></expr>:</case>
				<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_anycompatible_range_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_polymorphic_result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, extract actual datatype(s) from input arguments.  (We assume
	 * the parser already validated consistency of the arguments.  Also, for
	 * the ANYCOMPATIBLE pseudotype family, we expect that all matching
	 * arguments were coerced to the selected common supertype, so that it
	 * doesn't matter which one's exposed type we look at.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>call_expr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no hope */</comment>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>poly_actuals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>anyc_actuals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>declared_args</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
			<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
			<case>case <expr><name>ANYENUMOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEOID</name></expr>:</case>
			<case>case <expr><name>ANYCOMPATIBLENONARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLERANGEOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name> <operator>=</operator>
						<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* If needed, deduce one polymorphic type from others */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_anyelement_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyelement_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anyarray_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyarray_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anyrange_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyrange_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyelement_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_array_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyarray_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_range_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyrange_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify the collation to use for polymorphic OUT parameters. (It'll
	 * necessarily be the same for both anyelement and anyarray, likewise for
	 * anycompatible and anycompatiblearray.)  Note that range types are not
	 * collatable, so any possible internal collation of a range type is not
	 * considered here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>anycollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>anycollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>anycompatcollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>anycompatcollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycollation</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The types are collatable, so consider whether to use a nondefault
		 * collation.  We do so if we can identify the input collation used
		 * for the function.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>inputcollation</name> <init>= <expr><call><name>exprInputCollation</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>inputcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>anycollation</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>anycompatcollation</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And finally replace the tuple column types as needed */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
			<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
			<case>case <expr><name>ANYENUMOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>anycollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>anycollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no collation should be attached to a range type */</comment>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEOID</name></expr>:</case>
			<case>case <expr><name>ANYCOMPATIBLENONARRAYOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>anycompatcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>anycompatcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLERANGEOID</name></expr>:</case>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no collation should be attached to a range type */</comment>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given the declared argument types and modes for a function, replace any
 * polymorphic types (ANYELEMENT etc) in argtypes[] with concrete data types
 * deduced from the input arguments found in call_expr.
 *
 * Returns true if able to deduce all types, false if necessary information
 * is not provided (call_expr is NULL or arg types aren't identifiable).
 *
 * This is the same logic as resolve_polymorphic_tupdesc, but with a different
 * argument representation, and slightly different output responsibilities.
 *
 * argmodes may be NULL, in which case all arguments are assumed to be IN mode.
 */</comment>
<function><type><name>bool</name></type>
<name>resolve_polymorphic_argtypes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_polymorphic_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyelement_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyarray_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyrange_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_array_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_range_result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polymorphic_actuals</name></type> <name>poly_actuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polymorphic_actuals</name></type> <name>anyc_actuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inargno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First pass: resolve polymorphic inputs, check for outputs.  As in
	 * resolve_polymorphic_tupdesc, we rely on the parser to have enforced
	 * type consistency and coerced ANYCOMPATIBLE args to a common supertype.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>poly_actuals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>anyc_actuals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inargno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>argmode</name> <init>= <expr><ternary><condition><expr><name>argmodes</name></expr> ?</condition><then> <expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>PROARGMODE_IN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
			<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
			<case>case <expr><name>ANYENUMOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anyelement_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anyarray_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anyrange_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEOID</name></expr>:</case>
			<case>case <expr><name>ANYCOMPATIBLENONARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anycompatible_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anycompatible_array_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLERANGEOID</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator> <name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>have_polymorphic_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_anycompatible_range_result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name> <operator>=</operator>
							<call><name>get_call_expr_argtype</name><argument_list>(<argument><expr><name>call_expr</name></expr></argument>, <argument><expr><name>inargno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>!=</operator> <name>PROARGMODE_OUT</name> <operator>&amp;&amp;</operator> <name>argmode</name> <operator>!=</operator> <name>PROARGMODE_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inargno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Done? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_polymorphic_result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If needed, deduce one polymorphic type from others */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_anyelement_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyelement_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anyarray_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyarray_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anyrange_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyrange_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>poly_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyelement_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_array_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyarray_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anycompatible_range_result</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolve_anyrange_from_others</name><argument_list>(<argument><expr><operator>&amp;</operator><name>anyc_actuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And finally replace the output column types as needed */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
			<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
			<case>case <expr><name>ANYENUMOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>poly_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEOID</name></expr>:</case>
			<case>case <expr><name>ANYCOMPATIBLENONARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyelement_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyarray_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ANYCOMPATIBLERANGEOID</name></expr>:</case>
				<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>anyc_actuals</name><operator>.</operator><name>anyrange_type</name></name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_func_class
 *		Given the type OID, obtain its TYPEFUNC classification.
 *		Also, if it's a domain, return the base type OID.
 *
 * This is intended to centralize a bunch of formerly ad-hoc code for
 * classifying types.  The categories used here are useful for deciding
 * how to handle functions returning the datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>TypeFuncClass</name></type>
<name>get_type_func_class</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>base_typeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>base_typeid</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
			<return>return <expr><name>TYPEFUNC_COMPOSITE</name></expr>;</return>
		<case>case <expr><name>TYPTYPE_BASE</name></expr>:</case>
		<case>case <expr><name>TYPTYPE_ENUM</name></expr>:</case>
		<case>case <expr><name>TYPTYPE_RANGE</name></expr>:</case>
			<return>return <expr><name>TYPEFUNC_SCALAR</name></expr>;</return>
		<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>base_typeid</name> <operator>=</operator> <name>typid</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>				<comment type="block">/* domain base type can't be a pseudotype */</comment>
				<return>return <expr><name>TYPEFUNC_SCALAR</name></expr>;</return></block_content></block></else></if_stmt>
		<case>case <expr><name>TYPTYPE_PSEUDO</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>TYPEFUNC_RECORD</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We treat VOID and CSTRING as legitimate scalar datatypes,
			 * mostly for the convenience of the JDBC driver (which wants to
			 * be able to do "SELECT * FROM foo()" for all legitimately
			 * user-callable functions).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator> <name>typid</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>TYPEFUNC_SCALAR</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>TYPEFUNC_OTHER</name></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* shouldn't get here, probably */</comment>
	<return>return <expr><name>TYPEFUNC_OTHER</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_func_arg_info
 *
 * Fetch info about the argument types, names, and IN/OUT modes from the
 * pg_proc tuple.  Return value is the total number of arguments.
 * Other results are palloc'd.  *p_argtypes is always filled in, but
 * *p_argnames and *p_argmodes will be set NULL in the default cases
 * (no names, and all IN arguments, respectively).
 *
 * Note that this function simply fetches what is in the pg_proc tuple;
 * it doesn't do any interpretation of polymorphic types.
 */</comment>
<function><type><name>int</name></type>
<name>get_func_arg_info</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procTup</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_argtypes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>p_argnames</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_argmodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proallargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* First discover the total number of parameters and get their types */</comment>
	<expr_stmt><expr><name>proallargtypes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_proallargtypes</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We expect the arrays to be 1-D arrays of the right types; verify
		 * that.  For the OID and char arrays, we don't need to use
		 * deconstruct_array() since the array data is just going to look like
		 * a C array of values.
		 */</comment>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proallargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>numargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proallargtypes is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numargs</name> <operator>&gt;=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>p_argtypes</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If no proallargtypes, use proargtypes */</comment>
		<expr_stmt><expr><name>numargs</name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>dim1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numargs</name> <operator>==</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>p_argtypes</name></expr></argument>, <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
			   <argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Get argument names, if available */</comment>
	<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p_argnames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>!=</operator> <name>numargs</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargnames must have the same number of elements as the function has arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_argnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>p_argnames</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Get argument modes, if available */</comment>
	<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p_argmodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>numargs</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargmodes is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_argmodes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>p_argmodes</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>numargs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_trftypes
 *
 * Returns the number of transformed types used by the function.
 * If there are any, a palloc'd array of the type OIDs is returned
 * into *p_trftypes.
 */</comment>
<function><type><name>int</name></type>
<name>get_func_trftypes</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procTup</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_trftypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>protrftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>protrftypes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_protrftypes</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We expect the arrays to be 1-D arrays of the right types; verify
		 * that.  For the OID and char arrays, we don't need to use
		 * deconstruct_array() since the array data is just going to look like
		 * a C array of values.
		 */</comment>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>protrftypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>nelems</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"protrftypes is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_trftypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>p_trftypes</name></expr></argument>, <argument><expr><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>nelems</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_input_arg_names
 *
 * Extract the names of input arguments only, given a function's
 * proargnames and proargmodes entries in Datum form.
 *
 * Returns the number of input arguments, which is the length of the
 * palloc'd array returned to *arg_names.  Entries for unnamed args
 * are set to NULL.  You don't get anything if proargnames is NULL.
 */</comment>
<function><type><name>int</name></type>
<name>get_func_input_arg_names</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>proargnames</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>proargmodes</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>arg_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>inargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numinargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if null proargnames */</comment>
	<if_stmt><if>if <condition>(<expr><name>proargnames</name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>arg_names</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We expect the arrays to be 1-D arrays of the right types; verify that.
	 * For proargmodes, we don't need to use deconstruct_array() since the
	 * array data is just going to look like a C array of values.
	 */</comment>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargnames is not a 1-D text array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proargmodes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>numargs</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargmodes is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* zero elements probably shouldn't happen, but handle it gracefully */</comment>
	<if_stmt><if>if <condition>(<expr><name>numargs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>arg_names</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract input-argument names */</comment>
	<expr_stmt><expr><name>inargnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numinargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>argmodes</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_IN</name> <operator>||</operator>
			<name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
			<name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pname</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>inargnames</name><index>[<expr><name>numinargs</name></expr>]</index></name> <operator>=</operator> <name>pname</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>inargnames</name><index>[<expr><name>numinargs</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>numinargs</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>arg_names</name> <operator>=</operator> <name>inargnames</name></expr>;</expr_stmt>
	<return>return <expr><name>numinargs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_func_result_name
 *
 * If the function has exactly one output parameter, and that parameter
 * is named, return the name (as a palloc'd string).  Else return NULL.
 *
 * This is used to determine the default output column name for functions
 * returning scalar types.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_func_result_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numoutargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* First fetch the function's pg_proc row */</comment>
	<expr_stmt><expr><name>procTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If there are no named OUT parameters, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Get the data out of the tuple */</comment>
		<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTuple</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We expect the arrays to be 1-D arrays of the right types; verify
		 * that.  For the char array, we don't need to use deconstruct_array()
		 * since the array data is just going to look like a C array of
		 * values.
		 */</comment>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>numargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargmodes is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>numargs</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargnames is not a 1-D text array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargnames</name> <operator>==</operator> <name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* scan for output argument(s) */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numoutargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_IN</name> <operator>||</operator>
				<name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator>
				   <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
				   <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>numoutargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* multiple out args, so forget it */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Parameter is not named, so forget it */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * build_function_result_tupdesc_t
 *
 * Given a pg_proc row for a function, return a tuple descriptor for the
 * result rowtype, or NULL if the function does not have OUT parameters.
 *
 * Note that this does not handle resolution of polymorphic types;
 * that is deliberate.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>build_function_result_tupdesc_t</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>procTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proallargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* Return NULL if the function isn't declared to return RECORD */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If there are no OUT parameters, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proallargtypes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the data out of the tuple */</comment>
	<expr_stmt><expr><name>proallargtypes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_proallargtypes</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* just to be sure */</comment>

	<return>return <expr><call><name>build_function_result_tupdesc_d</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>prokind</name></name></expr></argument>,
										   <argument><expr><name>proallargtypes</name></expr></argument>,
										   <argument><expr><name>proargmodes</name></expr></argument>,
										   <argument><expr><name>proargnames</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_function_result_tupdesc_d
 *
 * Build a RECORD function's tupledesc from the pg_proc proallargtypes,
 * proargmodes, and proargnames arrays.  This is split out for the
 * convenience of ProcedureCreate, which needs to be able to compute the
 * tupledesc before actually creating the function.
 *
 * For functions (but not for procedures), returns NULL if there are not at
 * least two OUT or INOUT arguments.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>build_function_result_tupdesc_d</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>prokind</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>proallargtypes</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>proargmodes</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>proargnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>outargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>outargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numoutargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Can't have output args if columns are null */</comment>
	<if_stmt><if>if <condition>(<expr><name>proallargtypes</name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name>proargmodes</name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We expect the arrays to be 1-D arrays of the right types; verify that.
	 * For the OID and char arrays, we don't need to use deconstruct_array()
	 * since the array data is just going to look like a C array of values.
	 */</comment>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proallargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
	<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name>numargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proallargtypes is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>numargs</name> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargmodes is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proargnames</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>numargs</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"proargnames is not a 1-D text array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargnames</name> <operator>==</operator> <name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* zero elements probably shouldn't happen, but handle it gracefully */</comment>
	<if_stmt><if>if <condition>(<expr><name>numargs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* extract output-argument types and names */</comment>
	<expr_stmt><expr><name>outargtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outargnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numoutargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_IN</name> <operator>||</operator>
			<name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator>
			   <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
			   <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outargtypes</name><index>[<expr><name>numoutargs</name></expr>]</index></name> <operator>=</operator> <name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argnames</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>pname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Parameter is not named, so gin up a column name */</comment>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>numoutargs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>outargnames</name><index>[<expr><name>numoutargs</name></expr>]</index></name> <operator>=</operator> <name>pname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numoutargs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there is no output argument, or only one, the function does not
	 * return tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numoutargs</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>prokind</name> <operator>!=</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>numoutargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numoutargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><name><name>outargnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>outargtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationNameGetTupleDesc
 *
 * Given a (possibly qualified) relation name, build a TupleDesc.
 *
 * Note: while this works as advertised, it's seldom the best way to
 * build a tupdesc for a function's result type.  It's kept around
 * only for backwards compatibility with existing user-written code.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>RelationNameGetTupleDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relname_list</name></decl>;</decl_stmt>

	<comment type="block">/* Open relation and copy the tuple description */</comment>
	<expr_stmt><expr><name>relname_list</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relvar</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>relname_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TypeGetTupleDesc
 *
 * Given a type Oid, build a TupleDesc.  (In most cases you should be
 * using get_call_result_type or one of its siblings instead of this
 * routine, so that you can handle OUT parameters, RECORD result type,
 * and polymorphic results.)
 *
 * If the type is composite, *and* a colaliases List is provided, *and*
 * the List is of natts length, use the aliases instead of the relation
 * attnames.  (NB: this usage is deprecated since it may result in
 * creation of unnecessary transient record types.)
 *
 * If the type is a base type, a single item alias List is required.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>TypeGetTupleDesc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeoid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colaliases</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typeoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name> <init>= <expr><call><name>get_type_func_class</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_typeoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build a suitable tupledesc representing the output rows.  We
	 * intentionally do not support TYPEFUNC_COMPOSITE_DOMAIN here, as it's
	 * unlikely that legacy callers of this obsolete function would be
	 * prepared to apply domain constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name>base_typeoid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>colaliases</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>

			<comment type="block">/* does the list length match the number of attributes? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>colaliases</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of aliases does not match number of columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* OK, use the aliases instead */</comment>
			<for>for <control>(<init><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>varattno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>varattno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>colaliases</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>label</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* The tuple type is now an anonymous record type */</comment>
			<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Base data type, i.e. scalar */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<comment type="block">/* the alias list is required for base types */</comment>
		<if_stmt><if>if <condition>(<expr><name>colaliases</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no column alias was provided"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* the alias list length must be 1 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>colaliases</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of aliases does not match number of columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, get the column alias */</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>colaliases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>attname</name></expr></argument>,
						   <argument><expr><name>typeoid</name></expr></argument>,
						   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX can't support this because typmod wasn't passed in ... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine row description for function returning record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* crummy error message, but parser should have caught this */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function in FROM has unsupported return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_variadic_args
 *
 * Extract a set of argument values, types and NULL markers for a given
 * input function which makes use of a VARIADIC input whose argument list
 * depends on the caller context. When doing a VARIADIC call, the caller
 * has provided one argument made of an array of values, so deconstruct the
 * array data before using it for the next processing. If no VARIADIC call
 * is used, just fill in the status data based on all the arguments given
 * by the caller.
 *
 * This function returns the number of arguments generated, or -1 in the
 * case of "VARIADIC NULL".
 */</comment>
<function><type><name>int</name></type>
<name>extract_variadic_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>variadic_start</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>convert_unknown</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>variadic</name> <init>= <expr><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>args_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>types_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>args</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>types</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>variadic</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array_in</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <name>variadic_start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>array_in</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>,
						  <argument><expr><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args_res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls_res</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* All the elements of the array have the same type */</comment>
		<expr_stmt><expr><name>types_res</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <name>variadic_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nulls_res</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args_res</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>types_res</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
											   <argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Turn a constant (more or less literal) value that's of unknown
			 * type into text if required. Unknowns come in as a cstring
			 * pointer. Note: for functions declared as taking type "any", the
			 * parser will not do any type conversion on unknown-type literals
			 * (that is, undecorated strings or NULLs).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>convert_unknown</name> <operator>&amp;&amp;</operator>
				<name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
				<call><name>get_fn_expr_arg_stable</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* no conversion needed, just take the datum as given */</comment>
				<expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>(</operator><name>convert_unknown</name> <operator>&amp;&amp;</operator> <name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type for argument %d"</literal></expr></argument>,
								<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Fill in results */</comment>
	<expr_stmt><expr><operator>*</operator><name>args</name> <operator>=</operator> <name>args_res</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>nulls_res</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>types</name> <operator>=</operator> <name>types_res</name></expr>;</expr_stmt>

	<return>return <expr><name>nargs</name></expr>;</return>
</block_content>}</block></function>
</unit>
