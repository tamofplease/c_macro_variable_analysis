<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/mmgr/mcxt.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * mcxt.c
 *	  POSTGRES memory context management code.
 *
 * This module handles context management operations that are independent
 * of the particular kind of context being operated on.  It calls
 * context-type-specific operations via the function pointers in a
 * context's MemoryContextMethods struct.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/mmgr/mcxt.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/*****************************************************************************
 *	  GLOBAL MEMORY															 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * CurrentMemoryContext
 *		Default memory context for allocations.
 */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CurrentMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Standard top-level contexts. For a description of the purpose of each
 * of these contexts, refer to src/backend/utils/mmgr/README
 */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>TopMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ErrorContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>PostmasterContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CacheMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>MessageContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>TopTransactionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CurTransactionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* This is a transient link to the active portal's memory context: */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>PortalContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextCallResetCallbacks</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>,
									   <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MemoryContextStatsPrint</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passthru</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stats_string</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * You should not do memory allocations within a critical section, because
 * an out-of-memory error will be escalated to a PANIC. To enforce that
 * rule, the allocation functions Assert that.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AssertNotInCriticalSection</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>Assert(CritSectionCount == 0 || (context)-&gt;allowInCritSection)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************
 *	  EXPORTED ROUTINES														 *
 *****************************************************************************/</comment>


<comment type="block">/*
 * MemoryContextInit
 *		Start up the memory-context subsystem.
 *
 * This must be called before creating contexts or allocating memory in
 * contexts.  TopMemoryContext and ErrorContext are initialized here;
 * other contexts must be created afterwards.
 *
 * In normal multi-backend operation, this is called once during
 * postmaster startup, and not at all by individual backend startup
 * (since the backends inherit an already-initialized context subsystem
 * by virtue of being forked off the postmaster).  But in an EXEC_BACKEND
 * build, each process must do this for itself.
 *
 * In a standalone backend this must be called during backend startup.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>TopMemoryContext</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, initialize TopMemoryContext, which is the parent of all others.
	 */</comment>
	<expr_stmt><expr><name>TopMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContext</name><operator>)</operator> <name>NULL</name></expr></argument>,
											 <argument><expr><literal type="string">"TopMemoryContext"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not having any other place to point CurrentMemoryContext, make it point
	 * to TopMemoryContext.  Caller should change this soon!
	 */</comment>
	<expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <name>TopMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize ErrorContext as an AllocSetContext with slow growth rate ---
	 * we don't really expect much to be allocated in it. More to the point,
	 * require it to contain at least 8K at all times. This is the only case
	 * where retained memory in a context is *essential* --- we want to be
	 * sure ErrorContext still has some memory even if we've run out
	 * elsewhere! Also, allow allocations in ErrorContext within a critical
	 * section. Otherwise a PANIC will cause an assertion failure in the error
	 * reporting code, before printing out the real cause of the failure.
	 *
	 * This should be the last step in this function, as elog.c assumes memory
	 * management works once ErrorContext is non-null.
	 */</comment>
	<expr_stmt><expr><name>ErrorContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"ErrorContext"</literal></expr></argument>,
										 <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
										 <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
										 <argument><expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextReset
 *		Release all space allocated within a context and delete all its
 *		descendant contexts (but not the named context itself).
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextReset</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save a function call in common case where there are no children */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* save a function call if no pallocs since startup or last reset */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetOnly
 *		Release all space allocated within a context.
 *		Nothing is done to the context's descendant contexts.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetOnly</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if no pallocs since startup or last reset */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextCallResetCallbacks</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If context-&gt;ident points into the context's memory, it will become
		 * a dangling pointer.  We could prevent that by setting it to NULL
		 * here, but that would break valid coding patterns that keep the
		 * ident elsewhere, e.g. in a parent context.  Another idea is to use
		 * MemoryContextContains(), but we don't require ident strings to be
		 * in separately-palloc'd chunks, so that risks false positives.  So
		 * for now we assume the programmer got it right.
		 */</comment>

		<expr_stmt><expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>reset</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_DESTROY_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VALGRIND_CREATE_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextResetChildren
 *		Release all space allocated within a context's descendants,
 *		but don't delete the contexts themselves.  The named context
 *		itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextResetChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextResetChildren</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetOnly</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDelete
 *		Delete a context and its descendants, and release all space
 *		allocated therein.
 *
 * The type-specific delete routine removes all storage for the context,
 * but we have to recurse to handle the children.
 * We must also delink the context from its parent, if it has one.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextDelete</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We had better not be deleting TopMemoryContext ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And not CurrentMemoryContext, either */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save a function call in common case where there are no children */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It's not entirely clear whether 'tis better to do this before or after
	 * delinking the context; but an error in a callback will likely result in
	 * leaking the whole context (if it's not a root context) if we do it
	 * after, so let's do it before.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextCallResetCallbacks</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We delink the context from its parent before deleting it, so that if
	 * there's an error we won't have deleted/busted contexts still attached
	 * to the context tree.  Better a leak than a crash.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also reset the context's ident pointer, in case it points into the
	 * context.  This would only matter if someone tries to get stats on the
	 * (already unlinked) context, which is unlikely, but let's be safe.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>delete_context</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VALGRIND_DESTROY_MEMPOOL</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextDeleteChildren
 *		Delete all the descendants of the named context and release all
 *		space allocated therein.  The named context itself is not touched.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextDeleteChildren</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MemoryContextDelete will delink the child from me, so just iterate as
	 * long as there is a child.
	 */</comment>
	<while>while <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextRegisterResetCallback
 *		Register a function to be called before next context reset/delete.
 *		Such callbacks will be called in reverse order of registration.
 *
 * The caller is responsible for allocating a MemoryContextCallback struct
 * to hold the info about this callback request, and for filling in the
 * "func" and "arg" fields in the struct to show what function to call with
 * what argument.  Typically the callback struct should be allocated within
 * the specified context, since that means it will automatically be freed
 * when no longer needed.
 *
 * There is no API for deregistering a callback once registered.  If you
 * want it to not do anything anymore, adjust the state pointed to by its
 * "arg" to indicate that.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextRegisterResetCallback</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>,
								   <parameter><decl><type><name>MemoryContextCallback</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Push onto head so this will be called before older registrants. */</comment>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
	<comment type="block">/* Mark the context as non-reset (it probably is already). */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCallResetCallbacks
 *		Internal function to call all registered callbacks for context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextCallResetCallbacks</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContextCallback</name> <modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We pop each callback from the list before calling.  That way, if an
	 * error occurs inside the callback, we won't try to call it a second time
	 * in the likely event that we reset or delete the context later.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>cb</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>reset_cbs</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>cb</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextSetIdentifier
 *		Set the identifier string for a memory context.
 *
 * An identifier can be provided to help distinguish among different contexts
 * of the same kind in memory context stats dumps.  The identifier string
 * must live at least as long as the context it is for; typically it is
 * allocated inside that context, so that it automatically goes away on
 * context deletion.  Pass id = NULL to forget any old identifier.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextSetIdentifier</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextSetParent
 *		Change a context to belong to a new parent (or no parent).
 *
 * We provide this as an API function because it is sometimes useful to
 * change a context's lifespan after creation.  For example, a context
 * might be created underneath a transient context, filled with data,
 * and then reparented underneath CacheMemoryContext to make it long-lived.
 * In this way no special effort is needed to get rid of the context in case
 * a failure occurs before its contents are completely set up.
 *
 * Callers often assume that this function cannot fail, so don't put any
 * elog(ERROR) calls in it.
 *
 * A possible caller error is to reparent a context under itself, creating
 * a loop in the context graph.  We assert here that context != new_parent,
 * but checking for multi-level loops seems more trouble than it's worth.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextSetParent</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>new_parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>context</name> <operator>!=</operator> <name>new_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fast path if it's got correct parent already */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_parent</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Delink from existing parent, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>parent</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>==</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And relink */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_parent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>new_parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>new_parent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>new_parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllowInCriticalSection
 *		Allow/disallow allocations in this memory context within a critical
 *		section.
 *
 * Normally, memory allocations are not allowed within a critical section,
 * because a failure would lead to PANIC.  There are a few exceptions to
 * that, like allocations related to debugging code that is not supposed to
 * be enabled in production.  This function can be used to exempt specific
 * memory contexts from the assertion in palloc().
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextAllowInCriticalSection</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>allowInCritSection</name></name> <operator>=</operator> <name>allow</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetMemoryChunkSpace
 *		Given a currently-allocated chunk, determine the total space
 *		it occupies (including all memory-allocation overhead).
 *
 * This is useful for measuring the total space occupied by a set of
 * allocated chunks.
 */</comment>
<function><type><name>Size</name></type>
<name>GetMemoryChunkSpace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>get_chunk_space</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextGetParent
 *		Get the parent context (if any) of the specified context
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>MemoryContextGetParent</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>-&gt;</operator><name>parent</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextIsEmpty
 *		Is a memory context empty of any allocated space?
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextIsEmpty</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, we consider a memory context nonempty if it has any children;
	 * perhaps this should be changed later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Otherwise use the type-specific inquiry */</comment>
	<return>return <expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>is_empty</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the memory allocated to blocks for this memory context. If recurse is
 * true, also include children.
 */</comment>
<function><type><name>Size</name></type>
<name>MemoryContextMemAllocated</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>total</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>mem_allocated</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init>
			 <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name>MemoryContextMemAllocated</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStats
 *		Print statistics about the named context and all its descendants.
 *
 * This is just a debugging utility, so it's not very fancy.  However, we do
 * make some effort to summarize when the output would otherwise be very long.
 * The statistics are sent to stderr.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextStats</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A hard-wired limit on the number of children is usually good enough */</comment>
	<expr_stmt><expr><call><name>MemoryContextStatsDetail</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStatsDetail
 *
 * Entry point for use if you want to vary the number of child contexts shown.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextStatsDetail</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContextCounters</name></type> <name>grand_totals</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>grand_totals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>grand_totals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>grand_totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr><literal type="string">"Grand total: %zu bytes in %zd blocks; %zu free (%zd chunks); %zu used\n"</literal></expr></argument>,
			<argument><expr><name><name>grand_totals</name><operator>.</operator><name>totalspace</name></name></expr></argument>, <argument><expr><name><name>grand_totals</name><operator>.</operator><name>nblocks</name></name></expr></argument>,
			<argument><expr><name><name>grand_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>, <argument><expr><name><name>grand_totals</name><operator>.</operator><name>freechunks</name></name></expr></argument>,
			<argument><expr><name><name>grand_totals</name><operator>.</operator><name>totalspace</name></name> <operator>-</operator> <name><name>grand_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStatsInternal
 *		One recursion level for MemoryContextStats
 *
 * Print this context if print is true, but in any case accumulate counts into
 * *totals (if given).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextStatsInternal</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_children</name></decl></parameter>,
						   <parameter><decl><type><name>MemoryContextCounters</name> <modifier>*</modifier></type><name>totals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContextCounters</name></type> <name>local_totals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ichild</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Examine the context itself */</comment>
	<expr_stmt><expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>stats</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>print</name></expr> ?</condition><then> <expr><name>MemoryContextStatsPrint</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>level</name></expr></argument>,
							<argument><expr><name>totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Examine children.  If there are more than max_children of them, we do
	 * not print the rest explicitly, but just summarize them.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_totals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_totals</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr><operator>,</operator> <expr><name>ichild</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
		 <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr><operator>,</operator> <expr><name>ichild</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ichild</name> <operator>&lt;</operator> <name>max_children</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>print</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>,
									   <argument><expr><name>totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextStatsInternal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>max_children</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>local_totals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Deal with excess children */</comment>
	<if_stmt><if>if <condition>(<expr><name>ichild</name> <operator>&gt;</operator> <name>max_children</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>print</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><literal type="string">"%d more child contexts containing %zu total in %zd blocks; %zu free (%zd chunks); %zu used\n"</literal></expr></argument>,
					<argument><expr><name>ichild</name> <operator>-</operator> <name>max_children</name></expr></argument>,
					<argument><expr><name><name>local_totals</name><operator>.</operator><name>totalspace</name></name></expr></argument>,
					<argument><expr><name><name>local_totals</name><operator>.</operator><name>nblocks</name></name></expr></argument>,
					<argument><expr><name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>,
					<argument><expr><name><name>local_totals</name><operator>.</operator><name>freechunks</name></name></expr></argument>,
					<argument><expr><name><name>local_totals</name><operator>.</operator><name>totalspace</name></name> <operator>-</operator> <name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>totals</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>nblocks</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>nblocks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freechunks</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>freechunks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>totalspace</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>totalspace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>totals</name><operator>-&gt;</operator><name>freespace</name></name> <operator>+=</operator> <name><name>local_totals</name><operator>.</operator><name>freespace</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStatsPrint
 *		Print callback used by MemoryContextStatsInternal
 *
 * For now, the passthru pointer just points to "int level"; later we might
 * make that more complicated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MemoryContextStatsPrint</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>passthru</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stats_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>passthru</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>ident</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It seems preferable to label dynahash contexts with just the hash table
	 * name.  Those are already unique enough, so the "dynahash" part isn't
	 * very helpful, and this way is more consistent with pre-v11 practice.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ident</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"dynahash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name>ident</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>stats_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ident</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Some contexts may have very long identifiers (e.g., SQL queries).
		 * Arbitrarily truncate at 100 bytes, but be careful not to break
		 * multibyte characters.  Also, replace ASCII control characters, such
		 * as newlines, with spaces.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>idlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>truncated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>idlen</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>idlen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>truncated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>idlen</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>ident</name><operator>++</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>truncated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCheck
 *		Check all chunks in the named context.
 *
 * This is just a debugging utility, so it's not fancy.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>MemoryContextCheck</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>child</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>check</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>child</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</init> <condition><expr><name>child</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>nextchild</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * MemoryContextContains
 *		Detect whether an allocated chunk of memory belongs to a given
 *		context or not.
 *
 * Caution: this test is reliable as long as 'pointer' does point to
 * a chunk of memory allocated from *some* context.  If 'pointer' points
 * at memory obtained in some other way, there is a small chance of a
 * false-positive result, since the bits right before it might look like
 * a valid chunk header by chance.
 */</comment>
<function><type><name>bool</name></type>
<name>MemoryContextContains</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ptr_context</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NB: Can't use GetMemoryChunkContext() here - that performs assertions
	 * that aren't acceptable here since we might be passed memory not
	 * allocated by any memory context.
	 *
	 * Try to detect bogus pointers handed to us, poorly though we can.
	 * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an
	 * allocated chunk.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pointer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pointer</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, it's probably safe to look at the context.
	 */</comment>
	<expr_stmt><expr><name>ptr_context</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>MemoryContext</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pointer</name><operator>)</operator> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>ptr_context</name> <operator>==</operator> <name>context</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextCreate
 *		Context-type-independent part of context creation.
 *
 * This is only intended to be called by context-type-specific
 * context creation routines, not by the unwashed masses.
 *
 * The memory context creation procedure goes like this:
 *	1.  Context-type-specific routine makes some initial space allocation,
 *		including enough space for the context header.  If it fails,
 *		it can ereport() with no damage done.
 *	2.	Context-type-specific routine sets up all type-specific fields of
 *		the header (those beyond MemoryContextData proper), as well as any
 *		other management fields it needs to have a fully valid context.
 *		Usually, failure in this step is impossible, but if it's possible
 *		the initial space allocation should be freed before ereport'ing.
 *	3.	Context-type-specific routine calls MemoryContextCreate() to fill in
 *		the generic header fields and link the context into the context tree.
 *	4.  We return to the context-type-specific routine, which finishes
 *		up type-specific initialization.  This routine can now do things
 *		that might fail (like allocate more memory), so long as it's
 *		sure the node is left in a state that delete will handle.
 *
 * node: the as-yet-uninitialized common part of the context header node.
 * tag: NodeTag code identifying the memory context type.
 * methods: context-type-specific methods (usually statically allocated).
 * parent: parent context, or NULL if this will be a top-level context.
 * name: name of context (must be statically allocated).
 *
 * Context routines generally assume that MemoryContextCreate can't fail,
 * so this can contain Assert but not elog/ereport.
 */</comment>
<function><type><name>void</name></type>
<name>MemoryContextCreate</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>node</name></decl></parameter>,
					<parameter><decl><type><name>NodeTag</name></type> <name>tag</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>MemoryContextMethods</name> <modifier>*</modifier></type><name>methods</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>parent</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Creating new memory contexts is not allowed in a critical section */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize all standard fields of memory context header */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mem_allocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>reset_cbs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* OK to link node into context tree */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name><operator>-&gt;</operator><name>prevchild</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<comment type="block">/* inherit allowInCritSection flag from parent */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>allowInCritSection</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>allowInCritSection</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nextchild</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>allowInCritSection</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_CREATE_MEMPOOL</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAlloc
 *		Allocate space within the specified context.
 *
 * This could be turned into a macro, but we'd have to import
 * nodes/memnodes.h into postgres.h which seems a bad idea.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAlloc</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Here, and elsewhere in this module, we show the target context's
		 * "name" but not its "ident" (if any) in user-visible error messages.
		 * The "ident" string might contain security-sensitive data, such as
		 * values in SQL commands.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZero
 *		Like MemoryContextAlloc, but clears allocated memory
 *
 *	We could just call MemoryContextAlloc then clear the memory, but this
 *	is a very common combination, so we provide the combined operation.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZero</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocZeroAligned
 *		MemoryContextAllocZero where length is suitable for MemSetLoop
 *
 *	This might seem overly specialized, but it's not because newNode()
 *	is so often called with compile-time-constant sizes.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocZeroAligned</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSetLoop</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocExtended
 *		Allocate space within the specified context using the given flags.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocExtended</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
							   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* duplicates MemoryContextAlloc to avoid increased overhead */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc0</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* duplicates MemoryContextAllocZero to avoid increased overhead */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>palloc_extended</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* duplicates MemoryContextAllocExtended to avoid increased overhead */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_HUGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_NO_OOM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
							   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>MCXT_ALLOC_ZERO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSetAligned</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pfree
 *		Release an allocated chunk.
 */</comment>
<function><type><name>void</name></type>
<name>pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>free_p</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_FREE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * repalloc
 *		Adjust the size of a previously allocated chunk.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* isReset must be false already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>realloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_CHANGE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextAllocHuge
 *		Allocate (possibly-expansive) space within the specified context.
 *
 * See considerations in comment at MaxAllocHugeSize.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>MemoryContextAllocHuge</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>alloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_ALLOC</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * repalloc_huge
 *		Adjust the size of a previously allocated chunk, permitting a large
 *		value.  The previous allocation need not have been "huge".
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>repalloc_huge</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocHugeSizeIsValid</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory alloc request size %zu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertNotInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* isReset must be false already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>isReset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>realloc</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu in memory context \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>VALGRIND_MEMPOOL_CHANGE</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MemoryContextStrdup
 *		Like strdup(), but allocate from the specified context
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>MemoryContextStrdup</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nstr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nstr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>pstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pnstrdup
 *		Like pstrdup(), but append null byte to a
 *		not-necessarily-null-terminated input string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pnstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make copy of string with all trailing newline characters removed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pchomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>in</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
