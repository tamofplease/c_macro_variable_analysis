<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/init/miscinit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * miscinit.c
 *	  miscellaneous initialization support stuff
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/init/miscinit.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pidfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECTORY_LOCK_FILE</name></cpp:macro>		<cpp:value>"postmaster.pid"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>ProcessingMode</name></type> <name>Mode</name> <init>= <expr><name>InitProcessing</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BackendType</name></type> <name>MyBackendType</name></decl>;</decl_stmt>

<comment type="block">/* List of lock files to be removed at proc exit */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>lock_files</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Latch</name></type> <name>LocalLatchData</name></decl>;</decl_stmt>

<comment type="block">/* ----------------------------------------------------------------
 *		ignoring system indexes support stuff
 *
 * NOTE: "ignoring system indexes" means we do not use the system indexes
 * for lookups (either in hardwired catalog accesses or in planner-generated
 * plans).  We do, however, still update the indexes when a catalog
 * modification is made.
 * ----------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>IgnoreSystemIndexes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------------------------------------------------------------
 *	common process startup code
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Initialize the basic environment for a postmaster child
 *
 * Should be called as early as possible after the child's startup.
 */</comment>
<function><type><name>void</name></type>
<name>InitPostmasterChild</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we are a postmaster subprocess now */</comment>

	<comment type="block">/*
	 * Set reference point for stack-depth checking.  This might seem
	 * redundant in !EXEC_BACKEND builds; but it's not because the postmaster
	 * launches its children from signal handlers, so we might be running on
	 * an alternative stack.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_stack_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitProcessGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * make sure stderr is in binary mode before anything can possibly be
	 * written to it, in case it's actually the syslogger pipe, so the pipe
	 * chunking protocol isn't disturbed. Non-logpipe data gets translated on
	 * redirection (e.g. via pg_ctl -l) anyway.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We don't want the postmaster's proc_exit() handlers */</comment>
	<expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize process-local latch support */</comment>
	<expr_stmt><expr><call><name>InitializeLatchSupport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If possible, make this process a group leader, so that the postmaster
	 * can signal any child processes too. Not all processes will have
	 * children, but for consistency we make all postmaster child processes do
	 * this.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsid</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"setsid() failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Request a signal if the postmaster dies, if possible. */</comment>
	<expr_stmt><expr><call><name>PostmasterDeathSignalInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the basic environment for a standalone process.
 *
 * argv0 has to be suitable to find the program's executable.
 */</comment>
<function><type><name>void</name></type>
<name>InitStandaloneProcess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitProcessGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize process-local latch support */</comment>
	<expr_stmt><expr><call><name>InitializeLatchSupport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute paths, no postmaster to inherit from */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>my_exec_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"%s: could not locate my own executable path"</literal></expr></argument>,
				 <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pkglib_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_pkglib_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>pkglib_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SwitchToSharedLatch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyLatch</name> <operator>==</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>FeBeWaitSet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set the shared latch as the local one might have been set. This
	 * shouldn't normally be necessary as code is supposed to check the
	 * condition before waiting for the latch, but a bit care can't hurt.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SwitchBackToLocalLatch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyLatch</name> <operator>!=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>MyLatch</name> <operator>==</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>FeBeWaitSet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetBackendTypeDesc</name><parameter_list>(<parameter><decl><type><name>BackendType</name></type> <name>backendType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backendDesc</name> <init>= <expr><literal type="string">"unknown process type"</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>backendType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>B_INVALID</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"not initialized"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_AUTOVAC_LAUNCHER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"autovacuum launcher"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_AUTOVAC_WORKER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"autovacuum worker"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_BACKEND</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"client backend"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_BG_WORKER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"background worker"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_BG_WRITER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"background writer"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_CHECKPOINTER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"checkpointer"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_STARTUP</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"startup"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_WAL_RECEIVER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walreceiver"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_WAL_SENDER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walsender"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_WAL_WRITER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"walwriter"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_ARCHIVER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"archiver"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_STATS_COLLECTOR</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"stats collector"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>B_LOGGER</name></expr>:</case>
			<expr_stmt><expr><name>backendDesc</name> <operator>=</operator> <literal type="string">"logger"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>backendDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *				database path / name support stuff
 * ----------------------------------------------------------------
 */</comment>

<function><type><name>void</name></type>
<name>SetDatabasePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This should happen only once per process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>DatabasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>DatabasePath</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the proposed data directory.
 *
 * Also initialize file and directory create modes and mode mask.
 */</comment>
<function><type><name>void</name></type>
<name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read permissions of directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* eventual chdir would fail anyway, but let's test ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified data directory \"%s\" is not a directory"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the directory belongs to my userid; if not, reject.
	 *
	 * This check is an essential part of the interlock that prevents two
	 * postmasters from starting in the same directory (see CreateLockFile()).
	 * Do not remove or weaken it.
	 *
	 * XXX can we safely enable this check on Windows?
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_uid</name></name> <operator>!=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has wrong ownership"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The server must be started by the user that owns the data directory."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Check if the directory has correct permissions.  If not, reject.
	 *
	 * Only two possible modes are allowed, 0700 and 0750.  The latter mode
	 * indicates that group read/execute should be allowed on all newly
	 * created files and directories.
	 *
	 * XXX temporarily suppress check when on Windows, because there may not
	 * be proper support for Unix-y file permissions.  Need to think of a
	 * reasonable check to apply on Windows.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>PG_MODE_MASK_GROUP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has invalid permissions"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Reset creation modes and mask based on the mode of the data directory.
	 *
	 * The mask was set earlier in startup to disallow group permissions on
	 * newly created files and directories.  However, if group read/execute
	 * are present on the data directory then modify the create modes and mask
	 * to allow group read/execute on newly created files and directories and
	 * set the data_directory_mode GUC.
	 *
	 * Suppress when on Windows, because there may not be proper support for
	 * Unix-y file permissions.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>SetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_directory_mode</name> <operator>=</operator> <name>pg_dir_create_mode</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Check for PG_VERSION */</comment>
	<expr_stmt><expr><call><name>ValidatePgVersion</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set data directory, but make sure it's an absolute path.  Use this,
 * never set DataDir directly.
 */</comment>
<function><type><name>void</name></type>
<name>SetDataDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If presented path is relative, convert to absolute */</comment>
	<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DataDir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>DataDir</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change working directory to DataDir.  Most of the postmaster and backend
 * code assumes that we are in DataDir so it can use relative paths to access
 * stuff in and under the data directory.  For convenience during path
 * setup, however, we don't force the chdir to occur during SetDataDir.
 */</comment>
<function><type><name>void</name></type>
<name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *	User ID state
 *
 * We have to track several different values associated with the concept
 * of "user ID".
 *
 * AuthenticatedUserId is determined at connection start and never changes.
 *
 * SessionUserId is initially the same as AuthenticatedUserId, but can be
 * changed by SET SESSION AUTHORIZATION (if AuthenticatedUserIsSuperuser).
 * This is the ID reported by the SESSION_USER SQL function.
 *
 * OuterUserId is the current user ID in effect at the "outer level" (outside
 * any transaction or function).  This is initially the same as SessionUserId,
 * but can be changed by SET ROLE to any role that SessionUserId is a
 * member of.  (XXX rename to something like CurrentRoleId?)
 *
 * CurrentUserId is the current effective user ID; this is the one to use
 * for all normal permissions-checking purposes.  At outer level this will
 * be the same as OuterUserId, but it changes during calls to SECURITY
 * DEFINER functions, as well as locally in some specialized commands.
 *
 * SecurityRestrictionContext holds flags indicating reason(s) for changing
 * CurrentUserId.  In some cases we need to lock down operations that are
 * not directly controlled by privilege settings, and this provides a
 * convenient way to do it.
 * ----------------------------------------------------------------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>AuthenticatedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>SessionUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>OuterUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>CurrentUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* We also have to remember the superuser state of some of these levels */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>AuthenticatedUserIsSuperuser</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>SessionUserIsSuperuser</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>SecurityRestrictionContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* We also remember if a SET ROLE is currently active */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetRoleIsActive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GetUserId - get the current effective user ID.
 *
 * Note: there's no SetUserId() anymore; use SetUserIdAndSecContext().
 */</comment>
<function><type><name>Oid</name></type>
<name>GetUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>CurrentUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>CurrentUserId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOuterUserId/SetOuterUserId - get/set the outer-level user ID.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetOuterUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OuterUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>OuterUserId</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetOuterUserId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>SecurityRestrictionContext</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>OuterUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>

	<comment type="block">/* We force the effective user ID to match, too */</comment>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSessionUserId/SetSessionUserId - get/set the session user ID.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetSessionUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>SessionUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SessionUserId</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetSessionUserId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>SecurityRestrictionContext</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>SessionUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SessionUserIsSuperuser</name> <operator>=</operator> <name>is_superuser</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* We force the effective user IDs to match, too */</comment>
	<expr_stmt><expr><name>OuterUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetAuthenticatedUserId - get the authenticated user ID
 */</comment>
<function><type><name>Oid</name></type>
<name>GetAuthenticatedUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>AuthenticatedUserId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetUserIdAndSecContext/SetUserIdAndSecContext - get/set the current user ID
 * and the SecurityRestrictionContext flags.
 *
 * Currently there are three valid bits in SecurityRestrictionContext:
 *
 * SECURITY_LOCAL_USERID_CHANGE indicates that we are inside an operation
 * that is temporarily changing CurrentUserId via these functions.  This is
 * needed to indicate that the actual value of CurrentUserId is not in sync
 * with guc.c's internal state, so SET ROLE has to be disallowed.
 *
 * SECURITY_RESTRICTED_OPERATION indicates that we are inside an operation
 * that does not wish to trust called user-defined functions at all.  The
 * policy is to use this before operations, e.g. autovacuum and REINDEX, that
 * enumerate relations of a database or schema and run functions associated
 * with each found relation.  The relation owner is the new user ID.  Set this
 * as soon as possible after locking the relation.  Restore the old user ID as
 * late as possible before closing the relation; restoring it shortly after
 * close is also tolerable.  If a command has both relation-enumerating and
 * non-enumerating modes, e.g. ANALYZE, both modes set this bit.  This bit
 * prevents not only SET ROLE, but various other changes of session state that
 * normally is unprotected but might possibly be used to subvert the calling
 * session later.  An example is replacing an existing prepared statement with
 * new code, which will then be executed with the outer session's permissions
 * when the prepared statement is next used.  These restrictions are fairly
 * draconian, but the functions called in relation-enumerating operations are
 * really supposed to be side-effect-free anyway.
 *
 * SECURITY_NOFORCE_RLS indicates that we are inside an operation which should
 * ignore the FORCE ROW LEVEL SECURITY per-table indication.  This is used to
 * ensure that FORCE RLS does not mistakenly break referential integrity
 * checks.  Note that this is intentionally only checked when running as the
 * owner of the table (which should always be the case for referential
 * integrity checks).
 *
 * Unlike GetUserId, GetUserIdAndSecContext does *not* Assert that the current
 * value of CurrentUserId is valid; nor does SetUserIdAndSecContext require
 * the new value to be valid.  In fact, these routines had better not
 * ever throw any kind of error.  This is because they are used by
 * StartTransaction and AbortTransaction to save/restore the settings,
 * and during the first transaction within a backend, the value to be saved
 * and perhaps restored is indeed invalid.  We have to be able to get
 * through AbortTransaction without asserting in case InitPostgres fails.
 */</comment>
<function><type><name>void</name></type>
<name>GetUserIdAndSecContext</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>userid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>userid</name> <operator>=</operator> <name>CurrentUserId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sec_context</name> <operator>=</operator> <name>SecurityRestrictionContext</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetUserIdAndSecContext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>=</operator> <name>sec_context</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InLocalUserIdChange - are we inside a local change of CurrentUserId?
 */</comment>
<function><type><name>bool</name></type>
<name>InLocalUserIdChange</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InSecurityRestrictedOperation - are we inside a security-restricted command?
 */</comment>
<function><type><name>bool</name></type>
<name>InSecurityRestrictedOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_RESTRICTED_OPERATION</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InNoForceRLSOperation - are we ignoring FORCE ROW LEVEL SECURITY ?
 */</comment>
<function><type><name>bool</name></type>
<name>InNoForceRLSOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_NOFORCE_RLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These are obsolete versions of Get/SetUserIdAndSecContext that are
 * only provided for bug-compatibility with some rather dubious code in
 * pljava.  We allow the userid to be set, but only when not inside a
 * security restriction context.
 */</comment>
<function><type><name>void</name></type>
<name>GetUserIdAndContext</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>sec_def_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>userid</name> <operator>=</operator> <name>CurrentUserId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sec_def_context</name> <operator>=</operator> <call><name>InLocalUserIdChange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetUserIdAndContext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sec_def_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We throw the same error SET ROLE would. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-restricted operation"</literal></expr></argument>,
						<argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sec_def_context</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>|=</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>&amp;=</operator> <operator>~</operator><name>SECURITY_LOCAL_USERID_CHANGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether specified role has explicit REPLICATION privilege
 */</comment>
<function><type><name>bool</name></type>
<name>has_rolreplication</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>utup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>utup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolreplication</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize user identity during normal backend startup
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSessionUserId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roleTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>rform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't do scans if we're bootstrapping, none of the system catalogs
	 * exist yet, and they should be owned by postgres anyway.
	 */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call only once */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure syscache entries are flushed for recent catalog changes. This
	 * allows us to find roles that were created on-the-fly during
	 * authentication.
	 */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rolename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>rform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name><name>rform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>rform</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuthenticatedUserId</name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuthenticatedUserIsSuperuser</name> <operator>=</operator> <name><name>rform</name><operator>-&gt;</operator><name>rolsuper</name></name></expr>;</expr_stmt>

	<comment type="block">/* This sets OuterUserId/CurrentUserId too */</comment>
	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>AuthenticatedUserIsSuperuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also mark our PGPROC entry with the authenticated user id */</comment>
	<comment type="block">/* (We assume this is an atomic store so no lock is needed) */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * These next checks are not enforced when in standalone mode, so that
	 * there is a way to recover from sillinesses like "UPDATE pg_authid SET
	 * rolcanlogin = false;".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Is role allowed to login at all?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rform</name><operator>-&gt;</operator><name>rolcanlogin</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" is not permitted to log in"</literal></expr></argument>,
							<argument><expr><name>rname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check connection limit for this role.
		 *
		 * There is a race condition here --- we create our PGPROC before
		 * checking for other PGPROCs.  If two backends did this at about the
		 * same time, they might both think they were over the limit, while
		 * ideally one should succeed and one fail.  Getting that to work
		 * exactly seems more trouble than it is worth, however; instead we
		 * just document that the connection limit is approximate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rform</name><operator>-&gt;</operator><name>rolconnlimit</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>AuthenticatedUserIsSuperuser</name> <operator>&amp;&amp;</operator>
			<call><name>CountUserBackends</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>rform</name><operator>-&gt;</operator><name>rolconnlimit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many connections for role \"%s\""</literal></expr></argument>,
							<argument><expr><name>rname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Record username and superuser status as GUC settings too */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"session_authorization"</literal></expr></argument>, <argument><expr><name>rname</name></expr></argument>,
					<argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>AuthenticatedUserIsSuperuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize user identity during special backend startup
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSessionUserIdStandalone</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This function should only be called in single-user mode, in autovacuum
	 * workers, and in background workers.
	 */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name> <operator>||</operator> <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IsBackgroundWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call only once */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuthenticatedUserId</name> <operator>=</operator> <name>BOOTSTRAP_SUPERUSERID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuthenticatedUserIsSuperuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Change session auth ID while running
 *
 * Only a superuser may set auth ID to something other than himself.  Note
 * that in case of multiple SETs in a single session, the original userid's
 * superuserness is what matters.  But we set the GUC variable is_superuser
 * to indicate whether the *current* session userid is a superuser.
 *
 * Note: this is not an especially clean place to do the permission check.
 * It's OK because the check does not require catalog access and can't
 * fail during an end-of-transaction GUC reversion, but we may someday
 * have to push it up into assign_session_authorization.
 */</comment>
<function><type><name>void</name></type>
<name>SetSessionAuthorization</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Must have authenticated already, else can't make permission check */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>userid</name> <operator>!=</operator> <name>AuthenticatedUserId</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>AuthenticatedUserIsSuperuser</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set session authorization"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name>is_superuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_superuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report current role id
 *		This follows the semantics of SET ROLE, ie return the outer-level ID
 *		not the current effective ID, and return InvalidOid when the setting
 *		is logically SET ROLE NONE.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetCurrentRoleId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>SetRoleIsActive</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OuterUserId</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change Role ID while running (SET ROLE)
 *
 * If roleid is InvalidOid, we are doing SET ROLE NONE: revert to the
 * session user authorization.  In this case the is_superuser argument
 * is ignored.
 *
 * When roleid is not InvalidOid, the caller must have checked whether
 * the session user has permission to become that role.  (We cannot check
 * here because this routine must be able to execute in a failed transaction
 * to restore a prior value of the ROLE GUC variable.)
 */</comment>
<function><type><name>void</name></type>
<name>SetCurrentRoleId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get correct info if it's SET ROLE NONE
	 *
	 * If SessionUserId hasn't been set yet, just do nothing --- the eventual
	 * SetSessionUserId call will fix everything.  This is needed since we
	 * will get called during GUC initialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>SessionUserId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name>SessionUserId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_superuser</name> <operator>=</operator> <name>SessionUserIsSuperuser</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SetOuterUserId</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_superuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get user name from user oid, returns NULL for nonexistent roleid if noerr
 * is true.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetUserNameFromId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noerr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noerr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid role OID: %u"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *				Interlock-file support
 *
 * These routines are used to create both a data-directory lockfile
 * ($DATADIR/postmaster.pid) and Unix-socket-file lockfiles ($SOCKFILE.lock).
 * Both kinds of files contain the same info initially, although we can add
 * more information to a data-directory lockfile after it's created, using
 * AddToDataDirLockFile().  See pidfile.h for documentation of the contents
 * of these lockfiles.
 *
 * On successful lockfile creation, a proc_exit callback to remove the
 * lockfile is automatically created.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * proc_exit callback to remove lockfiles.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlinkLockFiles</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lock_files</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curfile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>curfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Should we complain if the unlink fails? */</comment>
	</block_content>}</block>
	<comment type="block">/* Since we're about to exit, no need to reclaim storage */</comment>
	<expr_stmt><expr><name>lock_files</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock file removal should always be the last externally visible action
	 * of a postmaster or standalone backend, while we won't come here at all
	 * when exiting postmaster child processes.  Therefore, this is a good
	 * place to log completion of shutdown.  We could alternatively teach
	 * proc_exit() to do it, but that seems uglier.  In a standalone backend,
	 * use NOTICE elevel to be less chatty.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsPostmasterEnvironment</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system is shut down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile.
 *
 * filename is the path name of the lockfile to create.
 * amPostmaster is used to determine how to encode the output PID.
 * socketDir is the Unix socket directory path to include (possibly empty).
 * isDDLock and refName are used to determine what error message to produce.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketDir</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>isDDLock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoded_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>other_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>my_pid</name></decl>,
				<decl><type ref="prev"/><name>my_p_pid</name></decl>,
				<decl><type ref="prev"/><name>my_gp_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envvar</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the PID in the lockfile is our own PID or our parent's or
	 * grandparent's PID, then the file must be stale (probably left over from
	 * a previous system boot cycle).  We need to check this because of the
	 * likelihood that a reboot will assign exactly the same PID as we had in
	 * the previous reboot, or one that's only one or two counts larger and
	 * hence the lockfile's PID now refers to an ancestor shell process.  We
	 * allow pg_ctl to pass down its parent shell PID (our grandparent PID)
	 * via the environment variable PG_GRANDPARENT_PID; this is so that
	 * launching the postmaster via pg_ctl can be just as reliable as
	 * launching it directly.  There is no provision for detecting
	 * further-removed ancestor processes, but if the init script is written
	 * carefully then all but the immediate parent shell will be root-owned
	 * processes and so the kill test will fail with EPERM.  Note that we
	 * cannot get a false negative this way, because an existing postmaster
	 * would surely never launch a competing postmaster or pg_ctl process
	 * directly.
	 */</comment>
	<expr_stmt><expr><name>my_pid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>my_p_pid</name> <operator>=</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * Windows hasn't got getppid(), but doesn't need it since it's not using
	 * real kill() either...
	 */</comment>
	<expr_stmt><expr><name>my_p_pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>envvar</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_GRANDPARENT_PID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>envvar</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_gp_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_gp_pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We need a loop here because of race conditions.  But don't loop forever
	 * (for example, a non-writable $PGDATA directory might cause a failure
	 * that won't go away).  100 tries seems like plenty.
	 */</comment>
	<for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to create the lock file --- O_EXCL makes this atomic.
		 *
		 * Think not to make the file protection weaker than 0600/0640.  See
		 * comments below.
		 */</comment>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* Success; exit the retry loop */</comment>

		<comment type="block">/*
		 * Couldn't create the pid file. Probably it already exists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name><operator>)</operator> <operator>||</operator> <name>ntries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Read the file to get the old owner's PID.  Note race condition
		 * here: file might have been deleted since we tried to create it.
		 */</comment>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* race condition; try again */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" is empty"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either another server is starting, or the lock file is the remnant of a previous server startup crash."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>encoded_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if pid &lt; 0, the pid is for postgres, not postmaster */</comment>
		<expr_stmt><expr><name>other_pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>encoded_pid</name></expr> </then><else>: <expr><name>encoded_pid</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bogus data in lock file \"%s\": \"%s\""</literal></expr></argument>,
				 <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if the other process still exists
		 *
		 * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be
		 * ignored as false matches.
		 *
		 * Normally kill() will fail with ESRCH if the given PID doesn't
		 * exist.
		 *
		 * We can treat the EPERM-error case as okay because that error
		 * implies that the existing process has a different userid than we
		 * do, which means it cannot be a competing postmaster.  A postmaster
		 * cannot successfully attach to a data directory owned by a userid
		 * other than its own, as enforced in checkDataDir(). Also, since we
		 * create the lockfiles mode 0600/0640, we'd have failed above if the
		 * lockfile belonged to another userid --- which means that whatever
		 * process kill() is reporting about isn't the one that made the
		 * lockfile.  (NOTE: this last consideration is the only one that
		 * keeps us from blowing away a Unix socket file belonging to an
		 * instance of Postgres being run by someone else, at least on
		 * machines where /tmp hasn't got a stickybit.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>!=</operator> <name>my_pid</name> <operator>&amp;&amp;</operator> <name>other_pid</name> <operator>!=</operator> <name>my_p_pid</name> <operator>&amp;&amp;</operator>
			<name>other_pid</name> <operator>!=</operator> <name>my_gp_pid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>other_pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name>errno</name> <operator>!=</operator> <name>ESRCH</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EPERM</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* lockfile belongs to a live process */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" already exists"</literal></expr></argument>,
								<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>isDDLock</name></expr> ?</condition><then>
						 <expr><operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postgres (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr> </then><else>:
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr> </then><else>:
						 <expr><operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postgres (PID %d) using socket file \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr> </then><else>:
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster (PID %d) using socket file \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * No, the creating process did not exist.  However, it could be that
		 * the postmaster crashed (or more likely was kill -9'd by a clueless
		 * admin) but has left orphan backends behind.  Check for this by
		 * looking to see if there is an associated shmem segment that is
		 * still in use.
		 *
		 * Note: because postmaster.pid is written in multiple steps, we might
		 * not find the shmem ID values in it; we can't treat that as an
		 * error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isDDLock</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>id1</name></decl>,
						<decl><type ref="prev"/><name>id2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>LOCK_FILE_LINE_SHMEM_KEY</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%lu %lu"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>id1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>PGSharedMemoryIsInUse</name><argument_list>(<argument><expr><name>id1</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pre-existing shared memory block (key %lu, ID %lu) is still in use"</literal></expr></argument>,
									<argument><expr><name>id1</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Terminate any old server processes associated with data directory \"%s\"."</literal></expr></argument>,
									 <argument><expr><name>refName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Looks like nobody's home.  Unlink the file and try again to create
		 * it.  Need a loop because of possible race condition against other
		 * would-be creators.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
							 <literal type="string">"it could not be removed. Please remove the file "</literal>
							 <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Successfully created the file, now fill it.  See comment in pidfile.h
	 * about the contents.  Note that we write the same first five lines into
	 * both datadir and socket lockfiles; although more stuff may get added to
	 * the datadir lockfile later.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d\n%s\n%ld\n%d\n%s\n"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>amPostmaster</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name><operator>)</operator></expr></else></ternary></expr></argument>,
			 <argument><expr><name>DataDir</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>MyStartTime</name></expr></argument>,
			 <argument><expr><name>PostPortNumber</name></expr></argument>,
			 <argument><expr><name>socketDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)
	 * will never receive data, so fill it in as empty now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isDDLock</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>amPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Arrange to unlink the lock file(s) at proc_exit.  If this is the first
	 * one, set up the on_proc_exit function to do it; then add this lock file
	 * to the list of files to unlink.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lock_files</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>UnlinkLockFiles</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use lcons so that the lock files are unlinked in reverse order of
	 * creation; this is critical!
	 */</comment>
	<expr_stmt><expr><name>lock_files</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the data directory lockfile.
 *
 * When this is called, we must have already switched the working
 * directory to DataDir, so we can just use a relative path.  This
 * helps ensure that we are locking the directory we should be.
 *
 * Note that the socket directory path line is initially written as empty.
 * postmaster.c will rewrite it upon creating the first Unix socket.
 */</comment>
<function><type><name>void</name></type>
<name>CreateDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>amPostmaster</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile for the specified Unix socket file.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSocketLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketfile</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketDir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lockfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lockfile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.lock"</literal></expr></argument>, <argument><expr><name>socketfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name>amPostmaster</name></expr></argument>, <argument><expr><name>socketDir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>socketfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TouchSocketLockFiles -- mark socket lock files as recently accessed
 *
 * This routine should be called every so often to ensure that the socket
 * lock files have a recent mod or access date.  That saves them
 * from being removed by overenthusiastic /tmp-directory-cleaner daemons.
 * (Another reason we should never have put the socket file in /tmp...)
 */</comment>
<function><type><name>void</name></type>
<name>TouchSocketLockFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lock_files</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>socketLockFile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* No need to touch the data directory lock file, we trust */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* we just ignore any error here */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>utime</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Add (or replace) a line in the data directory lock file.
 * The given string should not include a trailing newline.
 *
 * Note: because we don't truncate the file, if we were to rewrite a line
 * with less data than it had before, there would be garbage after the last
 * line.  While we could fix that by adding a truncate call, that would make
 * the file update non-atomic, which we'd rather avoid.  Therefore, callers
 * should endeavor never to shorten a line once it's been written.
 */</comment>
<function><type><name>void</name></type>
<name>AddToDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>target_line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>destptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>srcbuffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>destbuffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>srcbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>srcbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>srcbuffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance over lines we are not supposed to rewrite, then copy them to
	 * destbuffer.
	 */</comment>
	<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <name>srcbuffer</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>target_line</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>srcptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>eol</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* not enough lines in file yet */</comment>
		<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destbuffer</name></expr></argument>, <argument><expr><name>srcbuffer</name></expr></argument>, <argument><expr><name>srcptr</name> <operator>-</operator> <name>srcbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destptr</name> <operator>=</operator> <name>destbuffer</name> <operator>+</operator> <operator>(</operator><name>srcptr</name> <operator>-</operator> <name>srcbuffer</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in any missing lines before the target line, in case lines are
	 * added to the file out of order.
	 */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>target_line</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>destptr</name> <operator>&lt;</operator> <name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>destptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Write or rewrite the target line.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>destptr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are more lines in the old file, append them to destbuffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>srcptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>srcptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>destptr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><name>srcptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And rewrite the data.  Since we write in a single kernel call, this
	 * update should appear atomic to onlookers.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_pwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>destbuffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Recheck that the data directory lock file still exists with expected
 * content.  Return true if the lock file appears OK, false if it isn't.
 *
 * We call this periodically in the postmaster.  The idea is that if the
 * lock file has been removed or replaced by another postmaster, we should
 * do a panic database shutdown.  Therefore, we should return true if there
 * is any doubt: we do not want to cause a panic shutdown unnecessarily.
 * Transient failures like EINTR or ENFILE should not cause us to fail.
 * (If there really is something wrong, we'll detect it on a future recheck.)
 */</comment>
<function><type><name>bool</name></type>
<name>RecheckDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>file_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are many foreseeable false-positive error conditions.  For
		 * safety, fail only on enumerated clearly-something-is-wrong
		 * conditions.
		 */</comment>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ENOENT</name></expr>:</case>
			<case>case <expr><name>ENOTDIR</name></expr>:</case>
				<comment type="block">/* disaster */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			<default>default:</default>
				<comment type="block">/* non-fatal, at least for now */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m; continuing anyway"</literal></expr></argument>,
								<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* treat read failure as nonfatal */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file_pid</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file_pid</name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* all is well */</comment>

	<comment type="block">/* Trouble: someone's overwritten the lock file */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" contains wrong PID: %ld instead of %ld"</literal></expr></argument>,
					<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>file_pid</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *				Version checking support
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * ValidateAgVersion() is always called by ValidatePgVersion().
 * Because seperated call could make human mistake
 * and renaming ValidatePgVersion() can cause future merge confilct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ValidateAgVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>file_version_string</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/AG_VERSION"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" is missing."</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>file_version_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"%63s"</literal></expr></argument>, <argument><expr><name>file_version_string</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" does not contain valid data."</literal></expr></argument>,
						   <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_COMP_VERSION</name></expr></argument>, <argument><expr><name>file_version_string</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The data directory was initialized by AgensGraph version %s, "</literal>
								  <literal type="string">"which is not compatible with this version %s."</literal></expr></argument>,
								  <argument><expr><name>file_version_string</name></expr></argument>, <argument><expr><name>AG_COMP_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether the PG_VERSION file in directory `path' indicates
 * a data version compatible with the version of this program.
 *
 * If compatible, return. Otherwise, ereport(FATAL).
 */</comment>
<function><type><name>void</name></type>
<name>ValidatePgVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>file_major</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>my_major</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>file_version_string</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_version_string</name> <init>= <expr><name>PG_VERSION</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>my_major</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>my_version_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" is missing."</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>file_version_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fscanf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"%63s"</literal></expr></argument>, <argument><expr><name>file_version_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file_major</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>file_version_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>endptr</name> <operator>==</operator> <name>file_version_string</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" does not contain valid data."</literal></expr></argument>,
						   <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>my_major</name> <operator>!=</operator> <name>file_major</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The data directory was initialized by PostgreSQL version %s, "</literal>
						   <literal type="string">"which is not compatible with this version %s."</literal></expr></argument>,
						   <argument><expr><name>file_version_string</name></expr></argument>, <argument><expr><name>my_version_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* AG_VERSION must be validated too */</comment>
	<expr_stmt><expr><call><name>ValidateAgVersion</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 *				Library preload support
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * GUC variables: lists of library names to be preloaded at postmaster
 * start and at backend start
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>session_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>local_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flag telling that we are loading shared_preload_libraries */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>process_shared_preload_libraries_in_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * load the shared libraries listed in 'libraries'
 *
 * 'gucname': name of GUC variable, for error reports
 * 'restricted': if true, force libraries to be in $libdir/plugins/
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_libraries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraries</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gucname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restricted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>libraries</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>libraries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>libraries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of filename paths */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitDirectoriesString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>gucname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* Note that filename was already canonicalized */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>expanded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If restricting, insert $libdir/plugins if not mentioned already */</comment>
		<if_stmt><if>if <condition>(<expr><name>restricted</name> <operator>&amp;&amp;</operator> <call><name>first_dir_separator</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expanded</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"$libdir/plugins/%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>expanded</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>restricted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded library \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expanded</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process any libraries that should be preloaded at postmaster start
 */</comment>
<function><type><name>void</name></type>
<name>process_shared_preload_libraries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>process_shared_preload_libraries_in_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>shared_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"shared_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>process_shared_preload_libraries_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process any libraries that should be preloaded at backend start
 */</comment>
<function><type><name>void</name></type>
<name>process_session_preload_libraries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>session_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"session_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>local_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"local_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pg_bindtextdomain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>my_exec_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>locale_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_locale_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>locale_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bindtextdomain</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>locale_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_bind_textdomain_codeset</name><argument_list>(<argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
