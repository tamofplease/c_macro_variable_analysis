<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/utils/time/combocid.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * combocid.c
 *	  Combo command ID support routines
 *
 * Before version 8.3, HeapTupleHeaderData had separate fields for cmin
 * and cmax.  To reduce the header size, cmin and cmax are now overlayed
 * in the same field in the header.  That usually works because you rarely
 * insert and delete a tuple in the same transaction, and we don't need
 * either field to remain valid after the originating transaction exits.
 * To make it work when the inserting transaction does delete the tuple,
 * we create a "combo" command ID and store that in the tuple header
 * instead of cmin and cmax. The combo command ID can be mapped to the
 * real cmin and cmax using a backend-private array, which is managed by
 * this module.
 *
 * To allow reusing existing combo cids, we also keep a hash table that
 * maps cmin,cmax pairs to combo cids.  This keeps the data structure size
 * reasonable in most cases, since the number of unique pairs used by any
 * one transaction is likely to be small.
 *
 * With a 32-bit combo command id we can represent 2^32 distinct cmin,cmax
 * combinations. In the most perverse case where each command deletes a tuple
 * generated by every previous command, the number of combo command ids
 * required for N commands is N*(N+1)/2.  That means that in the worst case,
 * that's enough for 92682 commands.  In practice, you'll run out of memory
 * and/or disk space way before you reach that limit.
 *
 * The array and hash table are kept in TopTransactionContext, and are
 * destroyed at the end of each transaction.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/time/combocid.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* Hash table to lookup combo cids by cmin and cmax */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>comboHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Key and entry structures for the hash table */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmax</name></decl>;</decl_stmt>
}</block></struct></type> <name>ComboCidKeyData</name>;</typedef>

<typedef>typedef <type><name>ComboCidKeyData</name> <modifier>*</modifier></type><name>ComboCidKey</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ComboCidKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>combocid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ComboCidEntryData</name>;</typedef>

<typedef>typedef <type><name>ComboCidEntryData</name> <modifier>*</modifier></type><name>ComboCidEntry</name>;</typedef>

<comment type="block">/* Initial size of the hash table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCID_HASH_SIZE</name></cpp:macro>			<cpp:value>100</cpp:value></cpp:define>


<comment type="block">/*
 * An array of cmin,cmax pairs, indexed by combo command id.
 * To convert a combo cid to cmin and cmax, you do a simple array lookup.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ComboCidKey</name></type> <name>comboCids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>usedComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* number of elements in comboCids */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sizeComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* allocated size of array */</comment>

<comment type="block">/* Initial size of the array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCID_ARRAY_SIZE</name></cpp:macro>			<cpp:value>100</cpp:value></cpp:define>


<comment type="block">/* prototypes for internal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetComboCommandId</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetRealCmin</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetRealCmax</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/**** External API ****/</comment>

<comment type="block">/*
 * GetCmin and GetCmax assert that they are only called in situations where
 * they make sense, that is, can deliver a useful answer.  If you have
 * reason to examine a tuple's t_cid field from a transaction other than
 * the originating one, use HeapTupleHeaderGetRawCommandId() directly.
 */</comment>

<function><type><name>CommandId</name></type>
<name>HeapTupleHeaderGetCmin</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name> <init>= <expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_COMBOCID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetRealCmin</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>cid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>CommandId</name></type>
<name>HeapTupleHeaderGetCmax</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name> <init>= <expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Because GetUpdateXid() performs memory allocations if xmax is a
	 * multixact we can't Assert() if we're inside a critical section. This
	 * weakens the check, but not using GetCmax() inside one would complicate
	 * things too much.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_COMBOCID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetRealCmax</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>cid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a tuple we are about to delete, determine the correct value to store
 * into its t_cid field.
 *
 * If we don't need a combo CID, *cmax is unchanged and *iscombo is set to
 * false.  If we do need one, *cmax is replaced by a combo CID and *iscombo
 * is set to true.
 *
 * The reason this is separate from the actual HeapTupleHeaderSetCmax()
 * operation is that this could fail due to out-of-memory conditions.  Hence
 * we need to do this before entering the critical section that actually
 * changes the tuple in shared buffers.
 */</comment>
<function><type><name>void</name></type>
<name>HeapTupleHeaderAdjustCmax</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>,
						  <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmax</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>iscombo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're marking a tuple deleted that was inserted by (any
	 * subtransaction of) our transaction, we need to use a combo command id.
	 * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper
	 * than a TransactionIdIsCurrentTransactionId call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderXminCommitted</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmin</name> <init>= <expr><call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>cmax</name> <operator>=</operator> <call><name>GetComboCommandId</name><argument_list>(<argument><expr><name>cmin</name></expr></argument>, <argument><expr><operator>*</operator><name>cmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>iscombo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>iscombo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Combo command ids are only interesting to the inserting and deleting
 * transaction, so we can forget about them at the end of transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_ComboCid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Don't bother to pfree. These are allocated in TopTransactionContext, so
	 * they're going to go away at the end of transaction anyway.
	 */</comment>
	<expr_stmt><expr><name>comboHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**** Internal routines ****/</comment>

<comment type="block">/*
 * Get a combo command id that maps to cmin and cmax.
 *
 * We try to reuse old combo command ids when possible.
 */</comment>
<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetComboCommandId</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>combocid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidEntry</name></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the hash table and array the first time we need to use combo
	 * cids in the transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>comboHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

		<comment type="block">/* Make array first; existence of hash table asserts array exists */</comment>
		<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CCID_ARRAY_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <name>CCID_ARRAY_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidEntryData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>comboHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Combo CIDs"</literal></expr></argument>,
								<argument><expr><name>CCID_HASH_SIZE</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grow the array if there's not at least one free slot.  We must do this
	 * before possibly entering a new hashtable entry, else failure to
	 * repalloc would leave a corrupt hashtable entry behind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>usedComboCids</name> <operator>&gt;=</operator> <name>sizeComboCids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><name>sizeComboCids</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>comboCids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Lookup or create a hash entry with the desired cmin/cmax */</comment>

	<comment type="block">/* We assume there is no struct padding in ComboCidKeyData! */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ComboCidEntry</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>comboHash</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
										<argument><expr><name>HASH_ENTER</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reuse an existing combo cid */</comment>
		<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>combocid</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We have to create a new combo cid; we already made room in the array */</comment>
	<expr_stmt><expr><name>combocid</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedComboCids</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name>combocid</name></expr>;</expr_stmt>

	<return>return <expr><name>combocid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetRealCmin</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>combocid</name> <operator>&lt;</operator> <name>usedComboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmin</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetRealCmax</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>combocid</name> <operator>&lt;</operator> <name>usedComboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmax</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the amount of space required to serialize the current ComboCID
 * state.
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateComboCIDStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Add space required for saving usedComboCids */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Add space required for saving the combocids key */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>usedComboCids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize the ComboCID state into the memory, beginning at start_address.
 * maxsize should be at least as large as the value returned by
 * EstimateComboCIDStateSpace.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeComboCIDState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* First, we store the number of currently-existing ComboCIDs. */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>start_address</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>

	<comment type="block">/* If maxsize is too small, throw an error. */</comment>
	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>usedComboCids</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>endptr</name> <argument_list type="generic">&lt; <argument><expr><name>start_address</name> <operator>||</operator> <name>endptr</name></expr></argument> &gt;</argument_list></name> <name>start_address</name> <operator>+</operator> <name>maxsize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize ComboCID state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now, copy the actual cmin/cmax pairs. */</comment>
	<if_stmt><if>if <condition>(<expr><name>usedComboCids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comboCids</name></expr></argument>,
			   <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>usedComboCids</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the ComboCID state at the specified address and initialize this
 * backend with the same ComboCIDs.  This is only valid in a backend that
 * currently has no ComboCIDs (and only makes sense if the transaction state
 * is serialized and restored as well).
 */</comment>
<function><type><name>void</name></type>
<name>RestoreComboCIDState</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>comboCIDstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKeyData</name> <modifier>*</modifier></type><name>keydata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>comboCids</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>comboHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, we retrieve the number of ComboCIDs that were serialized. */</comment>
	<expr_stmt><expr><name>num_elements</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>comboCIDstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keydata</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>comboCIDstate</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Use GetComboCommandId to restore each ComboCID. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>GetComboCommandId</name><argument_list>(<argument><expr><name><name>keydata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmin</name></expr></argument>, <argument><expr><name><name>keydata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Verify that we got the expected answer. */</comment>
		<if_stmt><if>if <condition>(<expr><name>cid</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected command ID while restoring combo CIDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
