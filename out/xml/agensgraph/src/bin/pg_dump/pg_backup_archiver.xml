<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_dump/pg_backup_archiver.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_backup_archiver.c
 *
 *	Private implementation of the archiver routines.
 *
 *	See the headers to pg_restore for more details.
 *
 * Copyright (c) 2000, Philip Warner
 *	Rights are granted to use this software in any way so long
 *	as this notice is not removed.
 *
 *	The author is not responsible for loss or damages that may
 *	result from its use.
 *
 *
 * IDENTIFICATION
 *		src/bin/pg_dump/pg_backup_archiver.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_archiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXT_DUMP_HEADER</name></cpp:macro> <cpp:value>"--\n-- PostgreSQL database dump\n--\n\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXT_DUMPALL_HEADER</name></cpp:macro> <cpp:value>"--\n-- PostgreSQL database cluster dump\n--\n\n"</cpp:value></cpp:define>

<comment type="block">/* state needed to save/restore an archive's output target */</comment>
<typedef>typedef <type><struct>struct <name>_outputContext</name>
<block>{
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>OF</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>gzOut</name></decl>;</decl_stmt>
}</block></struct></type> <name>OutputContext</name>;</typedef>

<comment type="block">/*
 * State for tracking TocEntrys that are ready to process during a parallel
 * restore.  (This used to be a list, and we still call it that, though now
 * it's really an array so that we can apply qsort to it.)
 *
 * tes[] is sized large enough that we can't overrun it.
 * The valid entries are indexed first_te .. last_te inclusive.
 * We periodically sort the array to bring larger-by-dataLength entries to
 * the front; "sorted" is true if the valid entries are known sorted.
 */</comment>
<typedef>typedef <type><struct>struct <name>_parallelReadyList</name>
<block>{
	<decl_stmt><decl><type><name>TocEntry</name>  <modifier>*</modifier><modifier>*</modifier></type><name>tes</name></decl>;</decl_stmt>			<comment type="block">/* Ready-to-dump TocEntrys */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>first_te</name></decl>;</decl_stmt>		<comment type="block">/* index of first valid entry in tes[] */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_te</name></decl>;</decl_stmt>		<comment type="block">/* index of last valid entry in tes[] */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sorted</name></decl>;</decl_stmt>			<comment type="block">/* are valid entries currently sorted? */</comment>
}</block></struct></type> <name>ParallelReadyList</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>ArchiveHandle</name> <modifier>*</modifier></type><name>_allocAH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>FileSpec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArchiveFormat</name></type> <name>fmt</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>compression</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dosync</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name></type> <name>mode</name></decl></parameter>,
							   <parameter><decl><type><name>SetupWorkerPtrType</name></type> <name>setupWorkerPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_getObjectDescription</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
								  <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_printTocEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sanitize_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>want_hyphen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_doSetFixedOutputState</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_doSetSessionAuth</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_reconnectToDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_becomeUser</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_becomeOwner</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_selectOutputSchema</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_selectTablespace</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_selectTableAccessMethod</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processEncodingEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processStdStringsEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processSearchPathEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>teReqs</name></type> <name>_tocEntryRequired</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>teSection</name></type> <name>curSection</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RestorePass</name></type> <name>_tocEntryRestorePass</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_tocEntryIsACL</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_disableTriggersIfNecessary</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_enableTriggersIfNecessary</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>buildTocEntryArrays</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_moveBefore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_discoverArchiveFormat</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>RestoringToDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_lo_buf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTimestamp</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>tim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OutputContext</name></type> <name>SaveOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RestoreOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>OutputContext</name></type> <name>savedContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>restore_toc_entry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_parallel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restore_toc_entries_prefork</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
										<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restore_toc_entries_parallel</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
										 <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
										 <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restore_toc_entries_postfork</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
										 <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pending_list_header_init</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pending_list_append</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pending_list_remove</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ready_list_init</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tocCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ready_list_free</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ready_list_insert</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ready_list_remove</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ready_list_sort</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>TocEntrySizeCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>move_to_ready_list</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>,
							   <parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>,
							   <parameter><decl><type><name>RestorePass</name></type> <name>pass</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TocEntry</name> <modifier>*</modifier></type><name>pop_next_work_item</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
									<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>,
									<parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mark_dump_job_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
							   <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mark_restore_job_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
								  <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
								  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fix_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_lock_conflicts</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te1</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repoint_table_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>identify_locking_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reduce_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
								<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mark_create_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inhibit_data_for_failed_table</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StrictNamesCheck</name><parameter_list>(<parameter><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Allocate a new DumpOptions block containing all default values.
 */</comment>
<function><type><name>DumpOptions</name> <modifier>*</modifier></type>
<name>NewDumpOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>opts</name> <init>= <expr><operator>(</operator><name>DumpOptions</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitDumpOptions</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>opts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a DumpOptions struct to all default values
 */</comment>
<function><type><name>void</name></type>
<name>InitDumpOptions</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set any fields that shouldn't default to zeroes */</comment>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>include_everything</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name>TRI_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>=</operator> <name>DUMP_UNSECTIONED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a freshly allocated DumpOptions with options equivalent to those
 * found in the given RestoreOptions.
 */</comment>
<function><type><name>DumpOptions</name> <modifier>*</modifier></type>
<name>dumpOptionsFromRestoreOptions</name><parameter_list>(<parameter><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><call><name>NewDumpOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this is the inverse of what's at the end of pg_dump.c's main() */</comment>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>dbname</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pgport</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pgport</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pgport</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pghost</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pghost</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>username</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>username</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>username</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>outputClean</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>schemaOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>if_exists</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>if_exists</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>column_inserts</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>column_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>aclsSkip</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>aclsSkip</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>outputSuperuser</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>superuser</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>outputCreateDB</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>outputNoOwner</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>outputNoTablespaces</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>noTablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_triggers</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>disable_triggers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>use_setsessauth</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>use_setsessauth</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>dump_inserts</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>dump_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>no_publications</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>no_security_labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>no_subscriptions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>include_everything</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>enable_row_security</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>enable_row_security</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>sequence_data</name></name> <operator>=</operator> <name><name>ropt</name><operator>-&gt;</operator><name>sequence_data</name></name></expr>;</expr_stmt>

	<return>return <expr><name>dopt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	Wrapper functions.
 *
 *	The objective it to make writing new formats and dumpers as simple
 *	as possible, if necessary at the expense of extra function calls etc.
 *
 */</comment>

<comment type="block">/*
 * The dump worker setup needs lots of knowledge of the internals of pg_dump,
 * so It's defined in pg_dump.c and passed into OpenArchive. The restore worker
 * setup doesn't need to know anything much, so it's defined here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupRestoreWorker</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReopenPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Create a new archive */</comment>
<comment type="block">/* Public */</comment>
<function><type><name>Archive</name> <modifier>*</modifier></type>
<name>CreateArchive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>FileSpec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArchiveFormat</name></type> <name>fmt</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>compression</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dosync</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name></type> <name>mode</name></decl></parameter>,
			  <parameter><decl><type><name>SetupWorkerPtrType</name></type> <name>setupDumpWorker</name></decl></parameter>)</parameter_list>

<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><call><name>_allocAH</name><argument_list>(<argument><expr><name>FileSpec</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>compression</name></expr></argument>, <argument><expr><name>dosync</name></expr></argument>,
								 <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>setupDumpWorker</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Open an existing archive */</comment>
<comment type="block">/* Public */</comment>
<function><type><name>Archive</name> <modifier>*</modifier></type>
<name>OpenArchive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>FileSpec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArchiveFormat</name></type> <name>fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><call><name>_allocAH</name><argument_list>(<argument><expr><name>FileSpec</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>archModeRead</name></expr></argument>, <argument><expr><name>setupRestoreWorker</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>CloseArchive</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ClosePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close the output */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* in case gzclose() doesn't set it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GZCLOSE</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>!=</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close output file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>SetArchiveOptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Caller can omit dump options, in which case we synthesize them */</comment>
	<if_stmt><if>if <condition>(<expr><name>dopt</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ropt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dopt</name> <operator>=</operator> <call><name>dumpOptionsFromRestoreOptions</name><argument_list>(<argument><expr><name>ropt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Save options for later access */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>dopt</name></name> <operator>=</operator> <name>dopt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ropt</name></name> <operator>=</operator> <name>ropt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>ProcessArchiveRestoreOptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>teSection</name></type>	<name>curSection</name></decl>;</decl_stmt>

	<comment type="block">/* Decide which TOC entries will be dumped/restored, and mark them */</comment>
	<expr_stmt><expr><name>curSection</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * When writing an archive, we also take this opportunity to check
		 * that we have generated the entries in a sane order that respects
		 * the section divisions.  When reading, don't complain, since buggy
		 * old versions of pg_dump might generate out-of-order archives.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>archModeRead</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>SECTION_NONE</name></expr>:</case>
					<comment type="block">/* ok to be anywhere */</comment>
					<break>break;</break>
				<case>case <expr><name>SECTION_PRE_DATA</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>curSection</name> <operator>!=</operator> <name>SECTION_PRE_DATA</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"archive items not in correct section order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>SECTION_DATA</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>curSection</name> <operator>==</operator> <name>SECTION_POST_DATA</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"archive items not in correct section order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>SECTION_POST_DATA</name></expr>:</case>
					<comment type="block">/* ok no matter which section we were in */</comment>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unexpected section code %d"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>section</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>!=</operator> <name>SECTION_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>curSection</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>section</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>=</operator> <call><name>_tocEntryRequired</name><argument_list>(<argument><expr><name>te</name></expr></argument>, <argument><expr><name>curSection</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Enforce strict names checking */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>strict_names</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>StrictNamesCheck</name><argument_list>(<argument><expr><name>ropt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>RestoreArchive</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>parallel_mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OutputContext</name></type> <name>sav</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>STAGE_INITIALIZING</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're going to do parallel restore, there are some restrictions.
	 */</comment>
	<expr_stmt><expr><name>parallel_mode</name> <operator>=</operator> <operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>numWorkers</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ropt</name><operator>-&gt;</operator><name>useDB</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parallel_mode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We haven't got round to making this work for all archive formats */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>ClonePtr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>AH</name><operator>-&gt;</operator><name>ReopenPtr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"parallel restore is not supported with this archive file format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Doesn't work if the archive represents dependencies as OIDs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_8</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"parallel restore is not supported with archives made by pre-8.0 pg_dump"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * It's also not gonna work if we can't reopen the input file, so
		 * let's try that immediately.
		 */</comment>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReopenPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure we won't need (de)compression we haven't got
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>hadDumper</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <name>REQ_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"cannot restore from compressed archive (compression not supported in this installation)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Prepare index arrays, so we can assume we have them throughout restore.
	 * It's possible we already did this, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>buildTocEntryArrays</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're using a DB connection, then connect it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>useDB</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"connecting to database for restore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_3</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"direct database connections are not supported in pre-1.3 archives"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We don't want to guess at whether the dump will successfully
		 * restore; allow the attempt regardless of the version of the restore
		 * target.
		 */</comment>
		<expr_stmt><expr><name><name>AHX</name><operator>-&gt;</operator><name>minRemoteVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AHX</name><operator>-&gt;</operator><name>maxRemoteVersion</name></name> <operator>=</operator> <literal type="number">9999999</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConnectDatabase</name><argument_list>(<argument><expr><name>AHX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're talking to the DB directly, don't send comments since they
		 * obscure SQL when displaying errors
		 */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>noTocComments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Work out if we have an implied data-only restore. This can happen if
	 * the dump was data only or if the user has used a toc list to exclude
	 * all of the schema data. All we do is look for schema entries - if none
	 * are found then we set the dataOnly flag.
	 *
	 * We could scan for wanted TABLE entries, but that is not the same as
	 * dataOnly. At this stage, it seems unnecessary (6-Mar-2001).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>impliedDataOnly</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <name>REQ_SCHEMA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>					<comment type="block">/* It's schema, and it's wanted */</comment>
				<expr_stmt><expr><name>impliedDataOnly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>impliedDataOnly</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>=</operator> <name>impliedDataOnly</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"implied data-only restore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Setup the output file if necessary.
	 */</comment>
	<expr_stmt><expr><name>sav</name> <operator>=</operator> <call><name>SaveOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name> <operator>||</operator> <name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"--\n-- PostgreSQL database dump\n--\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- Dumped from database version %s\n"</literal></expr></argument>,
				 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- Dumped by pg_dump version %s\n"</literal></expr></argument>,
				 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTimestamp</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"Started on"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>single_txn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StartTransaction</name><argument_list>(<argument><expr><name>AHX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"BEGIN;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Establish important parameter values right away.
	 */</comment>
	<expr_stmt><expr><call><name>_doSetFixedOutputState</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>STAGE_PROCESSING</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop the items at the start, in reverse order
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * In createDB mode, issue a DROP *only* for the database as a
			 * whole.  Issuing drops against anything else would be wrong,
			 * because at this point we're connected to the wrong database.
			 * (The DATABASE PROPERTIES entry, if any, should be treated like
			 * the DATABASE entry.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Otherwise, drop anything that's selected and has a dropStmt */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"dropping %s %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Select owner and schema as necessary */</comment>
				<expr_stmt><expr><call><name>_becomeOwner</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_selectOutputSchema</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now emit the DROP command, if the object has one.  Note we
				 * don't necessarily emit it verbatim; at this point we add an
				 * appropriate IF EXISTS clause, if the user requested it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>if_exists</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* No --if-exists?	Then just use the original */</comment>
						<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Inject an appropriate spelling of "if exists".  For
						 * large objects, we have a separate routine that
						 * knows how to do it, without depending on
						 * te-&gt;dropStmt; use that.  For other objects we need
						 * to parse the command.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>DropBlobIfExists</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dropStmt</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dropStmtOrig</name> <init>= <expr><name>dropStmt</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>ftStmt</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

							<comment type="block">/*
							 * Need to inject IF EXISTS clause after ALTER
							 * TABLE part in ALTER TABLE .. DROP statement
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>ftStmt</name></expr></argument>,
													 <argument><expr><literal type="string">"ALTER TABLE IF EXISTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>dropStmt</name> <operator>=</operator> <name>dropStmt</name> <operator>+</operator> <literal type="number">11</literal></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * ALTER TABLE..ALTER COLUMN..DROP DEFAULT does
							 * not support the IF EXISTS clause, and therefore
							 * we simply emit the original command for DEFAULT
							 * objects (modulo the adjustment made above).
							 *
							 * Likewise, don't mess with DATABASE PROPERTIES.
							 *
							 * If we used CREATE OR REPLACE VIEW as a means of
							 * quasi-dropping an ON SELECT rule, that should
							 * be emitted unchanged as well.
							 *
							 * For other object types, we need to extract the
							 * first part of the DROP which includes the
							 * object type.  Most of the time this matches
							 * te-&gt;desc, so search for that; however for the
							 * different kinds of CONSTRAINTs, we know to
							 * search for hardcoded "DROP CONSTRAINT" instead.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
								<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
								<call><name>strncmp</name><argument_list>(<argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW"</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>ftStmt</name></expr></argument>, <argument><expr><name>dropStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else
							<block>{<block_content>
								<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mark</name></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
									<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
									<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"DROP %s"</literal></expr></argument>,
											 <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

								<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><operator>*</operator><name>mark</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>ftStmt</name></expr></argument>, <argument><expr><literal type="string">"%s%s IF EXISTS%s"</literal></expr></argument>,
													  <argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
													  <argument><expr><name>mark</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<comment type="block">/* complain and emit unmodified command */</comment>
									<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not find where to insert IF EXISTS in statement \"%s\""</literal></expr></argument>,
												   <argument><expr><name>dropStmtOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>ftStmt</name></expr></argument>, <argument><expr><name>dropStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></else></if_stmt>
							</block_content>}</block></else></if_stmt>

							<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>ftStmt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>ftStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>dropStmtOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * _selectOutputSchema may have set currSchema to reflect the effect
		 * of a "SET search_path" command it emitted.  However, by now we may
		 * have dropped that schema; or it might not have existed in the first
		 * place.  In either case the effective value of search_path will not
		 * be what we think.  Forcibly reset currSchema so that we will
		 * re-establish the search_path setting when needed (after creating
		 * the schema).
		 *
		 * If we treated users as pg_dump'able objects then we'd need to reset
		 * currUser here too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parallel_mode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In parallel mode, turn control over to the parallel-restore logic.
		 */</comment>
		<decl_stmt><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TocEntry</name></type>	<name>pending_list</name></decl>;</decl_stmt>

		<comment type="block">/* The archive format module may need some setup for this */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>PrepParallelRestorePtr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>PrepParallelRestorePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pending_list_header_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pending_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* This runs PRE_DATA items and then disconnects from the database */</comment>
		<expr_stmt><expr><call><name>restore_toc_entries_prefork</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ParallelBackupStart() will actually fork the processes */</comment>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>ParallelBackupStart</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>restore_toc_entries_parallel</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ParallelBackupEnd</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reconnect the master and see if we missed something */</comment>
		<expr_stmt><expr><call><name>restore_toc_entries_postfork</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pending_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In serial mode, process everything in three phases: normal items,
		 * then ACLs, then post-ACL items.  We might be able to skip one or
		 * both extra phases in some cases, eg data-only restores.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveACL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>havePostACL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore if not to be dumped at all */</comment>

			<switch>switch <condition>(<expr><call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RESTORE_PASS_MAIN</name></expr>:</case>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RESTORE_PASS_ACL</name></expr>:</case>
					<expr_stmt><expr><name>haveACL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RESTORE_PASS_POST_ACL</name></expr>:</case>
					<expr_stmt><expr><name>havePostACL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>haveACL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESTORE_PASS_ACL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>havePostACL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESTORE_PASS_POST_ACL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>single_txn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>(<argument><expr><name>AHX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"COMMIT;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTimestamp</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"Completed on"</literal></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"--\n-- PostgreSQL database dump complete\n--\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up &amp; we're done.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>=</operator> <name>STAGE_FINALIZING</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name> <operator>||</operator> <name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RestoreOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>sav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>useDB</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a single TOC item.  Used in both parallel and non-parallel restore;
 * is_parallel is true if we are in a worker child process.
 *
 * Returns 0 normally, but WORKER_CREATE_DONE or WORKER_INHIBIT_DATA if
 * the parallel parent has to make the corresponding status update.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>restore_toc_entry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_parallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>WORKER_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>teReqs</name></type>		<name>reqs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>defnDumped</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>

	<comment type="block">/* Dump any relevant dump warnings to stderr */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>suppressDumpWarnings</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>defn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"warning from original dump file: %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"warning from original dump file: %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Work out what, if anything, we want from this entry */</comment>
	<expr_stmt><expr><name>reqs</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>reqs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>defnDumped</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it has a schema component that we want, then process that
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>reqs</name> <operator>&amp;</operator> <name>REQ_SCHEMA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Show namespace in log message if available */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"creating %s \"%s.%s\""</literal></expr></argument>,
						<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"creating %s \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>_printTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defnDumped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lastErrorTE</name></name> <operator>==</operator> <name>te</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We failed to create the table. If
				 * --no-data-for-failed-tables was given, mark the
				 * corresponding TABLE DATA to be ignored.
				 *
				 * In the parallel case this must be done in the parent, so we
				 * just set the return value.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>noDataForFailedTables</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>is_parallel</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>status</name> <operator>=</operator> <name>WORKER_INHIBIT_DATA</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>inhibit_data_for_failed_table</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We created the table successfully.  Mark the corresponding
				 * TABLE DATA for possible truncation.
				 *
				 * In the parallel case this must be done in the parent, so we
				 * just set the return value.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_parallel</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>WORKER_CREATE_DONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>mark_create_done</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we created a DB, connect to it.  Also, if we changed DB
		 * properties, reconnect to ensure that relevant GUC settings are
		 * applied to our session.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"connecting to new database \"%s\""</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_reconnectToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it has a data component that we want, then process that
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>reqs</name> <operator>&amp;</operator> <name>REQ_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * hadDumper will be set if there is genuine data component for this
		 * node. Otherwise, we need to check the defn field for statements
		 * that need to be executed in data-only restores.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>hadDumper</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we can output the data, then restore it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_printTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB COMMENTS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"processing %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>_selectOutputSchema</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Send BLOB COMMENTS data to ExecuteSimpleCommands() */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB COMMENTS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>=</operator> <name>OUTPUT_OTHERDATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>=</operator> <name>OUTPUT_SQLCMDS</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>_disableTriggersIfNecessary</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Select owner and schema as necessary */</comment>
					<expr_stmt><expr><call><name>_becomeOwner</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_selectOutputSchema</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"processing data for table \"%s.%s\""</literal></expr></argument>,
								<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * In parallel restore, if we created the table earlier in
					 * the run then we wrap the COPY in a transaction and
					 * precede it with a TRUNCATE.  If archiving is not on
					 * this prevents WAL-logging the COPY.  This obtains a
					 * speedup similar to that from using single_txn mode in
					 * non-parallel restores.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>is_parallel</name> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>created</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Parallel restore is always talking directly to a
						 * server, so no need to see if we should issue BEGIN.
						 */</comment>
						<expr_stmt><expr><call><name>StartTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If the server version is &gt;= 8.4, make sure we issue
						 * TRUNCATE with ONLY so that child tables are not
						 * wiped.
						 */</comment>
						<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE TABLE %s%s;\n\n"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">80400</literal></expr> ?</condition><then>
								  <expr><literal type="string">"ONLY "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><call><name>fmtQualifiedId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If we have a copy statement, use it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>=</operator> <name>OUTPUT_COPYDATA</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>=</operator> <name>OUTPUT_OTHERDATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Terminate COPY if needed.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>==</operator> <name>OUTPUT_COPYDATA</name> <operator>&amp;&amp;</operator>
						<call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>EndDBCopyMode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>=</operator> <name>OUTPUT_SQLCMDS</name></expr>;</expr_stmt>

					<comment type="block">/* close out the transaction started above */</comment>
					<if_stmt><if>if <condition>(<expr><name>is_parallel</name> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>created</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>_enableTriggersIfNecessary</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>defnDumped</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we haven't already dumped the defn part, do so now */</comment>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"executing %s %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_printTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>WORKER_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>WORKER_IGNORED_ERRORS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new RestoreOptions block.
 * This is mainly so we can initialize it, but also for future expansion,
 */</comment>
<function><type><name>RestoreOptions</name> <modifier>*</modifier></type>
<name>NewRestoreOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>opts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opts</name> <operator>=</operator> <operator>(</operator><name>RestoreOptions</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestoreOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set any fields that shouldn't default to zeroes */</comment>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archUnknown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name>TRI_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>=</operator> <name>DUMP_UNSECTIONED</name></expr>;</expr_stmt>

	<return>return <expr><name>opts</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_disableTriggersIfNecessary</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This hack is only needed in a data-only restore */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>||</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>disable_triggers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"disabling triggers for %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Become superuser if possible, since they are the only ones who can
	 * disable constraint triggers.  If -S was not given, assume the initial
	 * user identity is a superuser.  (XXX would it be better to become the
	 * table owner?)
	 */</comment>
	<expr_stmt><expr><call><name>_becomeUser</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Disable them.
	 */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s DISABLE TRIGGER ALL;\n\n"</literal></expr></argument>,
			 <argument><expr><call><name>fmtQualifiedId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_enableTriggersIfNecessary</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This hack is only needed in a data-only restore */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>||</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>disable_triggers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"enabling triggers for %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Become superuser if possible, since they are the only ones who can
	 * disable constraint triggers.  If -S was not given, assume the initial
	 * user identity is a superuser.  (XXX would it be better to become the
	 * table owner?)
	 */</comment>
	<expr_stmt><expr><call><name>_becomeUser</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Enable them.
	 */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ENABLE TRIGGER ALL;\n\n"</literal></expr></argument>,
			 <argument><expr><call><name>fmtQualifiedId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is a routine that is part of the dumper interface, hence the 'Archive*' parameter.
 */</comment>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>WriteData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>currToc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"internal error -- WriteData cannot be called outside the context of a DataDumper routine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteDataPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new TOC entry. The TOC was designed as a TOC, but is now the
 * repository for all metadata. But the name has stuck.
 *
 * The new entry is added to the Archive's TOC list.  Most callers can ignore
 * the result value because nothing else need be done, but a few want to
 * manipulate the TOC entry further.
 */</comment>

<comment type="block">/* Public */</comment>
<function><type><name>TocEntry</name> <modifier>*</modifier></type>
<name>ArchiveEntry</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>,
			 <parameter><decl><type><name>ArchiveOpts</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>newToc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newToc</name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dumpId</name> <operator>&gt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>=</operator> <name>dumpId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newToc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>newToc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>catalogId</name></name> <operator>=</operator> <name>catalogId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>=</operator> <name>dumpId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <name><name>opts</name><operator>-&gt;</operator><name>section</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>namespace</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>namespace</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>tablespace</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>tableam</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>tableam</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>tableam</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>owner</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>defn</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>createStmt</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>createStmt</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dropStmt</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>dropStmt</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>dropStmt</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>copyStmt</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>copyStmt</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newToc</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>, <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>deps</name></name></expr></argument>, <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <name><name>opts</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dataDumper</name></name> <operator>=</operator> <name><name>opts</name><operator>-&gt;</operator><name>dumpFn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dataDumperArg</name></name> <operator>=</operator> <name><name>opts</name><operator>-&gt;</operator><name>dumpArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>hadDumper</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>dumpFn</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newToc</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>ArchiveEntryPtr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ArchiveEntryPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>newToc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>newToc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>PrintTOCSummary</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>teSection</name></type>	<name>curSection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OutputContext</name></type> <name>sav</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmtName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>stamp_str</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sav</name> <operator>=</operator> <call><name>SaveOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* no compression */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>stamp_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stamp_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PGDUMP_STRFTIME_FMT</name></expr></argument>,
				 <argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>stamp_str</name></expr></argument>, <argument><expr><literal type="string">"[unknown]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";\n; Archive created at %s\n"</literal></expr></argument>, <argument><expr><name>stamp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     dbname: %s\n;     TOC Entries: %d\n;     Compression: %d\n"</literal></expr></argument>,
			 <argument><expr><call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>archdbname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>archCustom</name></expr>:</case>
			<expr_stmt><expr><name>fmtName</name> <operator>=</operator> <literal type="string">"CUSTOM"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>archDirectory</name></expr>:</case>
			<expr_stmt><expr><name>fmtName</name> <operator>=</operator> <literal type="string">"DIRECTORY"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>archTar</name></expr>:</case>
			<expr_stmt><expr><name>fmtName</name> <operator>=</operator> <literal type="string">"TAR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>fmtName</name> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Dump Version: %d.%d-%d\n"</literal></expr></argument>,
			 <argument><expr><call><name>ARCHIVE_MAJOR</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARCHIVE_MINOR</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARCHIVE_REV</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Format: %s\n"</literal></expr></argument>, <argument><expr><name>fmtName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Integer: %d bytes\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Offset: %d bytes\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Dumped from database version: %s\n"</literal></expr></argument>,
				 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";     Dumped by pg_dump version: %s\n"</literal></expr></argument>,
				 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";\n;\n; Selected TOC Entries:\n;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>curSection</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>!=</operator> <name>SECTION_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>curSection</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>section</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>verbose</name></name> <operator>||</operator>
			<operator>(</operator><call><name>_tocEntryRequired</name><argument_list>(<argument><expr><name>te</name></expr></argument>, <argument><expr><name>curSection</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_schema</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_owner</name></decl>;</decl_stmt>

			<comment type="block">/*
			 */</comment>
			<expr_stmt><expr><name>sanitized_name</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sanitized_schema</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sanitized_owner</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%d; %u %u %s %s %s %s\n"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>,
					 <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>sanitized_schema</name></expr></argument>, <argument><expr><name>sanitized_name</name></expr></argument>,
					 <argument><expr><name>sanitized_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">";\tdepends on:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Enforce strict names checking */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>strict_names</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>StrictNamesCheck</name><argument_list>(<argument><expr><name>ropt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RestoreOutput</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>sav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********
 * BLOB Archival
 ***********/</comment>

<comment type="block">/* Called by a dumper to signal start of a BLOB */</comment>
<function><type><name>int</name></type>
<name>StartBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>StartBlobPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"large-object output not supported in chosen format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>StartBlobPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currToc</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Called by a dumper to signal end of a BLOB */</comment>
<function><type><name>int</name></type>
<name>EndBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>EndBlobPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>EndBlobPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currToc</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********
 * BLOB Restoration
 **********/</comment>

<comment type="block">/*
 * Called by a format handler before any blobs are restored
 */</comment>
<function><type><name>void</name></type>
<name>StartRestoreBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>single_txn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StartTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"BEGIN;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>blobCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by a format handler after all blobs are restored
 */</comment>
<function><type><name>void</name></type>
<name>EndRestoreBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>single_txn</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"COMMIT;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"restored %d large object"</literal></expr></argument>,
						 <argument><expr><literal type="string">"restored %d large objects"</literal></expr></argument>,
						 <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>blobCount</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>blobCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Called by a format handler to initiate restoration of a blob
 */</comment>
<function><type><name>void</name></type>
<name>StartRestoreBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_blob_style</name> <init>= <expr><operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_12</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loOid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>blobCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Initialize the LO Buffer */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"restoring large object with OID %u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* With an old archive we must do drop and create logic here */</comment>
	<if_stmt><if>if <condition>(<expr><name>old_blob_style</name> <operator>&amp;&amp;</operator> <name>drop</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DropBlobIfExists</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>old_blob_style</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>loOid</name> <operator>=</operator> <call><name>lo_create</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>loOid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>loOid</name> <operator>!=</operator> <name>oid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not create large object %u: %s"</literal></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>loFd</name></name> <operator>=</operator> <call><name>lo_open</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>loFd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open large object %u: %s"</literal></expr></argument>,
				  <argument><expr><name>oid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>old_blob_style</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.lo_open(pg_catalog.lo_create('%u'), %d);\n"</literal></expr></argument>,
					 <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.lo_open('%u', %d);\n"</literal></expr></argument>,
					 <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>writingBlob</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>EndRestoreBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Write remaining bytes from the LO buffer */</comment>
		<expr_stmt><expr><call><name>dump_lo_buf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>writingBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lo_close</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>loFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>loFd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.lo_close(0);\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********
 * Sorting and Reordering
 ***********/</comment>

<function><type><name>void</name></type>
<name>SortTocFromFile</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>incomplete_line</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate space for the 'wanted' array, and init it */</comment>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>idWanted</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup the file */</comment>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>tocFile</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open TOC file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>tocFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>incomplete_line</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fh</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>prev_incomplete_line</name> <init>= <expr><name>incomplete_line</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpId</name></type>		<name>id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Some lines in the file might be longer than sizeof(buf).  This is
		 * no problem, since we only care about the leading numeric ID which
		 * can be at most a few characters; but we have to skip continuation
		 * bufferloads when processing a long line.
		 */</comment>
		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>buflen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>incomplete_line</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>incomplete_line</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>prev_incomplete_line</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Truncate line at comment, if any */</comment>
		<expr_stmt><expr><name>cmnt</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmnt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cmnt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore if all blank */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" \t\r\n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Get an ID, check it's valid and not already seen */</comment>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>buf</name> <operator>||</operator> <name>id</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>id</name> <operator>&gt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>||</operator>
			<name><name>ropt</name><operator>-&gt;</operator><name>idWanted</name><index>[<expr><name>id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"line ignored: %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Find TOC entry */</comment>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>getTocEntryByDumpId</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>te</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find entry for ID %d"</literal></expr></argument>,
				  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Mark it wanted */</comment>
		<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>idWanted</name><index>[<expr><name>id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Move each item to the end of the list as it is selected, so that
		 * they are placed in the desired order.  Any unwanted items will end
		 * up at the front of the list, which may seem unintuitive but it's
		 * what we need.  In an ordinary serial restore that makes no
		 * difference, but in a parallel restore we need to mark unrestored
		 * items' dependencies as satisfied before we start examining
		 * restorable items.  Otherwise they could have surprising
		 * side-effects on the order in which restorable items actually get
		 * restored.
		 */</comment>
		<expr_stmt><expr><call><name>_moveBefore</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close TOC file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************
 * 'Convenience functions that look like standard IO functions
 * for writing data when in dump mode.
 **********************/</comment>

<comment type="block">/* Public */</comment>
<function><type><name>void</name></type>
<name>archputs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Public */</comment>
<function><type><name>int</name></type>
<name>archprintf</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* initial assumption about buffer size */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

		<comment type="block">/* Allocate work buffer. */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to format the data. */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>pvsnprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* success */</comment>

		<comment type="block">/* Release buffer and loop around to try again with larger len. */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>cnt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*******************************
 * Stuff below here should be 'private' to the archiver routines
 *******************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fn</name> <operator>=</operator> <call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fn</name> <operator>=</operator> <call><name>fileno</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fn</name> <operator>=</operator> <call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If compression explicitly requested, use gzopen */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>compression</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fmode</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Don't use PG_BINARY_x since this is zlib */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fmode</name></expr></argument>, <argument><expr><literal type="string">"wb%d"</literal></expr></argument>, <argument><expr><name>compression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>gzdopen</name><argument_list>(<argument><expr><call><name>dup</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>							<comment type="block">/* Use fopen */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeAppend</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><call><name>dup</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_BINARY_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><call><name>dup</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OutputContext</name></type>
<name>SaveOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OutputContext</name></type> <name>sav</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sav</name><operator>.</operator><name>OF</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sav</name><operator>.</operator><name>gzOut</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name></expr>;</expr_stmt>

	<return>return <expr><name>sav</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RestoreOutput</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>OutputContext</name></type> <name>savedContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* in case gzclose() doesn't set it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GZCLOSE</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close output file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name> <operator>=</operator> <name><name>savedContext</name><operator>.</operator><name>gzOut</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <name><name>savedContext</name><operator>.</operator><name>OF</name></name></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 *	Print formatted text to the output file (usually stdout).
 */</comment>
<function><type><name>int</name></type>
<name>ahprintf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* initial assumption about buffer size */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

		<comment type="block">/* Allocate work buffer. */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to format the data. */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>pvsnprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* success */</comment>

		<comment type="block">/* Release buffer and loop around to try again with larger len. */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ahwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Single place for logic which says 'We are restoring to a direct DB connection'.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>RestoringToDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>ropt</name> <operator>&amp;&amp;</operator> <name><name>ropt</name><operator>-&gt;</operator><name>useDB</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>connection</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dump the current contents of the LO data buffer while writing a BLOB
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_lo_buf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lo_write</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>loFd</name></name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"wrote %lu byte of large object data (result = %lu)"</literal></expr></argument>,
							  <argument><expr><literal type="string">"wrote %lu bytes of large object data (result = %lu)"</literal></expr></argument>,
							  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to large object (result: %lu, expected: %lu)"</literal></expr></argument>,
				  <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>res</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendByteaLiteralAHX</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							  <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name></expr></argument>,
							  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>,
							  <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Hack: turn off writingBlob so ahwrite doesn't recurse to here */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>writingBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.lowrite(0, %s);\n"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>writingBlob</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Write buffer to the output file (usually stdout). This is used for
 *	outputting 'restore' scripts etc. It is even possible for an archive
 *	format to create a custom output routine to 'fake' a restore if it
 *	wants to generate a script (see TAR output).
 */</comment>
<function><type><name>void</name></type>
<name>ahwrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>writingBlob</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>remaining</name> <init>= <expr><name>size</name> <operator>*</operator> <name>nmemb</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>+</operator> <name>remaining</name> <operator>&gt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_size</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>avail</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_size</name></name> <operator>-</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name> <operator>+</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>avail</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dump_lo_buf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name> <operator>+</operator> <name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_used</name></name> <operator>+=</operator> <name>remaining</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <name>size</name> <operator>*</operator> <name>nmemb</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name>GZWRITE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nmemb</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>CustomOutPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>CustomOutPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>nmemb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we're doing a restore, and it's direct to DB, and we're
		 * connected then send it to the DB.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name>ExecuteSqlCommandBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <name>nmemb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nmemb</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytes_written</name> <operator>!=</operator> <name>size</name> <operator>*</operator> <name>nmemb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WRITE_ERROR_EXIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* on some error, we may decide to go on... */</comment>
<function><type><name>void</name></type>
<name>warn_or_exit_horribly</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name></expr>)</condition>
	<block>{<block_content>

		<case>case <expr><name>STAGE_NONE</name></expr>:</case>
			<comment type="block">/* Do nothing special */</comment>
			<break>break;</break>

		<case>case <expr><name>STAGE_INITIALIZING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>lastErrorStage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_generic</name><argument_list>(<argument><expr><name>PG_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"while INITIALIZING:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>STAGE_PROCESSING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>lastErrorStage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_generic</name><argument_list>(<argument><expr><name>PG_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"while PROCESSING TOC:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>STAGE_FINALIZING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>stage</name></name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>lastErrorStage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_generic</name><argument_list>(<argument><expr><name>PG_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"while FINALIZING:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>currentTE</name></name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>lastErrorTE</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_generic</name><argument_list>(<argument><expr><name>PG_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"from TOC entry %d; %u %u %s %s %s"</literal></expr></argument>,
					   <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
					   <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>,
					   <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>,
					   <argument><expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>desc</name></name></expr> ?</condition><then> <expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>desc</name></name></expr> </then><else>: <expr><literal type="string">"(no desc)"</literal></expr></else></ternary></expr></argument>,
					   <argument><expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>tag</name></name></expr> ?</condition><then> <expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>tag</name></name></expr> </then><else>: <expr><literal type="string">"(no tag)"</literal></expr></else></ternary></expr></argument>,
					   <argument><expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>owner</name></name></expr> ?</condition><then> <expr><name><name>AH</name><operator>-&gt;</operator><name>currentTE</name><operator>-&gt;</operator><name>owner</name></name></expr> </then><else>: <expr><literal type="string">"(no owner)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lastErrorStage</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>stage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lastErrorTE</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>currentTE</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_log_generic_v</name><argument_list>(<argument><expr><name>PG_LOG_ERROR</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>exit_on_error</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_moveAfter</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Unlink te from list */</comment>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

	<comment type="block">/* and insert it after "pos" */</comment>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_moveBefore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Unlink te from list */</comment>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

	<comment type="block">/* and insert it before "pos" */</comment>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build index arrays for the TOC list
 *
 * This should be invoked only after we have created or read in all the TOC
 * items.
 *
 * The arrays are indexed by dump ID (so entry zero is unused).  Note that the
 * array entries run only up to maxDumpId.  We might see dependency dump IDs
 * beyond that (if the dump was partial); so always check the array bound
 * before trying to touch an array entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildTocEntryArrays</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>maxDumpId</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name></name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>maxDumpId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>maxDumpId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* this check is purely paranoia, maxDumpId should be correct */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&gt;</operator> <name>maxDumpId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"bad dumpId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* tocsByDumpId indexes all TOCs by their dump ID */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * tableDataId provides the TABLE DATA item's dump ID for each TABLE
		 * TOC entry that has a DATA item.  We compute this by reversing the
		 * TABLE DATA item's dependency, knowing that a TABLE DATA item has
		 * just one dependency and it is the TABLE item.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DumpId</name></type>		<name>tableId</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The TABLE item might not have been in the archive, if this was
			 * a data-only dump; but its dump ID should be less than its data
			 * item's dump ID, so there should be a place for it in the array.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>tableId</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>tableId</name> <operator>&gt;</operator> <name>maxDumpId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"bad table dumpId for TABLE DATA item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name>tableId</name></expr>]</index></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>TocEntry</name> <modifier>*</modifier></type>
<name>getTocEntryByDumpId</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* build index arrays if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>buildTocEntryArrays</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>id</name> <operator>&lt;=</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>id</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>teReqs</name></type>
<name>TocIDRequired</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>getTocEntryByDumpId</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>te</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>WriteOffset</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>pgoff_t</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wasSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

	<comment type="block">/* Save the flag */</comment>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>wasSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write out pgoff_t smallest byte first, prevents endian mismatch */</comment>
	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgoff_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>o</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>o</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgoff_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ReadOffset</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>pgoff_t</name> <modifier>*</modifier></type> <name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offsetFlg</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize to zero */</comment>
	<expr_stmt><expr><operator>*</operator><name>o</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Check for old version */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_7</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Prior versions wrote offsets using WriteInt */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* -1 means not set */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>K_OFFSET_POS_NOT_SET</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>K_OFFSET_NO_DATA</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Cast to pgoff_t because it was written as an int. */</comment>
		<expr_stmt><expr><operator>*</operator><name>o</name> <operator>=</operator> <operator>(</operator><name>pgoff_t</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
		<return>return <expr><name>K_OFFSET_POS_SET</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read the flag indicating the state of the data pointer. Check if valid
	 * and die if not.
	 *
	 * This used to be handled by a negative or zero pointer, now we use an
	 * extra byte specifically for the state.
	 */</comment>
	<expr_stmt><expr><name>offsetFlg</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>offsetFlg</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>K_OFFSET_POS_NOT_SET</name></expr>:</case>
		<case>case <expr><name>K_OFFSET_NO_DATA</name></expr>:</case>
		<case>case <expr><name>K_OFFSET_POS_SET</name></expr>:</case>

			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unexpected data offset flag %d"</literal></expr></argument>, <argument><expr><name>offsetFlg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Read the bytes
	 */</comment>
	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgoff_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>o</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>pgoff_t</name><operator>)</operator> <operator>(</operator><call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>off</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"file offset in dump file is too large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>offsetFlg</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>WriteInt</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>b</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is a bit yucky, but I don't want to make the binary format very
	 * dependent on representation, and not knowing much about it, I write out
	 * a sign byte. If you change this, don't forget to change the file
	 * version #, and modify ReadInt to read the new format AS WELL AS the old
	 * formats.
	 */</comment>

	<comment type="block">/* SIGN byte */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>i</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ReadInt</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bv</name></decl>,
				<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* Default positive */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitShift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <name>K_VERS_1_0</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Read a sign byte */</comment>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bv</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>+</operator> <operator>(</operator><name>bv</name> <operator>&lt;&lt;</operator> <name>bitShift</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bitShift</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>WriteStr</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBufPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ReadStr</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReadBufPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_discoverArchiveFormat</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sig</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>			<comment type="block">/* More than enough */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wantClose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"attempting to ascertain archive format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>readHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadSize</name></name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>wantClose</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check if the specified archive is a directory. If so, check if
		 * there's a "toc.dat" (or "toc.dat.gz") file in it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/toc.dat"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"directory name too long: \"%s\""</literal></expr></argument>,
					  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt>
				<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/toc.dat.gz"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"directory name too long: \"%s\""</literal></expr></argument>,
					  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt>
				<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"directory \"%s\" does not appear to be a valid archive (\"toc.dat\" does not exist)"</literal></expr></argument>,
				  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>fh</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>fh</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not read input file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"input file is too short (read %lu, expected 5)"</literal></expr></argument>,
				  <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save it, just in case we need it later */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><literal type="string">"PGDMP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's custom format, stop here */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archCustom</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>readHeader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * *Maybe* we have a tar archive format file or a text dump ... So,
		 * read first 512 byte header...
		 */</comment>
		<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name><index>[<expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">512</literal> <operator>-</operator> <name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name></expr></argument>, <argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* read failure is checked below */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>&gt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>TEXT_DUMPALL_HEADER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>, <argument><expr><name>TEXT_DUMP_HEADER</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEXT_DUMP_HEADER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>, <argument><expr><name>TEXT_DUMPALL_HEADER</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEXT_DUMPALL_HEADER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * looks like it's probably a text format dump. so suggest they
			 * try psql
			 */</comment>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"input file appears to be a text format dump. Please use psql."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>!=</operator> <literal type="number">512</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"input file does not appear to be a valid archive (too short?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>READ_ERROR_EXIT</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isValidTarHeader</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"input file does not appear to be a valid archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Close the file if we opened it */</comment>
	<if_stmt><if>if <condition>(<expr><name>wantClose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close input file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Forget lookahead, since we'll re-read header after re-opening */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>readHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lookaheadLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Allocate an archive handle
 */</comment>
<function><type><specifier>static</specifier> <name>ArchiveHandle</name> <modifier>*</modifier></type>
<name>_allocAH</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>FileSpec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArchiveFormat</name></type> <name>fmt</name></decl></parameter>,
		 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>compression</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dosync</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name></type> <name>mode</name></decl></parameter>,
		 <parameter><decl><type><name>SetupWorkerPtrType</name></type> <name>setupWorkerPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"allocating AH for %s, format %d"</literal></expr></argument>, <argument><expr><name>FileSpec</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AH</name> <operator>=</operator> <operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>K_VERS_SELF</name></expr>;</expr_stmt>

	<comment type="block">/* initialize for backwards compatible string processing */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* PG_SQL_ASCII */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* sql error handling */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>exit_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name> <operator>=</operator> <name>PG_VERSION</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgoff_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>FileSpec</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>FileSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Not used; maybe later....
		 *
		 * AH-&gt;workDir = pg_strdup(FileSpec); for(i=strlen(FileSpec) ; i &gt; 0 ;
		 * i--) if (AH-&gt;workDir[i-1] == '/')
		 */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* unknown */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* ditto */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* ditto */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* ditto */</comment>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name></name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>compression</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>dosync</name></name> <operator>=</operator> <name>dosync</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open stdout with no compression for AH output handle */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>gzOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>OF</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * On Windows, we need to use binary mode to read/write non-text files,
	 * which include all archive formats as well as compressed plain text.
	 * Force stdin/stdout into binary mode if that is what we are using.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmt</name> <operator>!=</operator> <name>archNull</name> <operator>||</operator> <name>compression</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>SetupWorkerPtr</name></name> <operator>=</operator> <name>setupWorkerPtr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>archUnknown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <call><name>_discoverArchiveFormat</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>fmt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>archCustom</name></expr>:</case>
			<expr_stmt><expr><call><name>InitArchiveFmt_Custom</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>archNull</name></expr>:</case>
			<expr_stmt><expr><call><name>InitArchiveFmt_Null</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>archDirectory</name></expr>:</case>
			<expr_stmt><expr><call><name>InitArchiveFmt_Directory</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>archTar</name></expr>:</case>
			<expr_stmt><expr><call><name>InitArchiveFmt_Tar</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized file format \"%d\""</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>AH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write out all data (tables &amp; blobs)
 */</comment>
<function><type><name>void</name></type>
<name>WriteDataChunks</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In parallel mode, this code runs in the master process.  We
		 * construct an array of candidate TEs, then sort it into decreasing
		 * size order, then dispatch each TE to a data-transfer worker.  By
		 * dumping larger tables first, we avoid getting into a situation
		 * where we're down to one job and it's big, losing parallelism.
		 */</comment>
		<decl_stmt><decl><type><name>TocEntry</name>  <modifier>*</modifier><modifier>*</modifier></type><name>tes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tes</name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Consider only TEs with dataDumper functions ... */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* ... and ignore ones not enabled for dump */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <name>REQ_DATA</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tes</name><index>[<expr><name>ntes</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>ntes</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tes</name></expr></argument>, <argument><expr><name>ntes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>TocEntrySizeCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DispatchJobForTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ACT_DUMP</name></expr></argument>,
								   <argument><expr><name>mark_dump_job_done</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>tes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now wait for workers to finish. */</comment>
		<expr_stmt><expr><call><name>WaitForWorkers</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>WFW_ALL_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Non-parallel mode: just dump all candidate TEs sequentially. */</comment>
		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Must have same filter conditions as above */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <name>REQ_DATA</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>WriteDataChunksForTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Callback function that's invoked in the master process after a step has
 * been parallel dumped.
 *
 * We don't need to do anything except check for worker failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_dump_job_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
				   <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"finished item %d %s %s"</literal></expr></argument>,
				<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"worker process failed: exit code %d"</literal></expr></argument>,
			  <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>WriteDataChunksForTocEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StartDataPtrType</name></type> <name>startPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EndDataPtrType</name></type> <name>endPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currToc</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>startPtr</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>StartBlobsPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>EndBlobsPtr</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>startPtr</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>StartDataPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endPtr</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>EndDataPtr</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>startPtr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>startPtr</name>) <argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The user-provided DataDumper routine needs to call AH-&gt;WriteData
	 */</comment>
	<expr_stmt><expr><call><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dataDumperArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>endPtr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>endPtr</name>) <argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currToc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>WriteToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tocCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* count entries that will actually be dumped */</comment>
	<expr_stmt><expr><name>tocCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name> <operator>|</operator> <name>REQ_SPECIAL</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tocCount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* printf("%d TOC Entries to save\n", tocCount); */</comment>

	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>tocCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name> <operator>|</operator> <name>REQ_SPECIAL</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* OID is recorded as a string for historical reasons */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>workbuf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>workbuf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tableam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Dump list of dependencies */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>workbuf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* Terminate List */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>WriteExtraTocPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteExtraTocPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReadToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name>	   <modifier>*</modifier></type><name>deps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>depSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&gt;</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Sanity check */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"entry ID %d out of range -- perhaps a corrupt TOC"</literal></expr></argument>,
				  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>hadDumper</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_8</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_11</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Rules for pre-8.4 archives wherein pg_dump hasn't classified
			 * the entries into sections.  This list need not cover entry
			 * types added later than 8.4.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <name>SECTION_NONE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB COMMENTS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <name>SECTION_DATA</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"RULE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_3</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>copyStmt</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_6</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_10</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_14</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>tableam</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_9</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"restoring tables WITH OIDS is not supported anymore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Read TOC entry dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_5</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>depSize</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>deps</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>depSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>depIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of list */</comment>
				<if_stmt><if>if <condition>(<expr><name>depIdx</name> <operator>&gt;=</operator> <name>depSize</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>depSize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>deps</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>deps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>depSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>deps</name><index>[<expr><name>depIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>depIdx</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>depIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* We have a non-null entry */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>deps</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>deps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>depIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>deps</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <name>depIdx</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>deps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>ReadExtraTocPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReadExtraTocPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"read TOC entry %d (ID %d) for %s %s"</literal></expr></argument>,
					 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* link completed entry into TOC circular list */</comment>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</expr_stmt>

		<comment type="block">/* special processing immediately upon read for some items */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>processEncodingEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"STDSTRINGS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>processStdStringsEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEARCHPATH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>processSearchPathEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>processEncodingEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* te-&gt;defn should have the form SET client_encoding = 'foo'; */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defn</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr1</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>defn</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>++</operator><name>ptr1</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized encoding \"%s\""</literal></expr></argument>,
				  <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid ENCODING item: %s"</literal></expr></argument>,
			  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>processStdStringsEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* te-&gt;defn should have the form SET standard_conforming_strings = 'x'; */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr1</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr1</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><literal type="string">"'on'"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ptr1</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><literal type="string">"'off'"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid STDSTRINGS item: %s"</literal></expr></argument>,
			  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>processSearchPathEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * te-&gt;defn should contain a command to set search_path.  We just copy it
	 * verbatim for use later.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>searchpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>StrictNamesCheck</name><parameter_list>(<parameter><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>missing_name</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>strict_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missing_name</name> <operator>=</operator> <call><name>simple_string_list_not_touched</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>schemaNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" not found"</literal></expr></argument>, <argument><expr><name>missing_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>tableNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missing_name</name> <operator>=</operator> <call><name>simple_string_list_not_touched</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>tableNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" not found"</literal></expr></argument>, <argument><expr><name>missing_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>indexNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missing_name</name> <operator>=</operator> <call><name>simple_string_list_not_touched</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>indexNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" not found"</literal></expr></argument>, <argument><expr><name>missing_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>functionNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missing_name</name> <operator>=</operator> <call><name>simple_string_list_not_touched</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>functionNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" not found"</literal></expr></argument>, <argument><expr><name>missing_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>triggerNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>missing_name</name> <operator>=</operator> <call><name>simple_string_list_not_touched</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>triggerNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" not found"</literal></expr></argument>, <argument><expr><name>missing_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether we want to restore this TOC entry.
 *
 * Returns 0 if entry should be skipped, or some combination of the
 * REQ_SCHEMA and REQ_DATA bits if we want to restore schema and/or data
 * portions of this TOC entry, or REQ_SPECIAL if it's a special entry.
 */</comment>
<function><type><specifier>static</specifier> <name>teReqs</name></type>
<name>_tocEntryRequired</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>teSection</name></type> <name>curSection</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>teReqs</name></type>		<name>res</name> <init>= <expr><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* These items are treated specially */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"STDSTRINGS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEARCHPATH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REQ_SPECIAL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * DATABASE and DATABASE PROPERTIES also have a special rule: they are
	 * restored in createDB mode, and not restored otherwise, independently of
	 * all else.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>REQ_SCHEMA</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process exclusions that affect certain classes of TOC entries.
	 */</comment>

	<comment type="block">/* If it's an ACL, maybe ignore it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>aclsSkip</name></name> <operator>&amp;&amp;</operator> <call><name>_tocEntryIsACL</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If it's a comment, maybe ignore it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>no_comments</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a publication or a table part of a publication, maybe ignore
	 * it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If it's a security label, maybe ignore it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If it's a subscription, maybe ignore it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ignore it if section is not to be dumped/restored */</comment>
	<switch>switch <condition>(<expr><name>curSection</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SECTION_PRE_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>&amp;</operator> <name>DUMP_PRE_DATA</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SECTION_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>&amp;</operator> <name>DUMP_DATA</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SECTION_POST_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>&amp;</operator> <name>DUMP_POST_DATA</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* shouldn't get here, really, but ignore it */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* Ignore it if rejected by idWanted[] (cf. SortTocFromFile) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>idWanted</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>idWanted</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check options for selective dump/restore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Database properties react to createDB, not selectivity options. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE "</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
				 <name><name>ropt</name><operator>-&gt;</operator><name>schemaExcludeNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
				 <name><name>ropt</name><operator>-&gt;</operator><name>selTypes</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In a selective dump/restore, we want to restore these dependent
			 * TOC entry types only if their parent object is being restored.
			 * Without selectivity options, we let through everything in the
			 * archive.  Note there may be such entries with no parent, eg
			 * non-default ACLs for built-in objects.
			 *
			 * This code depends on the parent having been marked already,
			 * which should be the case; if it isn't, perhaps due to
			 * SortTocFromFile rearrangement, skipping the dependent entry
			 * seems prudent anyway.
			 *
			 * Ideally we'd handle, eg, table CHECK constraints this way too.
			 * But it's hard to tell which of their dependencies is the one to
			 * consult.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>TocIDRequired</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Apply selective-restore rules for standalone TOC entries. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If no namespace is specified, it means all. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>schemaNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaExcludeNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>te</name><operator>-&gt;</operator><name>namespace</name></name> <operator>&amp;&amp;</operator>
			<call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>schemaExcludeNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>selTypes</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FOREIGN TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED VIEW DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE SET"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>selTable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>tableNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>tableNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>selIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>indexNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>indexNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PROCEDURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>selFunction</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>functionNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>functionNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>selTrigger</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>triggerNames</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>simple_string_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>triggerNames</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Determine whether the TOC entry contains schema and/or data components,
	 * and mask off inapplicable REQ bits.  If it had a dataDumper, assume
	 * it's both schema and data.  Otherwise it's probably schema-only, but
	 * there are exceptions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>hadDumper</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Special Case: If 'SEQUENCE SET' or anything to do with BLOBs, then
		 * it is considered a data entry.  We don't need to check for the
		 * BLOBS entry or old-style BLOB COMMENTS, because they will have
		 * hadDumper = true ... but we do need to check new-style BLOB ACLs,
		 * comments, etc.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE SET"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>&amp;</operator> <name>REQ_DATA</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>&amp;</operator> <operator>~</operator><name>REQ_DATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If there's no definition command, there's no schema component */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>defn</name></name> <operator>||</operator> <operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>defn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>&amp;</operator> <operator>~</operator><name>REQ_SCHEMA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Special case: &lt;Init&gt; type with &lt;Max OID&gt; tag; this is obsolete and we
	 * always ignore it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"&lt;Init&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"Max OID"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Mask it if we only want schema */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The sequence_data option overrides schemaOnly for SEQUENCE SET.
		 *
		 * In binary-upgrade mode, even with schemaOnly set, we do not mask
		 * out large objects.  (Only large object definitions, comments and
		 * other metadata should be generated in binary-upgrade mode, not the
		 * actual data, but that need not concern us here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>sequence_data</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE SET"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator>
			  <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			   <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>&amp;</operator> <name>REQ_SCHEMA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mask it if we only want data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>&amp;</operator> <name>REQ_DATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify which pass we should restore this TOC entry in.
 *
 * See notes with the RestorePass typedef in pg_backup_archiver.h.
 */</comment>
<function><type><specifier>static</specifier> <name>RestorePass</name></type>
<name>_tocEntryRestorePass</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* "ACL LANGUAGE" was a crock emitted only in PG 7.4 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DEFAULT ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RESTORE_PASS_ACL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED VIEW DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RESTORE_PASS_POST_ACL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Comments need to be emitted in the same pass as their parent objects.
	 * ACLs haven't got comments, and neither do matview data objects, but
	 * event triggers do.  (Fortunately, event triggers haven't got ACLs, or
	 * we'd need yet another weird special case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER "</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RESTORE_PASS_POST_ACL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* All else can be handled in the main pass. */</comment>
	<return>return <expr><name>RESTORE_PASS_MAIN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify TOC entries that are ACLs.
 *
 * Note: it seems worth duplicating some code here to avoid a hard-wired
 * assumption that these are exactly the same entries that we restore during
 * the RESTORE_PASS_ACL phase.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_tocEntryIsACL</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* "ACL LANGUAGE" was a crock emitted only in PG 7.4 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ACL LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DEFAULT ACL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Issue SET commands for parameters that we want to have set the same way
 * at all times during execution of a restore script.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_doSetFixedOutputState</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disable timeouts to allow for slow commands, idle parallel workers, etc
	 */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = 0;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET lock_timeout = 0;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET idle_in_transaction_session_timeout = 0;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select the correct character set encoding */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET client_encoding = '%s';\n"</literal></expr></argument>,
			 <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select the correct string literal syntax */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET standard_conforming_strings = %s;\n"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select the role to be used during restore */</comment>
	<if_stmt><if>if <condition>(<expr><name>ropt</name> <operator>&amp;&amp;</operator> <name><name>ropt</name><operator>-&gt;</operator><name>use_role</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET ROLE %s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>ropt</name><operator>-&gt;</operator><name>use_role</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Select the dump-time search_path */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>searchpath</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>searchpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure function checking is disabled */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET check_function_bodies = false;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure that all valid XML data will be accepted */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET xmloption = content;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid annoying notices etc */</comment>
	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET client_min_messages = warning;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET escape_string_warning = off;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Adjust row-security state */</comment>
	<if_stmt><if>if <condition>(<expr><name>ropt</name> <operator>&amp;&amp;</operator> <name><name>ropt</name><operator>-&gt;</operator><name>enable_row_security</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = on;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = off;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET cypher_allow_unsafe_ddl = on;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Issue a SET SESSION AUTHORIZATION command.  Caller is responsible
 * for updating state if appropriate.  If user is NULL or an empty string,
 * the specification DEFAULT will be used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_doSetSessionAuth</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cmd</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SET SESSION AUTHORIZATION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SQL requires a string literal here.  Might as well be correct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>user</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>user</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringLiteralAHX</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* NOT warn_or_exit_horribly... use -O instead to skip this. */</comment>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not set session user to \"%s\": %s"</literal></expr></argument>,
				  <argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Issue the commands to connect to the specified database.
 *
 * If we're currently restoring right into a database, this will
 * actually establish a connection. Otherwise it puts a \connect into
 * the script output.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_reconnectToDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReconnectToServer</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>connectbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPsqlMetaConnect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>connectbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * NOTE: currUser keeps track of what the imaginary session user in our
	 * script is.  It's now effectively reset to the original userID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* don't assume we still know the output schema, tablespace, etc either */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* re-establish fixed state */</comment>
	<expr_stmt><expr><call><name>_doSetFixedOutputState</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Become the specified user, and update state to avoid redundant commands
 *
 * NULL or empty argument is taken to mean restoring the session default
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_becomeUser</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>user</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>user</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* avoid null pointers */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no need to do anything */</comment>

	<expr_stmt><expr><call><name>_doSetSessionAuth</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * NOTE: currUser keeps track of what the imaginary session user in our
	 * script is
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Become the owner of the given TOC entry object.  If
 * changes in ownership are not allowed, this doesn't do anything.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_becomeOwner</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ropt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>||</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>use_setsessauth</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_becomeUser</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Issue the commands to select the specified schema as the current schema
 * in the target database.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_selectOutputSchema</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there was a SEARCHPATH TOC entry, we're supposed to just stay with
	 * that search_path rather than switching to entry-specific paths.
	 * Otherwise, it's an old archive that will not restore correctly unless
	 * we set the search_path as it's expecting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>searchpath</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>schemaName</name> <operator>||</operator> <operator>*</operator><name>schemaName</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
		<operator>(</operator><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no need to do anything */</comment>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET search_path = %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">", pg_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warn_or_exit_horribly</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								  <argument><expr><literal type="string">"could not set search_path to \"%s\": %s"</literal></expr></argument>,
								  <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s;\n\n"</literal></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Issue the commands to select the specified tablespace as the current one
 * in the target database.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_selectTablespace</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>want</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>have</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing in --no-tablespaces mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>noTablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>want</name> <operator>=</operator> <name>tablespace</name></expr>;</expr_stmt>

	<comment type="block">/* no need to do anything for non-tablespace object */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>want</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>want</name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no need to do anything */</comment>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>want</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We want the tablespace to be the database's default */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET default_tablespace = ''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We want an explicit tablespace */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET default_tablespace = %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>want</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warn_or_exit_horribly</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								  <argument><expr><literal type="string">"could not set default_tablespace to %s: %s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>want</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s;\n\n"</literal></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>want</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the proper default_table_access_method value for the table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_selectTableAccessMethod</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>want</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>have</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>want</name> <operator>=</operator> <name>tableam</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>want</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>want</name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SET default_table_access_method = %s;"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>want</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RestoringToDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warn_or_exit_horribly</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								  <argument><expr><literal type="string">"could not set default_table_access_method: %s"</literal></expr></argument>,
								  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>want</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract an object description for a TOC entry, and append it to buf.
 *
 * This is used for ALTER ... OWNER TO.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_getObjectDescription</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Use ALTER TABLE for views and sequences */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"TABLE"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* objects that don't require special decoration */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"COLLATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"STATISTICS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	<comment type="block">/* non-schema-specified objects */</comment>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURAL LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SERVER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"USER MAPPING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"GRAPH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* BLOBs just have a name, but it's numeric so must not use fmtId */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"BLOB"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT %s"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * These object types require additional decoration.  Fortunately, the
	 * information needed is exactly what's in the DROP command.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Chop "DROP " off the front and make a modifiable copy */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

		<comment type="block">/* point to last character in string */</comment>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <name>first</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* Strip off any ';' or '\n' at the end */</comment>
		<while>while <condition>(<expr><name>last</name> <operator>&gt;=</operator> <name>first</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>last</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>last</name> <operator>==</operator> <literal type="char">';'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>last</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"don't know how to set owner for object type \"%s\""</literal></expr></argument>,
				   <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the SQL commands to create the object represented by a TOC entry
 *
 * This now also includes issuing an ALTER OWNER command to restore the
 * object's ownership, if wanted.  But note that the object's permissions
 * will remain at default, until the matching ACL TOC entry is restored.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_printTocEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Select owner, schema, tablespace and default AM as necessary */</comment>
	<expr_stmt><expr><call><name>_becomeOwner</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_selectOutputSchema</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_selectTablespace</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_selectTableAccessMethod</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tableam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit header comment for item */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>noTocComments</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pfx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_schema</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_owner</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isData</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pfx</name> <operator>=</operator> <literal type="string">"Data for "</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pfx</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"--\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>verbose</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- TOC entry %d (class %u OID %u)\n"</literal></expr></argument>,
					 <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- Dependencies:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sanitized_name</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sanitized_schema</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sanitized_owner</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- %sName: %s; Type: %s; Schema: %s; Owner: %s"</literal></expr></argument>,
				 <argument><expr><name>pfx</name></expr></argument>, <argument><expr><name>sanitized_name</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>sanitized_schema</name></expr></argument>,
				 <argument><expr><name>sanitized_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>noTablespace</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sanitized_tablespace</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sanitized_tablespace</name> <operator>=</operator> <call><name>sanitize_line</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"; Tablespace: %s"</literal></expr></argument>, <argument><expr><name>sanitized_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sanitized_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>PrintExtraTocPtr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>PrintExtraTocPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"--\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Actually print the definition.
	 *
	 * Really crude hack for suppressing AUTHORIZATION clause that old pg_dump
	 * versions put into CREATE SCHEMA.  We have to do this when --no-owner
	 * mode is selected.  This is ugly, but I see no other good way ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"CREATE SCHEMA %s;\n\n\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"GRAPH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"CREATE GRAPH ONLY %s;\n\n\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we aren't using SET SESSION AUTH to determine ownership, we must
	 * instead issue an ALTER OWNER command.  We assume that anything without
	 * a DROP command is not a separately ownable object.  All the categories
	 * with DROP commands must appear in one list or the other.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ropt</name><operator>-&gt;</operator><name>use_setsessauth</name></name> <operator>&amp;&amp;</operator>
		<name><name>te</name><operator>-&gt;</operator><name>owner</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dropStmt</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"COLLATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PROCEDURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PROCEDURAL LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FOREIGN TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SERVER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"STATISTICS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"GRAPH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>temp</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">"ALTER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_getObjectDescription</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">" OWNER TO %s;"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CAST"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"FK CONSTRAINT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"RULE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ROW SECURITY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"USER MAPPING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* these object types don't have separate owners */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"don't know how to set owner for object type \"%s\""</literal></expr></argument>,
						   <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an ACL entry, it might contain SET SESSION AUTHORIZATION
	 * commands, so we can no longer assume we know the current auth setting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>_tocEntryIsACL</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sanitize a string to be included in an SQL comment or TOC listing, by
 * replacing any newlines with spaces.  This ensures each logical output line
 * is in fact one physical output line, to prevent corruption of the dump
 * (which could, in the worst case, present an SQL injection vulnerability
 * if someone were to incautiously load a dump containing objects with
 * maliciously crafted names).
 *
 * The result is a freshly malloc'd string.  If the input string is NULL,
 * return a malloc'ed empty string, unless want_hyphen, in which case return a
 * malloc'ed hyphen.
 *
 * Note that we currently don't bother to quote names, meaning that the name
 * fields aren't automatically parseable.  "pg_restore -L" doesn't care because
 * it only examines the dumpId field, but someday we might want to try harder.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>sanitize_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>want_hyphen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>want_hyphen</name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write the file header for a custom-format archive
 */</comment>
<function><type><name>void</name></type>
<name>WriteHead</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>crtm</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBufPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"PGDMP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Magic code */</comment>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><call><name>ARCHIVE_MAJOR</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><call><name>ARCHIVE_MINOR</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><call><name>ARCHIVE_REV</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>crtm</name> <operator>=</operator> <operator>*</operator><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>crtm</name><operator>.</operator><name>tm_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>remoteVersionStr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReadHead</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>vmaj</name></decl>,
				<decl><type ref="prev"/><name>vmin</name></decl>,
				<decl><type ref="prev"/><name>vrev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we haven't already read the header, do so.
	 *
	 * NB: this code must agree with _discoverArchiveFormat().  Maybe find a
	 * way to unify the cases?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>readHeader</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpMag</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>ReadBufPtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>tmpMag</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>tmpMag</name></expr></argument>, <argument><expr><literal type="string">"PGDMP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"did not find magic string in file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>vmaj</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vmin</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vmaj</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>vmaj</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>vmin</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Version &gt; 1.0 */</comment>
		<expr_stmt><expr><name>vrev</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>vrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <call><name>MAKE_ARCHIVE_VERSION</name><argument_list>(<argument><expr><name>vmaj</name></expr></argument>, <argument><expr><name>vmin</name></expr></argument>, <argument><expr><name>vrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_0</name> <operator>||</operator> <name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;</operator> <name>K_VERS_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unsupported version (%d.%d) in file header"</literal></expr></argument>,
			  <argument><expr><name>vmaj</name></expr></argument>, <argument><expr><name>vmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"sanity check on integer size (%lu) failed"</literal></expr></argument>,
			  <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"archive was made on a machine with larger integers, some operations might fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_7</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>offSize</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>intSize</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>fmt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"expected format (%d) differs from format found in file (%d)"</literal></expr></argument>,
			  <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_4</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <call><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"archive is compressed, but this installation does not support compression -- no data will be available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_4</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>crtm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_isdst</name></name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Newer versions of glibc have mktime() report failure if tm_isdst is
		 * inconsistent with the prevailing timezone, e.g. tm_isdst = 1 when
		 * TZ=UTC.  This is problematic when restoring an archive under a
		 * different timezone setting.  If we get a failure, try again with
		 * tm_isdst set to -1 ("don't know").
		 *
		 * XXX with or without this hack, we reconstruct createDate
		 * incorrectly when the prevailing timezone is different from
		 * pg_dump's.  Next time we bump the archive version, we should flush
		 * this representation and store a plain seconds-since-the-Epoch
		 * timestamp instead.
		 */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name> <operator>=</operator> <call><name>mktime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>crtm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name> <operator>==</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>crtm</name><operator>.</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name> <operator>=</operator> <call><name>mktime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>crtm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>createDate</name></name> <operator>==</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"invalid creation date in header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_4</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>archdbname</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>K_VERS_1_10</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveDumpVersion</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * checkSeek
 *	  check to see if ftell/fseek can be performed.
 */</comment>
<function><type><name>bool</name></type>
<name>checkSeek</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>tpos</name></decl>;</decl_stmt>

	<comment type="block">/* Check that ftello works on this file */</comment>
	<expr_stmt><expr><name>tpos</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that fseeko(SEEK_SET) works, too.  NB: we used to try to test
	 * this with fseeko(fp, 0, SEEK_CUR).  But some platforms treat that as a
	 * successful no-op even on files that are otherwise unseekable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>tpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * dumpTimestamp
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTimestamp</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>tim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strftime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PGDUMP_STRFTIME_FMT</name></expr></argument>, <argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- %s %s\n\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main engine for parallel restore.
 *
 * Parallel restore is done in three phases.  In this first phase,
 * we'll process all SECTION_PRE_DATA TOC entries that are allowed to be
 * processed in the RESTORE_PASS_MAIN pass.  (In practice, that's all
 * PRE_DATA items other than ACLs.)  Entries we can't process now are
 * added to the pending_list for later phases to deal with.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_toc_entries_prefork</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipped_some</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>next_work_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"entering restore_toc_entries_prefork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust dependency information */</comment>
	<expr_stmt><expr><call><name>fix_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do all the early stuff in a single connection in the parent. There's no
	 * great point in running it in parallel, in fact it will actually run
	 * faster in a single connection because we avoid all the connection and
	 * setup overhead.  Also, pre-9.2 pg_dump versions were not very good
	 * about showing all the dependencies of SECTION_PRE_DATA items, so we do
	 * not risk trying to process them out-of-order.
	 *
	 * Stuff that we can't do immediately gets added to the pending_list.
	 * Note: we don't yet filter out entries that aren't going to be restored.
	 * They might participate in dependency chains connecting entries that
	 * should be restored, so we treat them as live until we actually process
	 * them.
	 *
	 * Note: as of 9.2, it should be guaranteed that all PRE_DATA items appear
	 * before DATA items, and all DATA items before POST_DATA items.  That is
	 * not certain to be true in older archives, though, and in any case use
	 * of a list file would destroy that ordering (cf. SortTocFromFile).  So
	 * this loop cannot assume that it holds.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name> <operator>=</operator> <name>RESTORE_PASS_MAIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>skipped_some</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>next_work_item</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>next_work_item</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>next_work_item</name> <operator>=</operator> <name><name>next_work_item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>do_now</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>next_work_item</name><operator>-&gt;</operator><name>section</name></name> <operator>!=</operator> <name>SECTION_PRE_DATA</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* DATA and POST_DATA items are just ignored for now */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>next_work_item</name><operator>-&gt;</operator><name>section</name></name> <operator>==</operator> <name>SECTION_DATA</name> <operator>||</operator>
				<name><name>next_work_item</name><operator>-&gt;</operator><name>section</name></name> <operator>==</operator> <name>SECTION_POST_DATA</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>do_now</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>skipped_some</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * SECTION_NONE items, such as comments, can be processed now
				 * if we are still in the PRE_DATA part of the archive.  Once
				 * we've skipped any items, we have to consider whether the
				 * comment's dependencies are satisfied, so skip it for now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>skipped_some</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>do_now</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Also skip items that need to be forced into later passes.  We need
		 * not set skipped_some in this case, since by assumption no main-pass
		 * items could depend on these.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>next_work_item</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESTORE_PASS_MAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>do_now</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>do_now</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK, restore the item and update its dependencies */</comment>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"processing item %d %s %s"</literal></expr></argument>,
						<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
						<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>next_work_item</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Reduce dependencies, but don't move anything to ready_list */</comment>
			<expr_stmt><expr><call><name>reduce_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>next_work_item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Nope, so add it to pending_list */</comment>
			<expr_stmt><expr><call><name>pending_list_append</name><argument_list>(<argument><expr><name>pending_list</name></expr></argument>, <argument><expr><name>next_work_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now close parent connection in prep for parallel steps.  We do this
	 * mainly to ensure that we don't exceed the specified number of parallel
	 * connections.
	 */</comment>
	<expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* blow away any transient state from the old connection */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main engine for parallel restore.
 *
 * Parallel restore is done in three phases.  In this second phase,
 * we process entries by dispatching them to parallel worker children
 * (processes on Unix, threads on Windows), each of which connects
 * separately to the database.  Inter-entry dependencies are respected,
 * and so is the RestorePass multi-pass structure.  When we can no longer
 * make any entries ready to process, we exit.  Normally, there will be
 * nothing left to do; but if there is, the third phase will mop up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_toc_entries_parallel</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							 <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelReadyList</name></type> <name>ready_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>next_work_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"entering restore_toc_entries_parallel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up ready_list with enough room for all known TocEntrys */</comment>
	<expr_stmt><expr><call><name>ready_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The pending_list contains all items that we need to restore.  Move all
	 * items that are available to process immediately into the ready_list.
	 * After this setup, the pending list is everything that needs to be done
	 * but is blocked by one or more dependencies, while the ready list
	 * contains items that have no remaining dependencies and are OK to
	 * process in the current restore pass.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name> <operator>=</operator> <name>RESTORE_PASS_MAIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>move_to_ready_list</name><argument_list>(<argument><expr><name>pending_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * main parent loop
	 *
	 * Keep going until there is no worker still running AND there is no work
	 * left to be done.  Note invariant: at top of loop, there should always
	 * be at least one worker available to dispatch a job to.
	 */</comment>
	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"entering main parallel loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Look for an item ready to be dispatched to a worker */</comment>
		<expr_stmt><expr><name>next_work_item</name> <operator>=</operator> <call><name>pop_next_work_item</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>next_work_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If not to be restored, don't waste time launching a worker */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>next_work_item</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <operator>(</operator><name>REQ_SCHEMA</name> <operator>|</operator> <name>REQ_DATA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"skipping item %d %s %s"</literal></expr></argument>,
							<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
							<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Update its dependencies as though we'd completed it */</comment>
				<expr_stmt><expr><call><name>reduce_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>next_work_item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Loop around to see if anything else can be dispatched */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"launching item %d %s %s"</literal></expr></argument>,
						<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
						<argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>next_work_item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Dispatch to some worker */</comment>
			<expr_stmt><expr><call><name>DispatchJobForTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>next_work_item</name></expr></argument>, <argument><expr><name>ACT_RESTORE</name></expr></argument>,
								   <argument><expr><name>mark_restore_job_done</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsEveryWorkerIdle</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Nothing is ready and no worker is running, so we're done with
			 * the current pass or maybe with the whole process.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name> <operator>==</operator> <name>RESTORE_PASS_LAST</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* No more parallel processing is possible */</comment>

			<comment type="block">/* Advance to next restore pass */</comment>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* That probably allows some stuff to be made ready */</comment>
			<expr_stmt><expr><call><name>move_to_ready_list</name><argument_list>(<argument><expr><name>pending_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Loop around to see if anything's now ready */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We have nothing ready, but at least one child is working, so
			 * wait for some subjob to finish.
			 */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Before dispatching another job, check to see if anything has
		 * finished.  We should check every time through the loop so as to
		 * reduce dependencies as soon as possible.  If we were unable to
		 * dispatch any job this time through, wait until some worker finishes
		 * (and, hopefully, unblocks some pending item).  If we did dispatch
		 * something, continue as soon as there's at least one idle worker.
		 * Note that in either case, there's guaranteed to be at least one
		 * idle worker when we return to the top of the loop.  This ensures we
		 * won't block inside DispatchJobForTocEntry, which would be
		 * undesirable: we'd rather postpone dispatching until we see what's
		 * been unblocked by finished jobs.
		 */</comment>
		<expr_stmt><expr><call><name>WaitForWorkers</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
					   <argument><expr><ternary><condition><expr><name>next_work_item</name></expr> ?</condition><then> <expr><name>WFW_ONE_IDLE</name></expr> </then><else>: <expr><name>WFW_GOT_STATUS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* There should now be nothing in ready_list. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ready_list</name><operator>.</operator><name>first_te</name></name> <operator>&gt;</operator> <name><name>ready_list</name><operator>.</operator><name>last_te</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ready_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ready_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"finished main parallel loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main engine for parallel restore.
 *
 * Parallel restore is done in three phases.  In this third phase,
 * we mop up any remaining TOC entries by processing them serially.
 * This phase normally should have nothing to do, but if we've somehow
 * gotten stuck due to circular dependencies or some such, this provides
 * at least some chance of completing the restore successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_toc_entries_postfork</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"entering restore_toc_entries_postfork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now reconnect the single parent connection.
	 */</comment>
	<expr_stmt><expr><call><name>ConnectDatabase</name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* re-establish fixed state */</comment>
	<expr_stmt><expr><call><name>_doSetFixedOutputState</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure there is no work left due to, say, circular dependencies, or
	 * some other pathological condition.  If so, do it in the single parent
	 * connection.  We don't sweat about RestorePass ordering; it's likely we
	 * already violated that.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>pending_list</name><operator>-&gt;</operator><name>pending_next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name>pending_list</name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"processing missed item %d %s %s"</literal></expr></argument>,
					<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check if te1 has an exclusive lock requirement for an item that te2 also
 * requires, whether or not te2's requirement is for an exclusive lock.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_lock_conflicts</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te1</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>te1</name><operator>-&gt;</operator><name>nLockDeps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>te2</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>te1</name><operator>-&gt;</operator><name>lockDeps</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>te2</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize the header of the pending-items list.
 *
 * This is a circular list with a dummy TocEntry as header, just like the
 * main TOC list; but we use separate list links so that an entry can be in
 * the main TOC list as well as in the pending list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pending_list_header_init</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append te to the end of the pending-list headed by l */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pending_list_append</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>pending_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>pending_prev</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove te from the pending-list */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pending_list_remove</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_prev</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_next</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>pending_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize the ready_list with enough room for up to tocCount entries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ready_list_init</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tocCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name></name> <operator>=</operator> <operator>(</operator><name>TocEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><name>tocCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>last_te</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free storage for a ready_list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ready_list_free</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add te to the ready_list */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ready_list_insert</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name><index>[<expr><operator>++</operator><name><name>ready_list</name><operator>-&gt;</operator><name>last_te</name></name></expr>]</index></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
	<comment type="block">/* List is (probably) not sorted anymore. */</comment>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove the i'th entry in the ready_list */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ready_list_remove</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>f</name> <init>= <expr><name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <name>f</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name><name>ready_list</name><operator>-&gt;</operator><name>last_te</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the typical case where the item to be removed is the first ready
	 * entry, we need only increment first_te to remove it.  Otherwise, move
	 * the entries before it to compact the list.  (This preserves sortedness,
	 * if any.)  We could alternatively move the entries after i, but there
	 * are typically many more of those.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>f</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>  <modifier>*</modifier><modifier>*</modifier></type><name>first_te_ptr</name> <init>= <expr><operator>&amp;</operator><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name><index>[<expr><name>f</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>first_te_ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>first_te_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>-</operator> <name>f</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Sort the ready_list into the desired order */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ready_list_sort</name><parameter_list>(<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ready_list</name><operator>-&gt;</operator><name>sorted</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>ready_list</name><operator>-&gt;</operator><name>last_te</name></name> <operator>-</operator> <name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name></name> <operator>+</operator> <name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TocEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>TocEntrySizeCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ready_list</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* qsort comparator for sorting TocEntries by dataLength */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>TocEntrySizeCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TocEntry</name> <modifier>*</modifier></type><name>te1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>TocEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TocEntry</name> <modifier>*</modifier></type><name>te2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>TocEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Sort by decreasing dataLength */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>te1</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>&gt;</operator> <name><name>te2</name><operator>-&gt;</operator><name>dataLength</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>te1</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>&lt;</operator> <name><name>te2</name><operator>-&gt;</operator><name>dataLength</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* For equal dataLengths, sort by dumpId, just to be stable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>te1</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&lt;</operator> <name><name>te2</name><operator>-&gt;</operator><name>dumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>te1</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&gt;</operator> <name><name>te2</name><operator>-&gt;</operator><name>dumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Move all immediately-ready items from pending_list to ready_list.
 *
 * Items are considered ready if they have no remaining dependencies and
 * they belong in the current restore pass.  (See also reduce_dependencies,
 * which applies the same logic one-at-a-time.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>move_to_ready_list</name><parameter_list>(<parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>pending_list</name></decl></parameter>,
				   <parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>,
				   <parameter><decl><type><name>RestorePass</name></type> <name>pass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>next_te</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>pending_list</name><operator>-&gt;</operator><name>pending_next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name>pending_list</name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name>next_te</name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* must save list link before possibly removing te from list */</comment>
		<expr_stmt><expr><name>next_te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>depCount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pass</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remove it from pending_list ... */</comment>
			<expr_stmt><expr><call><name>pending_list_remove</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ... and add to ready_list */</comment>
			<expr_stmt><expr><call><name>ready_list_insert</name><argument_list>(<argument><expr><name>ready_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Find the next work item (if any) that is capable of being run now,
 * and remove it from the ready_list.
 *
 * Returns the item, or NULL if nothing is runnable.
 *
 * To qualify, the item must have no remaining dependencies
 * and no requirements for locks that are incompatible with
 * items currently running.  Items in the ready_list are known to have
 * no remaining dependencies, but we have to check for lock conflicts.
 */</comment>
<function><type><specifier>static</specifier> <name>TocEntry</name> <modifier>*</modifier></type>
<name>pop_next_work_item</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>,
				   <parameter><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Sort the ready_list so that we'll tackle larger jobs first.
	 */</comment>
	<expr_stmt><expr><call><name>ready_list_sort</name><argument_list>(<argument><expr><name>ready_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search the ready_list until we find a suitable item.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>ready_list</name><operator>-&gt;</operator><name>first_te</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>ready_list</name><operator>-&gt;</operator><name>last_te</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name> <init>= <expr><name><name>ready_list</name><operator>-&gt;</operator><name>tes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>conflicts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check to see if the item would need exclusive lock on something
		 * that a currently running item also needs lock on, or vice versa. If
		 * so, we don't want to schedule them together.
		 */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>numWorkers</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>running_te</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>te</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>running_te</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>has_lock_conflicts</name><argument_list>(<argument><expr><name>te</name></expr></argument>, <argument><expr><name>running_te</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>has_lock_conflicts</name><argument_list>(<argument><expr><name>running_te</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>conflicts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>conflicts</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* passed all tests, so this item can run */</comment>
		<expr_stmt><expr><call><name>ready_list_remove</name><argument_list>(<argument><expr><name>ready_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>te</name></expr>;</return>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"no item ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Restore a single TOC item in parallel with others
 *
 * this is run in the worker, i.e. in a thread (Windows) or a separate process
 * (everything else). A worker process executes several such work items during
 * a parallel backup or restore. Once we terminate here and report back that
 * our work is finished, the master process will assign us a new work item.
 */</comment>
<function><type><name>int</name></type>
<name>parallel_restore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count only errors associated with this TOC entry */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Restore the TOC item */</comment>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>restore_toc_entry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Callback function that's invoked in the master process after a step has
 * been parallel restored.
 *
 * Update status and reduce the dependency count of any dependent items.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_restore_job_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
					  <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name> <init>= <expr><operator>(</operator><name>ParallelReadyList</name> <operator>*</operator><operator>)</operator> <name>callback_data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"finished item %d %s %s"</literal></expr></argument>,
				<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>WORKER_CREATE_DONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mark_create_done</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>WORKER_INHIBIT_DATA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>inhibit_data_for_failed_table</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>WORKER_IGNORED_ERRORS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"worker process failed: exit code %d"</literal></expr></argument>,
			  <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>reduce_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>ready_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Process the dependency information into a form useful for parallel restore.
 *
 * This function takes care of fixing up some missing or badly designed
 * dependencies, and then prepares subsidiary data structures that will be
 * used in the main parallel-restore logic, including:
 * 1. We build the revDeps[] arrays of incoming dependency dumpIds.
 * 2. We set up depCount fields that are the number of as-yet-unprocessed
 * dependencies for each TOC entry.
 *
 * We also identify locking dependencies so that we can avoid trying to
 * schedule conflicting items at the same time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the depCount/revDeps/nRevDeps fields, and make sure the TOC
	 * items are marked as not being in any parallel-processing list.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>depCount</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>revDeps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nRevDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>pending_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * POST_DATA items that are shown as depending on a table need to be
	 * re-pointed to depend on that table's data, instead.  This ensures they
	 * won't get scheduled until the data has been loaded.
	 */</comment>
	<expr_stmt><expr><call><name>repoint_table_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pre-8.4 versions of pg_dump neglected to set up a dependency from BLOB
	 * COMMENTS to BLOBS.  Cope.  (We assume there's only one BLOBS and only
	 * one BLOB COMMENTS in such files.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_11</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOB COMMENTS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te2</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>te2</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te2</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te2</name> <operator>=</operator> <name><name>te2</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te2</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>te2</name><operator>-&gt;</operator><name>dumpId</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>depCount</name></name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point we start to build the revDeps reverse-dependency arrays,
	 * so all changes of dependencies must be complete.
	 */</comment>

	<comment type="block">/*
	 * Count the incoming dependencies for each item.  Also, it is possible
	 * that the dependencies list items that are not in the archive at all
	 * (that should not happen in 9.2 and later, but is highly likely in older
	 * archives).  Subtract such items from the depCounts.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DumpId</name></type>		<name>depid</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>depid</name> <operator>&lt;=</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name><operator>-&gt;</operator><name>nRevDeps</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>depCount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Allocate space for revDeps[] arrays, and reset nRevDeps so we can use
	 * it as a counter below.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nRevDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>revDeps</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>nRevDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nRevDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Build the revDeps[] arrays of incoming-dependency dumpIds.  This had
	 * better agree with the loops above.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DumpId</name></type>		<name>depid</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>depid</name> <operator>&lt;=</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>otherte</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>otherte</name><operator>-&gt;</operator><name>revDeps</name><index>[<expr><name><name>otherte</name><operator>-&gt;</operator><name>nRevDeps</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Lastly, work out the locking dependencies.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>lockDeps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nLockDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>identify_locking_dependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Change dependencies on table items to depend on table data items instead,
 * but only in POST_DATA items.
 *
 * Also, for any item having such dependency(s), set its dataLength to the
 * largest dataLength of the table data items it depends on.  This ensures
 * that parallel restore will prioritize larger jobs (index builds, FK
 * constraint checks, etc) over smaller ones, avoiding situations where we
 * end a restore with only one active job working on a large table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repoint_table_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>olddep</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>!=</operator> <name>SECTION_POST_DATA</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>olddep</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>olddep</name> <operator>&lt;=</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>&amp;&amp;</operator>
				<name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name>olddep</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DumpId</name></type>		<name>tabledataid</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name>olddep</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>tabledatate</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>tabledataid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tabledataid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name></expr></argument>, <argument><expr><name><name>tabledatate</name><operator>-&gt;</operator><name>dataLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"transferring dependency %d -&gt; %d to %d"</literal></expr></argument>,
							 <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>olddep</name></expr></argument>, <argument><expr><name>tabledataid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Identify which objects we'll need exclusive lock on in order to restore
 * the given TOC entry (*other* than the one identified by the TOC entry
 * itself).  Record their dump IDs in the entry's lockDeps[] array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>identify_locking_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpId</name>	   <modifier>*</modifier></type><name>lockids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlockids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only care about this for POST_DATA items.  PRE_DATA items are not
	 * run in parallel, and DATA items are all independent by assumption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>section</name></name> <operator>!=</operator> <name>SECTION_POST_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Quick exit if no dependencies at all */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most POST_DATA items are ALTER TABLEs or some moral equivalent of that,
	 * and hence require exclusive lock.  However, we know that CREATE INDEX
	 * does not.  (Maybe someday index-creating CONSTRAINTs will fall in that
	 * category too ... but today is not that day.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We assume the entry requires exclusive lock on each TABLE or TABLE DATA
	 * item listed among its dependencies.  Originally all of these would have
	 * been TABLE items, but repoint_table_dependencies would have repointed
	 * them to the TABLE DATA items if those are present (which they might not
	 * be, eg in a schema-only dump).  Note that all of the entries we are
	 * processing here are POST_DATA; otherwise there might be a significant
	 * difference between a dependency on a table and a dependency on its
	 * data, so that closer analysis would be needed here.
	 */</comment>
	<expr_stmt><expr><name>lockids</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nlockids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpId</name></type>		<name>depid</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>depid</name> <operator>&lt;=</operator> <name><name>AH</name><operator>-&gt;</operator><name>maxDumpId</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="string">"TABLE DATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			  <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			  <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			  <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name>depid</name></expr>]</index></name><operator>-&gt;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lockids</name><index>[<expr><name>nlockids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>depid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nlockids</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lockids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>lockDeps</name></name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>lockids</name></expr></argument>, <argument><expr><name>nlockids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nLockDeps</name></name> <operator>=</operator> <name>nlockids</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the specified TOC entry from the depCounts of items that depend on
 * it, thereby possibly making them ready-to-run.  Any pending item that
 * becomes ready should be moved to the ready_list, if that's provided.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce_dependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>,
					<parameter><decl><type><name>ParallelReadyList</name> <modifier>*</modifier></type><name>ready_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_debug</name><argument_list>(<argument><expr><literal type="string">"reducing dependencies for %d"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>te</name><operator>-&gt;</operator><name>nRevDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>otherte</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>revDeps</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>otherte</name><operator>-&gt;</operator><name>depCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>otherte</name><operator>-&gt;</operator><name>depCount</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's ready if it has no remaining dependencies, and it belongs in
		 * the current restore pass, and it is currently a member of the
		 * pending list (that check is needed to prevent double restore in
		 * some cases where a list-file forces out-of-order restoring).
		 * However, if ready_list == NULL then caller doesn't want any list
		 * memberships changed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>otherte</name><operator>-&gt;</operator><name>depCount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>_tocEntryRestorePass</name><argument_list>(<argument><expr><name>otherte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>AH</name><operator>-&gt;</operator><name>restorePass</name></name> <operator>&amp;&amp;</operator>
			<name><name>otherte</name><operator>-&gt;</operator><name>pending_prev</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>ready_list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remove it from pending list ... */</comment>
			<expr_stmt><expr><call><name>pending_list_remove</name><argument_list>(<argument><expr><name>otherte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ... and add to ready_list */</comment>
			<expr_stmt><expr><call><name>ready_list_insert</name><argument_list>(<argument><expr><name>ready_list</name></expr></argument>, <argument><expr><name>otherte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Set the created flag on the DATA member corresponding to the given
 * TABLE member
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_create_done</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>ted</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ted</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark the DATA member corresponding to the given TABLE member
 * as not wanted
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inhibit_data_for_failed_table</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" could not be created, will not restore its data"</literal></expr></argument>,
				<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>ted</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>tocsByDumpId</name><index>[<expr><name><name>AH</name><operator>-&gt;</operator><name>tableDataId</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ted</name><operator>-&gt;</operator><name>reqs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clone and de-clone routines used in parallel restoration.
 *
 * Enough of the structure is cloned to ensure that there is no
 * conflict between different threads each with their own clone.
 */</comment>
<function><type><name>ArchiveHandle</name> <modifier>*</modifier></type>
<name>CloneArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>clone</name></decl>;</decl_stmt>

	<comment type="block">/* Make a "flat" copy */</comment>
	<expr_stmt><expr><name>clone</name> <operator>=</operator> <operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle format-independent fields */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>clone</name><operator>-&gt;</operator><name>sqlparse</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>clone</name><operator>-&gt;</operator><name>sqlparse</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The clone will have its own connection, so disregard connection state */</comment>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>connCancel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>currUser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>currSchema</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>currTablespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* savedPassword must be local in case we change it while connecting */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>clone</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>savedPassword</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>clone</name><operator>-&gt;</operator><name>savedPassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* clone has its own error count, too */</comment>
	<expr_stmt><expr><name><name>clone</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>n_errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Connect our new clone object to the database, using the same connection
	 * parameters used for the original connection.
	 */</comment>
	<expr_stmt><expr><call><name>ConnectDatabase</name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>clone</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name><operator>-&gt;</operator><name>cparams</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* re-establish fixed state */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeRead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_doSetFixedOutputState</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* in write case, setupDumpWorker will fix up connection state */</comment>

	<comment type="block">/* Let the format-specific code have a chance too */</comment>
	<expr_stmt><expr><call><name><name>clone</name><operator>-&gt;</operator><name>ClonePtr</name></name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>clone</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>clone</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release clone-local storage.
 *
 * Note: we assume any clone-local connection was already closed.
 */</comment>
<function><type><name>void</name></type>
<name>DeCloneArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should not have an open database connection */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear format-specific state */</comment>
	<expr_stmt><expr><call><name><name>AH</name><operator>-&gt;</operator><name>DeClonePtr</name></name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear state allocated by CloneArchive */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear any connection-local state */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currUser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>currTableAm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
