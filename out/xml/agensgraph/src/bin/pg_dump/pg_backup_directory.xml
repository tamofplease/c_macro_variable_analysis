<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_dump/pg_backup_directory.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_backup_directory.c
 *
 *	A directory format dump is a directory, which contains a "toc.dat" file
 *	for the TOC, and a separate file for each data entry, named "&lt;oid&gt;.dat".
 *	Large objects (BLOBs) are stored in separate files named "blob_&lt;uid&gt;.dat",
 *	and there's a plain-text TOC file for them called "blobs.toc". If
 *	compression is used, each data file is individually compressed and the
 *	".gz" suffix is added to the filenames. The TOC files are never
 *	compressed by pg_dump, however they are accepted with the .gz suffix too,
 *	in case the user has manually compressed them with 'gzip'.
 *
 *	NOTE: This format is identical to the files written in the tar file in
 *	the 'tar' format, except that we don't write the restore.sql file (TODO),
 *	and the tar format doesn't support compression. Please keep the formats in
 *	sync.
 *
 *
 *	Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *	Portions Copyright (c) 1994, Regents of the University of California
 *	Portions Copyright (c) 2000, Philip Warner
 *
 *	Rights are granted to use this software in any way so long
 *	as this notice is not removed.
 *
 *	The author is not responsible for loss or damages that may
 *	result from its use.
 *
 * IDENTIFICATION
 *		src/bin/pg_dump/pg_backup_directory.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compress_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * Our archive location. This is basically what the user specified as his
	 * backup file but of course here it is a directory.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>directory</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>cfp</name>		   <modifier>*</modifier></type><name>dataFH</name></decl>;</decl_stmt>			<comment type="block">/* currently open data file */</comment>

	<decl_stmt><decl><type><name>cfp</name>		   <modifier>*</modifier></type><name>blobsTocFH</name></decl>;</decl_stmt>		<comment type="block">/* file handle for blobs.toc */</comment>
	<decl_stmt><decl><type><name>ParallelState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>		<comment type="block">/* for parallel backup / restore */</comment>
}</block></struct></type> <name>lclContext</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>		<comment type="block">/* filename excluding the directory (basename) */</comment>
}</block></struct></type> <name>lclTocEntry</name>;</typedef>

<comment type="block">/* prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ArchiveEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_WriteByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_ReadByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReadBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_CloseArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReopenArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrintTocData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReadExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrintExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_LoadBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrepParallelRestore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_Clone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_DeClone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_WorkerJobRestoreDirectory</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_WorkerJobDumpDirectory</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setFilePath</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relativeFilename</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	Init routine required by ALL formats. This is a global routine
 *	and should be declared in pg_backup_archiver.h
 *
 *	Its task is to create any extra archive context (using AH-&gt;formatData),
 *	and to initialize the supported function pointers.
 *
 *	It should also prepare whatever its input source is for reading/writing,
 *	and in the case of a read mode connection, it should load the Header &amp; TOC.
 */</comment>
<function><type><name>void</name></type>
<name>InitArchiveFmt_Directory</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

	<comment type="block">/* Assuming static functions, this can be copied for each format. */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ArchiveEntryPtr</name></name> <operator>=</operator> <name>_ArchiveEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartDataPtr</name></name> <operator>=</operator> <name>_StartData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteDataPtr</name></name> <operator>=</operator> <name>_WriteData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndDataPtr</name></name> <operator>=</operator> <name>_EndData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name> <operator>=</operator> <name>_WriteByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name> <operator>=</operator> <name>_ReadByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteBufPtr</name></name> <operator>=</operator> <name>_WriteBuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadBufPtr</name></name> <operator>=</operator> <name>_ReadBuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ClosePtr</name></name> <operator>=</operator> <name>_CloseArchive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReopenPtr</name></name> <operator>=</operator> <name>_ReopenArchive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name> <operator>=</operator> <name>_PrintTocData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadExtraTocPtr</name></name> <operator>=</operator> <name>_ReadExtraToc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteExtraTocPtr</name></name> <operator>=</operator> <name>_WriteExtraToc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrintExtraTocPtr</name></name> <operator>=</operator> <name>_PrintExtraToc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartBlobsPtr</name></name> <operator>=</operator> <name>_StartBlobs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartBlobPtr</name></name> <operator>=</operator> <name>_StartBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndBlobPtr</name></name> <operator>=</operator> <name>_EndBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndBlobsPtr</name></name> <operator>=</operator> <name>_EndBlobs</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrepParallelRestorePtr</name></name> <operator>=</operator> <name>_PrepParallelRestore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ClonePtr</name></name> <operator>=</operator> <name>_Clone</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>DeClonePtr</name></name> <operator>=</operator> <name>_DeClone</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobRestorePtr</name></name> <operator>=</operator> <name>_WorkerJobRestoreDirectory</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobDumpPtr</name></name> <operator>=</operator> <name>_WorkerJobDumpDirectory</name></expr>;</expr_stmt>

	<comment type="block">/* Set up our private context */</comment>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ctx</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize LO buffering */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_size</name></name> <operator>=</operator> <name>LOBBUFSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>LOBBUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now open the TOC file
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"no output directory specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we accept an empty existing directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>is_empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></while>

				<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not read directory \"%s\": %m"</literal></expr></argument>,
						  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close directory \"%s\": %m"</literal></expr></argument>,
						  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_empty</name> <operator>&amp;&amp;</operator> <call><name>mkdir</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>, <argument><expr><literal type="number">0700</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>,
				  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>							<comment type="block">/* Read Mode */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>cfp</name>		   <modifier>*</modifier></type><name>tocFH</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"toc.dat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tocFH</name> <operator>=</operator> <call><name>cfopen_read</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tocFH</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>tocFH</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The TOC of a directory format dump shares the format code of the
		 * tar format.
		 */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReadHead</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReadToc</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Nothing else in the file, so close it again... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name>tocFH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close TOC file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver when the dumper creates a new TOC entry.
 *
 * We determine the filename for this entry.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ArchiveEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tctx</name> <operator>=</operator> <operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclTocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"blobs.toc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%d.dat"</literal></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tctx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver to save any extra format-related TOC entry
 * data.
 *
 * Use the Archiver routines to write data - they are non-endian, and
 * maintain other important file information.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * A dumpable object has set tctx-&gt;filename, any other object has not.
	 * (see _ArchiveEntry).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver to read any extra format-related TOC data.
 *
 * Needs to match the order defined in _WriteExtraToc, and should also
 * use the Archiver input routines.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReadExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tctx</name> <operator>=</operator> <operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclTocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tctx</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>ReadStr</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver when restoring an archive to output a comment
 * that includes useful information about the TOC entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>verbose</name></name> <operator>&amp;&amp;</operator> <name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- File: %s\n"</literal></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when saving TABLE DATA (not schema). This routine
 * should save whatever format-specific information is needed to read
 * the archive back.
 *
 * It is called just prior to the dumper's 'DataDumper' routine being called.
 *
 * We create the data file for writing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <call><name>cfopen_write</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by archiver when dumper calls WriteData. This routine is
 * called for both BLOB and TABLE data; it is the responsibility of
 * the format to manage each kind of data using StartBlob/StartData.
 *
 * It should only be called from within a DataDumper routine.
 *
 * We write the data to the open data file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dLen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>cfwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>dLen</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>dLen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to output file: %s"</literal></expr></argument>,
			  <argument><expr><call><name>get_cfp_error</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when a dumper's 'DataDumper' routine has
 * finished.
 *
 * We close the data file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Close the file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close data file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print data for a given file (can be a BLOB as well)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintFileData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cfp</name>		   <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>cfopen_read</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cfp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ZLIB_OUT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>ZLIB_OUT_SIZE</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>cfread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ahwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close data file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print data for a given TOC entry
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintTocData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_LoadBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PrintFileData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_LoadBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tocfname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>line</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StartRestoreBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>tocfname</name></expr></argument>, <argument><expr><literal type="string">"blobs.toc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>=</operator> <call><name>cfopen_read</name><argument_list>(<argument><expr><name>tocfname</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open large object TOC file \"%s\" for input: %m"</literal></expr></argument>,
			  <argument><expr><name>tocfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read the blobs TOC file line-by-line, and process each blob */</comment>
	<while>while <condition>(<expr><operator>(</operator><call><name>cfgets</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>blobfname</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Can't overflow because line and blobfname are the same length */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%u %"</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call> <literal type="string">"s\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>blobfname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid line in large object TOC file \"%s\": \"%s\""</literal></expr></argument>,
				  <argument><expr><name>tocfname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRestoreBlob</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>, <argument><expr><name>blobfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PrintFileData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EndRestoreBlob</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfeof</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error reading large object TOC file \"%s\""</literal></expr></argument>,
			  <argument><expr><name>tocfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close large object TOC file \"%s\": %m"</literal></expr></argument>,
			  <argument><expr><name>tocfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EndRestoreBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write a byte of data to the archive.
 * Called by the archiver to do integer &amp; byte output to the archive.
 * These routines are only used to read &amp; write the headers &amp; TOC.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_WriteByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>i</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>cfwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to output file: %s"</literal></expr></argument>,
			  <argument><expr><call><name>get_cfp_error</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a byte of data from the archive.
 * Called by the archiver to read bytes &amp; integers from the archive.
 * These routines are only used to read &amp; write headers &amp; TOC.
 * EOF should be treated as a fatal error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_ReadByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>cfgetc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a buffer of data to the archive.
 * Called by the archiver to write a block of bytes to the TOC or a data file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>cfwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to output file: %s"</literal></expr></argument>,
			  <argument><expr><call><name>get_cfp_error</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a block of bytes from the archive.
 *
 * Called by the archiver to read a block of bytes from the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReadBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there was an I/O error, we already exited in cfread(), so here we
	 * exit on short reads.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cfread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not read from input file: end of file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close the archive.
 *
 * When writing the archive, this is the routine that actually starts
 * the process of saving it to files. No data should be written prior
 * to this point, since the user could sort the TOC after creating it.
 *
 * If an archive is to be written, this routine must call:
 *		WriteHead			to save the archive header
 *		WriteToc			to save the TOC entries
 *		WriteDataChunks		to save all DATA &amp; BLOBs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_CloseArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>cfp</name>		   <modifier>*</modifier></type><name>tocFH</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"toc.dat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this will actually fork the processes for a parallel backup */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <call><name>ParallelBackupStart</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The TOC is always created uncompressed */</comment>
		<expr_stmt><expr><name>tocFH</name> <operator>=</operator> <call><name>cfopen_write</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tocFH</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>tocFH</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Write 'tar' in the format field of the toc.dat file. The directory
		 * is compatible with 'tar', so there's no point having a different
		 * format code for it.
		 */</comment>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteHead</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteToc</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name>tocFH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close TOC file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WriteDataChunks</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ParallelBackupEnd</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In directory mode, there is no need to sync all the entries
		 * individually. Just recurse once through all the files generated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>dosync</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fsync_dir_recurse</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reopen the archive's file handle.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReopenArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Our TOC is in memory, our data files are opened by each child anyway as
	 * they are separate. We support reopening the archive by just doing
	 * nothing.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BLOB support
 */</comment>

<comment type="block">/*
 * Called by the archiver when starting to save all BLOB DATA (not schema).
 * It is called just prior to the dumper's DataDumper routine.
 *
 * We open the large object TOC file here, so that we can append a line to
 * it for each blob.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"blobs.toc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The blob TOC file is never compressed */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>=</operator> <call><name>cfopen_write</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"ab"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when we're about to start dumping a blob.
 *
 * We create a file to write the blob to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/blob_%u.dat"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <call><name>cfopen_write</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when the dumper is finished writing a blob.
 *
 * We close the blob file and write an entry to the blob TOC file for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Close the BLOB data file itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close blob data file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* register the blob in blobs.toc */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u blob_%u.dat\n"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>cfwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to blobs TOC file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when finishing saving all BLOB DATA.
 *
 * We close the blobs TOC file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cfclose</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close blobs TOC file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>blobsTocFH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Gets a relative file name and prepends the output directory, writing the
 * result to buf. The caller needs to make sure that buf is MAXPGPATH bytes
 * big. Can't use a static char[MAXPGPATH] inside the function because we run
 * multithreaded on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setFilePath</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relativeFilename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dname</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>directory</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>relativeFilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"file name too long: \"%s\""</literal></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>relativeFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare for parallel restore.
 *
 * The main thing that needs to happen here is to fill in TABLE DATA and BLOBS
 * TOC entries' dataLength fields with appropriate values to guide the
 * ordering of restore jobs.  The source of said data is format-dependent,
 * as is the exact meaning of the values.
 *
 * A format module might also choose to do other setup here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrepParallelRestore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * A dumpable object has set tctx-&gt;filename, any other object has not.
		 * (see _ArchiveEntry).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We may ignore items not due to be restored */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>&amp;</operator> <name>REQ_DATA</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Stat the file and, if successful, put its size in dataLength.  When
		 * using compression, the physical file size might not be a very good
		 * guide to the amount of work involved in restoring the file, but we
		 * only need an approximate indicator of that.
		 */</comment>
		<expr_stmt><expr><call><name>setFilePath</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* It might be compressed */</comment>
			<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">".gz"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If this is the BLOBS entry, what we stat'd was blobs.toc, which
		 * most likely is a lot smaller than the actual blob data.  We don't
		 * have a cheap way to estimate how much smaller, but fortunately it
		 * doesn't matter too much as long as we get the blobs processed
		 * reasonably early.  Arbitrarily scale up by a factor of 1K.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>*=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Clone format-specific fields during parallel restoration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_Clone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we do not make a local lo_buf because we expect at most one BLOBS
	 * entry per archive, so no parallelism is possible.  Likewise,
	 * TOC-entry-local state isn't an issue because any one TOC entry is
	 * touched by just one worker child.
	 */</comment>

	<comment type="block">/*
	 * We also don't copy the ParallelState pointer (pstate), only the master
	 * process ever writes to it.
	 */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_DeClone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function is executed in the child of a parallel backup for a
 * directory-format archive and dumps the actual data for one TOC entry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_WorkerJobDumpDirectory</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This function returns void. We either fail and die horribly or
	 * succeed... A failure will be detected by the parent when the child dies
	 * unexpectedly.
	 */</comment>
	<expr_stmt><expr><call><name>WriteDataChunksForTocEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function is executed in the child of a parallel restore from a
 * directory-format archive and restores the actual data for one TOC entry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_WorkerJobRestoreDirectory</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>parallel_restore</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
