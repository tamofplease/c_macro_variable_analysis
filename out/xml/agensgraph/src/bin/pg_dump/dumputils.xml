<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_dump/dumputils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * Utility routines for SQL dumping
 *
 * Basically this is stuff that is useful in both pg_dump and pg_dumpall.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/pg_dump/dumputils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>parseAclItem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
						 <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantor</name></decl></parameter>,
						 <parameter><decl><type><name>PQExpBuffer</name></type> <name>privs</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>privswgo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>copyAclUserName</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddAcl</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>aclbuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Build GRANT/REVOKE command(s) for an object.
 *
 *	name: the object name, in the form to use in the commands (already quoted)
 *	subname: the sub-object name, if any (already quoted); NULL if none
 *	nspname: the namespace the object is in (NULL if none); not pre-quoted
 *	type: the object type (as seen in GRANT command: must be one of
 *		TABLE, SEQUENCE, FUNCTION, PROCEDURE, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
 *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT)
 *	acls: the ACL string fetched from the database
 *	racls: the ACL string of any initial-but-now-revoked privileges
 *	owner: username of object owner (will be passed through fmtId); can be
 *		NULL or empty string to indicate "no owner known"
 *	prefix: string to prefix to each generated command; typically empty
 *	remoteVersion: version of database
 *
 * Returns true if okay, false if could not parse the acl string.
 * The resulting commands (if any) are appended to the contents of 'sql'.
 *
 * Note: when processing a default ACL, prefix is "ALTER DEFAULT PRIVILEGES "
 * or something similar, and name is an empty string.
 *
 * Note: beware of passing a fmtId() result directly as 'name' or 'subname',
 * since this routine uses fmtId() internally.
 */</comment>
<function><type><name>bool</name></type>
<name>buildACLCommands</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>racls</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
				 <parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>aclitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>raclitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>naclitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nraclitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl>,
				<decl><type ref="prev"/><name>grantor</name></decl>,
				<decl><type ref="prev"/><name>privs</name></decl>,
				<decl><type ref="prev"/><name>privswgo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>firstsql</name></decl>,
				<decl><type ref="prev"/><name>secondsql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_owner_privs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>acls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>racls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* object has default permissions */</comment>

	<comment type="block">/* treat empty-string owner same as NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>owner</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>acls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>acls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aclitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>naclitems</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>racls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>racls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raclitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nraclitems</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>raclitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>grantee</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>grantor</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>privs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>privswgo</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At the end, these two will be pasted together to form the result.
	 *
	 * For older systems we use these to ensure that the owner privileges go
	 * before the other ones, as a GRANT could create the default entry for
	 * the object, which generally includes all rights for the owner. In more
	 * recent versions we normally handle this because the owner rights come
	 * first in the ACLs, but older versions might have them after the PUBLIC
	 * privileges.
	 *
	 * For 9.6 and later systems, much of this changes.  With 9.6, we check
	 * the default privileges for the objects at dump time and create two sets
	 * of ACLs- "racls" which are the ACLs to REVOKE from the object (as the
	 * object may have initial privileges on it, along with any default ACLs
	 * which are not part of the current set of privileges), and regular
	 * "acls", which are the ACLs to GRANT to the object.  We handle the
	 * REVOKEs first, followed by the GRANTs.
	 */</comment>
	<expr_stmt><expr><name>firstsql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>secondsql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For pre-9.6 systems, we always start with REVOKE ALL FROM PUBLIC, as we
	 * don't wish to make any assumptions about what the default ACLs are, and
	 * we do not collect them during the dump phase (and racls will always be
	 * the empty set, see above).
	 *
	 * For 9.6 and later, if any revoke ACLs have been provided, then include
	 * them in 'firstsql'.
	 *
	 * Revoke ACLs happen when an object starts out life with a set of
	 * privileges (eg: GRANT SELECT ON pg_class TO PUBLIC;) and the user has
	 * decided to revoke those rights.  Since those objects come into being
	 * with those default privileges, we have to revoke them to match what the
	 * current state of affairs is.  Note that we only started explicitly
	 * tracking such initial rights in 9.6, and prior to that all initial
	 * rights are actually handled by the simple 'REVOKE ALL .. FROM PUBLIC'
	 * case, for initdb-created objects.  Prior to 9.6, we didn't handle
	 * extensions correctly, but we do now by tracking their initial
	 * privileges, in the same way we track initdb initial privileges, see
	 * pg_init_privs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nraclitems</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE ALL"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM PUBLIC;\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Scan individual REVOKE ACL items */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nraclitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseAclItem</name><argument_list>(<argument><expr><name><name>raclitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>,
							  <argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE %s ON %s "</literal></expr></argument>,
								  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
								 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We still need some hacking though to cover the case where new default
	 * public privileges are added in new versions: the REVOKE ALL will revoke
	 * them, leading to behavior different from what the old version had,
	 * which is generally not what's wanted.  So add back default privs if the
	 * source database is too old to have had that particular priv.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&lt;</operator> <literal type="number">80200</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* database CONNECT priv didn't exist before 8.2 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sGRANT CONNECT ON %s %s TO PUBLIC;\n"</literal></expr></argument>,
						  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Scan individual ACL items */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>naclitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseAclItem</name><argument_list>(<argument><expr><name><name>aclitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>,
						  <argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Prior to 9.6, we had to handle owner privileges in a special
			 * manner by first REVOKE'ing the rights and then GRANT'ing them
			 * after.  With 9.6 and above, what we need to REVOKE and what we
			 * need to GRANT is figured out when we dump and stashed into
			 * "racls" and "acls", respectively.  See above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&lt;</operator> <literal type="number">90600</literal> <operator>&amp;&amp;</operator> <name>owner</name>
				<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
				<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found_owner_privs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * For the owner, the default privilege level is ALL WITH
				 * GRANT OPTION.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>privswgo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE ALL"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM %s;\n"</literal></expr></argument>,
									  <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>,
										  <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
										  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>,
										  <argument><expr><literal type="string">"%s TO %s;\n"</literal></expr></argument>,
										  <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>,
										  <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
										  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privswgo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>,
										  <argument><expr><literal type="string">"%s TO %s WITH GRANT OPTION;\n"</literal></expr></argument>,
										  <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * For systems prior to 9.6, we can assume we are starting
				 * from no privs at this point.
				 *
				 * For 9.6 and above, at this point we have issued REVOKE
				 * statements for all initial and default privileges which are
				 * no longer present on the object (as they were passed in as
				 * 'racls') and we can simply GRANT the rights which are in
				 * 'acls'.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
					<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>owner</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"SET SESSION AUTHORIZATION %s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%s TO "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s;\n"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privswgo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"%s TO "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">" WITH GRANT OPTION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
					<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>owner</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>, <argument><expr><literal type="string">"RESET SESSION AUTHORIZATION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * For systems prior to 9.6, if we didn't find any owner privs, the owner
	 * must have revoked 'em all.
	 *
	 * For 9.6 and above, we handle this through the 'racls'.  See above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&lt;</operator> <literal type="number">90600</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_owner_privs</name> <operator>&amp;&amp;</operator> <name>owner</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE ALL"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM %s;\n"</literal></expr></argument>,
						  <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>firstsql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>secondsql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>raclitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build ALTER DEFAULT PRIVILEGES command(s) for single pg_default_acl entry.
 *
 *	type: the object type (TABLES, FUNCTIONS, etc)
 *	nspname: schema name, or NULL for global default privileges
 *	acls: the ACL string fetched from the database
 *	owner: username of privileges owner (will be passed through fmtId)
 *	remoteVersion: version of database
 *
 * Returns true if okay, false if could not parse the acl string.
 * The resulting commands (if any) are appended to the contents of 'sql'.
 */</comment>
<function><type><name>bool</name></type>
<name>buildDefaultACLCommands</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>racls</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initacls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initracls</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
						<parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>prefix</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We incorporate the target role directly into the command, rather than
	 * playing around with SET ROLE or anything like that.  This is so that a
	 * permissions error leads to nothing happening, rather than changing
	 * default privileges for the wrong user.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"ALTER DEFAULT PRIVILEGES FOR ROLE %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"IN SCHEMA %s "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>initacls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>initracls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
							  <argument><expr><name>initacls</name></expr></argument>, <argument><expr><name>initracls</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
							  <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
						  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>racls</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
						  <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This will parse an aclitem string, having the general form
 *		username=privilegecodes/grantor
 * or
 *		group groupname=privilegecodes/grantor
 * (the "group" case occurs only with servers before 8.1).
 *
 * Returns true on success, false on parse error.  On success, the components
 * of the string are returned in the PQExpBuffer parameters.
 *
 * The returned grantee string will be the dequoted username or groupname
 * (preceded with "group " in the latter case).  Note that a grant to PUBLIC
 * is represented by an empty grantee string.  The returned grantor is the
 * dequoted grantor name.  Privilege characters are translated to GRANT/REVOKE
 * comma-separated privileges lists.  If "privswgo" is non-NULL, the result is
 * separate lists for privileges with grant option ("privswgo") and without
 * ("privs").  Otherwise, "privs" bears every relevant privilege, ignoring the
 * grant option distinction.
 *
 * Note: for cross-version compatibility, it's important to use ALL to
 * represent the privilege sets whenever appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parseAclItem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
			 <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantor</name></decl></parameter>,
			 <parameter><decl><type><name>PQExpBuffer</name></type> <name>privs</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>privswgo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_with_go</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_without_go</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eqpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* user or group name is string up to = */</comment>
	<expr_stmt><expr><name>eqpos</name> <operator>=</operator> <call><name>copyAclUserName</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eqpos</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* grantor should appear after / */</comment>
	<expr_stmt><expr><name>slpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>eqpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slpos</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>slpos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>slpos</name> <operator>=</operator> <call><name>copyAclUserName</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>slpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slpos</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* privilege codes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_PRIV</name><parameter_list>(<parameter><type><name>code</name></type></parameter>, <parameter><type><name>keywd</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if ((pos = strchr(eqpos + 1, code))) \
	{ \
		if (*(pos + 1) == '*' &amp;&amp; privswgo != NULL) \
		{ \
			AddAcl(privswgo, keywd, subname); \
			all_without_go = false; \
		} \
		else \
		{ \
			AddAcl(privs, keywd, subname); \
			all_with_go = false; \
		} \
	} \
	else \
		all_with_go = all_without_go = false; \
} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"ELABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"VLABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* sequence only */</comment>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* table only */</comment>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>, <argument><expr><literal type="string">"REFERENCES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* rest are not applicable to columns */</comment>
			<if_stmt><if>if <condition>(<expr><name>subname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* UPDATE */</comment>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FUNCTIONS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SCHEMAS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"GRAPH"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="string">"CONNECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><literal type="string">"TEMPORARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLESPACE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TYPES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN SERVER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONVERT_PRIV</name></cpp:undef>

	<if_stmt><if>if <condition>(<expr><name>all_with_go</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>all_without_go</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer a user or group name starting at *input into the output buffer,
 * dequoting if needed.  Returns a pointer to just past the input name.
 * The name is taken to end at an unquoted '=' or end of string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>copyAclUserName</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If user name isn't quoted, then just add it to the output buffer
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise, it's a quoted username */</comment>
			<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Loop until we come across an unescaped quote */</comment>
			<while>while <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>input</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* really a syntax error... */</comment>

				<comment type="block">/*
				 * Quoting convention is to escape " as "".  Keep this code in
				 * sync with putid() in backend's acl.c.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>input</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append a privilege keyword to a keyword list, inserting comma if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddAcl</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>aclbuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aclbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * buildShSecLabelQuery
 *
 * Build a query to retrieve security labels for a shared object.
 * The object is identified by its OID plus the name of the catalog
 * it can be found in (e.g., "pg_database" for database names).
 * The query is appended to "sql".  (We don't execute it here so as to
 * keep this file free of assumptions about how to deal with SQL errors.)
 */</comment>
<function><type><name>void</name></type>
<name>buildShSecLabelQuery</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>catalog_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
					 <parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT provider, label FROM pg_catalog.pg_shseclabel "</literal>
					  <literal type="string">"WHERE classoid = 'pg_catalog.%s'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND objoid = '%u'"</literal></expr></argument>, <argument><expr><name>catalog_name</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * emitShSecLabels
 *
 * Construct SECURITY LABEL commands using the data retrieved by the query
 * generated by buildShSecLabelQuery, and append them to "buffer".
 * Here, the target object is identified by its type name (e.g. "DATABASE")
 * and its name (not pre-quoted).
 */</comment>
<function><type><name>void</name></type>
<name>emitShSecLabels</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>provider</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must use fmtId result before calling it again */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						  <argument><expr><literal type="string">" %s IS "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * buildACLQueries
 *
 * Build the subqueries to extract out the correct set of ACLs to be
 * GRANT'd and REVOKE'd for the specific kind of object, accounting for any
 * initial privileges (from pg_init_privs) and based on if we are in binary
 * upgrade mode or not.
 *
 * Also builds subqueries to extract out the set of ACLs to go from the object
 * default privileges to the privileges in pg_init_privs, if we are in binary
 * upgrade mode, so that those privileges can be set up and recorded in the new
 * cluster before the regular privileges are added on top of those.
 */</comment>
<function><type><name>void</name></type>
<name>buildACLQueries</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name></decl></parameter>,
				<parameter><decl><type><name>PQExpBuffer</name></type> <name>init_acl_subquery</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>init_racl_subquery</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acl_column</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acl_owner</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obj_kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binary_upgrade</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * To get the delta from what the permissions were at creation time
	 * (either initdb or CREATE EXTENSION) vs. what they are now, we have to
	 * look at two things:
	 *
	 * What privileges have been added, which we calculate by extracting all
	 * the current privileges (using the set of default privileges for the
	 * object type if current privileges are NULL) and then removing those
	 * which existed at creation time (again, using the set of default
	 * privileges for the object type if there were no creation time
	 * privileges).
	 *
	 * What privileges have been removed, which we calculate by extracting the
	 * privileges as they were at creation time (or the default privileges, as
	 * above), and then removing the current privileges (or the default
	 * privileges, if current privileges are NULL).
	 *
	 * As a good cross-check, both directions of these checks should result in
	 * the empty set if both the current ACL and the initial privs are NULL
	 * (meaning, in practice, that the default ACLs were there at init time
	 * and is what the current privileges are).
	 *
	 * We always perform this delta on all ACLs and expect that by the time
	 * these are run the initial privileges will be in place, even in a binary
	 * upgrade situation (see below).
	 *
	 * Finally, the order in which privileges are in the ACL string (the order
	 * they been GRANT'd in, which the backend maintains) must be preserved to
	 * ensure that GRANTs WITH GRANT OPTION and subsequent GRANTs based on
	 * those are dumped in the correct order.
	 */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>,
					  <argument><expr><literal type="string">"(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "</literal>
					  <literal type="string">"(SELECT acl, row_n FROM "</literal>
					  <literal type="string">"pg_catalog.unnest(coalesce(%s,pg_catalog.acldefault(%s,%s))) "</literal>
					  <literal type="string">"WITH ORDINALITY AS perm(acl,row_n) "</literal>
					  <literal type="string">"WHERE NOT EXISTS ( "</literal>
					  <literal type="string">"SELECT 1 FROM "</literal>
					  <literal type="string">"pg_catalog.unnest(coalesce(pip.initprivs,pg_catalog.acldefault(%s,%s))) "</literal>
					  <literal type="string">"AS init(init_acl) WHERE acl = init_acl)) as foo)"</literal></expr></argument>,
					  <argument><expr><name>acl_column</name></expr></argument>,
					  <argument><expr><name>obj_kind</name></expr></argument>,
					  <argument><expr><name>acl_owner</name></expr></argument>,
					  <argument><expr><name>obj_kind</name></expr></argument>,
					  <argument><expr><name>acl_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>,
					  <argument><expr><literal type="string">"(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "</literal>
					  <literal type="string">"(SELECT acl, row_n FROM "</literal>
					  <literal type="string">"pg_catalog.unnest(coalesce(pip.initprivs,pg_catalog.acldefault(%s,%s))) "</literal>
					  <literal type="string">"WITH ORDINALITY AS initp(acl,row_n) "</literal>
					  <literal type="string">"WHERE NOT EXISTS ( "</literal>
					  <literal type="string">"SELECT 1 FROM "</literal>
					  <literal type="string">"pg_catalog.unnest(coalesce(%s,pg_catalog.acldefault(%s,%s))) "</literal>
					  <literal type="string">"AS permp(orig_acl) WHERE acl = orig_acl)) as foo)"</literal></expr></argument>,
					  <argument><expr><name>obj_kind</name></expr></argument>,
					  <argument><expr><name>acl_owner</name></expr></argument>,
					  <argument><expr><name>acl_column</name></expr></argument>,
					  <argument><expr><name>obj_kind</name></expr></argument>,
					  <argument><expr><name>acl_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In binary upgrade mode we don't run the extension script but instead
	 * dump out the objects independently and then recreate them.  To preserve
	 * the initial privileges which were set on extension objects, we need to
	 * grab the set of GRANT and REVOKE commands necessary to get from the
	 * default privileges of an object to the initial privileges as recorded
	 * in pg_init_privs.
	 *
	 * These will then be run ahead of the regular ACL commands, which were
	 * calculated using the queries above, inside of a block which sets a flag
	 * to indicate that the backend should record the results of these GRANT
	 * and REVOKE statements into pg_init_privs.  This is how we preserve the
	 * contents of that catalog across binary upgrades.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>binary_upgrade</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>init_acl_subquery</name></expr></argument>,
						  <argument><expr><literal type="string">"CASE WHEN privtype = 'e' THEN "</literal>
						  <literal type="string">"(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "</literal>
						  <literal type="string">"(SELECT acl, row_n FROM pg_catalog.unnest(pip.initprivs) "</literal>
						  <literal type="string">"WITH ORDINALITY AS initp(acl,row_n) "</literal>
						  <literal type="string">"WHERE NOT EXISTS ( "</literal>
						  <literal type="string">"SELECT 1 FROM "</literal>
						  <literal type="string">"pg_catalog.unnest(pg_catalog.acldefault(%s,%s)) "</literal>
						  <literal type="string">"AS privm(orig_acl) WHERE acl = orig_acl)) as foo) END"</literal></expr></argument>,
						  <argument><expr><name>obj_kind</name></expr></argument>,
						  <argument><expr><name>acl_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>init_racl_subquery</name></expr></argument>,
						  <argument><expr><literal type="string">"CASE WHEN privtype = 'e' THEN "</literal>
						  <literal type="string">"(SELECT pg_catalog.array_agg(acl) FROM "</literal>
						  <literal type="string">"(SELECT acl, row_n FROM "</literal>
						  <literal type="string">"pg_catalog.unnest(pg_catalog.acldefault(%s,%s)) "</literal>
						  <literal type="string">"WITH ORDINALITY AS privp(acl,row_n) "</literal>
						  <literal type="string">"WHERE NOT EXISTS ( "</literal>
						  <literal type="string">"SELECT 1 FROM pg_catalog.unnest(pip.initprivs) "</literal>
						  <literal type="string">"AS initp(init_acl) WHERE acl = init_acl)) as foo) END"</literal></expr></argument>,
						  <argument><expr><name>obj_kind</name></expr></argument>,
						  <argument><expr><name>acl_owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>init_acl_subquery</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>init_racl_subquery</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether the given GUC variable is of GUC_LIST_QUOTE type.
 *
 * It'd be better if we could inquire this directly from the backend; but even
 * if there were a function for that, it could only tell us about variables
 * currently known to guc.c, so that it'd be unsafe for extensions to declare
 * GUC_LIST_QUOTE variables anyway.  Lacking a solution for that, it doesn't
 * seem worth the work to do more than have this list, which must be kept in
 * sync with the variables actually marked GUC_LIST_QUOTE in guc.c.
 */</comment>
<function><type><name>bool</name></type>
<name>variable_is_guc_list_quote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"temp_tablespaces"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"session_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"shared_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"local_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"search_path"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SplitGUCList --- parse a string containing identifiers or file names
 *
 * This is used to split the value of a GUC_LIST_QUOTE GUC variable, without
 * presuming whether the elements will be taken as identifiers or file names.
 * See comparable code in src/backend/utils/adt/varlena.c.
 *
 * Inputs:
 *	rawstring: the input string; must be overwritable!	On return, it's
 *			   been modified to contain the separated identifiers.
 *	separator: the separator punctuation expected between identifiers
 *			   (typically '.' or ',').  Whitespace may also appear around
 *			   identifiers.
 * Outputs:
 *	namelist: receives a malloc'd, null-terminated array of pointers to
 *			  identifiers within rawstring.  Caller should free this
 *			  even on error return.
 *
 * Returns true if okay, false if there is a syntax error in the string.
 */</comment>
<function><type><name>bool</name></type>
<name>SplitGUCList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawstring</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>,
			 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextp</name> <init>= <expr><name>rawstring</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nextptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we disallow empty identifiers, this is a conservative
	 * overestimate of the number of pointers we could need.  Allow one for
	 * list terminator.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <name>nextptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nextptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>				<comment type="block">/* skip leading whitespace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* allow empty string */</comment>

	<comment type="block">/* At the top of the loop, we are at start of a new identifier. */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Quoted name --- collapse quote-quote pairs */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* mismatched quotes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>endp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found end of quoted name */</comment>
				<comment type="block">/* Collapse adjacent quotes into one quote, and look again */</comment>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* endp now points at the terminating quote */</comment>
			<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unquoted name --- extends to separator or whitespace */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>nextp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nextp</name> <operator>!=</operator> <name>separator</name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>nextp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* empty unquoted name not allowed */</comment>
		</block_content>}</block></else></if_stmt>

		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip trailing whitespace */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <name>separator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip leading whitespace for next */</comment>
			<comment type="block">/* we expect another name, so done remains false */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid syntax */</comment>

		<comment type="block">/* Now safe to overwrite separator with a null */</comment>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Finished isolating current name --- add it to output array
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>nextptr</name><operator>++</operator> <operator>=</operator> <name>curname</name></expr>;</expr_stmt>

		<comment type="block">/* Loop back if we didn't reach end of string */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<expr_stmt><expr><operator>*</operator><name>nextptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for dumping "ALTER DATABASE/ROLE SET ..." commands.
 *
 * Parse the contents of configitem (a "name=value" string), wrap it in
 * a complete ALTER command, and append it to buf.
 *
 * type is DATABASE or ROLE, and name is the name of the database or role.
 * If we need an "IN" clause, type2 and name2 similarly define what to put
 * there; otherwise they should be NULL.
 * conn is used only to determine string-literal quoting conventions.
 */</comment>
<function><type><name>void</name></type>
<name>makeAlterConfigCommand</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>configitem</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>,
					   <parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* Parse the configitem.  If we can't find an "=", silently do nothing. */</comment>
	<expr_stmt><expr><name>mine</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Build the command, with suitable quoting for everything. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER %s %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>name2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"IN %s %s "</literal></expr></argument>, <argument><expr><name>type2</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SET %s TO "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Variables that are marked GUC_LIST_QUOTE were already fully quoted by
	 * flatten_set_variable_args() before they were put into the setconfig
	 * array.  However, because the quoting rules used there aren't exactly
	 * like SQL's, we have to break the list value apart and then quote the
	 * elements as string literals.  (The elements may be double-quoted as-is,
	 * but we can't just feed them to the SQL parser; it would do the wrong
	 * thing with elements that are zero-length or longer than NAMEDATALEN.)
	 *
	 * Variables that are not so marked should just be emitted as simple
	 * string literals.  If the variable is not known to
	 * variable_is_guc_list_quote(), we'll do that; this makes it unsafe to
	 * use GUC_LIST_QUOTE for extension variables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>variable_is_guc_list_quote</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nameptr</name></decl>;</decl_stmt>

		<comment type="block">/* Parse string into list of identifiers */</comment>
		<comment type="block">/* this shouldn't fail really */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>nameptr</name> <operator>=</operator> <name>namelist</name></expr>;</init> <condition><expr><operator>*</operator><name>nameptr</name></expr>;</condition> <incr><expr><name>nameptr</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>nameptr</name> <operator>!=</operator> <name>namelist</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
