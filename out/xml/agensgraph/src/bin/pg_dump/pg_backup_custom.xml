<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_dump/pg_backup_custom.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_backup_custom.c
 *
 *	Implements the custom output format.
 *
 *	The comments with the routines in this code are a good place to
 *	understand how to write a new format.
 *
 *	See the headers to pg_restore for more details.
 *
 * Copyright (c) 2000, Philip Warner
 *		Rights are granted to use this software in any way so long
 *		as this notice is not removed.
 *
 *	The author is not responsible for loss or damages that may
 *	and any liability will be limited to the time taken to fix any
 *	related bug.
 *
 *
 * IDENTIFICATION
 *		src/bin/pg_dump/pg_backup_custom.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compress_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>

<comment type="block">/*--------
 * Routines in the format interface
 *--------
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ArchiveEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_WriteByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_ReadByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReadBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_CloseArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReopenArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrintTocData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_WriteExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_ReadExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrintExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrintData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_skipData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_skipBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_StartBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_EndBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_LoadBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_PrepParallelRestore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_Clone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_DeClone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_WorkerJobRestoreCustom</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>CompressorState</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hasSeek</name></decl>;</decl_stmt>
	<comment type="block">/* lastFilePos is used only when reading, and may be invalid if !hasSeek */</comment>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>lastFilePos</name></decl>;</decl_stmt>	<comment type="block">/* position after last data block we've read */</comment>
}</block></struct></type> <name>lclContext</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>dataState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>dataPos</name></decl>;</decl_stmt>		<comment type="block">/* valid only if dataState=K_OFFSET_POS_SET */</comment>
}</block></struct></type> <name>lclTocEntry</name>;</typedef>


<comment type="block">/*------
 * Static declarations
 *------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_readBlockHeader</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pgoff_t</name></type> <name>_getFilePos</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_CustomWriteFunc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>_CustomReadFunc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buflen</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	Init routine required by ALL formats. This is a global routine
 *	and should be declared in pg_backup_archiver.h
 *
 *	It's task is to create any extra archive context (using AH-&gt;formatData),
 *	and to initialize the supported function pointers.
 *
 *	It should also prepare whatever it's input source is for reading/writing,
 *	and in the case of a read mode connection, it should load the Header &amp; TOC.
 */</comment>
<function><type><name>void</name></type>
<name>InitArchiveFmt_Custom</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

	<comment type="block">/* Assuming static functions, this can be copied for each format. */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ArchiveEntryPtr</name></name> <operator>=</operator> <name>_ArchiveEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartDataPtr</name></name> <operator>=</operator> <name>_StartData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteDataPtr</name></name> <operator>=</operator> <name>_WriteData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndDataPtr</name></name> <operator>=</operator> <name>_EndData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteBytePtr</name></name> <operator>=</operator> <name>_WriteByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadBytePtr</name></name> <operator>=</operator> <name>_ReadByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteBufPtr</name></name> <operator>=</operator> <name>_WriteBuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadBufPtr</name></name> <operator>=</operator> <name>_ReadBuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ClosePtr</name></name> <operator>=</operator> <name>_CloseArchive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReopenPtr</name></name> <operator>=</operator> <name>_ReopenArchive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrintTocDataPtr</name></name> <operator>=</operator> <name>_PrintTocData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ReadExtraTocPtr</name></name> <operator>=</operator> <name>_ReadExtraToc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WriteExtraTocPtr</name></name> <operator>=</operator> <name>_WriteExtraToc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrintExtraTocPtr</name></name> <operator>=</operator> <name>_PrintExtraToc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartBlobsPtr</name></name> <operator>=</operator> <name>_StartBlobs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>StartBlobPtr</name></name> <operator>=</operator> <name>_StartBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndBlobPtr</name></name> <operator>=</operator> <name>_EndBlob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>EndBlobsPtr</name></name> <operator>=</operator> <name>_EndBlobs</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>PrepParallelRestorePtr</name></name> <operator>=</operator> <name>_PrepParallelRestore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>ClonePtr</name></name> <operator>=</operator> <name>_Clone</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>DeClonePtr</name></name> <operator>=</operator> <name>_DeClone</name></expr>;</expr_stmt>

	<comment type="block">/* no parallel dump in the custom archive, only parallel restore */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobDumpPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>WorkerJobRestorePtr</name></name> <operator>=</operator> <name>_WorkerJobRestoreCustom</name></expr>;</expr_stmt>

	<comment type="block">/* Set up a private area. */</comment>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ctx</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize LO buffering */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf_size</name></name> <operator>=</operator> <name>LOBBUFSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>lo_buf</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>LOBBUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now open the file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open output file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name> <operator>=</operator> <call><name>checkSeek</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name> <operator>=</operator> <call><name>checkSeek</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReadHead</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReadToc</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remember location of first data block (i.e., the point after TOC)
		 * in case we have to search for desired data blocks.
		 */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>lastFilePos</name></name> <operator>=</operator> <call><name>_getFilePos</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver when the dumper creates a new TOC entry.
 *
 * Optional.
 *
 * Set up extract format-related TOC data.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ArchiveEntry</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclTocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>dataDumper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <name>K_OFFSET_POS_NOT_SET</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <name>K_OFFSET_NO_DATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ctx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver to save any extra format-related TOC entry
 * data.
 *
 * Optional.
 *
 * Use the Archiver routines to write data - they are non-endian, and
 * maintain other important file information.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WriteOffset</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver to read any extra format-related TOC data.
 *
 * Optional.
 *
 * Needs to match the order defined in _WriteExtraToc, and should also
 * use the Archiver input routines.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReadExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclTocEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ctx</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <call><name>ReadOffset</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>dataPos</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prior to V1.7 (pg7.3), we dumped the data size as an int now we don't
	 * dump it at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_7</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the Archiver when restoring an archive to output a comment
 * that includes useful information about the TOC entry.
 *
 * Optional.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintExtraToc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"-- Data Pos: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when saving TABLE DATA (not schema). This routine
 * should save whatever format-specific information is needed to read
 * the archive back.
 *
 * It is called just prior to the dumper's 'DataDumper' routine being called.
 *
 * Optional, but strongly recommended.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>=</operator> <call><name>_getFilePos</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <name>K_OFFSET_POS_SET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_WriteByte</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>BLK_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Block type */</comment>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* For sanity check */</comment>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name> <operator>=</operator> <call><name>AllocateCompressor</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>, <argument><expr><name>_CustomWriteFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by archiver when dumper calls WriteData. This routine is
 * called for both BLOB and TABLE data; it is the responsibility of
 * the format to manage each kind of data using StartBlob/StartData.
 *
 * It should only be called from within a DataDumper routine.
 *
 * Mandatory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressorState</name> <modifier>*</modifier></type><name>cs</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* WriteDataToArchive() internally throws write errors */</comment>
		<expr_stmt><expr><call><name>WriteDataToArchive</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when a dumper's 'DataDumper' routine has
 * finished.
 *
 * Optional.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EndCompressor</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Send the end marker */</comment>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when starting to save all BLOB DATA (not schema).
 * This routine should save whatever format-specific information is needed
 * to read the BLOBs back into memory.
 *
 * It is called just prior to the dumper's DataDumper routine.
 *
 * Optional, but strongly recommended.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>=</operator> <call><name>_getFilePos</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <name>K_OFFSET_POS_SET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_WriteByte</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>BLK_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Block type */</comment>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* For sanity check */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when the dumper calls StartBlob.
 *
 * Mandatory.
 *
 * Must save the passed OID for retrieval at restore-time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_StartBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid OID for large object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name> <operator>=</operator> <call><name>AllocateCompressor</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>, <argument><expr><name>_CustomWriteFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when the dumper calls EndBlob.
 *
 * Optional.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndBlob</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EndCompressor</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Send the end marker */</comment>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called by the archiver when finishing saving all BLOB DATA.
 *
 * Optional.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_EndBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Write out a fake zero OID to mark end-of-blobs. */</comment>
	<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print data for a given TOC entry
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintTocData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>blkType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>id</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>==</operator> <name>K_OFFSET_NO_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name> <operator>||</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>==</operator> <name>K_OFFSET_POS_NOT_SET</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We cannot seek directly to the desired block.  Instead, skip over
		 * block headers until we find the one we want.  Remember the
		 * positions of skipped-over blocks, so that if we later decide we
		 * need to read one, we'll be able to seek to it.
		 *
		 * When our input file is seekable, we can do the search starting from
		 * the point after the last data block we scanned in previous
		 * iterations of this function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lastFilePos</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error during file seek: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>thisBlkPos</name> <init>= <expr><call><name>_getFilePos</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>_readBlockHeader</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>blkType</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Remember the block position, if we got one */</comment>
			<if_stmt><if>if <condition>(<expr><name>thisBlkPos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>otherte</name> <init>= <expr><call><name>getTocEntryByDumpId</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>otherte</name> <operator>&amp;&amp;</operator> <name><name>otherte</name><operator>-&gt;</operator><name>formatData</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>othertctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>otherte</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Note: on Windows, multiple threads might access/update
					 * the same lclTocEntry concurrently, but that should be
					 * safe as long as we update dataPos before dataState.
					 * Ideally, we'd use pg_write_barrier() to enforce that,
					 * but the needed infrastructure doesn't exist in frontend
					 * code.  But Windows only runs on machines with strong
					 * store ordering, so it should be okay for now.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>othertctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>==</operator> <name>K_OFFSET_POS_NOT_SET</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>othertctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>=</operator> <name>thisBlkPos</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>othertctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>=</operator> <name>K_OFFSET_POS_SET</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>othertctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>!=</operator> <name>thisBlkPos</name> <operator>||</operator>
							 <name><name>othertctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>!=</operator> <name>K_OFFSET_POS_SET</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* sanity check */</comment>
						<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"data block %d has wrong seek position"</literal></expr></argument>,
									   <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<switch>switch <condition>(<expr><name>blkType</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>BLK_DATA</name></expr>:</case>
					<expr_stmt><expr><call><name>_skipData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>BLK_BLOBS</name></expr>:</case>
					<expr_stmt><expr><call><name>_skipBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>		<comment type="block">/* Always have a default */</comment>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized data block type (%d) while searching archive"</literal></expr></argument>,
						  <argument><expr><name>blkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We can just seek to the place we need to be. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error during file seek: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>_readBlockHeader</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we reached EOF without finding the block we want, then either it
	 * doesn't exist, or it does but we lack the ability to seek back to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blkType</name> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find block ID %d in archive -- "</literal>
				  <literal type="string">"possibly due to out-of-order restore request, "</literal>
				  <literal type="string">"which cannot be handled due to non-seekable input file"</literal></expr></argument>,
				  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find block ID %d in archive -- "</literal>
				  <literal type="string">"possibly corrupt archive"</literal></expr></argument>,
				  <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Are we sane? */</comment>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"found unexpected block ID (%d) when reading data -- expected %d"</literal></expr></argument>,
			  <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>blkType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BLK_DATA</name></expr>:</case>
			<expr_stmt><expr><call><name>_PrintData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BLK_BLOBS</name></expr>:</case>
			<expr_stmt><expr><call><name>_LoadBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>				<comment type="block">/* Always have a default */</comment>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized data block type %d while restoring archive"</literal></expr></argument>,
				  <argument><expr><name>blkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If our input file is seekable but lacks data offsets, update our
	 * knowledge of where to start future searches from.  (Note that we did
	 * not update the current TE's dataState/dataPos.  We could have, but
	 * there is no point since it will not be visited again.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name> <operator>&amp;&amp;</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>==</operator> <name>K_OFFSET_POS_NOT_SET</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>curPos</name> <init>= <expr><call><name>_getFilePos</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>curPos</name> <operator>&gt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>lastFilePos</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>lastFilePos</name></name> <operator>=</operator> <name>curPos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print data from current file position.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrintData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ReadDataFromArchive</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>, <argument><expr><name>_CustomReadFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_LoadBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StartRestoreBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>oid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartRestoreBlob</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_PrintData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EndRestoreBlob</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>EndRestoreBlobs</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Skip the BLOBs from the current file position.
 * BLOBS are written sequentially as data blocks (see below).
 * Each BLOB is preceded by it's original OID.
 * A zero OID indicated the end of the BLOBS
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_skipBlobs</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>oid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_skipData</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Skip data from current file position.
 * Data blocks are formatted as an integer length, followed by data.
 * A zero length denoted the end of the block.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_skipData</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>blkLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkLen</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>blkLen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><name>blkLen</name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error during file seek: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>blkLen</name> <operator>&gt;</operator> <name>buflen</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>blkLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>blkLen</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>blkLen</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>blkLen</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not read from input file: end of file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not read from input file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>blkLen</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a byte of data to the archive.
 *
 * Mandatory.
 *
 * Called by the archiver to do integer &amp; byte output to the archive.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_WriteByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>fputc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WRITE_ERROR_EXIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a byte of data from the archive.
 *
 * Mandatory
 *
 * Called by the archiver to read bytes &amp; integers from the archive.
 * EOF should be treated as a fatal error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_ReadByte</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>READ_ERROR_EXIT</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a buffer of data to the archive.
 *
 * Mandatory.
 *
 * Called by the archiver to write a block of bytes to the archive.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_WriteBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WRITE_ERROR_EXIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a block of bytes from the archive.
 *
 * Mandatory.
 *
 * Called by the archiver to read a block of bytes from the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReadBuf</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>READ_ERROR_EXIT</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close the archive.
 *
 * Mandatory.
 *
 * When writing the archive, this is the routine that actually starts
 * the process of saving it to files. No data should be written prior
 * to this point, since the user could sort the TOC after creating it.
 *
 * If an archive is to be written, this routine must call:
 *		WriteHead			to save the archive header
 *		WriteToc			to save the TOC entries
 *		WriteDataChunks		to save all DATA &amp; BLOBs.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_CloseArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>tpos</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WriteHead</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Remember TOC's seek position for use below */</comment>
		<expr_stmt><expr><name>tpos</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tpos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not determine seek position in archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WriteToc</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteDataChunks</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If possible, re-write the TOC in order to update the data offset
		 * information.  This is not essential, as pg_restore can cope in most
		 * cases without it; but it can make pg_restore significantly faster
		 * in some situations (especially parallel restore).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name> <operator>&amp;&amp;</operator>
			<call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><name>tpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WriteToc</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sync the output file if one is defined */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>dosync</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_fname</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reopen the archive's file handle.
 *
 * We close the original file handle, except on Windows.  (The difference
 * is because on Windows, this is used within a multithreading context,
 * and we don't want a thread closing the parent file handle.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ReopenArchive</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>tpos</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>archModeWrite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"can only reopen input archives"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * These two cases are user-facing errors since they represent unsupported
	 * (but not invalid) use-cases.  Word the error messages appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"parallel restore from standard input is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"parallel restore from non-seekable file is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tpos</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not determine seek position in archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not close archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open input file \"%s\": %m"</literal></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>fSpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><name>tpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not set seek position in archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare for parallel restore.
 *
 * The main thing that needs to happen here is to fill in TABLE DATA and BLOBS
 * TOC entries' dataLength fields with appropriate values to guide the
 * ordering of restore jobs.  The source of said data is format-dependent,
 * as is the exact meaning of the values.
 *
 * A format module might also choose to do other setup here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_PrepParallelRestore</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>prev_te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>prev_tctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Knowing that the data items were dumped out in TOC order, we can
	 * reconstruct the length of each item as the delta to the start offset of
	 * the next data item.
	 */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>lclTocEntry</name> <modifier>*</modifier></type><name>tctx</name> <init>= <expr><operator>(</operator><name>lclTocEntry</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore entries without a known data offset; if we were unable to
		 * seek to rewrite the TOC when creating the archive, this'll be all
		 * of them, and we'll end up with no size estimates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>dataState</name></name> <operator>!=</operator> <name>K_OFFSET_POS_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Compute previous data item's length */</comment>
		<if_stmt><if>if <condition>(<expr><name>prev_te</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>&gt;</operator> <name><name>prev_tctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>prev_te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dataPos</name></name> <operator>-</operator> <name><name>prev_tctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prev_te</name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_tctx</name> <operator>=</operator> <name>tctx</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If OK to seek, we can determine the length of the last item */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_te</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>endpos</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error during file seek: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>endpos</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endpos</name> <operator>&gt;</operator> <name><name>prev_tctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prev_te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name>endpos</name> <operator>-</operator> <name><name>prev_tctx</name><operator>-&gt;</operator><name>dataPos</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clone format-specific fields during parallel restoration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_Clone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Each thread must have private lclContext working state.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lclContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr>;</expr_stmt>

	<comment type="block">/* sanity check, shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"compressor active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We intentionally do not clone TOC-entry-local state: it's useful to
	 * share knowledge about where the data blocks are across threads.
	 * _PrintTocData has to be careful about the order of operations on that
	 * state, though.
	 *
	 * Note: we do not make a local lo_buf because we expect at most one BLOBS
	 * entry per archive, so no parallelism is possible.
	 */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_DeClone</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>lclContext</name> <operator>*</operator><operator>)</operator> <name><name>AH</name><operator>-&gt;</operator><name>formatData</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function is executed in the child of a parallel restore from a
 * custom-format archive and restores the actual data for one TOC entry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_WorkerJobRestoreCustom</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>TocEntry</name> <modifier>*</modifier></type><name>te</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>parallel_restore</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*--------------------------------------------------
 * END OF FORMAT CALLBACKS
 *--------------------------------------------------
 */</comment>

<comment type="block">/*
 * Get the current position in the archive file.
 *
 * With a non-seekable archive file, we may not be able to obtain the
 * file position.  If so, just return -1.  It's not too important in
 * that case because we won't be able to rewrite the TOC to fill in
 * data block offsets anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>pgoff_t</name></type>
<name>_getFilePos</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>lclContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not expected if we found we can seek. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasSeek</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not determine seek position in archive file: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a data block header. The format changed in V1.3, so we
 * centralize the code here for simplicity.  Returns *type = EOF
 * if at EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_readBlockHeader</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>byt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: if we are at EOF with a pre-1.3 input file, we'll fatal() inside
	 * ReadInt rather than returning EOF.  It doesn't seem worth jumping
	 * through hoops to deal with that case better, because no such files are
	 * likely to exist in the wild: only some 7.1 development versions of
	 * pg_dump ever generated such files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>K_VERS_1_3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BLK_DATA</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>byt</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>FH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>byt</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>byt</name> <operator>==</operator> <name>EOF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* don't return an uninitialized value */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback function for WriteDataToArchive. Writes one block of (compressed)
 * data to the archive.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_CustomWriteFunc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* never write 0-byte blocks (this should not happen) */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WriteInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_WriteBuf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback function for ReadDataFromArchive. To keep things simple, we
 * always read one compressed block at a time.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>_CustomReadFunc</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>blkLen</name></decl>;</decl_stmt>

	<comment type="block">/* Read length */</comment>
	<expr_stmt><expr><name>blkLen</name> <operator>=</operator> <call><name>ReadInt</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>blkLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the caller's buffer is not large enough, allocate a bigger one */</comment>
	<if_stmt><if>if <condition>(<expr><name>blkLen</name> <operator>&gt;</operator> <operator>*</operator><name>buflen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>blkLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buflen</name> <operator>=</operator> <name>blkLen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* exits app on read errors */</comment>
	<expr_stmt><expr><call><name>_ReadBuf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>blkLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>blkLen</name></expr>;</return>
</block_content>}</block></function>
</unit>
