<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_verifybackup/pg_verifybackup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_verifybackup.c
 *	  Verify a backup against a backup manifest.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/pg_verifybackup/pg_verifybackup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/simple_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parse_manifest.h"</cpp:file></cpp:include>

<comment type="block">/*
 * For efficiency, we'd like our hash table containing information about the
 * manifest to start out with approximately the correct number of entries.
 * There's no way to know the exact number of entries without reading the whole
 * file, but we can get an estimate by dividing the file size by the estimated
 * number of bytes per line.
 *
 * This could be off by about a factor of two in either direction, because the
 * checksum algorithm has a big impact on the line lengths; e.g. a SHA512
 * checksum is 128 hex bytes, whereas a CRC-32C value is only 8, and there
 * might be no checksum at all.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESTIMATED_BYTES_PER_MANIFEST_LINE</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
 * How many bytes should we try to read from a file at once?
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHUNK_SIZE</name></cpp:macro>				<cpp:value>4096</cpp:value></cpp:define>

<comment type="block">/*
 * Each file described by the manifest file is parsed to produce an object
 * like this.
 */</comment>
<typedef>typedef <type><struct>struct <name>manifest_file</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type>		<name>status</name></decl>;</decl_stmt>			<comment type="block">/* hash status */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_checksum_type</name></type> <name>checksum_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>checksum_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>checksum_payload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>matched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bad</name></decl>;</decl_stmt>
}</block></struct></type> <name>manifest_file</name>;</typedef>

<comment type="block">/*
 * Define a hash table which we can use to store information about the files
 * mentioned in the backup manifest.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>hash_string_pointer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_PREFIX</name></cpp:macro>		<cpp:value>manifest_files</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_ELEMENT_TYPE</name></cpp:macro>	<cpp:value>manifest_file</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY_TYPE</name></cpp:macro>		<cpp:value>char *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>SH_KEY</name></cpp:macro>			<cpp:value>pathname</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_HASH_KEY</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>hash_string_pointer(key)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_EQUAL</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(strcmp(a, b) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>SH_SCOPE</name></cpp:macro>		<cpp:value>static inline</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_RAW_ALLOCATOR</name></cpp:macro>	<cpp:value>pg_malloc0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DECLARE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DEFINE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/simplehash.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Each WAL range described by the manifest file is parsed to produce an
 * object like this.
 */</comment>
<typedef>typedef <type><struct>struct <name>manifest_wal_range</name>
<block>{
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>start_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>end_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>manifest_wal_range</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>manifest_wal_range</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>manifest_wal_range</name>;</typedef>

<comment type="block">/*
 * Details we need in callbacks that occur while parsing a backup manifest.
 */</comment>
<typedef>typedef <type><struct>struct <name>parser_context</name>
<block>{
	<decl_stmt><decl><type><name>manifest_files_hash</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>first_wal_range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>last_wal_range</name></decl>;</decl_stmt>
}</block></struct></type> <name>parser_context</name>;</typedef>

<comment type="block">/*
 * All of the context information we need while checking a backup manifest.
 */</comment>
<typedef>typedef <type><struct>struct <name>verifier_context</name>
<block>{
	<decl_stmt><decl><type><name>manifest_files_hash</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>backup_directory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringList</name></type> <name>ignore_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exit_on_error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_any_error</name></decl>;</decl_stmt>
}</block></struct></type> <name>verifier_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_manifest_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>manifest_path</name></decl></parameter>,
								<parameter><decl><type><name>manifest_files_hash</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht_p</name></decl></parameter>,
								<parameter><decl><type><name>manifest_wal_range</name> <modifier>*</modifier><modifier>*</modifier></type><name>first_wal_range_p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>record_manifest_details_for_file</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
											 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
											 <parameter><decl><type><name>pg_checksum_type</name></type> <name>checksum_type</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>checksum_length</name></decl></parameter>,
											 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>checksum_payload</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>record_manifest_details_for_wal_range</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
												  <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>,
												  <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>,
												  <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_manifest_error</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
			pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>) <expr_stmt><expr><call><name>pg_attribute_noreturn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_backup_directory</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
									<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_backup_file</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_extra_backup_files</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_backup_checksums</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_file_checksum</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								 <parameter><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_required_wal</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pg_waldump_path</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>wal_directory</name></decl></parameter>,
							   <parameter><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>first_wal_range</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_backup_error</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>pg_restrict</name></type> <name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
			pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_fatal_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>pg_restrict</name></type> <name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
			pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>) <expr_stmt><expr><call><name>pg_attribute_noreturn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>should_ignore_relpath</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

<comment type="block">/*
 * Main entry point.
 */</comment>
<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"exit-on-error"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"ignore"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'i'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"manifest-path"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'m'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-parse-wal"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quiet"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'q'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"skip-checksums"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wal-directory"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>verifier_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>first_wal_range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>manifest_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>no_parse_wal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>quiet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_checksums</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>wal_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pg_waldump_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_verifybackup"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_verifybackup (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Skip certain files in the toplevel directory.
	 *
	 * Ignore the backup_manifest file, because it's not included in the
	 * backup manifest.
	 *
	 * Ignore the pg_wal directory, because those files are not included in
	 * the backup manifest either, since they are fetched separately from the
	 * backup itself, and verified via a separate mechanism.
	 *
	 * Ignore postgresql.auto.conf, recovery.signal, and standby.signal,
	 * because we expect that those files may sometimes be created or changed
	 * as part of the backup process. For example, pg_basebackup -R will
	 * modify postgresql.auto.conf and create standby.signal.
	 */</comment>
	<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><literal type="string">"backup_manifest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><literal type="string">"postgresql.auto.conf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><literal type="string">"recovery.signal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><literal type="string">"standby.signal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"ei:m:nqsw:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>exit_on_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'m'</literal></expr>:</case>
				<expr_stmt><expr><name>manifest_path</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>manifest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>no_parse_wal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case>
				<expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><name>skip_checksums</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name>wal_directory</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>wal_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/* Get backup directory name */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_fatal</name><argument_list>(<argument><expr><literal type="string">"no backup directory specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>backup_directory</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>backup_directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Complain if any arguments remain */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_fatal</name><argument_list>(<argument><expr><literal type="string">"too many command-line arguments (first is \"%s\")"</literal></expr></argument>,
					 <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Unless --no-parse-wal was specified, we will need pg_waldump. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_parse_wal</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_waldump_path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_other_exec</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"pg_waldump"</literal></expr></argument>,
							  <argument><expr><literal type="string">"pg_waldump (PostgreSQL) "</literal> <name>PG_VERSION</name> <literal type="string">"\n"</literal></expr></argument>,
							  <argument><expr><name>pg_waldump_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_fatal</name><argument_list>(<argument><expr><literal type="string">"The program \"%s\" is needed by %s but was not found in the\n"</literal>
							 <literal type="string">"same directory as \"%s\".\n"</literal>
							 <literal type="string">"Check your installation."</literal></expr></argument>,
							 <argument><expr><literal type="string">"pg_waldump"</literal></expr></argument>, <argument><expr><literal type="string">"pg_verifybackup"</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_fatal</name><argument_list>(<argument><expr><literal type="string">"The program \"%s\" was found by \"%s\"\n"</literal>
							 <literal type="string">"but was not the same version as %s.\n"</literal>
							 <literal type="string">"Check your installation."</literal></expr></argument>,
							 <argument><expr><literal type="string">"pg_waldump"</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><literal type="string">"pg_verifybackup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* By default, look for the manifest in the backup directory. */</comment>
	<if_stmt><if>if <condition>(<expr><name>manifest_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>manifest_path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/backup_manifest"</literal></expr></argument>,
								 <argument><expr><name><name>context</name><operator>.</operator><name>backup_directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* By default, look for the WAL in the backup directory, too. */</comment>
	<if_stmt><if>if <condition>(<expr><name>wal_directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>wal_directory</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/pg_wal"</literal></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>backup_directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to read the manifest. We treat any errors encountered while parsing
	 * the manifest as fatal; there doesn't seem to be much point in trying to
	 * verify the backup directory against a corrupted manifest.
	 */</comment>
	<expr_stmt><expr><call><name>parse_manifest_file</name><argument_list>(<argument><expr><name>manifest_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>ht</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_wal_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the files in the backup directory. At this stage, we verify
	 * that every file on disk is present in the manifest and that the sizes
	 * match. We also set the "matched" flag on every manifest entry that
	 * corresponds to a file on disk.
	 */</comment>
	<expr_stmt><expr><call><name>verify_backup_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>backup_directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The "matched" flag should now be set on every entry in the hash table.
	 * Any entries for which the bit is not set are files mentioned in the
	 * manifest that don't exist on disk.
	 */</comment>
	<expr_stmt><expr><call><name>report_extra_backup_files</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now do the expensive work of verifying file checksums, unless we were
	 * told to skip it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_checksums</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>verify_backup_checksums</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to parse the required ranges of WAL records, unless we were told
	 * not to do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_parse_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parse_required_wal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>pg_waldump_path</name></expr></argument>,
						   <argument><expr><name>wal_directory</name></expr></argument>, <argument><expr><name>first_wal_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If everything looks OK, tell the user this, unless we were asked to
	 * work quietly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>.</operator><name>saw_any_error</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quiet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"backup successfully verified\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name><name>context</name><operator>.</operator><name>saw_any_error</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a manifest file. Construct a hash table with information about
 * all the files it mentions, and a linked list of all the WAL ranges it
 * mentions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_manifest_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>manifest_path</name></decl></parameter>, <parameter><decl><type><name>manifest_files_hash</name> <modifier>*</modifier><modifier>*</modifier></type><name>ht_p</name></decl></parameter>,
					<parameter><decl><type><name>manifest_wal_range</name> <modifier>*</modifier><modifier>*</modifier></type><name>first_wal_range_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>estimate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>initial_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_files_hash</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parser_context</name></type> <name>private_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonManifestParseContext</name></type> <name>context</name></decl>;</decl_stmt>

	<comment type="block">/* Open the manifest file. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>manifest_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>manifest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Figure out how big the manifest is. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>manifest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Guess how large to make the hash table based on the manifest size. */</comment>
	<expr_stmt><expr><name>estimate</name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>/</operator> <name>ESTIMATED_BYTES_PER_MANIFEST_LINE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>initial_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>PG_UINT32_MAX</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>estimate</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the hash table. */</comment>
	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>manifest_files_create</name><argument_list>(<argument><expr><name>initial_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Slurp in the whole file.
	 *
	 * This is not ideal, but there's currently no easy way to get
	 * pg_parse_json() to perform incremental parsing.
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							   <argument><expr><name>manifest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							   <argument><expr><name>manifest_path</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Close the manifest file. */</comment>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse the manifest. */</comment>
	<expr_stmt><expr><name><name>private_context</name><operator>.</operator><name>ht</name></name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private_context</name><operator>.</operator><name>first_wal_range</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private_context</name><operator>.</operator><name>last_wal_range</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>private_data</name></name> <operator>=</operator> <operator>&amp;</operator><name>private_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>perfile_cb</name></name> <operator>=</operator> <name>record_manifest_details_for_file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>perwalrange_cb</name></name> <operator>=</operator> <name>record_manifest_details_for_wal_range</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>error_cb</name></name> <operator>=</operator> <name>report_manifest_error</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>json_parse_manifest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with the buffer. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the file hash table and WAL range list we constructed. */</comment>
	<expr_stmt><expr><operator>*</operator><name>ht_p</name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>first_wal_range_p</name> <operator>=</operator> <name><name>private_context</name><operator>.</operator><name>first_wal_range</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report an error while parsing the manifest.
 *
 * We consider all such errors to be fatal errors. The manifest parser
 * expects this function not to return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_manifest_error</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_log_generic_v</name><argument_list>(<argument><expr><name>PG_LOG_FATAL</name></expr></argument>, <argument><expr><call><name>gettext</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record details extracted from the backup manifest for one file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>record_manifest_details_for_file</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
								 <parameter><decl><type><name>pg_checksum_type</name></type> <name>checksum_type</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>checksum_length</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>checksum_payload</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>parser_context</name> <modifier>*</modifier></type><name>pcxt</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_files_hash</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>pcxt</name><operator>-&gt;</operator><name>ht</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Make a new entry in the hash table for this file. */</comment>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>manifest_files_insert</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"duplicate path name in backup manifest: \"%s\""</literal></expr></argument>,
						   <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the entry. */</comment>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_type</name></name> <operator>=</operator> <name>checksum_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_length</name></name> <operator>=</operator> <name>checksum_length</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_payload</name></name> <operator>=</operator> <name>checksum_payload</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>bad</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record details extracted from the backup manifest for one WAL range.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>record_manifest_details_for_wal_range</name><parameter_list>(<parameter><decl><type><name>JsonManifestParseContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
									  <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>,
									  <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>parser_context</name> <modifier>*</modifier></type><name>pcxt</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>range</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate and initialize a struct describing this WAL range. */</comment>
	<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>manifest_wal_range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>start_lsn</name></name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>last_wal_range</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Add it to the end of the list. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>first_wal_range</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>first_wal_range</name></name> <operator>=</operator> <name>range</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>last_wal_range</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>range</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>last_wal_range</name></name> <operator>=</operator> <name>range</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify one directory.
 *
 * 'relpath' is NULL if we are to verify the top-level backup directory,
 * and otherwise the relative path to the directory that is to be verified.
 *
 * 'fullpath' is the backup directory with 'relpath' appended; i.e. the actual
 * filesystem path at which it can be found.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_backup_directory</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dirent</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If even the toplevel backup directory cannot be found, treat this
		 * as a fatal error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, treat this as a non-fatal error, but ignore any further
		 * errors related to this path and anything beneath it.
		 */</comment>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>dirent</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name><name>dirent</name><operator>-&gt;</operator><name>d_name</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newfullpath</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newrelpath</name></decl>;</decl_stmt>

		<comment type="block">/* Skip "." and ".." */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>filename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>filename</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal>
								   <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>relpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newrelpath</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newrelpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>relpath</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_ignore_relpath</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>newrelpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>verify_backup_file</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>newrelpath</name></expr></argument>, <argument><expr><name>newfullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newfullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newrelpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"could not close directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify one file (which might actually be a directory or a symlink).
 *
 * The arguments to this function have the same meaning as the arguments to
 * verify_backup_directory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_backup_file</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"could not stat file or directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Suppress further errors related to this path name and, if it's a
		 * directory, anything underneath it.
		 */</comment>
		<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>ignore_list</name></name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If it's a directory, just recurse. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>verify_backup_directory</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If it's not a directory, it should be a plain file. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"\"%s\" is not a file or directory"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check whether there's an entry in the manifest hash. */</comment>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>manifest_files_lookup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"\"%s\" is present on disk but not in the manifest"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Flag this entry as having been encountered in the filesystem. */</comment>
	<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Check that the size matches. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"\"%s\" has size %zu on disk but size %zu in the manifest"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>bad</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't verify checksums at this stage. We first finish verifying that
	 * we have the expected set of files with the expected sizes, and only
	 * afterwards verify the checksums. That's because computing checksums may
	 * take a while, and we'd like to report more obvious problems quickly.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the hash table for entries where the 'matched' flag is not set; report
 * that such files are present in the manifest but not on disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_extra_backup_files</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>manifest_files_iterator</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>manifest_files_start_iterate</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>m</name> <operator>=</operator> <call><name>manifest_files_iterate</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>matched</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>should_ignore_relpath</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>pathname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
								<argument><expr><literal type="string">"\"%s\" is present in the manifest but not on disk"</literal></expr></argument>,
								<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pathname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Verify checksums for hash table entries that are otherwise unproblematic.
 * If we've already reported some problem related to a hash table entry, or
 * if it has no checksum, just skip it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_backup_checksums</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>manifest_files_iterator</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>manifest_files_start_iterate</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>m</name> <operator>=</operator> <call><name>manifest_files_iterate</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ht</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>matched</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>m</name><operator>-&gt;</operator><name>bad</name></name> <operator>&amp;&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>checksum_type</name></name> <operator>!=</operator> <name>CHECKSUM_TYPE_NONE</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>should_ignore_relpath</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>pathname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>

			<comment type="block">/* Compute the full pathname to the target file. */</comment>
			<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>backup_directory</name></name></expr></argument>,
								<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pathname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Do the actual checksum verification. */</comment>
			<expr_stmt><expr><call><name>verify_file_checksum</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Avoid leaking memory. */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Verify the checksum of a single file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_file_checksum</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>manifest_file</name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_checksum_context</name></type> <name>checksum_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relpath</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>pathname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>buffer</name><index>[<expr><name>READ_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>checksumbuf</name><index>[<expr><name>PG_CHECKSUM_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>checksumlen</name></decl>;</decl_stmt>

	<comment type="block">/* Open the target file. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize checksum context. */</comment>
	<expr_stmt><expr><call><name>pg_checksum_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checksum_ctx</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read the file chunk by chunk, updating the checksum as we go. */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>READ_CHUNK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bytes_read</name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_checksum_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checksum_ctx</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close the file. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we didn't manage to read the whole file, bail out now. */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Double-check that we read the expected number of bytes from the file.
	 * Normally, a file size mismatch would be caught in verify_backup_file
	 * and this check would never be reached, but this provides additional
	 * safety and clarity in the event of concurrent modifications or
	 * filesystem misbehavior.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"file \"%s\" should contain %zu bytes, but read %zu bytes"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the final checksum. */</comment>
	<expr_stmt><expr><name>checksumlen</name> <operator>=</operator> <call><name>pg_checksum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checksum_ctx</name></expr></argument>, <argument><expr><name>checksumbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And check it against the manifest. */</comment>
	<if_stmt><if>if <condition>(<expr><name>checksumlen</name> <operator>!=</operator> <name><name>m</name><operator>-&gt;</operator><name>checksum_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"file \"%s\" has checksum of length %d, but expected %d"</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_length</name></name></expr></argument>, <argument><expr><name>checksumlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>checksumbuf</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>checksum_payload</name></name></expr></argument>, <argument><expr><name>checksumlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
							<argument><expr><literal type="string">"checksum mismatch for file \"%s\""</literal></expr></argument>,
							<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to parse the WAL files required to restore from backup using
 * pg_waldump.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_required_wal</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pg_waldump_path</name></decl></parameter>,
				   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>wal_directory</name></decl></parameter>, <parameter><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>first_wal_range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>manifest_wal_range</name> <modifier>*</modifier></type><name>this_wal_range</name> <init>= <expr><name>first_wal_range</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>this_wal_range</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pg_waldump_cmd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_waldump_cmd</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"\"%s\" --quiet --path=\"%s\" --timeline=%u --start=%X/%X --end=%X/%X\n"</literal></expr></argument>,
								  <argument><expr><name>pg_waldump_path</name></expr></argument>, <argument><expr><name>wal_directory</name></expr></argument>, <argument><expr><name><name>this_wal_range</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>this_wal_range</name><operator>-&gt;</operator><name>start_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>this_wal_range</name><operator>-&gt;</operator><name>start_lsn</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>this_wal_range</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>this_wal_range</name><operator>-&gt;</operator><name>end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>pg_waldump_cmd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_backup_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
								<argument><expr><literal type="string">"WAL parsing failed for timeline %u"</literal></expr></argument>,
								<argument><expr><name><name>this_wal_range</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>this_wal_range</name> <operator>=</operator> <name><name>this_wal_range</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Report a problem with the backup.
 *
 * Update the context to indicate that we saw an error, and exit if the
 * context says we should.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_backup_error</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>pg_restrict</name></type> <name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_log_generic_v</name><argument_list>(<argument><expr><name>PG_LOG_ERROR</name></expr></argument>, <argument><expr><call><name>gettext</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>saw_any_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>exit_on_error</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report a fatal error and exit
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_fatal_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>pg_restrict</name></type> <name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_log_generic_v</name><argument_list>(<argument><expr><name>PG_LOG_FATAL</name></expr></argument>, <argument><expr><call><name>gettext</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is the specified relative path, or some prefix of it, listed in the set
 * of paths to ignore?
 *
 * Note that by "prefix" we mean a parent directory; for this purpose,
 * "aa/bb" is not a prefix of "aa/bbb", but it is a prefix of "aa/bb/cc".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_ignore_relpath</name><parameter_list>(<parameter><decl><type><name>verifier_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>ignore_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>r</name> <init>= <expr><name>relpath</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>*</operator><name>v</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>==</operator> <operator>*</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>r</name></expr><operator>,</operator> <expr><operator>++</operator><name>v</name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>v</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>r</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>r</name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for manifest_files hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>hash_string_pointer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_bytes</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print out usage information and exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s verifies a backup against the backup manifest.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n  %s [OPTION]... BACKUPDIR\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e, --exit-on-error         exit immediately on error\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -i, --ignore=RELATIVE_PATH  ignore indicated path\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -m, --manifest-path=PATH    use specified path for manifest\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-parse-wal          do not try to parse WAL files\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -q, --quiet                 do not print any output, except for errors\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --skip-checksums        skip checksum verification\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --wal-directory=PATH    use specified path for WAL files\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version               output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                  show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;%s&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PACKAGE_BUGREPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s home page: &lt;%s&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PACKAGE_NAME</name></expr></argument>, <argument><expr><name>PACKAGE_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
