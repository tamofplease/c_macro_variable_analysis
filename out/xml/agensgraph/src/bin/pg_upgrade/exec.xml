<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/bin/pg_upgrade/exec.c"><comment type="block">/*
 *	exec.c
 *
 *	execution functions
 *
 *	Copyright (c) 2010-2020, PostgreSQL Global Development Group
 *	src/bin/pg_upgrade/exec.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_upgrade.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_data_dir</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_bin_dir</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_bin_version</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdName</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>win32_check_directory_write_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * get_bin_version
 *
 *	Fetch major version of binaries for cluster.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_bin_version</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>cmd_output</name><index>[<expr><name>MAX_STRING</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>v1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>v2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\"%s/pg_ctl\" --version"</literal></expr></argument>, <argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>output</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>fgets</name><argument_list>(<argument><expr><name>cmd_output</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd_output</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not get pg_ctl version data using %s: %s\n"</literal></expr></argument>,
				 <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cmd_output</name></expr></argument>, <argument><expr><literal type="string">"%*s %*s %d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not get pg_ctl version output from %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* old style, e.g. 9.6.1 */</comment>
		<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>bin_version</name></name> <operator>=</operator> <name>v1</name> <operator>*</operator> <literal type="number">10000</literal> <operator>+</operator> <name>v2</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* new style, e.g. 10.1 */</comment>
		<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>bin_version</name></name> <operator>=</operator> <name>v1</name> <operator>*</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * exec_prog()
 *		Execute an external program with stdout/stderr redirected, and report
 *		errors
 *
 * Formats a command from the given argument list, logs it to the log file,
 * and attempts to execute that command.  If the command executes
 * successfully, exec_prog() returns true.
 *
 * If the command fails, an error message is optionally written to the specified
 * log_file, and the program optionally exits.
 *
 * The code requires it be called first from the primary thread on Windows.
 */</comment>
<function><type><name>bool</name></type>
<name>exec_prog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_log_file</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>report_error</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>exit_on_error</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>written</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCMDLEN</name></cpp:macro> <cpp:value>(2 * MAXPGPATH)</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXCMDLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>log</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>static</specifier> <name>DWORD</name></type> <name>mainThreadId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume we are called from the primary thread first */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mainThreadId</name> <operator>=</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <name>written</name></expr></argument>, <argument><expr><name>MAXCMDLEN</name> <operator>-</operator> <name>written</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>&gt;=</operator> <name>MAXCMDLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"command too long\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>written</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <name>written</name></expr></argument>, <argument><expr><name>MAXCMDLEN</name> <operator>-</operator> <name>written</name></expr></argument>,
						<argument><expr><literal type="string">" &gt;&gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>&gt;=</operator> <name>MAXCMDLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"command too long\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * For some reason, Windows issues a file-in-use error if we write data to
	 * the log file from a non-primary thread just before we create a
	 * subprocess that also writes to the same log file.  One fix is to sleep
	 * for 100ms.  A cleaner fix is to write to the log file _after_ the
	 * subprocess has completed, so we do this only when writing from a
	 * non-primary thread.  fflush(), running system() twice, and pre-creating
	 * the file do not see to help.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>!=</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>log</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<block>{<block_content>
		<comment type="block">/*
		 * "pg_ctl -w stop" might have reported that the server has stopped
		 * because the postmaster.pid file has been removed, but "pg_ctl -w
		 * start" might still be in the process of closing and might still be
		 * holding its stdout and -l log file descriptors open.  Therefore,
		 * try to open the log file a few more times.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>iter</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>iter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iter</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>log</name> <operator>==</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>iter</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1 sec */</comment>
			<expr_stmt><expr><name>log</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>log</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open log file \"%s\": %m\n"</literal></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Are we printing "command:" before its output? */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>==</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"command: %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Are we printing "command:" after its output? */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>!=</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * In Windows, we must close the log file at this point so the file is not
	 * open while the command is running, or we get a share violation.
	 */</comment>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* see comment above */</comment>
	<if_stmt><if>if <condition>(<expr><name>mainThreadId</name> <operator>==</operator> <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>report_error</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we might be in on a progress status line, so go to the next line */</comment>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"\n*failure*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"There were problems executing \"%s\"\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opt_log_file</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><ternary><condition><expr><name>exit_on_error</name></expr> ?</condition><then> <expr><name>PG_FATAL</name></expr> </then><else>: <expr><name>PG_REPORT</name></expr></else></ternary></expr></argument>,
				   <argument><expr><literal type="string">"Consult the last few lines of \"%s\" or \"%s\" for\n"</literal>
				   <literal type="string">"the probable cause of the failure.\n"</literal></expr></argument>,
				   <argument><expr><name>log_file</name></expr></argument>, <argument><expr><name>opt_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><ternary><condition><expr><name>exit_on_error</name></expr> ?</condition><then> <expr><name>PG_FATAL</name></expr> </then><else>: <expr><name>PG_REPORT</name></expr></else></ternary></expr></argument>,
				   <argument><expr><literal type="string">"Consult the last few lines of \"%s\" for\n"</literal>
				   <literal type="string">"the probable cause of the failure.\n"</literal></expr></argument>,
				   <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * We can't do this on Windows because it will keep the "pg_ctl start"
	 * output filename open until the server stops, so we do the \n\n above on
	 * that platform.  We use a unique filename for "pg_ctl start" that is
	 * never reused while the server is running, so it works fine.  We could
	 * log these commands to a third file, but that just adds complexity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>log</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not write to log file \"%s\": %m\n"</literal></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pid_lock_file_exists()
 *
 * Checks whether the postmaster.pid file exists.
 */</comment>
<function><type><name>bool</name></type>
<name>pid_lock_file_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datadir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/postmaster.pid"</literal></expr></argument>, <argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ENOTDIR means we will throw a more useful error later */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOTDIR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %s\n"</literal></expr></argument>,
					 <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * verify_directories()
 *
 * does all the hectic work of verifying directories and executables
 * of old and new server.
 *
 * NOTE: May update the values of all parameters
 */</comment>
<function><type><name>void</name></type>
<name>verify_directories</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>win32_check_directory_write_permissions</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"You must have read and write access in the current directory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_bin_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_data_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_bin_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_data_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * win32_check_directory_write_permissions()
 *
 *	access() on WIN32 can't check directory permissions, so we have to
 *	optionally create, then delete a file to check.
 *		http://msdn.microsoft.com/en-us/library/1w06ktdy%28v=vs.80%29.aspx
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>win32_check_directory_write_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We open a file we would normally create anyway.  We do this even in
	 * 'check' mode, which isn't ideal, but this is the best we can do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>GLOBALS_DUMP_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>unlink</name><argument_list>(<argument><expr><name>GLOBALS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * check_single_dir()
 *
 *	Check for the presence of a single directory in PGDATA, and fail if
 * is it missing or not accessible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_single_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>subDirName</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>subDirName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>subDirName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>,
	<comment type="block">/* Win32 can't stat() a directory with a trailing slash. */</comment>
			 <argument><expr><ternary><condition><expr><operator>*</operator><name>subdir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>subDirName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"check for \"%s\" failed: %s\n"</literal></expr></argument>,
					  <argument><expr><name>subDirName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a directory\n"</literal></expr></argument>,
					  <argument><expr><name>subDirName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * check_data_dir()
 *
 *	This function validates the given cluster directory - we search for a
 *	small set of subdirectories that we expect to find in a valid $PGDATA
 *	directory.  If any of the subdirectories are missing (or secured against
 *	us) we display an error message and exit()
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_data_dir</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><name><name>cluster</name><operator>-&gt;</operator><name>pgdata</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the cluster version */</comment>
	<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>major_version</name></name> <operator>=</operator> <call><name>get_major_server_version</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_multixact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_subtrans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_twophase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_xlog has been renamed to pg_wal in v10 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">906</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_xlog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* pg_clog has been renamed to pg_xact in v10 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">906</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_clog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_single_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><literal type="string">"pg_xact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * check_bin_dir()
 *
 *	This function searches for the executables that we expect to find
 *	in the binaries directory.  If we find that a required executable
 *	is missing (or secured against us), we display an error message and
 *	exit().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_bin_dir</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

	<comment type="block">/* check bindir */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"check for \"%s\" failed: %s\n"</literal></expr></argument>,
					  <argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a directory\n"</literal></expr></argument>,
					  <argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_controldata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_ctl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the binary version after checking for the existence of pg_ctl.
	 * This way we report a useful error if the pg_ctl binary used for version
	 * fetching is missing/broken.
	 */</comment>
	<expr_stmt><expr><call><name>get_bin_version</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_resetxlog has been renamed to pg_resetwal in version 10 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bin_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">906</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_resetxlog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_resetwal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cluster</name> <operator>==</operator> <operator>&amp;</operator><name>new_cluster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * These binaries are only needed for the target version. pg_dump and
		 * pg_dumpall are used to dump the old cluster, but must be of the
		 * target version.
		 */</comment>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"initdb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_dump"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_dumpall"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"pg_restore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"psql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_exec</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>, <argument><expr><literal type="string">"vacuumdb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * validate_exec()
 *
 * validate "path" as an executable file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>cmdName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Windows requires a .exe suffix for stat() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>EXE_EXT</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>EXE_EXT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EXE_EXT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>EXE_EXT</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Ensure that the file exists and is a regular file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"check for \"%s\" failed: %s\n"</literal></expr></argument>,
				 <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"check for \"%s\" failed: not a regular file\n"</literal></expr></argument>,
				 <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that the file is both executable and readable (required for
	 * dynamic loading).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRUSR</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"check for \"%s\" failed: cannot read file (permission denied)\n"</literal></expr></argument>,
				 <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUSR</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"check for \"%s\" failed: cannot execute (permission denied)\n"</literal></expr></argument>,
				 <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
