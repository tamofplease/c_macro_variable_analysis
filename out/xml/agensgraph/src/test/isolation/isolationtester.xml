<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/test/isolation/isolationtester.c"><comment type="block">/*
 * src/test/isolation/isolationtester.c
 *
 * isolationtester.c
 *		Runs an isolation test specified by a spec file.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatype/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"isolationtester.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREP_WAITING</name></cpp:macro> <cpp:value>"isolationtester_waiting"</cpp:value></cpp:define>

<comment type="block">/*
 * conns[0] is the global setup, teardown, and watchdog connection.  Additional
 * connections represent spec-defined sessions.
 */</comment>
<typedef>typedef <type><struct>struct <name>IsoConnInfo</name>
<block>{
	<comment type="block">/* The libpq connection object for this connection. */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<comment type="block">/* The backend PID, in numeric and string formats. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>backend_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backend_pid_str</name></decl>;</decl_stmt>
	<comment type="block">/* Name of the associated session. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionname</name></decl>;</decl_stmt>
	<comment type="block">/* Active step on this connection, or NULL if idle. */</comment>
	<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>active_step</name></decl>;</decl_stmt>
	<comment type="block">/* Number of NOTICE messages received from connection. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_notices</name></decl>;</decl_stmt>
}</block></struct></type> <name>IsoConnInfo</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>IsoConnInfo</name> <modifier>*</modifier></type><name>conns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nconns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flag indicating some new NOTICE has arrived */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>any_new_notice</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Maximum time to wait before giving up on a step (in usec) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>max_step_wait</name> <init>= <expr><literal type="number">300</literal> <operator>*</operator> <name>USECS_PER_SEC</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_all_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_all_permutations_recurse</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piles</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_named_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_permutation</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>,
							<parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Flag bits for try_complete_step(s) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP_NONBLOCK</name></cpp:macro>	<cpp:value>0x1</cpp:value></cpp:define>		<comment type="block">/* return as soon as cmd waits for a lock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP_RETRY</name></cpp:macro>		<cpp:value>0x2</cpp:value></cpp:define>		<comment type="block">/* this is a retry of a previously-waiting cmd */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>try_complete_steps</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>waiting</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nwaiting</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>try_complete_step</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>step_qsort_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>step_bsearch_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>step_has_blocker</name><parameter_list>(<parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printResultSet</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>isotesterNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>blackholeNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>env_wait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TestSpec</name>   <modifier>*</modifier></type><name>testspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>wait_query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"V"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>opt</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>
				<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"isolationtester (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: isolationtester [CONNINFO]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Make stdout unbuffered to match stderr; and ensure stderr is unbuffered
	 * too, which it should already be everywhere except sometimes in Windows.
	 */</comment>
	<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the user supplies a non-option parameter on the command line, use it
	 * as the conninfo string; otherwise default to setting dbname=postgres
	 * and using environment variables or defaults for all other connection
	 * parameters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>conninfo</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>conninfo</name> <operator>=</operator> <literal type="string">"dbname = postgres"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If PGISOLATIONTIMEOUT is set in the environment, adopt its value (given
	 * in seconds) as the max time to wait for any one step to complete.
	 */</comment>
	<expr_stmt><expr><name>env_wait</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGISOLATIONTIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env_wait</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_step_wait</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>env_wait</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read the test spec from stdin */</comment>
	<expr_stmt><expr><call><name>spec_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>testspec</name> <operator>=</operator> <operator>&amp;</operator><name>parseresult</name></expr>;</expr_stmt>

	<comment type="block">/* Perform post-parse checking, and fill in linking fields */</comment>
	<expr_stmt><expr><call><name>check_testspec</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Parsed test spec with %d sessions\n"</literal></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Establish connections to the database, one for each session and an
	 * extra for lock wait detection and global work.
	 */</comment>
	<expr_stmt><expr><name>nconns</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>conns</name> <operator>=</operator> <operator>(</operator><name>IsoConnInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>nconns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IsoConnInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>disconnect_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sessionname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sessionname</name> <operator>=</operator> <literal type="string">"control connection"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sessionname</name> <operator>=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionname</name> <operator>=</operator> <name>sessionname</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Connection %d failed: %s"</literal></expr></argument>,
					<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set up notice processors for the user-defined connections, so that
		 * messages can get printed prefixed with the session names.  The
		 * control connection gets a "blackhole" processor instead (hides all
		 * messages).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>,
								 <argument><expr><name>isotesterNoticeProcessor</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>,
								 <argument><expr><name>blackholeNoticeProcessor</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Similarly, append the session name to application_name to make it
		 * easier to map spec file sessions to log output and
		 * pg_stat_activity. The reason to append instead of just setting the
		 * name is that we don't know the name of the test currently running.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexecParams</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>,
						   <argument><expr><literal type="string">"SELECT set_config('application_name',\n"</literal>
						   <literal type="string">"  current_setting('application_name') || '/' || $1,\n"</literal>
						   <literal type="string">"  false)"</literal></expr></argument>,
						   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>sessionname</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setting of application name failed: %s"</literal></expr></argument>,
					<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Save each connection's backend PID for subsequent use. */</comment>
		<expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backend_pid</name> <operator>=</operator> <call><name>PQbackendPID</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backend_pid_str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Build the query we'll use to detect lock contention among sessions in
	 * the test specification.  Most of the time, we could get away with
	 * simply checking whether a session is waiting for *any* lock: we don't
	 * exactly expect concurrent use of test tables.  However, autovacuum will
	 * occasionally take AccessExclusiveLock to truncate a table, and we must
	 * ignore that transient wait.
	 */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT pg_catalog.pg_isolation_test_session_is_blocked($1, '{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The spec syntax requires at least one session; assume that here. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><name><name>conns</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>backend_pid_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backend_pid_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>, <argument><expr><literal type="string">"}')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQprepare</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name>PREP_WAITING</name></expr></argument>, <argument><expr><name><name>wait_query</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"prepare of lock wait query failed: %s"</literal></expr></argument>,
				<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the permutations specified in the spec, or all if none were
	 * explicitly specified.
	 */</comment>
	<expr_stmt><expr><call><name>run_testspec</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validity-check the test spec and fill in cross-links between nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nallsteps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Step</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>allsteps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<comment type="block">/* Create a sorted lookup table of all steps. */</comment>
	<expr_stmt><expr><name>nallsteps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nallsteps</name> <operator>+=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>allsteps</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nallsteps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>allsteps</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>steps</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>allsteps</name></expr></argument>, <argument><expr><name>nallsteps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>step_qsort_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify that all step names are unique. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nallsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>allsteps</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
				   <argument><expr><name><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"duplicate step name: %s\n"</literal></expr></argument>,
					<argument><expr><name><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Set the session index fields in steps. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Session</name>    <modifier>*</modifier></type><name>session</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>session</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>session</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we have manually-specified permutations, link PermutationSteps to
	 * Steps, and fill in blocker links.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>npermutations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Permutation</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Step</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>this</name> <init>= <expr><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><name><name>pstep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												 <argument><expr><name>allsteps</name></expr></argument>,
												 <argument><expr><name>nallsteps</name></expr></argument>,
												 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Step</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
												 <argument><expr><name>step_bsearch_cmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"undefined step \"%s\" specified in permutation\n"</literal></expr></argument>,
						<argument><expr><name><name>pstep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pstep</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;</expr_stmt>

			<comment type="block">/* Mark the step used, for check below */</comment>
			<expr_stmt><expr><name><name>pstep</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Identify any blocker steps.  We search only the current
		 * permutation, since steps not used there couldn't be concurrent.
		 * Note that it's OK to reference later permutation steps, so this
		 * can't be combined with the previous loop.
		 */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pstep</name><operator>-&gt;</operator><name>nblockers</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PermutationStepBlocker</name> <modifier>*</modifier></type><name>blocker</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>blockers</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>blocktype</name></name> <operator>==</operator> <name>PSB_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* nothing to link to */</comment>

				<expr_stmt><expr><name><name>blocker</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>otherp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>otherp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>blocker</name><operator>-&gt;</operator><name>stepname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>blocker</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <name><name>otherp</name><operator>-&gt;</operator><name>step</name></name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>step</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"undefined blocking step \"%s\" referenced in permutation step \"%s\"\n"</literal></expr></argument>,
							<argument><expr><name><name>blocker</name><operator>-&gt;</operator><name>stepname</name></name></expr></argument>, <argument><expr><name><name>pstep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* can't block on completion of step of own session */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>session</name></name> <operator>==</operator> <name><name>pstep</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"permutation step \"%s\" cannot block on its own session\n"</literal></expr></argument>,
							<argument><expr><name><name>pstep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we have manually-specified permutations, verify that all steps have
	 * been used, warning about anything defined but not used.  We can skip
	 * this when using automatically-generated permutations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nallsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>used</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unused step name: %s\n"</literal></expr></argument>, <argument><expr><name><name>allsteps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>allsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run the permutations specified in the spec, or all if none were
 * explicitly specified.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_testspec</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>run_named_permutations</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>run_all_permutations</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run all permutations of the steps and sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_all_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsteps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>steps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>stepptrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>piles</name></decl>;</decl_stmt>

	<comment type="block">/* Count the total number of steps in all sessions */</comment>
	<expr_stmt><expr><name>nsteps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nsteps</name> <operator>+=</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Create PermutationStep workspace array */</comment>
	<expr_stmt><expr><name>steps</name> <operator>=</operator> <operator>(</operator><name>PermutationStep</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PermutationStep</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stepptrs</name> <operator>=</operator> <operator>(</operator><name>PermutationStep</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PermutationStep</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stepptrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>steps</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * To generate the permutations, we conceptually put the steps of each
	 * session on a pile. To generate a permutation, we pick steps from the
	 * piles until all piles are empty. By picking steps from piles in
	 * different order, we get different permutations.
	 *
	 * A pile is actually just an integer which tells how many steps we've
	 * already picked from this pile.
	 */</comment>
	<expr_stmt><expr><name>piles</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>run_all_permutations_recurse</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>piles</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>stepptrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>stepptrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>piles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_all_permutations_recurse</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piles</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* If there's any more steps in this pile, pick it and recurse */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nsteps</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>newstep</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>steps</name><index>[<expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * These automatically-generated PermutationSteps never have
			 * blocker conditions.  So we need only fill these fields, relying
			 * on run_all_permutations() to have zeroed the rest:
			 */</comment>
			<expr_stmt><expr><name><name>steps</name><index>[<expr><name>nsteps</name></expr>]</index></name><operator>-&gt;</operator><name>name</name> <operator>=</operator> <name><name>newstep</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>steps</name><index>[<expr><name>nsteps</name></expr>]</index></name><operator>-&gt;</operator><name>step</name> <operator>=</operator> <name>newstep</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>run_all_permutations_recurse</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>piles</name></expr></argument>, <argument><expr><name>nsteps</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>piles</name><index>[<expr><name>i</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If all the piles were empty, this permutation is completed. Run it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>run_permutation</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>nsteps</name></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run permutations given in the test spec
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_named_permutations</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>npermutations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Permutation</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>testspec</name><operator>-&gt;</operator><name>permutations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>run_permutation</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nsteps</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>step_qsort_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>stepa</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>stepb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stepa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stepb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>step_bsearch_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stepname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Step</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>stepname</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Run one permutation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_permutation</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsteps</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwaiting</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>waiting</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>waiting</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PermutationStep</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nstarting permutation:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>steps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform setup */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsetupsqls</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>setupsqls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setup failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Perform per-session setup */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>setupsql</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>setupsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"setup of session %s failed: %s"</literal></expr></argument>,
						<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sessionname</name></expr></argument>,
						<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Perform steps */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsteps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name> <init>= <expr><name><name>steps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>step</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>step</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IsoConnInfo</name> <modifier>*</modifier></type><name>iconn</name> <init>= <expr><operator>&amp;</operator><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>iconn</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether the session that needs to perform the next step is
		 * still blocked on an earlier step.  If so, wait for it to finish.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_time</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>oldstep</name> <init>= <expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Wait for oldstep.  But even though we don't use
				 * STEP_NONBLOCK, it might not complete because of blocker
				 * conditions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_complete_step</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>oldstep</name></expr></argument>, <argument><expr><name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Done, so remove oldstep from the waiting[] array. */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>w</name></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>oldstep</name> <operator>==</operator> <name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></for>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&gt;=</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* can't happen */</comment>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								<argument><expr><operator>(</operator><name>nwaiting</name> <operator>-</operator> <operator>(</operator><name>w</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PermutationStep</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>nwaiting</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Check for other steps that have finished.  We should do
				 * this if oldstep completed, as it might have unblocked
				 * something.  On the other hand, if oldstep hasn't completed,
				 * we must poll all the active steps in hopes of unblocking
				 * oldstep.  So either way, poll them.
				 */</comment>
				<expr_stmt><expr><name>nwaiting</name> <operator>=</operator> <call><name>try_complete_steps</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>waiting</name></expr></argument>, <argument><expr><name>nwaiting</name></expr></argument>,
											  <argument><expr><name>STEP_NONBLOCK</name> <operator>|</operator> <name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the target session is still busy, apply a timeout to
				 * keep from hanging indefinitely, which could happen with
				 * incorrect blocker annotations.  Use the same 2 *
				 * max_step_wait limit as try_complete_step does for deciding
				 * to die.  (We don't bother with trying to cancel anything,
				 * since it's unclear what to cancel in this case.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>current_time</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int64</name></type>		<name>td</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>td</name> <operator>*=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>td</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>td</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>max_step_wait</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"step %s timed out after %d seconds\n"</literal></expr></argument>,
								<argument><expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>td</name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"active steps are:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nconns</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>IsoConnInfo</name> <modifier>*</modifier></type><name>oconn</name> <init>= <expr><operator>&amp;</operator><name><name>conns</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>oconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
										<argument><expr><name><name>oconn</name><operator>-&gt;</operator><name>active_step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Send the query for this step. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"failed to send query for step %s: %s\n"</literal></expr></argument>,
					<argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember we launched a step. */</comment>
		<expr_stmt><expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>=</operator> <name>pstep</name></expr>;</expr_stmt>

		<comment type="block">/* Remember target number of NOTICEs for any blocker conditions. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pstep</name><operator>-&gt;</operator><name>nblockers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PermutationStepBlocker</name> <modifier>*</modifier></type><name>blocker</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>blockers</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>blocktype</name></name> <operator>==</operator> <name>PSB_NUM_NOTICES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>blocker</name><operator>-&gt;</operator><name>target_notices</name></name> <operator>=</operator> <name><name>blocker</name><operator>-&gt;</operator><name>num_notices</name></name> <operator>+</operator>
					<name><name>conns</name><index>[<expr><name><name>blocker</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>session</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>total_notices</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Try to complete this step without blocking.  */</comment>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>try_complete_step</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>pstep</name></expr></argument>, <argument><expr><name>STEP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for completion of any steps that were previously waiting. */</comment>
		<expr_stmt><expr><name>nwaiting</name> <operator>=</operator> <call><name>try_complete_steps</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>waiting</name></expr></argument>, <argument><expr><name>nwaiting</name></expr></argument>,
									  <argument><expr><name>STEP_NONBLOCK</name> <operator>|</operator> <name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this step is waiting, add it to the array of waiters. */</comment>
		<if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>waiting</name><index>[<expr><name>nwaiting</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pstep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Wait for any remaining queries. */</comment>
	<expr_stmt><expr><name>nwaiting</name> <operator>=</operator> <call><name>try_complete_steps</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name>waiting</name></expr></argument>, <argument><expr><name>nwaiting</name></expr></argument>, <argument><expr><name>STEP_RETRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nwaiting</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to complete permutation due to mutually-blocking steps\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Perform per-session teardown */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>teardownsql</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>teardownsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"teardown of session %s failed: %s"</literal></expr></argument>,
						<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sessionname</name></expr></argument>,
						<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* don't exit on teardown failure */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Perform teardown */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>testspec</name><operator>-&gt;</operator><name>teardownsql</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>teardownsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"teardown failed: %s"</literal></expr></argument>,
					<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* don't exit on teardown failure */</comment>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>waiting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check for completion of any waiting step(s).
 * Remove completed ones from the waiting[] array,
 * and return the new value of nwaiting.
 * See try_complete_step for the meaning of the flags.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>try_complete_steps</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier><modifier>*</modifier></type><name>waiting</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nwaiting</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_nwaiting</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_blocker</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Reset latch; we only care about notices received within loop. */</comment>
		<expr_stmt><expr><name>any_new_notice</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Likewise, these variables reset for each retry. */</comment>
		<expr_stmt><expr><name>old_nwaiting</name> <operator>=</operator> <name>nwaiting</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_blocker</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Scan the array, try to complete steps. */</comment>
		<while>while <condition>(<expr><name>w</name> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>try_complete_step</name><argument_list>(<argument><expr><name>testspec</name></expr></argument>, <argument><expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Still blocked, leave it alone. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name><operator>-&gt;</operator><name>nblockers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_blocker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>w</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Done, remove it from array. */</comment>
				<if_stmt><if>if <condition>(<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nwaiting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>waiting</name><index>[<expr><name>w</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
							<argument><expr><operator>(</operator><name>nwaiting</name> <operator>-</operator> <operator>(</operator><name>w</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PermutationStep</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>nwaiting</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If any of the still-waiting steps have blocker conditions attached,
		 * it's possible that one of the steps we examined afterwards has
		 * released them (either by completing, or by sending a NOTICE).  If
		 * any step completions or NOTICEs happened, repeat the loop until
		 * none occurs.  Without this provision, completion timing could vary
		 * depending on the order in which the steps appear in the array.
		 */</comment>
	</block_content>}</block> while <condition>(<expr><name>have_blocker</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nwaiting</name> <operator>&lt;</operator> <name>old_nwaiting</name> <operator>||</operator> <name>any_new_notice</name><operator>)</operator></expr>)</condition>;</do>
	<return>return <expr><name>nwaiting</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Our caller already sent the query associated with this step.  Wait for it
 * to either complete, or hit a blocking condition.
 *
 * When calling this function on behalf of a given step for a second or later
 * time, pass the STEP_RETRY flag.  Do not pass it on the first call.
 *
 * Returns true if the step was *not* completed, false if it was completed.
 * Reasons for non-completion are (a) the STEP_NONBLOCK flag was specified
 * and the query is waiting to acquire a lock, or (b) the step has an
 * unsatisfied blocker condition.  When STEP_NONBLOCK is given, we assume
 * that any lock wait will persist until we have executed additional steps.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>try_complete_step</name><parameter_list>(<parameter><decl><type><name>TestSpec</name> <modifier>*</modifier></type><name>testspec</name></decl></parameter>, <parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Step</name>	   <modifier>*</modifier></type><name>step</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>step</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IsoConnInfo</name> <modifier>*</modifier></type><name>iconn</name> <init>= <expr><operator>&amp;</operator><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>iconn</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>read_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>notify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>canceled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the step is annotated with (*), then on the first call, force it to
	 * wait.  This is useful for ensuring consistent output when the step
	 * might or might not complete so fast that we don't observe it waiting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstep</name><operator>-&gt;</operator><name>nblockers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PermutationStepBlocker</name> <modifier>*</modifier></type><name>blocker</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>blockers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>blocktype</name></name> <operator>==</operator> <name>PSB_ONCE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s &lt;waiting ...&gt;\n"</literal></expr></argument>,
					   <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>	<comment type="block">/* Check for lock waits every 10ms. */</comment>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_set</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* error in select() */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"select failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* select() timeout: check for lock wait */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>current_time</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>td</name></decl>;</decl_stmt>

			<comment type="block">/* If it's OK for the step to block, check whether it has. */</comment>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STEP_NONBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>waiting</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexecPrepared</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>, <argument><expr><name>PREP_WAITING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>conns</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>session</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>backend_pid_str</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
					<call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lock wait query failed: %s"</literal></expr></argument>,
							<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>waiting</name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>waiting</name></expr>)</condition>	<comment type="block">/* waiting to acquire a lock */</comment>
				<block>{<block_content>
					<comment type="block">/*
					 * Since it takes time to perform the lock-check query,
					 * some data --- notably, NOTICE messages --- might have
					 * arrived since we looked.  We must call PQconsumeInput
					 * and then PQisBusy to collect and process any such
					 * messages.  In the (unlikely) case that PQisBusy then
					 * returns false, we might as well go examine the
					 * available result.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQconsumeInput failed: %s\n"</literal></expr></argument>,
								<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * conn is still busy, so conclude that the step really is
					 * waiting.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s &lt;waiting ...&gt;\n"</literal></expr></argument>,
							   <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else, not waiting */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Figure out how long we've been waiting for this step. */</comment>
			<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>td</name> <operator>*=</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>td</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>current_time</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>start_time</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * After max_step_wait microseconds, try to cancel the query.
			 *
			 * If the user tries to test an invalid permutation, we don't want
			 * to hang forever, especially when this is running in the
			 * buildfarm.  This will presumably lead to this permutation
			 * failing, but remaining permutations and tests should still be
			 * OK.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>td</name> <operator>&gt;</operator> <name>max_step_wait</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>canceled</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name> <init>= <expr><call><name>PQgetCancel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>cancel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * print to stdout not stderr, as this should appear
						 * in the test case's results
						 */</comment>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"isolationtester: canceling step %s after %d seconds\n"</literal></expr></argument>,
							   <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>td</name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>canceled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQcancel failed: %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * After twice max_step_wait, just give up and die.
			 *
			 * Since cleanup steps won't be run in this case, this may cause
			 * later tests to fail.  That stinks, but it's better than waiting
			 * forever for the server to respond to the cancel.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>td</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>max_step_wait</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"step %s timed out after %d seconds\n"</literal></expr></argument>,
						<argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>td</name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* select(): data available */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"PQconsumeInput failed: %s\n"</literal></expr></argument>,
					<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * The step is done, but we won't report it as complete so long as there
	 * are blockers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>step_has_blocker</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s &lt;waiting ...&gt;\n"</literal></expr></argument>,
				   <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise, go ahead and complete it. */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STEP_RETRY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: &lt;... completed&gt;\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"step %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
			<case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
				<expr_stmt><expr><call><name>printResultSet</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>

				<comment type="block">/*
				 * Detail may contain XID values, so we want to just show
				 * primary.  Beware however that libpq-generated error results
				 * may not contain subfields, only an old-style message.
				 */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sev</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
														 <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
														 <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>sev</name> <operator>&amp;&amp;</operator> <name>msg</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:  %s\n"</literal></expr></argument>, <argument><expr><name>sev</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unexpected result status: %s\n"</literal></expr></argument>,
					   <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Report any available NOTIFY messages, too */</comment>
	<expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>notify</name> <operator>=</operator> <call><name>PQnotifies</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try to identify which session it came from */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sendername</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>pidstring</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>testspec</name><operator>-&gt;</operator><name>nsessions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>notify</name><operator>-&gt;</operator><name>be_pid</name></name> <operator>==</operator> <name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>backend_pid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sendername</name> <operator>=</operator> <name><name>conns</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sessionname</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>sendername</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Doesn't seem to be any test session, so show the hard way */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pidstring</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pidstring</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PID %d"</literal></expr></argument>, <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendername</name> <operator>=</operator> <name>pidstring</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: NOTIFY \"%s\" with payload \"%s\" from %s\n"</literal></expr></argument>,
			   <argument><expr><name><name>testspec</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>,
			   <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>notify</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><name>sendername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Connection is now idle. */</comment>
	<expr_stmt><expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Detect whether a step has any unsatisfied blocker conditions */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>step_has_blocker</name><parameter_list>(<parameter><decl><type><name>PermutationStep</name> <modifier>*</modifier></type><name>pstep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pstep</name><operator>-&gt;</operator><name>nblockers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PermutationStepBlocker</name> <modifier>*</modifier></type><name>blocker</name> <init>= <expr><name><name>pstep</name><operator>-&gt;</operator><name>blockers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IsoConnInfo</name> <modifier>*</modifier></type><name>iconn</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>blocker</name><operator>-&gt;</operator><name>blocktype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PSB_ONCE</name></expr>:</case>
				<comment type="block">/* Ignore; try_complete_step handles this specially */</comment>
				<break>break;</break>
			<case>case <expr><name>PSB_OTHER_STEP</name></expr>:</case>
				<comment type="block">/* Block if referenced step is active */</comment>
				<expr_stmt><expr><name>iconn</name> <operator>=</operator> <operator>&amp;</operator><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>blocker</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>iconn</name><operator>-&gt;</operator><name>active_step</name></name> <operator>&amp;&amp;</operator>
					<name><name>iconn</name><operator>-&gt;</operator><name>active_step</name><operator>-&gt;</operator><name>step</name></name> <operator>==</operator> <name><name>blocker</name><operator>-&gt;</operator><name>step</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>PSB_NUM_NOTICES</name></expr>:</case>
				<comment type="block">/* Block if not enough notices received yet */</comment>
				<expr_stmt><expr><name>iconn</name> <operator>=</operator> <operator>&amp;</operator><name><name>conns</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name><name>blocker</name><operator>-&gt;</operator><name>step</name><operator>-&gt;</operator><name>session</name></name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>iconn</name><operator>-&gt;</operator><name>total_notices</name></name> <operator>&lt;</operator> <name><name>blocker</name><operator>-&gt;</operator><name>target_notices</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printResultSet</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQprintOpt</name></type>	<name>popt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>popt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>popt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>popt</name><operator>.</operator><name>header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>popt</name><operator>.</operator><name>align</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>popt</name><operator>.</operator><name>fieldSep</name></name> <operator>=</operator> <literal type="string">"|"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQprint</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>popt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* notice processor for regular user sessions */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>isotesterNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IsoConnInfo</name> <modifier>*</modifier></type><name>myconn</name> <init>= <expr><operator>(</operator><name>IsoConnInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Prefix the backend's message with the session name. */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name><name>myconn</name><operator>-&gt;</operator><name>sessionname</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Record notices, since we may need this to decide to unblock a step. */</comment>
	<expr_stmt><expr><name><name>myconn</name><operator>-&gt;</operator><name>total_notices</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>any_new_notice</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* notice processor, hides the message */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>blackholeNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* do nothing */</comment>
</block_content>}</block></function>
</unit>
