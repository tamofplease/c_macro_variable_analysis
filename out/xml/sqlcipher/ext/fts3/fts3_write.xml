<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/fts3/fts3_write.c"><comment type="block">/*
** 2009 Oct 23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file is part of the SQLite FTS3 extension module. Specifically,
** this file contains code to insert, update and delete rows from FTS3
** tables. It also contains code to merge FTS3 b-tree segments. Some
** of the sub-routines used to merge segments are also used by the query 
** code in fts3.c.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS_MAX_APPENDABLE_HEIGHT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
** When full-text index nodes are loaded from disk, the buffer that they
** are loaded into has the following number of bytes of padding at the end 
** of it. i.e. if a full-text index node is 900 bytes in size, then a buffer
** of 920 bytes is allocated for it.
**
** This means that if we have a pointer into a buffer containing node data,
** it is always safe to read up to two varints from it without risking an
** overread, even if the node data is corrupted.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_NODE_PADDING</name></cpp:macro> <cpp:value>(FTS3_VARINT_MAX*2)</cpp:value></cpp:define>

<comment type="block">/*
** Under certain circumstances, b-tree nodes (doclists) can be loaded into
** memory incrementally instead of all at once. This can be a big performance
** win (reduced IO and CPU) if SQLite stops calling the virtual table xNext()
** method before retrieving all query results (as may happen, for example,
** if a query has a LIMIT clause).
**
** Incremental loading is used for b-tree nodes FTS3_NODE_CHUNK_THRESHOLD 
** bytes and larger. Nodes are loaded in chunks of FTS3_NODE_CHUNKSIZE bytes.
** The code is written so that the hard lower-limit for each of these values 
** is 1. Clearly such small values would be inefficient, but can be useful 
** for testing purposes.
**
** If this module is built with SQLITE_TEST defined, these constants may
** be overridden at runtime for testing purposes. File fts3_test.c contains
** a Tcl interface to read and write the values.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>test_fts3_node_chunksize</name> <init>= <expr><operator>(</operator><literal type="number">4</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>test_fts3_node_chunk_threshold</name> <init>= <expr><operator>(</operator><literal type="number">4</literal><operator>*</operator><literal type="number">1024</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_NODE_CHUNKSIZE</name></cpp:macro>       <cpp:value>test_fts3_node_chunksize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_NODE_CHUNK_THRESHOLD</name></cpp:macro> <cpp:value>test_fts3_node_chunk_threshold</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_NODE_CHUNKSIZE</name></cpp:macro> <cpp:value>(4*1024)</cpp:value></cpp:define> 
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_NODE_CHUNK_THRESHOLD</name></cpp:macro> <cpp:value>(FTS3_NODE_CHUNKSIZE*4)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The values that may be meaningfully bound to the :1 parameter in
** statements SQL_REPLACE_STAT and SQL_SELECT_STAT.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS_STAT_DOCTOTAL</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS_STAT_INCRMERGEHINT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS_STAT_AUTOINCRMERGE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
** If FTS_LOG_MERGES is defined, call sqlite3_log() to report each automatic
** and incremental merge operation that takes place. This is used for 
** debugging FTS only, it should not usually be turned on in production
** systems.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FTS3_LOG_MERGES</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3LogMerge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr><literal type="string">"%d-way merge from level %d"</literal></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fts3LogMerge</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><name><name>struct</name> <name>PendingList</name></name></type> <name>PendingList</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SegmentNode</name></name></type> <name>SegmentNode</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SegmentWriter</name></name></type> <name>SegmentWriter</name>;</typedef>

<comment type="block">/*
** An instance of the following data structure is used to build doclists
** incrementally. See function fts3PendingListAppend() for details.
*/</comment>
<struct>struct <name>PendingList</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLastDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLastCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLastPos</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** Each cursor has a (possibly empty) linked list of the following objects.
*/</comment>
<struct>struct <name>Fts3DeferredToken</name> <block>{
  <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>        <comment type="block">/* Pointer to corresponding expr token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Column token must occur in */</comment>
  <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>       <comment type="block">/* Next in list of deferred tokens */</comment>
  <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>             <comment type="block">/* Doclist is assembled here */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of this structure is used to iterate through the terms on
** a contiguous set of segment b-tree leaf nodes. Although the details of
** this structure are only manipulated by code in this file, opaque handles
** of type Fts3SegReader* are also used by code in fts3.c to iterate through
** terms when querying the full-text index. See functions:
**
**   sqlite3Fts3SegReaderNew()
**   sqlite3Fts3SegReaderFree()
**   sqlite3Fts3SegReaderIterate()
**
** Methods used to manipulate Fts3SegReader structures:
**
**   fts3SegReaderNext()
**   fts3SegReaderFirstDocid()
**   fts3SegReaderNextDocid()
*/</comment>
<struct>struct <name>Fts3SegReader</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>                       <comment type="block">/* Index within level, or 0x7FFFFFFF for PT */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bLookup</name></decl>;</decl_stmt>                     <comment type="block">/* True for a lookup only */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>rootOnly</name></decl>;</decl_stmt>                    <comment type="block">/* True for a root-only reader */</comment>

  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iStartBlock</name></decl>;</decl_stmt>      <comment type="block">/* Rowid of first leaf block to traverse */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLeafEndBlock</name></decl>;</decl_stmt>    <comment type="block">/* Rowid of final leaf block to traverse */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEndBlock</name></decl>;</decl_stmt>        <comment type="block">/* Rowid of final block in segment (or 0) */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iCurrentBlock</name></decl>;</decl_stmt>    <comment type="block">/* Current leaf block (or 0) */</comment>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aNode</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to node data (or NULL) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNode</name></decl>;</decl_stmt>                      <comment type="block">/* Size of buffer at aNode (or 0) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPopulate</name></decl>;</decl_stmt>                  <comment type="block">/* If &gt;0, bytes of buffer aNode[] loaded */</comment>
  <decl_stmt><decl><type><name>sqlite3_blob</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>            <comment type="block">/* If not NULL, blob handle to read node */</comment>

  <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNextElem</name></decl>;</decl_stmt>

  <comment type="block">/* Variables set by fts3SegReaderNext(). These may be read directly
  ** by the caller. They are valid from the time SegmentReaderNew() returns
  ** until SegmentReaderNext() returns something other than SQLITE_OK
  ** (i.e. SQLITE_DONE).
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes in current term */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to current term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTermAlloc</name></decl>;</decl_stmt>                 <comment type="block">/* Allocated size of zTerm buffer */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl>;</decl_stmt>                 <comment type="block">/* Pointer to doclist of current entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoclist</name></decl>;</decl_stmt>                   <comment type="block">/* Size of doclist in current entry */</comment>

  <comment type="block">/* The following variables are used by fts3SegReaderNextDocid() to iterate 
  ** through the current doclist (aDoclist/nDoclist).
  */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pOffsetList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOffsetList</name></decl>;</decl_stmt>                <comment type="block">/* For descending pending seg-readers only */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fts3SegReaderIsPending</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;ppNextElem!=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fts3SegReaderIsRootOnly</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)-&gt;rootOnly!=0)</cpp:value></cpp:define>

<comment type="block">/*
** An instance of this structure is used to create a segment b-tree in the
** database. The internal details of this type are only accessed by the
** following functions:
**
**   fts3SegWriterAdd()
**   fts3SegWriterFlush()
**   fts3SegWriterFree()
*/</comment>
<struct>struct <name>SegmentWriter</name> <block>{
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pTree</name></decl>;</decl_stmt>             <comment type="block">/* Pointer to interior tree structure */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iFirst</name></decl>;</decl_stmt>           <comment type="block">/* First slot in %_segments written */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iFree</name></decl>;</decl_stmt>            <comment type="block">/* Next free slot in %_segments */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to previous term buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes in zTerm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMalloc</name></decl>;</decl_stmt>                    <comment type="block">/* Size of malloc'd buffer at zMalloc */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMalloc</name></decl>;</decl_stmt>                  <comment type="block">/* Malloc'd space (possibly) used for zTerm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSize</name></decl>;</decl_stmt>                      <comment type="block">/* Size of allocation at aData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes of data in aData */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to block from malloc() */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nLeafData</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes of leaf data written */</comment>
}</block>;</struct>

<comment type="block">/*
** Type SegmentNode is used by the following three functions to create
** the interior part of the segment b+-tree structures (everything except
** the leaf nodes). These functions and type are only ever used by code
** within the fts3SegWriterXXX() family of functions described above.
**
**   fts3NodeAddTerm()
**   fts3NodeWrite()
**   fts3NodeFree()
**
** When a b+tree is written to the database (either as a result of a merge
** or the pending-terms table being flushed), leaves are written into the 
** database file as soon as they are completely populated. The interior of
** the tree is assembled in memory and written out only once all leaves have
** been populated and stored. This is Ok, as the b+-tree fanout is usually
** very large, meaning that the interior of the tree consumes relatively 
** little memory.
*/</comment>
<struct>struct <name>SegmentNode</name> <block>{
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pParent</name></decl>;</decl_stmt>           <comment type="block">/* Parent node (or NULL for root node) */</comment>
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pRight</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to right-sibling */</comment>
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pLeftmost</name></decl>;</decl_stmt>         <comment type="block">/* Pointer to left-most node of this depth */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>                     <comment type="block">/* Number of terms written to node so far */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to previous term buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes in zTerm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMalloc</name></decl>;</decl_stmt>                    <comment type="block">/* Size of malloc'd buffer at zMalloc */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMalloc</name></decl>;</decl_stmt>                  <comment type="block">/* Malloc'd space (possibly) used for zTerm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes of valid data so far */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Node data */</comment>
}</block>;</struct>

<comment type="block">/*
** Valid values for the second argument to fts3SqlStmt().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_CONTENT</name></cpp:macro>             <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_IS_EMPTY</name></cpp:macro>                   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_CONTENT</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_SEGMENTS</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_SEGDIR</name></cpp:macro>          <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_DOCSIZE</name></cpp:macro>         <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_STAT</name></cpp:macro>            <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_CONTENT_BY_ROWID</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_NEXT_SEGMENT_INDEX</name></cpp:macro>         <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_INSERT_SEGMENTS</name></cpp:macro>            <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_NEXT_SEGMENTS_ID</name></cpp:macro>          <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_INSERT_SEGDIR</name></cpp:macro>             <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_LEVEL</name></cpp:macro>              <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_LEVEL_RANGE</name></cpp:macro>        <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_LEVEL_COUNT</name></cpp:macro>        <cpp:value>14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_SEGDIR_MAX_LEVEL</name></cpp:macro>   <cpp:value>15</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_SEGDIR_LEVEL</name></cpp:macro>       <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_SEGMENTS_RANGE</name></cpp:macro>     <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_CONTENT_INSERT</name></cpp:macro>            <cpp:value>18</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_DOCSIZE</name></cpp:macro>            <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_REPLACE_DOCSIZE</name></cpp:macro>           <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_DOCSIZE</name></cpp:macro>            <cpp:value>21</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_STAT</name></cpp:macro>               <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_REPLACE_STAT</name></cpp:macro>              <cpp:value>23</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_ALL_PREFIX_LEVEL</name></cpp:macro>   <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_ALL_TERMS_SEGDIR</name></cpp:macro>   <cpp:value>25</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_SEGDIR_RANGE</name></cpp:macro>       <cpp:value>26</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_ALL_LANGID</name></cpp:macro>         <cpp:value>27</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_FIND_MERGE_LEVEL</name></cpp:macro>          <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_MAX_LEAF_NODE_ESTIMATE</name></cpp:macro>    <cpp:value>29</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_DELETE_SEGDIR_ENTRY</name></cpp:macro>       <cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SHIFT_SEGDIR_ENTRY</name></cpp:macro>        <cpp:value>31</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_SEGDIR</name></cpp:macro>             <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_CHOMP_SEGDIR</name></cpp:macro>              <cpp:value>33</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SEGMENT_IS_APPENDABLE</name></cpp:macro>     <cpp:value>34</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_INDEXES</name></cpp:macro>            <cpp:value>35</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_MXLEVEL</name></cpp:macro>            <cpp:value>36</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_SELECT_LEVEL_RANGE2</name></cpp:macro>       <cpp:value>37</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_UPDATE_LEVEL_IDX</name></cpp:macro>          <cpp:value>38</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_UPDATE_LEVEL</name></cpp:macro>              <cpp:value>39</cpp:value></cpp:define>

<comment type="block">/*
** This function is used to obtain an SQLite prepared statement handle
** for the statement identified by the second argument. If successful,
** *pp is set to the requested statement handle and SQLITE_OK returned.
** Otherwise, an SQLite error code is returned and *pp is set to 0.
**
** If argument apVal is not NULL, then it must point to an array with
** at least as many entries as the requested statement has bound 
** parameters. The values are bound to the statements parameters before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SqlStmt</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>eStmt</name></decl></parameter>,                      <comment type="block">/* One of the SQL_XXX constants above */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,              <comment type="block">/* OUT: Statement handle */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>           <comment type="block">/* Values to bind to statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azSql</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* 0  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_content' WHERE rowid = ?"</literal></expr>,
<comment type="block">/* 1  */</comment>  <expr><literal type="string">"SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)"</literal></expr>,
<comment type="block">/* 2  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_content'"</literal></expr>,
<comment type="block">/* 3  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_segments'"</literal></expr>,
<comment type="block">/* 4  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_segdir'"</literal></expr>,
<comment type="block">/* 5  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_docsize'"</literal></expr>,
<comment type="block">/* 6  */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_stat'"</literal></expr>,
<comment type="block">/* 7  */</comment>  <expr><literal type="string">"SELECT %s WHERE rowid=?"</literal></expr>,
<comment type="block">/* 8  */</comment>  <expr><literal type="string">"SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1"</literal></expr>,
<comment type="block">/* 9  */</comment>  <expr><literal type="string">"REPLACE INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)"</literal></expr>,
<comment type="block">/* 10 */</comment>  <expr><literal type="string">"SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)"</literal></expr>,
<comment type="block">/* 11 */</comment>  <expr><literal type="string">"REPLACE INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)"</literal></expr>,

          <comment type="block">/* Return segments in order from oldest to newest.*/</comment> 
<comment type="block">/* 12 */</comment>  <expr><literal type="string">"SELECT idx, start_block, leaves_end_block, end_block, root "</literal>
            <literal type="string">"FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC"</literal></expr>,
<comment type="block">/* 13 */</comment>  <expr><literal type="string">"SELECT idx, start_block, leaves_end_block, end_block, root "</literal>
            <literal type="string">"FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?"</literal>
            <literal type="string">"ORDER BY level DESC, idx ASC"</literal></expr>,

<comment type="block">/* 14 */</comment>  <expr><literal type="string">"SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?"</literal></expr>,
<comment type="block">/* 15 */</comment>  <expr><literal type="string">"SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?"</literal></expr>,

<comment type="block">/* 16 */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_segdir' WHERE level = ?"</literal></expr>,
<comment type="block">/* 17 */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?"</literal></expr>,
<comment type="block">/* 18 */</comment>  <expr><literal type="string">"INSERT INTO %Q.'%q_content' VALUES(%s)"</literal></expr>,
<comment type="block">/* 19 */</comment>  <expr><literal type="string">"DELETE FROM %Q.'%q_docsize' WHERE docid = ?"</literal></expr>,
<comment type="block">/* 20 */</comment>  <expr><literal type="string">"REPLACE INTO %Q.'%q_docsize' VALUES(?,?)"</literal></expr>,
<comment type="block">/* 21 */</comment>  <expr><literal type="string">"SELECT size FROM %Q.'%q_docsize' WHERE docid=?"</literal></expr>,
<comment type="block">/* 22 */</comment>  <expr><literal type="string">"SELECT value FROM %Q.'%q_stat' WHERE id=?"</literal></expr>,
<comment type="block">/* 23 */</comment>  <expr><literal type="string">"REPLACE INTO %Q.'%q_stat' VALUES(?,?)"</literal></expr>,
<comment type="block">/* 24 */</comment>  <expr><literal type="string">""</literal></expr>,
<comment type="block">/* 25 */</comment>  <expr><literal type="string">""</literal></expr>,

<comment type="block">/* 26 */</comment> <expr><literal type="string">"DELETE FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?"</literal></expr>,
<comment type="block">/* 27 */</comment> <expr><literal type="string">"SELECT ? UNION SELECT level / (1024 * ?) FROM %Q.'%q_segdir'"</literal></expr>,

<comment type="block">/* This statement is used to determine which level to read the input from
** when performing an incremental merge. It returns the absolute level number
** of the oldest level in the db that contains at least ? segments. Or,
** if no level in the FTS index contains more than ? segments, the statement
** returns zero rows.  */</comment>
<comment type="block">/* 28 */</comment> <expr><literal type="string">"SELECT level, count(*) AS cnt FROM %Q.'%q_segdir' "</literal>
         <literal type="string">"  GROUP BY level HAVING cnt&gt;=?"</literal>
         <literal type="string">"  ORDER BY (level %% 1024) ASC, 2 DESC LIMIT 1"</literal></expr>,

<comment type="block">/* Estimate the upper limit on the number of leaf nodes in a new segment
** created by merging the oldest :2 segments from absolute level :1. See 
** function sqlite3Fts3Incrmerge() for details.  */</comment>
<comment type="block">/* 29 */</comment> <expr><literal type="string">"SELECT 2 * total(1 + leaves_end_block - start_block) "</literal>
         <literal type="string">"  FROM (SELECT * FROM %Q.'%q_segdir' "</literal>
         <literal type="string">"        WHERE level = ? ORDER BY idx ASC LIMIT ?"</literal>
         <literal type="string">"  )"</literal></expr>,

<comment type="block">/* SQL_DELETE_SEGDIR_ENTRY
**   Delete the %_segdir entry on absolute level :1 with index :2.  */</comment>
<comment type="block">/* 30 */</comment> <expr><literal type="string">"DELETE FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?"</literal></expr>,

<comment type="block">/* SQL_SHIFT_SEGDIR_ENTRY
**   Modify the idx value for the segment with idx=:3 on absolute level :2
**   to :1.  */</comment>
<comment type="block">/* 31 */</comment> <expr><literal type="string">"UPDATE %Q.'%q_segdir' SET idx = ? WHERE level=? AND idx=?"</literal></expr>,

<comment type="block">/* SQL_SELECT_SEGDIR
**   Read a single entry from the %_segdir table. The entry from absolute 
**   level :1 with index value :2.  */</comment>
<comment type="block">/* 32 */</comment>  <expr><literal type="string">"SELECT idx, start_block, leaves_end_block, end_block, root "</literal>
            <literal type="string">"FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?"</literal></expr>,

<comment type="block">/* SQL_CHOMP_SEGDIR
**   Update the start_block (:1) and root (:2) fields of the %_segdir
**   entry located on absolute level :3 with index :4.  */</comment>
<comment type="block">/* 33 */</comment>  <expr><literal type="string">"UPDATE %Q.'%q_segdir' SET start_block = ?, root = ?"</literal>
            <literal type="string">"WHERE level = ? AND idx = ?"</literal></expr>,

<comment type="block">/* SQL_SEGMENT_IS_APPENDABLE
**   Return a single row if the segment with end_block=? is appendable. Or
**   no rows otherwise.  */</comment>
<comment type="block">/* 34 */</comment>  <expr><literal type="string">"SELECT 1 FROM %Q.'%q_segments' WHERE blockid=? AND block IS NULL"</literal></expr>,

<comment type="block">/* SQL_SELECT_INDEXES
**   Return the list of valid segment indexes for absolute level ?  */</comment>
<comment type="block">/* 35 */</comment>  <expr><literal type="string">"SELECT idx FROM %Q.'%q_segdir' WHERE level=? ORDER BY 1 ASC"</literal></expr>,

<comment type="block">/* SQL_SELECT_MXLEVEL
**   Return the largest relative level in the FTS index or indexes.  */</comment>
<comment type="block">/* 36 */</comment>  <expr><literal type="string">"SELECT max( level %% 1024 ) FROM %Q.'%q_segdir'"</literal></expr>,

          <comment type="block">/* Return segments in order from oldest to newest.*/</comment> 
<comment type="block">/* 37 */</comment>  <expr><literal type="string">"SELECT level, idx, end_block "</literal>
            <literal type="string">"FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ? "</literal>
            <literal type="string">"ORDER BY level DESC, idx ASC"</literal></expr>,

          <comment type="block">/* Update statements used while promoting segments */</comment>
<comment type="block">/* 38 */</comment>  <expr><literal type="string">"UPDATE OR FAIL %Q.'%q_segdir' SET level=-1,idx=? "</literal>
            <literal type="string">"WHERE level=? AND idx=?"</literal></expr>,
<comment type="block">/* 39 */</comment>  <expr><literal type="string">"UPDATE OR FAIL %Q.'%q_segdir' SET level=? WHERE level=-1"</literal></expr>

  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>SizeofArray</name><argument_list>(<argument><expr><name>azSql</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aStmt</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eStmt</name><operator>&lt;</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name>azSql</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>eStmt</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aStmt</name><index>[<expr><name>eStmt</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>SQLITE_PREPARE_PERSISTENT</name><operator>|</operator><name>SQLITE_PREPARE_NO_VTAB</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eStmt</name><operator>==</operator><name>SQL_CONTENT_INSERT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name><name>azSql</name><index>[<expr><name>eStmt</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zWriteExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>eStmt</name><operator>==</operator><name>SQL_SELECT_CONTENT_BY_ROWID</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>f</name> <operator>&amp;=</operator> <operator>~</operator><name>SQLITE_PREPARE_NO_VTAB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name><name>azSql</name><index>[<expr><name>eStmt</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name><name>azSql</name><index>[<expr><name>eStmt</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v3</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aStmt</name><index>[<expr><name>eStmt</name></expr>]</index></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>apVal</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nParam</name> <init>= <expr><call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nParam</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SelectDocsize</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl></parameter>,           <comment type="block">/* Docid to bind for SQL_SELECT_DOCSIZE */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>           <comment type="block">/* OUT: Statement handle */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Statement requested from fts3SqlStmt() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>SQL_SELECT_DOCSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>||</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3SelectDoctotal</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>           <comment type="block">/* OUT: Statement handle */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>SQL_SELECT_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_DOCTOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_ROW</name>
     <operator>||</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3SelectDocsize</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl></parameter>,           <comment type="block">/* Docid to read size data for */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>           <comment type="block">/* OUT: Statement handle */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fts3SelectDocsize</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Similar to fts3SqlStmt(). Except, after binding the parameters in
** array apVal[] to the SQL statement identified by eStmt, the statement
** is executed.
**
** Returns SQLITE_OK if the statement is successfully executed, or an
** SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SqlExec</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>,                <comment type="block">/* Result code */</comment>
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The FTS3 table */</comment>
  <parameter><decl><type><name>int</name></type> <name>eStmt</name></decl></parameter>,               <comment type="block">/* Index of statement to evaluate */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>    <comment type="block">/* Parameters to bind */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function ensures that the caller has obtained an exclusive 
** shared-cache table-lock on the %_segdir table. This is required before 
** writing data to the fts3 table. If this lock is not acquired first, then
** the caller may end up attempting to take this lock as part of committing
** a transaction, causing SQLite to return SQLITE_LOCKED or 
** LOCKED_SHAREDCACHEto a COMMIT command.
**
** It is best to avoid this because if FTS3 returns any error when 
** committing a transaction, the whole transaction will be rolled back. 
** And this is not what users expect when they get SQLITE_LOCKED_SHAREDCACHE. 
** It can still happen if the user locks the underlying tables directly 
** instead of accessing them via FTS.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3Writelock</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGDIR_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** FTS maintains a separate indexes for each language-id (a 32-bit integer).
** Within each language id, a separate index is maintained to store the
** document terms, and each configured prefix size (configured the FTS 
** "prefix=" option). And each index consists of multiple levels ("relative
** levels").
**
** All three of these values (the language id, the specific index and the
** level within the index) are encoded in 64-bit integer values stored
** in the %_segdir table on disk. This function is used to convert three
** separate component values into the single 64-bit integer value that
** can be used to query the %_segdir table.
**
** Specifically, each language-id/index combination is allocated 1024 
** 64-bit integer level values ("absolute levels"). The main terms index
** for language-id 0 is allocate values 0-1023. The first prefix index
** (if any) for language-id 0 is allocated values 1024-2047. And so on.
** Language 1 indexes are allocated immediately following language 0.
**
** So, for a system with nPrefix prefix indexes configured, the block of
** absolute levels that corresponds to language-id iLangid and index 
** iIndex starts at absolute level ((iLangid * (nPrefix+1) + iIndex) * 1024).
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>getAbsoluteLevel</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index in p-&gt;aIndex[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>                      <comment type="block">/* Level of segments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBase</name></decl>;</decl_stmt>            <comment type="block">/* First absolute level for iLangid/iIndex */</comment>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>iLangid</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndex</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIndex</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iBase</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>iLangid</name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name> <operator>+</operator> <name>iIndex</name><operator>)</operator> <operator>*</operator> <name>FTS3_SEGDIR_MAXLEVEL</name></expr>;</expr_stmt>
  <return>return <expr><name>iBase</name> <operator>+</operator> <name>iLevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set *ppStmt to a statement handle that may be used to iterate through
** all rows in the %_segdir table, from oldest to newest. If successful,
** return SQLITE_OK. If an error occurs while preparing the statement, 
** return an SQLite error code.
**
** There is only ever one instance of this SQL statement compiled for
** each FTS3 table.
**
** The statement returns the following columns from the %_segdir table:
**
**   0: idx
**   1: start_block
**   2: leaves_end_block
**   3: end_block
**   4: root
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3AllSegdirs</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language being queried */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index for p-&gt;aIndex[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Level to select (relative level) */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>           <comment type="block">/* OUT: Compiled statement */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name> <operator>||</operator> <name>iLevel</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&lt;</operator><name>FTS3_SEGDIR_MAXLEVEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndex</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIndex</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* "SELECT * FROM %_segdir WHERE level BETWEEN ? AND ? ORDER BY ..." */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_LEVEL_RANGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
          <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>FTS3_SEGDIR_MAXLEVEL</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* "SELECT * FROM %_segdir WHERE level = ? ORDER BY ..." */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content> 
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>,<argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Append a single varint to a PendingList buffer. SQLITE_OK is returned
** if successful, or an SQLite error code otherwise.
**
** This function also serves to allocate the PendingList structure itself.
** For example, to create a new PendingList structure containing two
** varints:
**
**   PendingList *p = 0;
**   fts3PendingListAppendVarint(&amp;p, 1);
**   fts3PendingListAppendVarint(&amp;p, 2);
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PendingListAppendVarint</name><parameter_list>(
  <parameter><decl><type><name>PendingList</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,               <comment type="block">/* IN/OUT: Pointer to PendingList struct */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl></parameter>                 <comment type="block">/* Value to append to data */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Allocate or grow the PendingList as required. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSpace</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name>FTS3_VARINT_MAX</name><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSpace</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nSpace</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSpace</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Append the new serialized varint to the end of the list. */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a docid/column/position entry to a PendingList structure. Non-zero
** is returned if the structure is sqlite3_realloced as part of adding
** the entry. Otherwise, zero.
**
** If an OOM error occurs, *pRc is set to SQLITE_NOMEM before returning.
** Zero is always returned in this case. Otherwise, if no OOM error occurs,
** it is set to SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PendingListAppend</name><parameter_list>(
  <parameter><decl><type><name>PendingList</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,               <comment type="block">/* IN/OUT: PendingList structure */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl></parameter>,           <comment type="block">/* Docid for entry to add */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iCol</name></decl></parameter>,             <comment type="block">/* Column for entry to add */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iPos</name></decl></parameter>,             <comment type="block">/* Position of term for entry to add */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* OUT: Return code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>p</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastDocid</name></name><operator>&lt;=</operator><name>iDocid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastDocid</name></name><operator>!=</operator><name>iDocid</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u64</name></type> <name>iDelta</name> <init>= <expr><operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name> <operator>-</operator> <operator>(</operator><name>u64</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>iLastDocid</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nSpace</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>fts3PendingListAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>iDelta</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <goto>goto <name>pendinglistappend_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastCol</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastCol</name></name><operator>!=</operator><name>iCol</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>fts3PendingListAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
     <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>fts3PendingListAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <goto>goto <name>pendinglistappend_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPos</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>||</operator> <operator>(</operator><name>iPos</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingListAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>iPos</name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>pendinglistappend_out</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>!=</operator><operator>*</operator><name>pp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a PendingList object allocated by fts3PendingListAppend().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3PendingListDelete</name><parameter_list>(<parameter><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add an entry to one of the pending-terms hash tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PendingTermsAddOne</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,
  <parameter><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>,                <comment type="block">/* Pending terms hash table to add entry to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nToken</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pList</name> <operator>=</operator> <operator>(</operator><name>PendingList</name> <operator>*</operator><operator>)</operator><call><name>fts3HashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>-=</operator> <operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>nToken</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fts3PendingListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pList</name><operator>==</operator><call><name>fts3HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Malloc failed while inserting the new entry. This can only 
      ** happen if there was no previous entry for this token.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>fts3HashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>+=</operator> <operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>nToken</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Tokenize the nul-terminated string zText and add all tokens to the
** pending-terms hash-table. The docid used is that currently stored in
** p-&gt;iPrevDocid, and the column is specified by argument iCol.
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PendingTermsAdd</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Table into which text will be inserted */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id to use */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>,              <comment type="block">/* Text of document to be inserted */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column into which text is being inserted */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pnWord</name></decl></parameter>                     <comment type="block">/* IN/OUT: Incr. by number tokens inserted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWord</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xNext</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
      <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTokenizer</name> <operator>&amp;&amp;</operator> <name>pModule</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the user has inserted a NULL value, this function may be called with
  ** zText==0. In this case, add zero token entries to the hash table and 
  ** return early. */</comment>
  <if_stmt><if>if<condition>( <expr><name>zText</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnWord</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>xNext</name> <operator>=</operator> <name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name>
      <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>xNext</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPos</name><operator>&gt;=</operator><name>nWord</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nWord</name> <operator>=</operator> <name>iPos</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Positions cannot be negative; we use -1 as a terminator internally.
    ** Tokens must have a non-zero length.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPos</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>zToken</name> <operator>||</operator> <name>nToken</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add the term to the terms index */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsAddOne</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>hPending</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Add the term to each of the prefix indexes that it is not too 
    ** short for. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>Fts3Index</name></name> <modifier>*</modifier></type><name>pIndex</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&lt;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>nPrefix</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsAddOne</name><argument_list>(
          <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>hPending</name></name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>nPrefix</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnWord</name> <operator>+=</operator> <name>nWord</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Calling this function indicates that subsequent calls to 
** fts3PendingTermsAdd() are to add term/position-list pairs for the
** contents of the document with docid iDocid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PendingTermsDocid</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Full-text table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>bDelete</name></decl></parameter>,                    <comment type="block">/* True if this op is a delete */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id of row being written */</comment>
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>             <comment type="block">/* Docid of row being written */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLangid</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bDelete</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>bDelete</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TODO(shess) Explore whether partially flushing the buffer on
  ** forced-flush would provide better performance.  I suspect that if
  ** we ordered the doclists by size and flushed the largest until the
  ** buffer was half empty, that would let the less frequent terms
  ** generate longer doclists.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>iDocid</name><argument_list type="generic">&lt;<argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name> 
   <operator>||</operator> <operator>(</operator><name>iDocid</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bPrevDelete</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name><operator>!=</operator><name>iLangid</name>
   <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name></expr></argument>&gt;</argument_list></name><name><name>p</name><operator>-&gt;</operator><name>nMaxPendingData</name></name></expr> 
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3Fts3PendingTermsFlush</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name> <operator>=</operator> <name>iLangid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPrevDelete</name></name> <operator>=</operator> <name>bDelete</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Discard the contents of the pending-terms hash tables. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3PendingTermsClear</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier></type><name>pElem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hPending</name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pElem</name><operator>=</operator><call><name>fts3HashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name><operator>=</operator><call><name>fts3HashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><operator>(</operator><name>PendingList</name> <operator>*</operator><operator>)</operator><call><name>fts3HashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3PendingListDelete</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fts3HashClear</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the xUpdate() method as part of an INSERT
** operation. It adds entries for each term in the new record to the
** pendingTerms hash table.
**
** Argument apVal is the same as the similarly named argument passed to
** fts3InsertData(). Parameter iDocid is the docid of the new row.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3InsertTerms</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSz</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name>i</name><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3PendingTermsAdd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aSz</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>aSz</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name> <operator>+=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by the xUpdate() method for an INSERT operation.
** The apVal parameter is passed a copy of the apVal argument passed by
** SQLite to the xUpdate() method. i.e:
**
**   apVal[0]                Not used for INSERT.
**   apVal[1]                rowid
**   apVal[2]                Left-most user-defined column
**   ...
**   apVal[p-&gt;nColumn+1]     Right-most user-defined column
**   apVal[p-&gt;nColumn+2]     Hidden column with same name as table
**   apVal[p-&gt;nColumn+3]     Hidden "docid" column (alias for rowid)
**   apVal[p-&gt;nColumn+4]     Hidden languageid column
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3InsertData</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Full-text table */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>,          <comment type="block">/* Array of values to insert */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piDocid</name></decl></parameter>          <comment type="block">/* OUT: Docid for row just inserted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pContentInsert</name></decl>;</decl_stmt>   <comment type="block">/* INSERT INTO %_content VALUES(...) */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRowid</name> <init>= <expr><name><name>apVal</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pRowid</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRowid</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pRowid</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the statement handle used to insert data into the %_content
  ** table. The SQL for this statement is:
  **
  **   INSERT INTO %_content VALUES(?, ?, ?, ...)
  **
  ** The statement features N '?' variables, where N is the number of user
  ** defined columns in the FTS3 table, plus one for the docid field.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_CONTENT_INSERT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pContentInsert</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(
        <argument><expr><name>pContentInsert</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>, 
        <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* There is a quirk here. The users INSERT statement may have specified
  ** a value for the "rowid" field, for the "docid" field, or for both.
  ** Which is a problem, since "rowid" and "docid" are aliases for the
  ** same value. For example:
  **
  **   INSERT INTO fts3tbl(rowid, docid) VALUES(1, 2);
  **
  ** In FTS3, this is an error. It is an error to specify non-NULL values
  ** for both docid and some other rowid alias.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_NULL</name><operator>!=</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_NULL</name><operator>==</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <name>SQLITE_NULL</name><operator>!=</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <comment type="block">/* A rowid/docid conflict. */</comment>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pContentInsert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Execute the statement to insert the record. Set *piDocid to the 
  ** new docid value. 
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pContentInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pContentInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Remove all data from the FTS3 table. Clear the hash table containing
** pending terms.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DeleteAll</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bContent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <comment type="block">/* Discard the contents of the pending-terms hash table. */</comment>
  <expr_stmt><expr><call><name>sqlite3Fts3PendingTermsClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Delete everything from the shadow tables. Except, leave %_content as
  ** is if bContent is false.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bContent</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bContent</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_ALL_CONTENT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_ALL_SEGMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_ALL_SEGDIR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_ALL_DOCSIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_ALL_STAT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>langidFromSelect</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLanguageid</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iLangid</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>iLangid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The first element in the apVal[] array is assumed to contain the docid
** (an integer) of a row about to be deleted. Remove all terms from the
** full-text index.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3DeleteTerms</name><parameter_list>( 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>,               <comment type="block">/* Result code */</comment>
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,           <comment type="block">/* The FTS table to delete from */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>,  <comment type="block">/* The docid to be deleted */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSz</name></decl></parameter>,               <comment type="block">/* Sizes of deleted document written here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbFound</name></decl></parameter>            <comment type="block">/* OUT: Set to true if row really does exist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pbFound</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_CONTENT_BY_ROWID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><call><name>langidFromSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iDocid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsAdd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aSz</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aSz</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name> <operator>+=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pbFound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Forward declaration to account for the circular dependency between
** functions fts3SegmentMerge() and fts3AllocateSegdirIdx().
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegmentMerge</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* 
** This function allocates a new level iLevel index in the segdir table.
** Usually, indexes are allocated within a level sequentially starting
** with 0, so the allocated index is one greater than the value returned
** by:
**
**   SELECT max(idx) FROM %_segdir WHERE level = :iLevel
**
** However, if there are already FTS3_MERGE_COUNT indexes at the requested
** level, they are merged into a single level (iLevel+1) segment and the 
** allocated index is 0.
**
** If successful, *piIdx is set to the allocated index slot and SQLITE_OK
** returned. Otherwise, an SQLite error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3AllocateSegdirIdx</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index for p-&gt;aIndex */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIdx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pNextIdx</name></decl>;</decl_stmt>         <comment type="block">/* Query for next idx at level iLevel */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Result of query pNextIdx */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLangid</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set variable iNext to the next available segdir index at level iLevel. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_NEXT_SEGMENT_INDEX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNextIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(
        <argument><expr><name>pNextIdx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pNextIdx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iNext</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pNextIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pNextIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If iNext is FTS3_MERGE_COUNT, indicating that level iLevel is already
    ** full, merge all segments in level iLevel into a single iLevel+1
    ** segment and allocate (newly freed) index 0 at level iLevel. Otherwise,
    ** if iNext is less than FTS3_MERGE_COUNT, allocate index iNext.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>iNext</name><operator>&gt;=</operator><call><name>MergeCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3LogMerge</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegmentMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piIdx</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The %_segments table is declared as follows:
**
**   CREATE TABLE %_segments(blockid INTEGER PRIMARY KEY, block BLOB)
**
** This function reads data from a single row of the %_segments table. The
** specific row is identified by the iBlockid parameter. If paBlob is not
** NULL, then a buffer is allocated using sqlite3_malloc() and populated
** with the contents of the blob stored in the "block" column of the 
** identified table row is. Whether or not paBlob is NULL, *pnBlob is set
** to the size of the blob in bytes before returning.
**
** If an error occurs, or the table does not contain the specified row,
** an SQLite error code is returned. Otherwise, SQLITE_OK is returned. If
** paBlob is non-NULL, then it is the responsibility of the caller to
** eventually free the returned buffer.
**
** This function may leave an open sqlite3_blob* handle in the
** Fts3Table.pSegments variable. This handle is reused by subsequent calls
** to this function. The handle may be closed by calling the
** sqlite3Fts3SegmentsClose() function. Reusing a blob handle is a handy
** performance improvement, but the blob handle should always be closed
** before control is returned to the user (to prevent a lock being held
** on the database file for longer than necessary). Thus, any virtual table
** method (xFilter etc.) that may directly or indirectly call this function
** must call sqlite3Fts3SegmentsClose() before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3ReadBlock</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iBlockid</name></decl></parameter>,         <comment type="block">/* Access the row with blockid=$iBlockid */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paBlob</name></decl></parameter>,                  <comment type="block">/* OUT: Blob data in malloc'd buffer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBlob</name></decl></parameter>,                    <comment type="block">/* OUT: Size of blob data */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnLoad</name></decl></parameter>                     <comment type="block">/* OUT: Bytes actually loaded */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <comment type="block">/* pnBlob must be non-NULL. paBlob may be NULL or non-NULL. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pnBlob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_reopen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>zSegmentsTbl</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zSegmentsTbl</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s_segments"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>zSegmentsTbl</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_open</name><argument_list>(
       <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSegmentsTbl</name></name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>sqlite3_blob_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnBlob</name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>paBlob</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aByte</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name> <operator>+</operator> <name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aByte</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pnLoad</name> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&gt;</operator><operator>(</operator><name>FTS3_NODE_CHUNK_THRESHOLD</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>FTS3_NODE_CHUNKSIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pnLoad</name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_read</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr></argument>, <argument><expr><name>aByte</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aByte</name><index>[<expr><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>aByte</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>paBlob</name> <operator>=</operator> <name>aByte</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the blob handle at p-&gt;pSegments, if it is open. See comments above
** the sqlite3Fts3ReadBlock() function for details.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3SegmentsClose</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
    
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderIncrRead</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Number of bytes to read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>nRead</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name> <operator>-</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr></argument>, <argument><expr><name>FTS3_NODE_CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_blob_read</name><argument_list>(
      <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>, 
      <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr>]</index></name></expr></argument>,
      <argument><expr><name>nRead</name></expr></argument>,
      <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name> <operator>+=</operator> <name>nRead</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name><operator>==</operator><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderRequire</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name> 
       <operator>||</operator> <operator>(</operator><name>pFrom</name><operator>&gt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name> <operator>&amp;&amp;</operator> <name>pFrom</name><operator>&lt;</operator><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr>]</index></name><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
     <operator>&amp;&amp;</operator>  <operator>(</operator><name>pFrom</name> <operator>-</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name> <operator>+</operator> <name>nByte</name><operator>)</operator><operator>&gt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderIncrRead</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set an Fts3SegReader cursor to point at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SegReaderSetEof</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>fts3SegReaderIsRootOnly</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Move the iterator passed as the first argument to the next term in the
** segment. If successful, SQLITE_OK is returned. If there is no next term,
** SQLITE_DONE. Otherwise, an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bIncr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code of various sub-routines */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                    <comment type="block">/* Cursor variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes in term prefix */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes in term suffix */</comment>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNext</name> <operator>||</operator> <name>pNext</name><operator>&gt;=</operator><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>

    <if_stmt><if>if<condition>( <expr><call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier></type><name>pElem</name> <init>= <expr><operator>*</operator><operator>(</operator><name><name>pReader</name><operator>-&gt;</operator><name>ppNextElem</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pElem</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aCopy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PendingList</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><operator>(</operator><name>PendingList</name> <operator>*</operator><operator>)</operator><call><name>fts3HashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name> <init>= <expr><call><name>fts3HashKeysize</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nTerm</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nTermAlloc</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>nTerm</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nTermAlloc</name></name> <operator>=</operator> <operator>(</operator><name>nTerm</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><call><name>fts3HashKey</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name><index>[<expr><name>nTerm</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>aCopy</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aCopy</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aCopy</name></expr></argument>, <argument><expr><name><name>pList</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name> <operator>=</operator> <name>nCopy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <name>aCopy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>ppNextElem</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fts3SegReaderSetEof</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If iCurrentBlock&gt;=iLeafEndBlock, this is an EOF condition. All leaf 
    ** blocks have already been traversed.  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CORRUPT_DB</name></cpp:ifdef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>iCurrentBlock</name></name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>iLeafEndBlock</name></name> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>iCurrentBlock</name></name><operator>&gt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>iLeafEndBlock</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>++</operator><name><name>pReader</name><operator>-&gt;</operator><name>iCurrentBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument>, 
        <argument><expr><operator>(</operator><ternary><condition><expr><name>bIncr</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bIncr</name> <operator>&amp;&amp;</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name><operator>&lt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderRequire</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>FTS3_VARINT_MAX</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  
  <comment type="block">/* Because of the FTS3_NODE_PADDING bytes of padding, the following is 
  ** safe (no risk of overread) even if the node data is corrupted. */</comment>
  <expr_stmt><expr><name>pNext</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal> 
   <operator>||</operator> <operator>(</operator><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name></expr>]</index></name> <operator>-</operator> <name>pNext</name><operator>)</operator><operator>&lt;</operator><name>nSuffix</name>
   <operator>||</operator> <name>nPrefix</name><operator>&gt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nTerm</name></name></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Both nPrefix and nSuffix were read by fts3GetVarint32() and so are
  ** between 0 and 0x7FFFFFFF. But the sum of the two may cause integer
  ** overflow - hence the (i64) casts.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>i64</name><operator>)</operator><name>nPrefix</name><operator>+</operator><name>nSuffix</name><operator>&gt;</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>pReader</name><operator>-&gt;</operator><name>nTermAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nNew</name> <init>= <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nPrefix</name><operator>+</operator><name>nSuffix</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nTermAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderRequire</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>nSuffix</name><operator>+</operator><name>FTS3_VARINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nPrefix</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Check that the doclist does not appear to extend past the end of the
  ** b-tree node. And that the final byte of the doclist is 0x00. If either 
  ** of these statements is untrue, then the data structure is corrupt.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name> <operator>&gt;</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><operator>(</operator><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name><operator>-</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator>
   <operator>||</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the SegReader to point to the first docid in the doclist associated
** with the current term.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderFirstDocid</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name> <operator>&amp;&amp;</operator> <call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nOffsetList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3DoclistPrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name></expr></argument>, 
        <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nOffsetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderRequire</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name>FTS3_VARINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the SegReader to point to the next docid in the doclist
** associated with the current term.
** 
** If arguments ppOffsetList and pnOffsetList are not NULL, then 
** *ppOffsetList is set to point to the first column-offset list
** in the doclist entry (i.e. immediately past the docid varint).
** *pnOffsetList is set to the length of the set of column-offset
** lists, not including the nul-terminator byte. For example:
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderNextDocid</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>,         <comment type="block">/* Reader to advance to next docid */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOffsetList</name></decl></parameter>,            <comment type="block">/* OUT: Pointer to current position-list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOffsetList</name></decl></parameter>               <comment type="block">/* OUT: Length of *ppOffsetList in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name> <operator>&amp;&amp;</operator> <call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* A pending-terms seg-reader for an FTS4 table that uses order=desc.
    ** Pending-terms doclists are always built up in ascending order, so
    ** we have to iterate through them backwards here. */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ppOffsetList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOffsetList</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnOffsetList</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nOffsetList</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3DoclistPrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nOffsetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bEof</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bEof</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aDoclist</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nDoclist</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Pointer p currently points at the first byte of an offset list. The
    ** following block advances it to point one byte past the end of
    ** the same offset list. */</comment>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
  
      <comment type="block">/* The following line of code (and the "p++" below the while() loop) is
      ** normally all that is required to move pointer p to the desired 
      ** position. The exception is if this node is being loaded from disk
      ** incrementally and pointer "p" now points to the first byte past
      ** the populated part of pReader-&gt;aNode[].
      */</comment>
      <while>while<condition>( <expr><operator>*</operator><name>p</name> <operator>|</operator> <name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>p</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
      <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>p</name><operator>&lt;</operator><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pReader</name><operator>-&gt;</operator><name>nPopulate</name></name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderIncrRead</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  
    <comment type="block">/* If required, populate the output variables with a pointer to and the
    ** size of the previous offset-list.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>ppOffsetList</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOffsetList</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnOffsetList</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* List may have been edited in place by fts3EvalNearTrim() */</comment>
    <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  
    <comment type="block">/* If there are no more entries in the doclist, set pOffsetList to
    ** NULL. Otherwise, set Fts3SegReader.iDocid to the next docid and
    ** Fts3SegReader.pOffsetList to point to the next offset list before
    ** returning.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>&gt;=</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderRequire</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>FTS3_VARINT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u64</name></type> <name>iDelta</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pOffsetList</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>-</operator> <name>iDelta</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>+</operator> <name>iDelta</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>sqlite3Fts3MsrOvfl</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pMsr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOvfl</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgsz</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name><name>pMsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name> <init>= <expr><name><name>pMsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fts3SegReaderIsRootOnly</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> 
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>jj</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>jj</name><operator>=</operator><name><name>pReader</name><operator>-&gt;</operator><name>iStartBlock</name></name></expr>;</init> <condition><expr><name>jj</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>iLeafEndBlock</name></name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>jj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nBlob</name><operator>+</operator><literal type="number">35</literal><operator>)</operator><operator>&gt;</operator><name>pgsz</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nOvfl</name> <operator>+=</operator> <operator>(</operator><name>nBlob</name> <operator>+</operator> <literal type="number">34</literal><operator>)</operator><operator>/</operator><name>pgsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnOvfl</name> <operator>=</operator> <name>nOvfl</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all allocations associated with the iterator passed as the 
** second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3SegReaderFree</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pReader</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>fts3SegReaderIsRootOnly</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pBlob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new SegReader object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3SegReaderNew</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iAge</name></decl></parameter>,                       <comment type="block">/* Segment "age". */</comment>
  <parameter><decl><type><name>int</name></type> <name>bLookup</name></decl></parameter>,                    <comment type="block">/* True for a lookup only */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iStartLeaf</name></decl></parameter>,       <comment type="block">/* First leaf to traverse */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iEndLeaf</name></decl></parameter>,         <comment type="block">/* Final leaf to traverse */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iEndBlock</name></decl></parameter>,        <comment type="block">/* Final block of segment */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRoot</name></decl></parameter>,              <comment type="block">/* Buffer containing root node */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRoot</name></decl></parameter>,                      <comment type="block">/* Size of buffer containing root node */</comment>
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppReader</name></decl></parameter>        <comment type="block">/* OUT: Allocated Fts3SegReader */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name></decl>;</decl_stmt>         <comment type="block">/* Newly allocated SegReader object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Bytes to allocate segment root node */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zRoot</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>nRoot</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CORRUPT_DB</name></cpp:ifdef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zRoot</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name>CORRUPT_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>iStartLeaf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iEndLeaf</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <name>nRoot</name> <operator>+</operator> <name>FTS3_NODE_PADDING</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pReader</name> <operator>=</operator> <operator>(</operator><name>Fts3SegReader</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegReader</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pReader</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>=</operator> <name>iAge</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>bLookup</name></name> <operator>=</operator> <name>bLookup</name><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iStartBlock</name></name> <operator>=</operator> <name>iStartLeaf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLeafEndBlock</name></name> <operator>=</operator> <name>iEndLeaf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iEndBlock</name></name> <operator>=</operator> <name>iEndBlock</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nExtra</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The entire segment is stored in the root node. */</comment>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pReader</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>rootOnly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nNode</name></name> <operator>=</operator> <name>nRoot</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nRoot</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>nRoot</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iCurrentBlock</name></name> <operator>=</operator> <name>iStartLeaf</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppReader</name> <operator>=</operator> <name>pReader</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a comparison function used as a qsort() callback when sorting
** an array of pending terms by term. This occurs as part of flushing
** the contents of the pending-terms hash table to the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name> <name>SQLITE_CDECL</name></type> <name>fts3CompareElemByTerm</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z1</name> <init>= <expr><call><name>fts3HashKey</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>fts3HashKey</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n1</name> <init>= <expr><call><name>fts3HashKeysize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>fts3HashKeysize</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>n1</name><operator>&lt;</operator><name>n2</name></expr> ?</condition><then> <expr><name>n1</name></expr> </then><else>: <expr><name>n2</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>n1</name> <operator>-</operator> <name>n2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to allocate an Fts3SegReader that iterates through
** a subset of the terms stored in the Fts3Table.pendingTerms array.
**
** If the isPrefixIter parameter is zero, then the returned SegReader iterates
** through each term in the pending-terms table. Or, if isPrefixIter is
** non-zero, it iterates through each term and its prefixes. For example, if
** the pending terms hash table contains the terms "sqlite", "mysql" and
** "firebird", then the iterator visits the following 'terms' (in the order
** shown):
**
**   f fi fir fire fireb firebi firebir firebird
**   m my mys mysq mysql
**   s sq sql sqli sqlit sqlite
**
** Whereas if isPrefixIter is zero, the terms visited are:
**
**   firebird mysql sqlite
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3SegReaderPending</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index for p-&gt;aIndex */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to search for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of buffer zTerm */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPrefix</name></decl></parameter>,                    <comment type="block">/* True for a prefix iterator */</comment>
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppReader</name></decl></parameter>        <comment type="block">/* OUT: SegReader for pending-terms */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pReader</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Fts3SegReader object to return */</comment>
  <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier></type><name>pE</name></decl>;</decl_stmt>               <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>aElem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Array of term hash entries to scan */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of array at aElem */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>Fts3Hash</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>iIndex</name></expr>]</index></name><operator>.</operator><name>hPending</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bPrefix</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Size of allocated array at aElem */</comment>

    <for>for<control>(<init><expr><name>pE</name><operator>=</operator><call><name>fts3HashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pE</name></expr>;</condition> <incr><expr><name>pE</name><operator>=</operator><call><name>fts3HashNext</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>fts3HashKey</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><call><name>fts3HashKeysize</name><argument_list>(<argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>nKey</name><operator>&gt;=</operator><name>nTerm</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>nElem</name><operator>==</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>Fts3HashElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>aElem2</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>aElem2</name> <operator>=</operator> <operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(
              <argument><expr><name>aElem</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aElem2</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nElem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>aElem</name> <operator>=</operator> <name>aElem2</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>aElem</name><index>[<expr><name>nElem</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If more than one term matches the prefix, sort the Fts3HashElem
    ** objects in term order using qsort(). This uses the same comparison
    ** callback as is used when flushing terms to disk.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nElem</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>aElem</name></expr></argument>, <argument><expr><name>nElem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fts3CompareElemByTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The query is a simple term lookup that matches at most one term in
    ** the index. All that is required is a straight hash-lookup. 
    **
    ** Because the stack address of pE may be accessed via the aElem pointer
    ** below, the "Fts3HashElem *pE" must be declared so that it is valid
    ** within this entire function, not just this "else{...}" block.
    */</comment>
    <expr_stmt><expr><name>pE</name> <operator>=</operator> <call><name>fts3HashFindElem</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aElem</name> <operator>=</operator> <operator>&amp;</operator><name>pE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nElem</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nElem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegReader</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>nElem</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>pReader</name> <operator>=</operator> <operator>(</operator><name>Fts3SegReader</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pReader</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>ppNextElem</name></name> <operator>=</operator> <operator>(</operator><name>Fts3HashElem</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pReader</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>ppNextElem</name></name></expr></argument>, <argument><expr><name>aElem</name></expr></argument>, <argument><expr><name>nElem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3HashElem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bPrefix</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppReader</name> <operator>=</operator> <name>pReader</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the entries pointed to by two Fts3SegReader structures. 
** Comparison is as follows:
**
**   1) EOF is greater than not EOF.
**
**   2) The current terms (if any) are compared using memcmp(). If one
**      term is a prefix of another, the longer term is considered the
**      larger.
**
**   3) By segment age. An older segment is considered larger.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderCmp</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pLhs</name></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pRhs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLhs</name><operator>-&gt;</operator><name>aNode</name></name> <operator>&amp;&amp;</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>aNode</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name><name>pLhs</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>-</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pRhs</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name><name>pLhs</name><operator>-&gt;</operator><name>aNode</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>pRhs</name><operator>-&gt;</operator><name>aNode</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>-</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>iIdx</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A different comparison function for SegReader structures. In this
** version, it is assumed that each SegReader points to an entry in
** a doclist for identical terms. Comparison is made as follows:
**
**   1) EOF (end of doclist in this case) is greater than not EOF.
**
**   2) By current docid.
**
**   3) By segment age. An older segment is considered larger.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderDoclistCmp</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pLhs</name></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pRhs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>(</operator><name><name>pLhs</name><operator>-&gt;</operator><name>pOffsetList</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><operator>(</operator><name><name>pRhs</name><operator>-&gt;</operator><name>pOffsetList</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLhs</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pRhs</name><operator>-&gt;</operator><name>iDocid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>-</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>iIdx</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pLhs</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>&gt;</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iDocid</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>aNode</name></name> <operator>&amp;&amp;</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderDoclistCmpRev</name><parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pLhs</name></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pRhs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>(</operator><name><name>pLhs</name><operator>-&gt;</operator><name>pOffsetList</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><operator>(</operator><name><name>pRhs</name><operator>-&gt;</operator><name>pOffsetList</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLhs</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>pRhs</name><operator>-&gt;</operator><name>iDocid</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>-</operator> <name><name>pLhs</name><operator>-&gt;</operator><name>iIdx</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pLhs</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>&lt;</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>iDocid</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLhs</name><operator>-&gt;</operator><name>aNode</name></name> <operator>&amp;&amp;</operator> <name><name>pRhs</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the term that the Fts3SegReader object passed as the first argument
** points to with the term specified by arguments zTerm and nTerm. 
**
** If the pSeg iterator is already at EOF, return 0. Otherwise, return
** -ve if the pSeg term is less than zTerm/nTerm, 0 if the two terms are
** equal, or +ve if the pSeg term is greater than zTerm/nTerm.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderTermCmp</name><parameter_list>(
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,            <comment type="block">/* Segment reader object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to compare to */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                       <comment type="block">/* Size of term zTerm in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>aNode</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;</operator><name>nTerm</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><name>nTerm</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Argument apSegment is an array of nSegment elements. It is known that
** the final (nSegment-nSuspect) members are already in sorted order
** (according to the comparison function provided). This function shuffles
** the array around until all entries are in sorted order.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SegReaderSort</name><parameter_list>(
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSegment</name></decl></parameter>,                     <comment type="block">/* Array to sort entries of */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSegment</name></decl></parameter>,                                  <comment type="block">/* Size of apSegment array */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSuspect</name></decl></parameter>,                                  <comment type="block">/* Unsorted entry count */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>  <comment type="block">/* Comparison function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSuspect</name><operator>&lt;=</operator><name>nSegment</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nSuspect</name><operator>==</operator><name>nSegment</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSuspect</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nSuspect</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><operator>(</operator><name>nSegment</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pTmp</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>xCmp</name><argument_list>(<argument><expr><name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pTmp</name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apSegment</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pTmp</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* Check that the list really is sorted now. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>nSuspect</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>xCmp</name><argument_list>(<argument><expr><name><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* 
** Insert a record into the %_segments table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3WriteSegment</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iBlock</name></decl></parameter>,           <comment type="block">/* Block id for new block */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,                        <comment type="block">/* Pointer to buffer containing block data */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>                           <comment type="block">/* Size of buffer z in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_INSERT_SEGMENTS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Find the largest relative level number in the table. If successful, set
** *pnMax to this value and return SQLITE_OK. Otherwise, if an error occurs,
** set *pnMax to zero and return an SQLite error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3MaxLevel</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_MXLEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mxLevel</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <name>mxLevel</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Insert a record into the %_segdir table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3WriteSegdir</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLevel</name></decl></parameter>,           <comment type="block">/* Value for "level" field (absolute level) */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>,                       <comment type="block">/* Value for "idx" field */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iStartBlock</name></decl></parameter>,      <comment type="block">/* Value for "start_block" field */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLeafEndBlock</name></decl></parameter>,    <comment type="block">/* Value for "leaves_end_block" field */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iEndBlock</name></decl></parameter>,        <comment type="block">/* Value for "end_block" field */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>nLeafData</name></decl></parameter>,        <comment type="block">/* Bytes of leaf data in segment */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zRoot</name></decl></parameter>,                    <comment type="block">/* Blob value for "root" field */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRoot</name></decl></parameter>                       <comment type="block">/* Number of bytes in buffer zRoot */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_INSERT_SEGDIR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iStartBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLeafEndBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nLeafData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>iEndBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%lld %lld"</literal></expr></argument>, <argument><expr><name>iEndBlock</name></expr></argument>, <argument><expr><name>nLeafData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the common prefix (if any) shared by zPrev and
** zNext, in bytes. For example, 
**
**   fts3PrefixCompress("abc", 3, "abcdef", 6)   // returns 3
**   fts3PrefixCompress("abX", 3, "abcdef", 6)   // returns 2
**   fts3PrefixCompress("abX", 3, "Xbcdef", 6)   // returns 0
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PrefixCompress</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPrev</name></decl></parameter>,              <comment type="block">/* Buffer containing previous term */</comment>
  <parameter><decl><type><name>int</name></type> <name>nPrev</name></decl></parameter>,                      <comment type="block">/* Size of buffer zPrev in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNext</name></decl></parameter>,              <comment type="block">/* Buffer containing next term */</comment>
  <parameter><decl><type><name>int</name></type> <name>nNext</name></decl></parameter>                       <comment type="block">/* Size of buffer zNext in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name><operator>&lt;</operator><name>nPrev</name> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>nNext</name> <operator>&amp;&amp;</operator> <name><name>zPrev</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><name><name>zNext</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>nNext</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add term zTerm to the SegmentNode. It is guaranteed that zTerm is larger
** (according to memcmp) than the previous term.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3NodeAddTerm</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>SegmentNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTree</name></decl></parameter>,           <comment type="block">/* IN/OUT: SegmentNode handle */</comment> 
  <parameter><decl><type><name>int</name></type> <name>isCopyTerm</name></decl></parameter>,                 <comment type="block">/* True if zTerm/nTerm is transient */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Pointer to buffer containing term */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                       <comment type="block">/* Size of term in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pTree</name> <init>= <expr><operator>*</operator><name>ppTree</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <comment type="block">/* First try to append the term to the current node. Return early if 
  ** this is possible.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><name><name>pTree</name><operator>-&gt;</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Current size of node in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nReq</name> <init>= <expr><name>nData</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Required space after adding zTerm */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes of prefix compression */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                  <comment type="block">/* Suffix length */</comment>

    <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <call><name>fts3PrefixCompress</name><argument_list>(<argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name><operator>-</operator><name>nPrefix</name></expr>;</expr_stmt>

    <comment type="block">/* If nSuffix is zero or less, then zTerm/nTerm must be a prefix of 
    ** pWriter-&gt;zTerm/pWriter-&gt;nTerm. i.e. must be equal to or less than when
    ** compared with BINARY collation. This indicates corruption.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nReq</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReq</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name> <operator>||</operator> <operator>!</operator><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name></expr> )</condition><block>{<block_content>

      <if_stmt><if>if<condition>( <expr><name>nReq</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* An unusual case: this is the first term to be added to the node
        ** and the static node buffer (p-&gt;nNodeSize bytes) is not large
        ** enough. Use a separately malloced buffer instead This wastes
        ** p-&gt;nNodeSize bytes, but since this scenario only comes about when
        ** the database contain two terms that share a prefix of almost 2KB, 
        ** this is not expected to be a serious problem. 
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>aData</name></name><operator>==</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTree</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name></name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name></expr> )</condition><block>{<block_content>
        <comment type="block">/* There is no prefix-length field for first term in a node */</comment>
        <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name> <operator>+</operator> <name>nSuffix</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>isCopyTerm</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pTree</name><operator>-&gt;</operator><name>nMalloc</name></name><operator>&lt;</operator><name>nTerm</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>, <argument><expr><name>nTerm</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block>{<block_content>
            <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>nMalloc</name></name> <operator>=</operator> <name>nTerm</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If control flows to here, it was not possible to append zTerm to the
  ** current node. Create a new node (a right-sibling of the current node).
  ** If this is the first node in the tree, the term is added to it.
  **
  ** Otherwise, the term is not added to the new node, it is left empty for
  ** now. Instead, the term is inserted into the parent of pTree. If pTree 
  ** has no parent, one is created here.
  */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>SegmentNode</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>FTS3_VARINT_MAX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pTree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pParent</name> <init>= <expr><name><name>pTree</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3NodeAddTerm</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pParent</name></expr></argument>, <argument><expr><name>isCopyTerm</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTree</name><operator>-&gt;</operator><name>pParent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>pRight</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeftmost</name></name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>pLeftmost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>zMalloc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nMalloc</name></name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>nMalloc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLeftmost</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3NodeAddTerm</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>, <argument><expr><name>isCopyTerm</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppTree</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for fts3NodeWrite().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TreeFinishNode</name><parameter_list>(
  <parameter><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pTree</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLeftChild</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nStart</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHeight</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iHeight</name><operator>&lt;</operator><literal type="number">128</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nStart</name> <operator>=</operator> <name>FTS3_VARINT_MAX</name> <operator>-</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>iLeftChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nStart</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>iHeight</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nStart</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iLeftChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nStart</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write the buffer for the segment node pTree and all of its peers to the
** database. Then call this function recursively to write the parent of 
** pTree and its peers to the database. 
**
** Except, if pTree is a root node, do not write it to the database. Instead,
** set output variables *paRoot and *pnRoot to contain the root node.
**
** If successful, SQLITE_OK is returned and output variable *piLast is
** set to the largest blockid written to the database (or zero if no
** blocks were written to the db). Otherwise, an SQLite error code is 
** returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3NodeWrite</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pTree</name></decl></parameter>,             <comment type="block">/* SegmentNode handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>,                    <comment type="block">/* Height of this node in tree */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLeaf</name></decl></parameter>,            <comment type="block">/* Block id of first leaf node */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iFree</name></decl></parameter>,            <comment type="block">/* Block id of next free slot in %_segments */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piLast</name></decl></parameter>,          <comment type="block">/* OUT: Block id of last entry written */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paRoot</name></decl></parameter>,                  <comment type="block">/* OUT: Data for root node */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRoot</name></decl></parameter>                     <comment type="block">/* OUT: Size of root node in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pTree</name><operator>-&gt;</operator><name>pParent</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Root node of the tree. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nStart</name> <init>= <expr><call><name>fts3TreeFinishNode</name><argument_list>(<argument><expr><name>pTree</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>, <argument><expr><name>iLeaf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>piLast</name> <operator>=</operator> <name>iFree</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRoot</name> <operator>=</operator> <name><name>pTree</name><operator>-&gt;</operator><name>nData</name></name> <operator>-</operator> <name>nStart</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>paRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pTree</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nStart</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNextFree</name> <init>= <expr><name>iFree</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNextLeaf</name> <init>= <expr><name>iLeaf</name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>pTree</name><operator>-&gt;</operator><name>pLeftmost</name></name></expr>;</init> <condition><expr><name>pIter</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pRight</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nStart</name> <init>= <expr><call><name>fts3TreeFinishNode</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>, <argument><expr><name>iNextLeaf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>nData</name></name> <operator>-</operator> <name>nStart</name></expr></init></decl>;</decl_stmt>
  
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iNextFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNextFree</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNextLeaf</name> <operator>+=</operator> <operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>nEntry</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iNextLeaf</name><operator>==</operator><name>iFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3NodeWrite</name><argument_list>(
          <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pTree</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>, <argument><expr><name>iHeight</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iFree</name></expr></argument>, <argument><expr><name>iNextFree</name></expr></argument>, <argument><expr><name>piLast</name></expr></argument>, <argument><expr><name>paRoot</name></expr></argument>, <argument><expr><name>pnRoot</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all memory allocations associated with the tree pTree.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3NodeFree</name><parameter_list>(<parameter><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pTree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pTree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pTree</name><operator>-&gt;</operator><name>pLeftmost</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fts3NodeFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>SegmentNode</name> <modifier>*</modifier></type><name>pRight</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name><operator>!=</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRight</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a term to the segment being constructed by the SegmentWriter object
** *ppWriter. When adding the first term to a segment, *ppWriter should
** be passed NULL. This function will allocate a new SegmentWriter object
** and return it via the input/output variable *ppWriter in this case.
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegWriterAdd</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>SegmentWriter</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppWriter</name></decl></parameter>,       <comment type="block">/* IN/OUT: SegmentWriter handle */</comment> 
  <parameter><decl><type><name>int</name></type> <name>isCopyTerm</name></decl></parameter>,                 <comment type="block">/* True if buffer zTerm must be copied */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Pointer to buffer containing term */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of term in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl></parameter>,           <comment type="block">/* Pointer to buffer containing doclist */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoclist</name></decl></parameter>                    <comment type="block">/* Size of doclist in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>                    <comment type="block">/* Size of term prefix in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                    <comment type="block">/* Size of term suffix in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReq</name></decl>;</decl_stmt>                       <comment type="block">/* Number of bytes required on leaf page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SegmentWriter</name> <modifier>*</modifier></type><name>pWriter</name> <init>= <expr><operator>*</operator><name>ppWriter</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pWriter</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate the SegmentWriter structure */</comment>
    <expr_stmt><expr><name>pWriter</name> <operator>=</operator> <operator>(</operator><name>SegmentWriter</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pWriter</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentWriter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppWriter</name> <operator>=</operator> <name>pWriter</name></expr>;</expr_stmt>

    <comment type="block">/* Allocate a buffer in which to accumulate data */</comment>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr>;</expr_stmt>

    <comment type="block">/* Find the next free blockid in the %_segments table */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_NEXT_SEGMENTS_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nData</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <call><name>fts3PrefixCompress</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name><operator>-</operator><name>nPrefix</name></expr>;</expr_stmt>

  <comment type="block">/* If nSuffix is zero or less, then zTerm/nTerm must be a prefix of 
  ** pWriter-&gt;zTerm/pWriter-&gt;nTerm. i.e. must be equal to or less than when
  ** compared with BINARY collation. This indicates corruption.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Figure out how many bytes are required by this new entry */</comment>
  <expr_stmt><expr><name>nReq</name> <operator>=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call> <operator>+</operator>    <comment type="block">/* varint containing prefix size */</comment>
    <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call> <operator>+</operator>         <comment type="block">/* varint containing suffix size */</comment>
    <name>nSuffix</name> <operator>+</operator>                               <comment type="block">/* Term suffix */</comment>
    <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call> <operator>+</operator>        <comment type="block">/* Size of doclist */</comment>
    <name>nDoclist</name></expr>;</expr_stmt>                               <comment type="block">/* Doclist data */</comment>

  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nData</name><operator>+</operator><name>nReq</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/* The current leaf node is full. Write it out to the database. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name><operator>==</operator><name>LARGEST_INT64</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name><operator>++</operator></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Add the current term to the interior node tree. The term added to
    ** the interior tree must:
    **
    **   a) be greater than the largest term on the leaf node just written
    **      to the database (still available in pWriter-&gt;zTerm), and
    **
    **   b) be less than or equal to the term about to be added to the new
    **      leaf node (zTerm/nTerm).
    **
    ** In other words, it must be the prefix of zTerm 1 byte longer than
    ** the common prefix (if any) of zTerm and pWriter-&gt;zTerm.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>&lt;</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3NodeAddTerm</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>pTree</name></name></expr></argument>, <argument><expr><name>isCopyTerm</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nPrefix</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nReq</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator>                              <comment type="block">/* varint containing prefix size */</comment>
      <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nTerm</name></expr></argument>)</argument_list></call> <operator>+</operator>         <comment type="block">/* varint containing suffix size */</comment>
      <name>nTerm</name> <operator>+</operator>                               <comment type="block">/* Term suffix */</comment>
      <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call> <operator>+</operator>      <comment type="block">/* Size of doclist */</comment>
      <name>nDoclist</name></expr>;</expr_stmt>                             <comment type="block">/* Doclist data */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Increase the total number of bytes written to account for the new entry. */</comment>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>+=</operator> <name>nReq</name></expr>;</expr_stmt>

  <comment type="block">/* If the buffer currently allocated is too small for this entry, realloc
  ** the buffer to make it large enough.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nReq</name><operator>&gt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nSize</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aNew</name> <init>= <expr><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>nReq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <name>nReq</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>+</operator><name>nReq</name><operator>&lt;=</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append the prefix-compressed term and doclist to the buffer. */</comment>
  <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSuffix</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nData</name></expr>]</index></name></expr></argument>, <argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name> <operator>+</operator> <name>nDoclist</name></expr>;</expr_stmt>

  <comment type="block">/* Save the current term so that it can be used to prefix-compress the next.
  ** If the isCopyTerm parameter is true, then the buffer pointed to by
  ** zTerm is transient, so take a copy of the term data. Otherwise, just
  ** store a copy of the pointer.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isCopyTerm</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nMalloc</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>, <argument><expr><name>nTerm</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nMalloc</name></name> <operator>=</operator> <name>nTerm</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zMalloc</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zTerm</name></name><operator>==</operator><name><name>pWriter</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>zTerm</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush all data associated with the SegmentWriter object pWriter to the
** database. This function must be called after all terms have been added
** to the segment using fts3SegWriterAdd(). If successful, SQLITE_OK is
** returned. Otherwise, an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegWriterFlush</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>SegmentWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,         <comment type="block">/* SegmentWriter to flush to the db */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iLevel</name></decl></parameter>,           <comment type="block">/* Value for 'level' column of %_segdir */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>                        <comment type="block">/* Value for 'idx' column of %_segdir */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>pTree</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Largest block id written to database */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLastLeaf</name></decl>;</decl_stmt>      <comment type="block">/* Largest leaf block id written to db */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Pointer to buffer containing root node */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Size of buffer zRoot */</comment>

    <expr_stmt><expr><name>iLastLeaf</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name><operator>++</operator></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3NodeWrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>pTree</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
          <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLast</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegdir</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, 
          <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>, <argument><expr><name>iLastLeaf</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* The entire tree fits on the root node. Write it to the segdir table. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegdir</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, 
        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release all memory held by the SegmentWriter object passed as the 
** first argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SegWriterFree</name><parameter_list>(<parameter><decl><type><name>SegmentWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pWriter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>zMalloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3NodeFree</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>pTree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The first value in the apVal[] array is assumed to contain an integer.
** This function tests if there exist any documents with docid values that
** are different from that integer. i.e. if deleting the document with docid
** pRowid would mean the FTS3 table were empty.
**
** If successful, *pisEmpty is set to true if the table is empty except for
** document pRowid, or false otherwise, and SQLITE_OK is returned. If an
** error occurs, an SQLite error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IsEmpty</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pisEmpty</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If using the content=xxx option, assume the table is never empty */</comment>
    <expr_stmt><expr><operator>*</operator><name>pisEmpty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_IS_EMPTY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pisEmpty</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set *pnMax to the largest segment level in the database for the index
** iIndex.
**
** Segment levels are stored in the 'level' column of the %_segdir table.
**
** Return SQLITE_OK if successful, or an SQLite error code if not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegmentMaxLevel</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pnMax</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndex</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIndex</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set pStmt to the compiled version of:
  **
  **   SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?
  **
  ** (1024 is actually the value of macro FTS3_SEGDIR_PREFIXLEVEL_STR).
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_SEGDIR_MAX_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
      <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>FTS3_SEGDIR_MAXLEVEL</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** iAbsLevel is an absolute level that may be assumed to exist within
** the database. This function checks if it is the largest level number
** within its index. Assuming no error occurs, *pbMax is set to 1 if
** iAbsLevel is indeed the largest level, or 0 otherwise, and SQLITE_OK
** is returned. If an error occurs, an error code is returned and the
** final value of *pbMax is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegmentIsMaxLevel</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iAbsLevel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbMax</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* Set pStmt to the compiled version of:
  **
  **   SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?
  **
  ** (1024 is actually the value of macro FTS3_SEGDIR_PREFIXLEVEL_STR).
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_SEGDIR_MAX_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
      <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>iAbsLevel</name><operator>/</operator><name>FTS3_SEGDIR_MAXLEVEL</name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>FTS3_SEGDIR_MAXLEVEL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pbMax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbMax</name> <operator>=</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete all entries in the %_segments table associated with the segment
** opened with seg-reader pSeg. This function does not affect the contents
** of the %_segdir table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DeleteSegment</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS table handle */</comment>
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>             <comment type="block">/* Segment to delete */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iStartBlock</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDelete</name></decl>;</decl_stmt>        <comment type="block">/* SQL statement to delete rows */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGMENTS_RANGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iStartBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iEndBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used after merging multiple segments into a single large
** segment to delete the old, now redundant, segment b-trees. Specifically,
** it:
** 
**   1) Deletes all %_segments entries for the segments associated with 
**      each of the SegReader objects in the array passed as the third 
**      argument, and
**
**   2) deletes all %_segdir entries with level iLevel, or all %_segdir
**      entries regardless of level if (iLevel&lt;0).
**
** SQLITE_OK is returned if successful, otherwise an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DeleteSegdir</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index for p-&gt;aIndex */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,                     <comment type="block">/* Level of %_segdir entries to delete */</comment>
  <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSegment</name></decl></parameter>,      <comment type="block">/* Array of SegReader objects */</comment>
  <parameter><decl><type><name>int</name></type> <name>nReader</name></decl></parameter>                     <comment type="block">/* Size of array apSegment */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* SQL statement to delete rows */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nReader</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGDIR_RANGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
          <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>FTS3_SEGDIR_MAXLEVEL</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGDIR_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(
          <argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When this function is called, buffer *ppList (size *pnList bytes) contains 
** a position list that may (or may not) feature multiple columns. This
** function adjusts the pointer *ppList and the length *pnList so that they
** identify the subset of the position list that corresponds to column iCol.
**
** If there are no entries in the input position list for column iCol, then
** *pnList is set to zero before returning.
**
** If parameter bZero is non-zero, then any part of the input list following
** the end of the output list is zeroed before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ColumnFilter</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column to filter on */</comment>
  <parameter><decl><type><name>int</name></type> <name>bZero</name></decl></parameter>,                      <comment type="block">/* Zero out anything following *ppList */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppList</name></decl></parameter>,                  <comment type="block">/* IN/OUT: Pointer to position list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnList</name></decl></parameter>                     <comment type="block">/* IN/OUT: Size of buffer *ppList in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><operator>*</operator><name>ppList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nList</name> <init>= <expr><operator>*</operator><name>pnList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pList</name><index>[<expr><name>nList</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pList</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>|</operator> <operator>*</operator><name>p</name><operator>)</operator><operator>&amp;</operator><literal type="number">0xFE</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></while>
  
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>iCurrent</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nList</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>pList</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nList</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>pList</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nList</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>bZero</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pEnd</name> <operator>-</operator> <operator>&amp;</operator><name><name>pList</name><index>[<expr><name>nList</name></expr>]</index></name><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pList</name><index>[<expr><name>nList</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pEnd</name> <operator>-</operator> <operator>&amp;</operator><name><name>pList</name><index>[<expr><name>nList</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppList</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnList</name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Cache data in the Fts3MultiSegReader.aBuffer[] buffer (overwriting any
** existing data). Grow the buffer if required.
**
** If successful, return SQLITE_OK. Otherwise, if an OOM error is encountered
** trying to resize the buffer, return SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MsrBufferData</name><parameter_list>(
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pMsr</name></decl></parameter>,       <comment type="block">/* Multi-segment-reader handle */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nList</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nList</name><operator>&gt;</operator><name><name>pMsr</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pMsr</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <name>nList</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pMsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name><name>pMsr</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pMsr</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nList</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pMsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3MsrIncrNext</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pMsr</name></decl></parameter>,       <comment type="block">/* Multi-segment-reader handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piDocid</name></decl></parameter>,         <comment type="block">/* OUT: Docid value */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paPoslist</name></decl></parameter>,               <comment type="block">/* OUT: Pointer to position list */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPoslist</name></decl></parameter>                  <comment type="block">/* OUT: Size of position list in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nMerge</name> <init>= <expr><name><name>pMsr</name><operator>-&gt;</operator><name>nAdvance</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSegment</name> <init>= <expr><name><name>pMsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator>
    <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr> ?</condition><then> <expr><name>fts3SegReaderDoclistCmpRev</name></expr></then></ternary></expr> <operator>:</operator> <expr><name>fts3SegReaderDoclistCmp</name></expr>
  )</init>;</function_decl>

  <if_stmt><if>if<condition>( <expr><name>nMerge</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>paPoslist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <name><name>pMsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pOffsetList</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>paPoslist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name> <init>= <expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>iDocid</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderNextDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> 
        <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>nMerge</name>
        <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>pOffsetList</name>
        <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>iDocid</name><operator>==</operator><name>iDocid</name></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderNextDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name><name>pMsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>nList</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MsrBufferData</name><argument_list>(<argument><expr><name>pMsr</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>nList</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nList</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFE</literal><operator>)</operator><operator>==</operator><literal type="number">0x00</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pList</name> <operator>=</operator> <name><name>pMsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pMsr</name><operator>-&gt;</operator><name>iColFilter</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3ColumnFilter</name><argument_list>(<argument><expr><name><name>pMsr</name><operator>-&gt;</operator><name>iColFilter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>nList</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>paPoslist</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>piDocid</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnPoslist</name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegReaderStart</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,       <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term searched for (or NULL) */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                       <comment type="block">/* Length of zTerm in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSeg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the Fts3SegFilter defines a specific term (or term prefix) to search 
  ** for, then advance each segment iterator until it points to a term of
  ** equal or greater value than the specified term. This prevents many
  ** unnecessary merge/sort operations for the case where single segment
  ** b-tree leaf nodes contain more than one term.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bRestart</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fts3SegReaderNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><name>zTerm</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>fts3SegReaderTermCmp</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition>;</do>

    <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>bLookup</name></name> <operator>&amp;&amp;</operator> <name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3SegReaderSetEof</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>, <argument><expr><name>nSeg</name></expr></argument>, <argument><expr><name>nSeg</name></expr></argument>, <argument><expr><name>fts3SegReaderCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3SegReaderStart</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,       <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><name>Fts3SegFilter</name> <modifier>*</modifier></type><name>pFilter</name></decl></parameter>          <comment type="block">/* Restrictions on range of iteration */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name></name> <operator>=</operator> <name>pFilter</name></expr>;</expr_stmt>
  <return>return <expr><call><name>fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pFilter</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pFilter</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3MsrIncrStart</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,       <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column to match on. */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to iterate through a doclist for */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                       <comment type="block">/* Number of bytes in zTerm */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSegment</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator>
    <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr> ?</condition><then> <expr><name>fts3SegReaderDoclistCmpRev</name></expr></then></ternary></expr> <operator>:</operator> <expr><name>fts3SegReaderDoclistCmp</name></expr>
  )</init>;</function_decl>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTerm</name> <operator>&amp;&amp;</operator> <name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Advance each segment iterator until it points to the term zTerm/nTerm. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Determine how many of the segments actually point to zTerm/nTerm. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSegment</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pSeg</name><operator>-&gt;</operator><name>aNode</name></name> <operator>||</operator> <call><name>fts3SegReaderTermCmp</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

  <comment type="block">/* Advance each of the segments to point to the first docid. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderFirstDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iColFilter</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called on a MultiSegReader that has been started using
** sqlite3Fts3MsrIncrStart(). One or more calls to MsrIncrNext() may also
** have been made. Calling this function puts the MultiSegReader in such
** a state that if the next two calls are:
**
**   sqlite3Fts3SegReaderStart()
**   sqlite3Fts3SegReaderStep()
**
** then the entire doclist for the term is available in 
** MultiSegReader.aDoclist/nDoclist.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3MsrIncrRestart</name><parameter_list>(<parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through segment-readers */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoclist</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bRestart</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pOffsetList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nOffsetList</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>iDocid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3GrowSegReaderBuffer</name><parameter_list>(<parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReq</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nReq</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <name>nReq</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>sqlite3Fts3SegReaderStep</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>        <comment type="block">/* Cursor object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>isIgnoreEmpty</name> <init>=  <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_IGNORE_EMPTY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isRequirePos</name> <init>=   <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_REQUIRE_POS</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isColFilter</name> <init>=    <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_COLUMN_FILTER</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isPrefix</name> <init>=       <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_PREFIX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isScan</name> <init>=         <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_SCAN</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isFirst</name> <init>=        <expr><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FTS3_SEGMENT_FIRST</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier><modifier>*</modifier></type><name>apSegment</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSegment</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3SegFilter</name> <modifier>*</modifier></type><name>pFilter</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFilter</name></name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCmp</name>)<parameter_list>(<parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator>
    <ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr> ?</condition><then> <expr><name>fts3SegReaderDoclistCmpRev</name></expr></then></ternary></expr> <operator>:</operator> <expr><name>fts3SegReaderDoclistCmp</name></expr>
  )</init>;</function_decl>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nMerge</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  
    <comment type="block">/* Advance the first pCsr-&gt;nAdvance entries in the apSegment[] array
    ** forward. Then sort the list in order of current term again.  
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><name><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>bLookup</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3SegReaderSetEof</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegReaderNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name>apSegment</name></expr></argument>, <argument><expr><name>nSegment</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name></expr></argument>, <argument><expr><name>fts3SegReaderCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* If all the seg-readers are at EOF, we're finished. return SQLITE_OK. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>aNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>zTerm</name></expr>;</expr_stmt>

    <comment type="block">/* If this is a prefix-search, and if the term that apSegment[0] points
    ** to does not share a suffix with pFilter-&gt;zTerm/nTerm, then all 
    ** required callbacks have been made. In this case exit early.
    **
    ** Similarly, if this is a search for an exact match, and the first term
    ** of segment apSegment[0] is not a match, exit early.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pFilter</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isScan</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&lt;</operator><name><name>pFilter</name><operator>-&gt;</operator><name>nTerm</name></name> 
       <operator>||</operator> <operator>(</operator><operator>!</operator><name>isPrefix</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&gt;</operator><name><name>pFilter</name><operator>-&gt;</operator><name>nTerm</name></name><operator>)</operator>
       <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pFilter</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>pFilter</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr> 
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nMerge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>nMerge</name><operator>&lt;</operator><name>nSegment</name> 
        <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>nMerge</name></expr>]</index></name><operator>-&gt;</operator><name>aNode</name>
        <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>nMerge</name></expr>]</index></name><operator>-&gt;</operator><name>nTerm</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name> 
        <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>nMerge</name></expr>]</index></name><operator>-&gt;</operator><name>zTerm</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>nMerge</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isIgnoreEmpty</name> <operator>||</operator> <operator>(</operator><name>isRequirePos</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isColFilter</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nMerge</name><operator>==</operator><literal type="number">1</literal> 
     <operator>&amp;&amp;</operator> <operator>!</operator><name>isIgnoreEmpty</name> 
     <operator>&amp;&amp;</operator> <operator>!</operator><name>isFirst</name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoclist</name></name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nDoclist</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MsrBufferData</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>aDoclist</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>aDoclist</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nDoclist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Size of doclist */</comment>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Previous docid stored in doclist */</comment>

      <comment type="block">/* The current term of the first nMerge entries in the array
      ** of Fts3SegReader objects is the same. The doclists must be merged
      ** and a single term returned with the merged doclist.
      */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMerge</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>fts3SegReaderFirstDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name>apSegment</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>pOffsetList</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                    <comment type="block">/* Number of segments that share a docid */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name> <init>= <expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>iDocid</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fts3SegReaderNextDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><name>nMerge</name>
            <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>pOffsetList</name>
            <operator>&amp;&amp;</operator> <name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>iDocid</name><operator>==</operator><name>iDocid</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3SegReaderNextDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if<condition>( <expr><name>isColFilter</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3ColumnFilter</name><argument_list>(<argument><expr><name><name>pFilter</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isIgnoreEmpty</name> <operator>||</operator> <name>nList</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>

          <comment type="block">/* Calculate the 'docid' delta value to write into the merged 
          ** doclist. */</comment>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDelta</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name> <operator>&amp;&amp;</operator> <name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;=</operator><name>iDocid</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iDelta</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>iPrev</name> <operator>-</operator> <operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iPrev</name><operator>&gt;=</operator><name>iDocid</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>iDelta</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name> <operator>-</operator> <operator>(</operator><name>u64</name><operator>)</operator><name>iPrev</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>iDelta</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>isRequirePos</name></expr>?</condition><then><expr><name>nList</name><operator>+</operator><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3GrowSegReaderBuffer</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><name>nDoclist</name><operator>+</operator><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>isFirst</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name></decl>;</decl_stmt>
           
            <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>sqlite3Fts3FirstFilter</name><argument_list>(<argument><expr><name>iDelta</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>nList</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>nWrite</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>nDoclist</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>nDoclist</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></argument>, <argument><expr><name>iDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>isRequirePos</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>nList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>nDoclist</name> <operator>+=</operator> <name>nList</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nDoclist</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fts3SegReaderSort</name><argument_list>(<argument><expr><name>apSegment</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>xCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>nDoclist</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3GrowSegReaderBuffer</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>nDoclist</name><operator>+</operator><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>nDoclist</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoclist</name></name> <operator>=</operator> <name>nDoclist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ROW</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nAdvance</name></name> <operator>=</operator> <name>nMerge</name></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition>;</do>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>sqlite3Fts3SegReaderFinish</name><parameter_list>(
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>       <comment type="block">/* Cursor object */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decode the "end_block" field, selected by column iCol of the SELECT 
** statement passed as the first argument. 
**
** The "end_block" field may contain either an integer, or a text field
** containing the text representation of two non-negative integers separated 
** by one or more space (0x20) characters. In the first case, set *piEndBlock 
** to the integer value and *pnByte to zero before returning. In the second, 
** set *piEndBlock to the first value and *pnByte to the second.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3ReadEndBlockField</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piEndBlock</name></decl></parameter>,
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iMul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>piEndBlock</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iVal</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iMul</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<comment type="block">/* no-op */</comment><init>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>iVal</name> <operator>=</operator> <name>iVal</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>iVal</name> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iMul</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** A segment of size nByte bytes has just been written to absolute level
** iAbsLevel. Promote any segments that should be promoted as a result.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3PromoteSegments</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level just updated */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>             <comment type="block">/* Size of new segment at iAbsLevel */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRange</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_LEVEL_RANGE2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRange</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iLast</name> <init>= <expr><operator>(</operator><name>iAbsLevel</name><operator>/</operator><name>FTS3_SEGDIR_MAXLEVEL</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>FTS3_SEGDIR_MAXLEVEL</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nLimit</name> <init>= <expr><operator>(</operator><name>nByte</name><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Loop through all entries in the %_segdir table corresponding to 
    ** segments in this index on levels greater than iAbsLevel. If there is
    ** at least one such segment, and it is possible to determine that all 
    ** such segments are smaller than nLimit bytes in size, they will be 
    ** promoted to level iAbsLevel.  */</comment>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dummy</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3ReadEndBlockField</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSize</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>nSize</name><operator>&gt;</operator><name>nLimit</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* If nSize==0, then the %_segdir.end_block field does not not 
        ** contain a size value. This happens if it was written by an
        ** old version of FTS. In this case it is not possible to determine
        ** the size of the segment, and so segment promotion does not
        ** take place.  */</comment>
        <expr_stmt><expr><name>bOk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bOk</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUpdate1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUpdate2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_UPDATE_LEVEL_IDX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pUpdate1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_UPDATE_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pUpdate2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

        <comment type="block">/* Loop through all %_segdir entries for segments in this index with
        ** levels equal to or greater than iAbsLevel. As each entry is visited,
        ** updated it to set (level = -1) and (idx = N), where N is 0 for the
        ** oldest segment in the range, 1 for the next oldest, and so on.
        **
        ** In other words, move all segments being promoted to level -1,
        ** setting the "idx" fields as appropriate to keep them in the same
        ** order. The contents of level -1 (which is never used, except
        ** transiently here), will be moved back to level iAbsLevel below.  */</comment>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pUpdate1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iIdx</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pUpdate1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pUpdate1</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUpdate1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUpdate1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Move level -1 to level iAbsLevel */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pUpdate2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUpdate2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUpdate2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Merge all level iLevel segments in the database into a single 
** iLevel+1 segment. Or, if iLevel&lt;0, merge all segments into a
** single segment with a level equal to the numerically largest level 
** currently present in the database.
**
** If this function is called with iLevel&lt;0, but there is only one
** segment in the database, SQLITE_DONE is returned immediately. 
** Otherwise, if successful, SQLITE_OK is returned. If an error occurs, 
** an SQLite error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SegmentMerge</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id to merge */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index in p-&gt;aIndex[] to merge */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>                      <comment type="block">/* Level to merge */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Index of new segment */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNewLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Level/index to create new segment at */</comment>
  <decl_stmt><decl><type><name>SegmentWriter</name> <modifier>*</modifier></type><name>pWriter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Used to write the new, merged, segment */</comment>
  <decl_stmt><decl><type><name>Fts3SegFilter</name></type> <name>filter</name></decl>;</decl_stmt>           <comment type="block">/* Segment term filter condition */</comment>
  <decl_stmt><decl><type><name>Fts3MultiSegReader</name></type> <name>csr</name></decl>;</decl_stmt>         <comment type="block">/* Cursor to iterate through level(s) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIgnoreEmpty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* True to ignore empty segments */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iMaxLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Max level number for this index/langid */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name>
       <operator>||</operator> <name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_PENDING</name>
       <operator>||</operator> <name>iLevel</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLevel</name><operator>&lt;</operator><name>FTS3_SEGDIR_MAXLEVEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIndex</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iIndex</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>csr</name><operator>.</operator><name>nSegment</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>!=</operator><name>FTS3_SEGCURSOR_PENDING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegmentMaxLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMaxLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_ALL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This call is to merge all segments in the database to a single
    ** segment. The level of the new segment is equal to the numerically
    ** greatest segment level currently present in the database for this
    ** index. The idx of the new segment is always 0.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>csr</name><operator>.</operator><name>nSegment</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>fts3SegReaderIsPending</name><argument_list>(<argument><expr><name><name>csr</name><operator>.</operator><name>apSegment</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      <goto>goto <name>finished</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iNewLevel</name> <operator>=</operator> <name>iMaxLevel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bIgnoreEmpty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* This call is to merge all segments at level iLevel. find the next
    ** available segment index at level iLevel+1. The call to
    ** fts3AllocateSegdirIdx() will merge the segments at level iLevel+1 to 
    ** a single iLevel+2 segment if necessary.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>FTS3_SEGCURSOR_PENDING</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iNewLevel</name> <operator>=</operator> <call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3AllocateSegdirIdx</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bIgnoreEmpty</name> <operator>=</operator> <operator>(</operator><name>iLevel</name><operator>!=</operator><name>FTS3_SEGCURSOR_PENDING</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>iNewLevel</name><operator>&gt;</operator><name>iMaxLevel</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>csr</name><operator>.</operator><name>nSegment</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>iNewLevel</name><operator>&gt;=</operator><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( 
    <argument><expr><name>iNewLevel</name><operator>&lt;</operator><call><name>getAbsoluteLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>,<argument><expr><name>FTS3_SEGDIR_MAXLEVEL</name></expr></argument>)</argument_list></call></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegFilter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>FTS3_SEGMENT_REQUIRE_POS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name>bIgnoreEmpty</name></expr> ?</condition><then> <expr><name>FTS3_SEGMENT_IGNORE_EMPTY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegWriterAdd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
        <argument><expr><name><name>csr</name><operator>.</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>nDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>pWriter</name> <operator>||</operator> <name>bIgnoreEmpty</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>!=</operator><name>FTS3_SEGCURSOR_PENDING</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteSegdir</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>apSegment</name></name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>nSegment</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>finished</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pWriter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegWriterFlush</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>iNewLevel</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iLevel</name><operator>==</operator><name>FTS3_SEGCURSOR_PENDING</name> <operator>||</operator> <name>iNewLevel</name><operator>&lt;</operator><name>iMaxLevel</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PromoteSegments</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iNewLevel</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>finished</name>:</label>
  <expr_stmt><expr><call><name>fts3SegWriterFree</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** Flush the contents of pendingTerms to level 0 segments. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3PendingTermsFlush</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegmentMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3Fts3PendingTermsClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine the auto-incr-merge setting if unknown.  If enabled,
  ** estimate the number of leaf blocks of content to be written
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name>
   <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name><operator>==</operator><literal type="number">0xff</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nLeafAdd</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_AUTOINCRMERGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Encode N integers as varints into a blob.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3EncodeIntArray</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,             <comment type="block">/* The number of integers to encode */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,            <comment type="block">/* The integer values */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,        <comment type="block">/* Write the BLOB here */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pNBuf</name></decl></parameter>         <comment type="block">/* Write number of bytes if zBuf[] used here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pNBuf</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decode a blob of varints into N integers
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3DecodeIntArray</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,             <comment type="block">/* The number of integers to decode */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,            <comment type="block">/* Write the integer values */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,  <comment type="block">/* The BLOB containing the varints */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>           <comment type="block">/* size of the BLOB */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBuf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zBuf</name><index>[<expr><name>nBuf</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>nBuf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>N</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
** Insert the sizes (in tokens) for each column of the document
** with docid equal to p-&gt;iPrevDocid.  The sizes are encoded as
** a blob of varints.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3InsertDocsize</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>,                       <comment type="block">/* Result code */</comment>
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Table into which to insert */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSz</name></decl></parameter>                        <comment type="block">/* Sizes of each column, in tokens */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>             <comment type="block">/* The BLOB encoding of the document size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in the BLOB */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>     <comment type="block">/* Statement used to insert the encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                  <comment type="block">/* Result code from subfunctions */</comment>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><literal type="number">10</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fts3EncodeIntArray</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_REPLACE_DOCSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Record 0 of the %_stat table contains a blob consisting of N varints,
** where N is the number of user defined columns in the fts3 table plus
** two. If nCol is the number of user defined columns, then values of the 
** varints are set as follows:
**
**   Varint 0:       Total number of rows in the table.
**
**   Varint 1..nCol: For each column, the total number of tokens stored in
**                   the column for all rows of the table.
**
**   Varint 1+nCol:  The total size, in bytes, of all text values in all
**                   columns of all rows of the table.
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3UpdateDocTotals</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRC</name></decl></parameter>,                       <comment type="block">/* The result code */</comment>
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Table being updated */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzIns</name></decl></parameter>,                    <comment type="block">/* Size increases */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzDel</name></decl></parameter>,                    <comment type="block">/* Size decreases */</comment>
  <parameter><decl><type><name>int</name></type> <name>nChng</name></decl></parameter>                       <comment type="block">/* Change in the number of documents */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>             <comment type="block">/* Storage for BLOB written into %_stat */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>               <comment type="block">/* Size of BLOB written into %_stat */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>                  <comment type="block">/* Array of integers that becomes the BLOB */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>     <comment type="block">/* Statement for reading and writing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                  <comment type="block">/* Result code from subfunctions */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nStat</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRC</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">10</literal><operator>)</operator><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nStat</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>a</name><index>[<expr><name>nStat</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_DOCTOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3DecodeIntArray</name><argument_list>(<argument><expr><name>nStat</name></expr></argument>, <argument><expr><name>a</name></expr></argument>,
         <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nStat</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nChng</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>-</operator><name>nChng</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>nChng</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name></type> <name>x</name> <init>= <expr><name><name>a</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name><operator>+</operator><name><name>aSzIns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>aSzDel</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name><name>aSzIns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>aSzDel</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fts3EncodeIntArray</name><argument_list>(<argument><expr><name>nStat</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_REPLACE_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_DOCTOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRC</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Merge the entire database so that there is one segment for each 
** iIndex/iLangid combination.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoOptimize</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bReturnDone</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bSeenDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllLangid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3PendingTermsFlush</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_ALL_LANGID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegmentMerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bSeenDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bReturnDone</name> <operator>&amp;&amp;</operator> <name>bSeenDone</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_DONE</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when the user executes the following statement:
**
**     INSERT INTO &lt;tbl&gt;(&lt;tbl&gt;) VALUES('rebuild');
**
** The entire FTS index is discarded and rebuilt. If the table is one 
** created using the content=xxx option, then the new index is based on
** the current contents of the xxx table. Otherwise, it is rebuilt based
** on the contents of the %_content table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoRebuild</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteAll</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzIns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Compose and prepare an SQL statement to loop through the content table */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %s"</literal></expr></argument> , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>aSz</name> <operator>=</operator> <operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aSz</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aSzIns</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSz</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>aSzDel</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSzIns</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><call><name>langidFromSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSz</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsAdd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aSz</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aSz</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name> <operator>+=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3InsertDocsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>aSzIns</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>+=</operator> <name><name>aSz</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3UpdateDocTotals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aSzIns</name></expr></argument>, <argument><expr><name>aSzDel</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function opens a cursor used to read the input data for an 
** incremental merge operation. Specifically, it opens a cursor to scan
** the oldest nSeg segments (idx=0 through idx=(nSeg-1)) in absolute 
** level iAbsLevel.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeCsr</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level to open */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSeg</name></decl></parameter>,                       <comment type="block">/* Number of segments to merge */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>        <comment type="block">/* Cursor object to populate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Statement used to read %_segdir entry */</comment>  
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>            <comment type="block">/* Bytes allocated at pCsr-&gt;apSegment[] */</comment>

  <comment type="block">/* Allocate space for the Fts3MultiSegReader.aCsr[] array */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Fts3SegReader</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nSeg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name> <operator>=</operator> <operator>(</operator><name>Fts3SegReader</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nSeg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderNew</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
          <argument><expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,        <comment type="block">/* segdir.start_block */</comment>
          <argument><expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,        <comment type="block">/* segdir.leaves_end_block */</comment>
          <argument><expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>,        <comment type="block">/* segdir.end_block */</comment>
          <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,         <comment type="block">/* segdir.root */</comment>
          <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,        <comment type="block">/* segdir.root */</comment>
          <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>IncrmergeWriter</name></name></type> <name>IncrmergeWriter</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>NodeWriter</name></name></type> <name>NodeWriter</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>Blob</name></name></type> <name>Blob</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>NodeReader</name></name></type> <name>NodeReader</name>;</typedef>

<comment type="block">/*
** An instance of the following structure is used as a dynamic buffer
** to build up nodes or other blobs of data in.
**
** The function blobGrowBuffer() is used to extend the allocation.
*/</comment>
<struct>struct <name>Blob</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>                        <comment type="block">/* Pointer to allocation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Number of valid bytes of data in a[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                     <comment type="block">/* Allocated size of a[] (nAlloc&gt;=n) */</comment>
}</block>;</struct>

<comment type="block">/*
** This structure is used to build up buffers containing segment b-tree 
** nodes (blocks).
*/</comment>
<struct>struct <name>NodeWriter</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBlock</name></decl>;</decl_stmt>           <comment type="block">/* Current block id */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>key</name></decl>;</decl_stmt>                       <comment type="block">/* Last key written to the current block */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>block</name></decl>;</decl_stmt>                     <comment type="block">/* Current block image */</comment>
}</block>;</struct>

<comment type="block">/*
** An object of this type contains the state required to create or append
** to an appendable b-tree segment.
*/</comment>
<struct>struct <name>IncrmergeWriter</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nLeafEst</name></decl>;</decl_stmt>                   <comment type="block">/* Space allocated for leaf blocks */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWork</name></decl>;</decl_stmt>                      <comment type="block">/* Number of leaf pages flushed */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl>;</decl_stmt>        <comment type="block">/* Absolute level of input segments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name></decl>;</decl_stmt>                       <comment type="block">/* Index of *output* segment in iAbsLevel+1 */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iStart</name></decl>;</decl_stmt>           <comment type="block">/* Block number of first allocated block */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name></decl>;</decl_stmt>             <comment type="block">/* Block number of last allocated block */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nLeafData</name></decl>;</decl_stmt>        <comment type="block">/* Bytes of leaf page data so far */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bNoLeafData</name></decl>;</decl_stmt>                 <comment type="block">/* If true, store 0 for segment size */</comment>
  <decl_stmt><decl><type><name>NodeWriter</name></type> <name><name>aNodeWriter</name><index>[<expr><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** An object of the following type is used to read data from a single
** FTS segment node. See the following functions:
**
**     nodeReaderInit()
**     nodeReaderNext()
**     nodeReaderRelease()
*/</comment>
<struct>struct <name>NodeReader</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>                       <comment type="block">/* Current offset within aNode[] */</comment>

  <comment type="block">/* Output variables. Containing the current node entry. */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iChild</name></decl>;</decl_stmt>           <comment type="block">/* Pointer to child node */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>term</name></decl>;</decl_stmt>                      <comment type="block">/* Current term */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl>;</decl_stmt>           <comment type="block">/* Pointer to doclist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoclist</name></decl>;</decl_stmt>                   <comment type="block">/* Size of doclist in bytes */</comment>
}</block>;</struct>

<comment type="block">/*
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, if the allocation at pBlob-&gt;a is not already at least nMin
** bytes in size, extend (realloc) it to be so.
**
** If an OOM error occurs, set *pRc to SQLITE_NOMEM and leave pBlob-&gt;a
** unmodified. Otherwise, if the allocation succeeds, update pBlob-&gt;nAlloc
** to reflect the new size of the pBlob-&gt;a[] buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>blobGrowBuffer</name><parameter_list>(<parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMin</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nMin</name><operator>&gt;</operator><name><name>pBlob</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><name>nMin</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pBlob</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBlob</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to advance the node-reader object passed as the first argument to
** the next entry on the node. 
**
** Return an error code if an error occurs (SQLITE_NOMEM is possible). 
** Otherwise return SQLITE_OK. If there is no next entry on the node
** (e.g. because the current entry is the last) set NodeReader-&gt;aNode to
** NULL to indicate EOF. Otherwise, populate the NodeReader structure output 
** variables for the new entry.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeReaderNext</name><parameter_list>(<parameter><decl><type><name>NodeReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirst</name> <init>= <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>    <comment type="block">/* True for first term on the node */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Bytes to copy from previous term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Bytes to append to the prefix */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iChild</name></name> <operator>&amp;&amp;</operator> <name>bFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iChild</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* EOF */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>nPrefix</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>n</name></name> <operator>||</operator> <name>nSuffix</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>||</operator> <name>nSuffix</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>nPrefix</name><operator>+</operator><name>nSuffix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>a</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>a</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nPrefix</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iChild</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name><operator>)</operator><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nDoclist</name></name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aDoclist</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDoclist</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release all dynamic resources held by node-reader object *p.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nodeReaderRelease</name><parameter_list>(<parameter><decl><type><name>NodeReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a node-reader object to read the node in buffer aNode/nNode.
**
** If successful, SQLITE_OK is returned and the NodeReader object set to 
** point to the first entry on the node (if any). Otherwise, an SQLite
** error code is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nodeReaderInit</name><parameter_list>(<parameter><decl><type><name>NodeReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeReader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <name>aNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNode</name></name> <operator>=</operator> <name>nNode</name></expr>;</expr_stmt>

  <comment type="block">/* Figure out if this is a leaf or an internal node. */</comment>
  <if_stmt><if>if<condition>( <expr><name>aNode</name> <operator>&amp;&amp;</operator> <name><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An internal node. */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>iChild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iOff</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><ternary><condition><expr><name>aNode</name></expr> ?</condition><then> <expr><call><name>nodeReaderNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called while writing an FTS segment each time a leaf o
** node is finished and written to disk. The key (zTerm/nTerm) is guaranteed
** to be greater than the largest key on the node just written, but smaller
** than or equal to the first key that will be written to the next leaf
** node.
**
** The block id of the leaf node just written to disk may be found in
** (pWriter-&gt;aNodeWriter[0].iBlock) when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergePush</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,       <comment type="block">/* Writer object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Term to write to internal node */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                       <comment type="block">/* Bytes at zTerm */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPtr</name> <init>= <expr><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iBlock</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLayer</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iLayer</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iLayer</name><operator>&lt;</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iLayer</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNextPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>iLayer</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>

    <comment type="block">/* Figure out how much space the key will consume if it is written to
    ** the current node of layer iLayer. Due to the prefix compression, 
    ** the space required changes depending on which node the key is to
    ** be added to.  */</comment>
    <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <call><name>fts3PrefixCompress</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name> <operator>-</operator> <name>nPrefix</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nSpace</name>  <operator>=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nSuffix</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name>nSpace</name><operator>)</operator><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr> )</condition><block>{<block_content> 
      <comment type="block">/* If the current node of layer iLayer contains zero keys, or if adding
      ** the key to it will not cause it to grow to larger than nNodeSize 
      ** bytes in size, write the key here.  */</comment>

      <decl_stmt><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pBlk</name> <init>= <expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pBlk</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pBlk</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>iLayer</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBlk</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pBlk</name></expr></argument>, <argument><expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name>nSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBlk</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBlk</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>+</operator><name>nSuffix</name><operator>&lt;=</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pBlk</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pBlk</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Otherwise, flush the current node of layer iLayer to disk.
      ** Then allocate a new, empty sibling node. The key will be written
      ** into the parent of this node. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>nAlloc</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>iLayer</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iPtr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>iNextPtr</name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>iNextPtr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iPtr</name> <operator>=</operator> <name>iNextPtr</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a term and (optionally) doclist to the FTS segment node currently
** stored in blob *pNode. The node need not contain any terms, but the
** header must be written before this function is called.
**
** A node header is a single 0x00 byte for a leaf node, or a height varint
** followed by the left-hand-child varint for an internal node.
**
** The term to be appended is passed via arguments zTerm/nTerm. For a 
** leaf node, the doclist is passed as aDoclist/nDoclist. For an internal
** node, both aDoclist and nDoclist must be passed 0.
**
** If the size of the value in blob pPrev is zero, then this is the first
** term written to the node. Otherwise, pPrev contains a copy of the 
** previous term. Before this function returns, it is updated to contain a
** copy of zTerm/nTerm.
**
** It is assumed that the buffer associated with pNode is already large
** enough to accommodate the new entry. The buffer associated with pPrev
** is extended by this function if requrired.
**
** If an error (i.e. OOM condition) occurs, an SQLite error code is
** returned. Otherwise, SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3AppendToNode</name><parameter_list>(
  <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,                    <comment type="block">/* Current node image to append to */</comment>
  <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pPrev</name></decl></parameter>,                    <comment type="block">/* Buffer containing previous term written */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* New term to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDoclist</name></decl></parameter>,           <comment type="block">/* Doclist (or NULL) to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoclist</name></decl></parameter>                    <comment type="block">/* Size of aDoclist in bytes */</comment> 
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFirst</name> <init>= <expr><operator>(</operator><name><name>pPrev</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>     <comment type="block">/* True if this is the first term written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>                    <comment type="block">/* Size of term prefix in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                    <comment type="block">/* Size of term suffix in bytes */</comment>

  <comment type="block">/* Node must have already been started. There must be a doclist for a
  ** leaf node, and there must not be a doclist for an internal node.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>aDoclist</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pPrev</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <call><name>fts3PrefixCompress</name><argument_list>(<argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name> <operator>-</operator> <name>nPrefix</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pPrev</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPrev</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>bFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nSuffix</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>aDoclist</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nDoclist</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append the current term and doclist pointed to by cursor pCsr to the
** appendable b-tree segment opened for writing by pWriter.
**
** Return SQLITE_OK if successful, or an SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeAppend</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,       <comment type="block">/* Writer object */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>        <comment type="block">/* Cursor containing term and doclist */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDoclist</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aDoclist</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoclist</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nDoclist</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>                   <comment type="block">/* Total space in bytes required on leaf */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>;</decl_stmt>                  <comment type="block">/* Size of prefix shared with previous term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSuffix</name></decl>;</decl_stmt>                  <comment type="block">/* Size of suffix (nTerm - nPrefix) */</comment>
  <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pLeaf</name></decl>;</decl_stmt>            <comment type="block">/* Object used to write leaf nodes */</comment>

  <expr_stmt><expr><name>pLeaf</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPrefix</name> <operator>=</operator> <call><name>fts3PrefixCompress</name><argument_list>(<argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name> <operator>-</operator> <name>nPrefix</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><name>nSuffix</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nSpace</name>  <operator>=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nSuffix</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nDoclist</name></expr>;</expr_stmt>

  <comment type="block">/* If the current block is not empty, and if adding this term/doclist
  ** to the current block would make it larger than Fts3Table.nNodeSize
  ** bytes, write this block out to the database. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name>nSpace</name><operator>)</operator><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>iBlock</name></name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nWork</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Add the current term to the parent node. The term added to the 
    ** parent must:
    **
    **   a) be greater than the largest term on the leaf node just written
    **      to the database (still available in pLeaf-&gt;key), and
    **
    **   b) be less than or equal to the term about to be added to the new
    **      leaf node (zTerm/nTerm).
    **
    ** In other words, it must be the prefix of zTerm 1 byte longer than
    ** the common prefix (if any) of zTerm and pWriter-&gt;zTerm.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergePush</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nPrefix</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Advance to the next output block */</comment>
    <expr_stmt><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>iBlock</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>nSuffix</name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSpace</name>  <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nSuffix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSpace</name> <operator>+=</operator> <call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>nDoclist</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nDoclist</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>+=</operator> <name>nSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name>nSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3AppendToNode</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name><name>pLeaf</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLeaf</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>aDoclist</name></expr></argument>, <argument><expr><name>nDoclist</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to release all dynamic resources held by the
** merge-writer object pWriter, and if no error has occurred, to flush
** all outstanding node buffers held by pWriter to disk.
**
** If *pRc is not SQLITE_OK when this function is called, then no attempt
** is made to write any data to disk. Instead, this function serves only
** to release outstanding resources.
**
** Otherwise, if *pRc is initially SQLITE_OK and an error occurs while
** flushing buffers to disk, *pRc is set to an SQLite error code before
** returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3IncrmergeRelease</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,       <comment type="block">/* Merge-writer object */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Used to iterate through non-root layers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRoot</name></decl>;</decl_stmt>                      <comment type="block">/* Index of root in pWriter-&gt;aNodeWriter */</comment>
  <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pRoot</name></decl>;</decl_stmt>              <comment type="block">/* NodeWriter for root node */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Error code */</comment>

  <comment type="block">/* Set iRoot to the index in pWriter-&gt;aNodeWriter[] of the output segment 
  ** root node. If the segment fits entirely on a single leaf node, iRoot
  ** will be set to 0. If the root node is the parent of the leaves, iRoot
  ** will be 1. And so on.  */</comment>
  <for>for<control>(<init><expr><name>iRoot</name><operator>=</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iRoot</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iRoot</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name> <operator>||</operator> <name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Empty output segment. This is a no-op. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iRoot</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* The entire output segment fits on a single node. Normally, this means
  ** the node would be stored as a blob in the "root" column of the %_segdir
  ** table. However, this is not permitted in this case. The problem is that 
  ** space has already been reserved in the %_segments table, and so the 
  ** start_block and end_block fields of the %_segdir table must be populated. 
  ** And, by design or by accident, released versions of FTS cannot handle 
  ** segments that fit entirely on the root node with start_block!=0.
  **
  ** Instead, create a synthetic root node that contains nothing but a 
  ** pointer to the single content node. So that the segment consists of a
  ** single leaf and a single interior (root) node.
  **
  ** Todo: Better might be to defer allocating space in the %_segments 
  ** table until we are sure it is needed.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pBlock</name> <init>= <expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>block</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>FTS3_VARINT_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(
          <argument><expr><operator>&amp;</operator><name><name>pBlock</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iBlock</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iRoot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Flush all currently outstanding nodes to disk. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iRoot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Write the %_segdir record. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegdir</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
        <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iAbsLevel</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,               <comment type="block">/* level */</comment>
        <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iIdx</name></name></expr></argument>,                      <comment type="block">/* idx */</comment>
        <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>,                    <comment type="block">/* start_block */</comment>
        <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iBlock</name></expr></argument>,     <comment type="block">/* leaves_end_block */</comment>
        <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEnd</name></name></expr></argument>,                      <comment type="block">/* end_block */</comment>
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pWriter</name><operator>-&gt;</operator><name>bNoLeafData</name></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,   <comment type="block">/* end_block */</comment>
        <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name></expr></argument>      <comment type="block">/* root */</comment>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRoot</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare the term in buffer zLhs (size in bytes nLhs) with that in
** zRhs (size in bytes nRhs) using memcmp. If one term is a prefix of
** the other, it is considered to be smaller than the other.
**
** Return -ve if zLhs is smaller than zRhs, 0 if it is equal, or +ve
** if it is greater.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TermCmp</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLhs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLhs</name></decl></parameter>,     <comment type="block">/* LHS of comparison */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRhs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRhs</name></decl></parameter>      <comment type="block">/* RHS of comparison */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>nLhs</name></expr></argument>, <argument><expr><name>nRhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nCmp</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>zLhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name>zRhs</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zLhs</name></expr></argument>, <argument><expr><name>zRhs</name></expr></argument>, <argument><expr><name>nCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <name>nLhs</name> <operator>-</operator> <name>nRhs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Query to see if the entry in the %_segments table with blockid iEnd is 
** NULL. If no error occurs and the entry is NULL, set *pbRes 1 before
** returning. Otherwise, set *pbRes to 0. 
**
** Or, if an error occurs while querying the database, return an SQLite 
** error code. The final value of *pbRes is undefined in this case.
**
** This is used to test if a segment is an "appendable" segment. If it
** is, then a NULL entry has been inserted into the %_segments table
** with blockid %_segdir.end_block.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IsAppendable</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbRes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bRes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Result to set *pbRes to */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pCheck</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Statement to query database with */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SEGMENT_IS_APPENDABLE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCheck</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bRes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><operator>*</operator><name>pbRes</name> <operator>=</operator> <name>bRes</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when initializing an incremental-merge operation.
** It checks if the existing segment with index value iIdx at absolute level 
** (iAbsLevel+1) can be appended to by the incremental merge. If it can, the
** merge-writer object *pWriter is initialized to write to it.
**
** An existing segment can be appended to by an incremental merge if:
**
**   * It was initially created as an appendable segment (with all required
**     space pre-allocated), and
**
**   * The first key read from the input (arguments zKey and nKey) is 
**     greater than the largest key currently stored in the potential
**     output segment.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeLoad</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level of input segments */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>,                       <comment type="block">/* Index of candidate output segment */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>,               <comment type="block">/* First key to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,                       <comment type="block">/* Number of bytes in nKey */</comment>
  <parameter><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>        <comment type="block">/* Populate this object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* SELECT to read %_segdir entry */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_SEGDIR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Value of %_segdir.start_block */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iLeafEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Value of %_segdir.leaves_end_block */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Value of %_segdir.end_block */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Pointer to %_segdir.root buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Size of aRoot[] in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>                      <comment type="block">/* Return code from sqlite3_reset() */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bAppendable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Set to true if segment is appendable */</comment>

    <comment type="block">/* Read the %_segdir entry for index iIdx absolute level (iAbsLevel+1) */</comment>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLeafEnd</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3ReadEndBlockField</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>bNoLeafData</name></name> <operator>=</operator> <operator>(</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRoot</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aRoot</name> <operator>=</operator> <call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>aRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><name>nRoot</name></expr> ?</condition><then> <expr><name>SQLITE_NOMEM</name></expr> </then><else>: <expr><name>FTS_CORRUPT_VTAB</name></expr></else></ternary></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Check for the zero-length marker in the %_segments table */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IsAppendable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bAppendable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check that zKey/nKey is larger than the largest key the candidate */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bAppendable</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aLeaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nLeaf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLeafEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aLeaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLeaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>NodeReader</name></type> <name>reader</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>aLeaf</name></expr></argument>, <argument><expr><name>nLeaf</name></expr></argument>)</argument_list></call></expr>;</init>
            <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>reader</name><operator>.</operator><name>aNode</name></name></expr>;</condition>
            <incr><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr></incr>
        )</control><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>reader</name><operator>.</operator><name>aNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><call><name>fts3TermCmp</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bAppendable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>nodeReaderRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bAppendable</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is possible to append to this segment. Set up the IncrmergeWriter
      ** object to do so.  */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aRoot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>NodeWriter</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nHeight</name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <name>nHeight</name><operator>&gt;=</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iEnd</name> <operator>-</operator> <name>iStart</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iAbsLevel</name></name> <operator>=</operator> <name>iAbsLevel</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>=</operator> <name>iIdx</name></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nHeight</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlock</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>i</name><operator>*</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>nHeight</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name><operator>*</operator><name>nHeight</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, 
          <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>nRoot</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>FTS3_NODE_PADDING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name>aRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name><index>[<expr><name>nRoot</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nHeight</name></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>NodeReader</name></type> <name>reader</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><name><name>reader</name><operator>.</operator><name>aNode</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>reader</name><operator>.</operator><name>aNode</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iBlock</name></name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>iChild</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>iChild</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlock</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, 
                  <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>nBlock</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>FTS3_NODE_PADDING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>
                  )</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nBlock</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>a</name><index>[<expr><name>nBlock</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FTS3_NODE_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>nodeReaderRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Determine the largest segment index value that exists within absolute
** level iAbsLevel+1. If no error occurs, set *piIdx to this value plus
** one before returning SQLITE_OK. Or, if there are no segments at all 
** within level iAbsLevel, set *piIdx to zero.
**
** If an error occurs, return an SQLite error code. The final value of
** *piIdx is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeOutputIdx</name><parameter_list>( 
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS Table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute index of input segments */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piIdx</name></decl></parameter>                      <comment type="block">/* OUT: Next free index at iAbsLevel+1 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pOutputIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* SQL used to find output index */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_NEXT_SEGMENT_INDEX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOutputIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pOutputIdx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pOutputIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piIdx</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pOutputIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pOutputIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Allocate an appendable output segment on absolute level iAbsLevel+1
** with idx value iIdx.
**
** In the %_segdir table, a segment is defined by the values in three
** columns:
**
**     start_block
**     leaves_end_block
**     end_block
**
** When an appendable segment is allocated, it is estimated that the
** maximum number of leaf blocks that may be required is the sum of the
** number of leaf blocks consumed by the input segments, plus the number
** of input segments, multiplied by two. This value is stored in stack 
** variable nLeafEst.
**
** A total of 16*nLeafEst blocks are allocated when an appendable segment
** is created ((1 + end_block - start_block)==16*nLeafEst). The contiguous
** array of leaf nodes starts at the first block allocated. The array
** of interior nodes that are parents of the leaf nodes start at block
** (start_block + (1 + end_block - start_block) / 16). And so on.
**
** In the actual code below, the value "16" is replaced with the 
** pre-processor macro FTS_MAX_APPENDABLE_HEIGHT.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeWriter</name><parameter_list>( 
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* Fts3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level of input segments */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>,                       <comment type="block">/* Index of new output segment */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,       <comment type="block">/* Cursor that data will be read from */</comment>
  <parameter><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>        <comment type="block">/* Populate this object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLeafEst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Blocks allocated for leaf nodes */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pLeafEst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* SQL used to determine nLeafEst */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFirstBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* SQL used to determine first block */</comment>

  <comment type="block">/* Calculate nLeafEst. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_MAX_LEAF_NODE_ESTIMATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeafEst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pLeafEst</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pLeafEst</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pLeafEst</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nLeafEst</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pLeafEst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pLeafEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Calculate the first block to use in the output segment */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_NEXT_SEGMENTS_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFirstBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pFirstBlock</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pFirstBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>+=</operator> <name>nLeafEst</name> <operator>*</operator> <name>FTS_MAX_APPENDABLE_HEIGHT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pFirstBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Insert the marker in the %_segments table to make sure nobody tries
  ** to steal the space just allocated. This is also used to identify 
  ** appendable segments.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEnd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iAbsLevel</name></name> <operator>=</operator> <name>iAbsLevel</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name> <operator>=</operator> <name>nLeafEst</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iIdx</name></name> <operator>=</operator> <name>iIdx</name></expr>;</expr_stmt>

  <comment type="block">/* Set up the array of NodeWriter objects */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>FTS_MAX_APPENDABLE_HEIGHT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>aNodeWriter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlock</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iStart</name></name> <operator>+</operator> <name>i</name><operator>*</operator><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove an entry from the %_segdir table. This involves running the 
** following two statements:
**
**   DELETE FROM %_segdir WHERE level = :iAbsLevel AND idx = :iIdx
**   UPDATE %_segdir SET idx = idx - 1 WHERE level = :iAbsLevel AND idx &gt; :iIdx
**
** The DELETE statement removes the specific %_segdir level. The UPDATE 
** statement ensures that the remaining segments have contiguously allocated
** idx values.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RemoveSegdirEntry</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level to delete from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>                        <comment type="block">/* Index of %_segdir entry to delete */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* DELETE statement */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGDIR_ENTRY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** One or more segments have just been removed from absolute level iAbsLevel.
** Update the 'idx' values of the remaining segments in the level so that
** the idx values are a contiguous sequence starting from 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3RepackSegdirLevel</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>         <comment type="block">/* Absolute level to repack */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Array of remaining idx values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Valid entries in aIdx[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Allocated size of aIdx[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Iterator variable */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Select statement to read idx values */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUpdate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Update statement to modify idx values */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_INDEXES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nIdx</name><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>aIdx</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>aIdx</name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>nIdx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SHIFT_SEGDIR_ENTRY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pUpdate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnoreSavepoint</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnoreSavepoint</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nIdx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>i</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bIgnoreSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3StartNode</name><parameter_list>(<parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iChild</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>iHeight</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iChild</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&gt;=</operator><literal type="number">1</literal><operator>+</operator><call><name>sqlite3Fts3VarintLen</name><argument_list>(<argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The first two arguments are a pointer to and the size of a segment b-tree
** node. The node may be a leaf or an internal node.
**
** This function creates a new node image in blob object *pNew by copying
** all terms that are greater than or equal to zTerm/nTerm (for leaf nodes)
** or greater than zTerm/nTerm (for internal nodes) from aNode/nNode.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TruncateNode</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aNode</name></decl></parameter>,              <comment type="block">/* Current node image */</comment>
  <parameter><decl><type><name>int</name></type> <name>nNode</name></decl></parameter>,                      <comment type="block">/* Size of aNode in bytes */</comment>
  <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>,                     <comment type="block">/* OUT: Write new node image here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Omit all terms smaller than this */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piBlock</name></decl></parameter>          <comment type="block">/* OUT: Block number in next layer down */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>NodeReader</name></type> <name>reader</name></decl>;</decl_stmt>              <comment type="block">/* Reader object */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>prev</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>          <comment type="block">/* Previous term written to new node */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bLeaf</name></decl>;</decl_stmt>                       <comment type="block">/* True for a leaf node */</comment>

  <if_stmt><if>if<condition>( <expr><name>nNode</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>bLeaf</name> <operator>=</operator> <name><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>

  <comment type="block">/* Allocate required output space */</comment>
  <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Populate new node buffer */</comment>
  <for>for<control>(<init><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>nNode</name></expr></argument>)</argument_list></call></expr>;</init> 
      <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>reader</name><operator>.</operator><name>aNode</name></name></expr>;</condition> 
      <incr><expr><name>rc</name> <operator>=</operator> <call><name>nodeReaderNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr></incr>
  )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>fts3TermCmp</name><argument_list>(<argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>bLeaf</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3StartNode</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>iChild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piBlock</name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>iChild</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3AppendToNode</name><argument_list>(
        <argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>term</name><operator>.</operator><name>n</name></name></expr></argument>,
        <argument><expr><name><name>reader</name><operator>.</operator><name>aDoclist</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>nDoclist</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3StartNode</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>iChild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piBlock</name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>iChild</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;=</operator><name><name>pNew</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>nodeReaderRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>prev</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Remove all terms smaller than zTerm/nTerm from segment iIdx in absolute 
** level iAbsLevel. This may involve deleting entries from the %_segments
** table, and modifying existing entries in both the %_segments and %_segdir
** tables.
**
** SQLITE_OK is returned if the segment is updated successfully. Or an
** SQLite error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3TruncateSegment</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level of segment to modify */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIdx</name></decl></parameter>,                       <comment type="block">/* Index within level of segment to modify */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Remove terms smaller than this */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>                      <comment type="block">/* Number of bytes in buffer zTerm */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>root</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>            <comment type="block">/* New root page image */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>block</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>           <comment type="block">/* Buffer used for any other block */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Block id */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNewStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* New value for iStartBlock */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOldStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Old value for iStartBlock */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFetch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Statement used to fetch segdir */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_SEGDIR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>                      <comment type="block">/* sqlite3_reset() return code */</comment>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aRoot</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>iOldStart</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TruncateNode</name><argument_list>(<argument><expr><name>aRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iBlock</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iNewStart</name> <operator>=</operator> <name>iBlock</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3ReadBlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TruncateNode</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3WriteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iNewStart</name></expr></argument>, <argument><expr><name><name>block</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Variable iNewStart now contains the first valid leaf node. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iNewStart</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_SEGMENTS_RANGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iOldStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iNewStart</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pChomp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_CHOMP_SEGDIR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iNewStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>root</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pChomp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>root</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>block</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after an incrmental-merge operation has run to
** merge (or partially merge) two or more segments from absolute level
** iAbsLevel.
**
** Each input segment is either removed from the db completely (if all of
** its data was copied to the output segment by the incrmerge operation)
** or modified in place so that it no longer contains those entries that
** have been duplicated in the output segment.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeChomp</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS table handle */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name></decl></parameter>,        <comment type="block">/* Absolute level containing segments */</comment>
  <parameter><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,       <comment type="block">/* Chomp all segments opened by this cursor */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRem</name></decl></parameter>                      <comment type="block">/* Number of segments not deleted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Fts3SegReader</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Find the Fts3SegReader object with Fts3SegReader.iIdx==i. It is hiding
    ** somewhere in the pCsr-&gt;apSegment[] array.  */</comment>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>j</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>apSegment</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iIdx</name></name><operator>==</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name> <operator>&amp;&amp;</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>iIdx</name></name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pSeg</name><operator>-&gt;</operator><name>aNode</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Seg-reader is at EOF. Remove the entire input segment. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3RemoveSegdirEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnRem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The incremental merge did not copy all the data from this 
      ** segment to the upper level. The segment is modified in place
      ** so that it contains no keys smaller than zTerm/nTerm. */</comment> 
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>zTerm</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3TruncateSegment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iIdx</name></name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>!=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3RepackSegdirLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnRem</name> <operator>=</operator> <name>nRem</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Store an incr-merge hint in the database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeHintStore</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pHint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pReplace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_REPLACE_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pReplace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pReplace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_INCRMERGEHINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pReplace</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pReplace</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load an incr-merge hint from the database. The incr-merge hint, if one 
** exists, is stored in the rowid==1 row of the %_stat table.
**
** If successful, populate blob *pHint with the value read from the %_stat
** table and return SQLITE_OK. Otherwise, if an error occurs, return an
** SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeHintLoad</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pHint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_INCRMERGEHINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aHint</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nHint</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aHint</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pHint</name></expr></argument>, <argument><expr><name>nHint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>a</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>aHint</name></expr></argument>, <argument><expr><name>nHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nHint</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, append an entry to the hint stored in blob *pHint. Each entry
** consists of two varints, the absolute level number of the input segments 
** and the number of input segments.
**
** If successful, leave *pRc set to SQLITE_OK and return. If an error occurs,
** set *pRc to an SQLite error code before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3IncrmergeHintPush</name><parameter_list>(
  <parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pHint</name></decl></parameter>,                    <comment type="block">/* Hint blob to append to */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iAbsLevel</name></decl></parameter>,                  <comment type="block">/* First varint to store in hint */</comment>
  <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,                     <comment type="block">/* Second varint to store in hint */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>blobGrowBuffer</name><argument_list>(<argument><expr><name>pHint</name></expr></argument>, <argument><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>FTS3_VARINT_MAX</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>sqlite3Fts3PutVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>nInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read the last entry (most recently pushed) from the hint blob *pHint
** and then remove the entry. Write the two values read to *piAbsLevel and 
** *pnInput before returning.
**
** If no error occurs, return SQLITE_OK. If the hint blob in *pHint does
** not contain at least two valid varints, return SQLITE_CORRUPT_VTAB.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IncrmergeHintPop</name><parameter_list>(<parameter><decl><type><name>Blob</name> <modifier>*</modifier></type><name>pHint</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piAbsLevel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnInput</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nHint</name> <init>= <expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pHint</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

  <expr_stmt><expr><name><name>pHint</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>piAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pHint</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pnInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;=</operator><name>nHint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>nHint</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Attempt an incremental merge that writes nMerge leaf blocks.
**
** Incremental merges happen nMin segments at a time. The segments 
** to be merged are the nMin oldest segments (the ones with the smallest 
** values for the _segdir.idx field) in the highest level that contains 
** at least nMin segments. Multiple merges might occur in an attempt to 
** write the quota of nMerge leaf blocks.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3Incrmerge</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMerge</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMin</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>nMerge</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Number of leaf pages yet to  be written */</comment>
  <decl_stmt><decl><type><name>Fts3MultiSegReader</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>       <comment type="block">/* Cursor used to read input data */</comment>
  <decl_stmt><decl><type><name>Fts3SegFilter</name> <modifier>*</modifier></type><name>pFilter</name></decl>;</decl_stmt>         <comment type="block">/* Filter used with cursor pCsr */</comment>
  <decl_stmt><decl><type><name>IncrmergeWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl>;</decl_stmt>       <comment type="block">/* Writer object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of input segments */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iAbsLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Absolute level number to work on */</comment>
  <decl_stmt><decl><type><name>Blob</name></type> <name>hint</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>          <comment type="block">/* Hint read from %_stat table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDirtyHint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if blob 'hint' has been modified */</comment>

  <comment type="block">/* Allocate space for the cursor, filter and writer objects */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nAlloc</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFilter</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pWriter</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pWriter</name> <operator>=</operator> <operator>(</operator><name>IncrmergeWriter</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pWriter</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pFilter</name> <operator>=</operator> <operator>(</operator><name>Fts3SegFilter</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pWriter</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>Fts3MultiSegReader</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFilter</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeHintLoad</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>i64</name></type> <name>nMod</name> <init>= <expr><name>FTS3_SEGDIR_MAXLEVEL</name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFindLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* SQL used to determine iAbsLevel */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bUseHint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* True if attempting to append */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Largest idx in level (iAbsLevel+1) */</comment>

    <comment type="block">/* Search the %_segdir table for the absolute level with the smallest
    ** relative level number that contains at least nMin segments, if any.
    ** If one is found, set iAbsLevel to the absolute level number and
    ** nSeg to nMin. If no level with at least nMin segments can be found, 
    ** set nSeg to -1.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_FIND_MERGE_LEVEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFindLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pFindLevel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>nMin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pFindLevel</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iAbsLevel</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pFindLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSeg</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pFindLevel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSeg</name><operator>&gt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nSeg</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pFindLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the hint read from the %_stat table is not empty, check if the
    ** last entry in it specifies a relative level smaller than or equal
    ** to the level identified by the block above (if any). If so, this 
    ** iteration of the loop will work on merging at the hinted level.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>.</operator><name>n</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nHint</name> <init>= <expr><name><name>hint</name><operator>.</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iHintAbsLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Hint level */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nHintSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Hint number of segments */</comment>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeHintPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHintAbsLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHintSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSeg</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iAbsLevel</name> <operator>%</operator> <name>nMod</name><operator>)</operator> <operator>&gt;=</operator> <operator>(</operator><name>iHintAbsLevel</name> <operator>%</operator> <name>nMod</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <comment type="block">/* Based on the scan in the block above, it is known that there
        ** are no levels with a relative level smaller than that of
        ** iAbsLevel with more than nSeg segments, or if nSeg is -1, 
        ** no levels with more than nMin segments. Use this to limit the
        ** value of nHintSeg to avoid a large memory allocation in case the 
        ** merge-hint is corrupt*/</comment>
        <expr_stmt><expr><name>iAbsLevel</name> <operator>=</operator> <name>iHintAbsLevel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSeg</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>nMin</name></expr></argument>,<argument><expr><name>nSeg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nHintSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bUseHint</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bDirtyHint</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* This undoes the effect of the HintPop() above - so that no entry
        ** is removed from the hint blob.  */</comment>
        <expr_stmt><expr><name><name>hint</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>nHint</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If nSeg is less that zero, then there is no level with at least
    ** nMin segments and no hint in the %_stat table. No work to do.
    ** Exit early in this case.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>nSeg</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMod</name><operator>&lt;=</operator><literal type="number">0x7FFFFFFF</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name><name>iAbsLevel</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>iAbsLevel</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>nMod</name><operator>&lt;&lt;</operator><literal type="number">32</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Open a cursor to iterate through the contents of the oldest nSeg 
    ** indexes of absolute level iAbsLevel. If this cursor is opened using 
    ** the 'hint' parameters, it is possible that there are less than nSeg
    ** segments available in level iAbsLevel. In this case, no work is
    ** done on iAbsLevel - fall through to the next iteration of the loop 
    ** to start work on some other level.  */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>FTS3_SEGMENT_REQUIRE_POS</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeOutputIdx</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bUseHint</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>bUseHint</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>bUseHint</name> <operator>&amp;&amp;</operator> <name>iIdx</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bIgnore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SegmentIsMaxLevel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bIgnore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bIgnore</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pFilter</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FTS3_SEGMENT_IGNORE_EMPTY</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeCsr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name>nSeg</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nSegment</name></name><operator>==</operator><name>nSeg</name>
     <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pFilter</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bEmpty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bEmpty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFinish</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bUseHint</name> <operator>&amp;&amp;</operator> <name>iIdx</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>zTerm</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>nTerm</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeLoad</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name>iIdx</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeWriter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nLeafEst</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3LogMerge</name><argument_list>(<argument><expr><name>nSeg</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bEmpty</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <do>do <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeAppend</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>nWork</name></name><operator>&gt;=</operator><name>nRem</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition>;</do>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update or delete the input segments */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nWork</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeChomp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>nSeg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bDirtyHint</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fts3IncrmergeHintPush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><name>iAbsLevel</name></expr></argument>, <argument><expr><name>nSeg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>nSeg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3IncrmergeRelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSeg</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>bNoLeafData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fts3PromoteSegments</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iAbsLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nLeafData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFinish</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Write the hint values into the %_stat table for the next incr-merger */</comment>
  <if_stmt><if>if<condition>( <expr><name>bDirtyHint</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IncrmergeHintStore</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the text beginning at *pz into an integer and return
** its value.  Advance *pz to point to the first character past
** the integer.
**
** This function used for parameters to merge= and incrmerge=
** commands. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3Getint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>*</operator><name>pz</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>z</name><operator>)</operator><operator>&lt;=</operator><literal type="char">'9'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">214748363</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">10</literal><operator>*</operator><name>i</name> <operator>+</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><operator>*</operator><name>pz</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Process statements of the form:
**
**    INSERT INTO table(table) VALUES('merge=A,B');
**
** A and B are integers that decode to be the number of leaf pages
** written for the merge, and the minimum number of segments on a level
** before it will be selected for a merge, respectively.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoIncrmerge</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>              <comment type="block">/* Nul-terminated string containing "A,B" */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMin</name> <init>= <expr><operator>(</operator><call><name>MergeCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMerge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zParam</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Read the first integer value */</comment>
  <expr_stmt><expr><name>nMerge</name> <operator>=</operator> <call><name>fts3Getint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the first integer value is followed by a ',',  read the second
  ** integer value. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">','</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nMin</name> <operator>=</operator> <call><name>fts3Getint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal> <operator>||</operator> <name>nMin</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Fts3CreateStatTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3Incrmerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nMerge</name></expr></argument>, <argument><expr><name>nMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Process statements of the form:
**
**    INSERT INTO table(table) VALUES('automerge=X');
**
** where X is an integer.  X==0 means to turn automerge off.  X!=0 means
** turn it on.  The setting is persistent.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoAutoincrmerge</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParam</name></decl></parameter>              <comment type="block">/* Nul-terminated string containing boolean */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <call><name>fts3Getint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name><operator>&gt;</operator><call><name>MergeCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3CreateStatTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_REPLACE_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FTS_STAT_AUTOINCRMERGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAutoincrmerge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 64-bit checksum for the FTS index entry specified by the
** arguments to this function.
*/</comment>
<function><type><specifier>static</specifier> <name>u64</name></type> <name>fts3ChecksumEntry</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,              <comment type="block">/* Pointer to buffer containing term */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,                      <comment type="block">/* Size of zTerm in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id for current row */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index (0..Fts3Table.nIndex-1) */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iDocid</name></decl></parameter>,                     <comment type="block">/* Docid for current row. */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Column number */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>                        <comment type="block">/* Position */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>ret</name> <init>= <expr><operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>iLangid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>iIndex</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>iCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>iPos</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name><name>zTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a checksum of all entries in the FTS index that correspond to
** language id iLangid. The checksum is calculated by XORing the checksums
** of each individual entry (see fts3ChecksumEntry()) together.
**
** If successful, the checksum value is returned and *pRc set to SQLITE_OK.
** Otherwise, if an error occurs, *pRc is set to an SQLite error code. The
** return value is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>u64</name></type> <name>fts3ChecksumIndex</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                   <comment type="block">/* FTS3 table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id to return cksum for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iIndex</name></decl></parameter>,                     <comment type="block">/* Index to cksum (0..p-&gt;nIndex-1) */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* OUT: Return code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3SegFilter</name></type> <name>filter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3MultiSegReader</name></type> <name>csr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>cksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>flags</name></name> <operator>=</operator>  <name>FTS3_SEGMENT_REQUIRE_POS</name><operator>|</operator><name>FTS3_SEGMENT_IGNORE_EMPTY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>filter</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>FTS3_SEGMENT_SCAN</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderCursor</name><argument_list>(
      <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>FTS3_SEGCURSOR_ALL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SegReaderStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>csr</name><operator>.</operator><name>aDoclist</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><index>[<expr><name><name>csr</name><operator>.</operator><name>nDoclist</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>i64</name></type> <name>iDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>pCsr</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u64</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pCsr</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iVal</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>iPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>iVal</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintU</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bDescIdx</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name> <operator>-</operator> <name>iVal</name><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><name>iDocid</name> <operator>+</operator> <name>iVal</name><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>iPos</name> <operator>+=</operator> <operator>(</operator><name>iVal</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>cksum</name> <operator>=</operator> <name>cksum</name> <operator>^</operator> <call><name>fts3ChecksumEntry</name><argument_list>(
                <argument><expr><name><name>csr</name><operator>.</operator><name>zTerm</name></name></expr></argument>, <argument><expr><name><name>csr</name><operator>.</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>iIndex</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iCol</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>iPos</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegReaderFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><name>cksum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check if the contents of the FTS index match the current contents of the
** content table. If no error occurs and the contents do match, set *pbOk
** to true and return SQLITE_OK. Or if the contents do not match, set *pbOk
** to false before returning.
**
** If an error occurs (e.g. an OOM or IO error), return an SQLite error 
** code. The final value of *pbOk is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3IntegrityCheck</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbOk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>cksum1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Checksum based on FTS index contents */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>cksum2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Checksum based on %_content contents */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllLangid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Statement to return all language-ids */</comment>

  <comment type="block">/* This block calculates the checksum according to the FTS index. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SqlStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_SELECT_ALL_LANGID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevLangid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>cksum1</name> <operator>=</operator> <name>cksum1</name> <operator>^</operator> <call><name>fts3ChecksumIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pAllLangid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This block calculates the checksum according to the %_content table */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
   
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %s"</literal></expr></argument> , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zReadExprlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iDocid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iLang</name> <init>= <expr><call><name>langidFromSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>

      <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>       <comment type="block">/* Buffer containing token */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in token */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iDum1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iDum2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Dummy variables */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Position of token in zText */</comment>

            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDum1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>cksum2</name> <operator>=</operator> <name>cksum2</name> <operator>^</operator> <call><name>fts3ChecksumEntry</name><argument_list>(
                  <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
              <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPrefix</name><operator>&lt;=</operator><name>nToken</name></expr> )</condition><block>{<block_content>
                  <expr_stmt><expr><name>cksum2</name> <operator>=</operator> <name>cksum2</name> <operator>^</operator> <call><name>fts3ChecksumEntry</name><argument_list>(
                      <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aIndex</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPrefix</name></expr></argument>, <argument><expr><name>iLang</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>
                  )</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></while>
          <if_stmt><if>if<condition>( <expr><name>pT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pbOk</name> <operator>=</operator> <operator>(</operator><name>cksum1</name><operator>==</operator><name>cksum2</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Run the integrity-check. If no error occurs and the current contents of
** the FTS index are correct, return SQLITE_OK. Or, if the contents of the
** FTS index are incorrect, return SQLITE_CORRUPT_VTAB.
**
** Or, if an error (e.g. an OOM or IO error) occurs, return an SQLite 
** error code.
**
** The integrity-check works as follows. For each token and indexed token
** prefix in the document set, a 64-bit checksum is calculated (by code
** in fts3ChecksumEntry()) based on the following:
**
**     + The index number (0 for the main index, 1 for the first prefix
**       index etc.),
**     + The token (or token prefix) text itself, 
**     + The language-id of the row it appears in,
**     + The docid of the row it appears in,
**     + The column it appears in, and
**     + The tokens position within that column.
**
** The checksums for all entries in the index are XORed together to create
** a single checksum for the entire index.
**
** The integrity-check code calculates the same checksum in two ways:
**
**     1. By scanning the contents of the FTS index, and 
**     2. By scanning and tokenizing the content table.
**
** If the two checksums are identical, the integrity-check is deemed to have
** passed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DoIntegrityCheck</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                    <comment type="block">/* FTS3 table handle */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IntegrityCheck</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bOk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Handle a 'special' INSERT of the form:
**
**   "INSERT INTO tbl(tbl) VALUES(&lt;expr&gt;)"
**
** Argument pVal contains the result of &lt;expr&gt;. Currently the only 
** meaningful value to insert is the text 'optimize'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SpecialInsert</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zVal</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"optimize"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoOptimize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">7</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"rebuild"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoRebuild</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">15</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"integrity-check"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoIntegrityCheck</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">6</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"merge="</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoIncrmerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">10</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"automerge="</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoAutoincrmerge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">9</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"nodesize="</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><literal type="number">24</literal> <operator>&amp;&amp;</operator> <name>v</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nPgsz</name></name><operator>-</operator><literal type="number">35</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nNodeSize</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">11</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><literal type="string">"maxpending="</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><literal type="number">64</literal> <operator>&amp;&amp;</operator> <name>v</name><operator>&lt;=</operator><name>FTS3_MAX_PENDING_DATA</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMaxPendingData</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">21</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>,<argument><expr><literal type="string">"test-no-incr-doclist="</literal></expr></argument>,<argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNoIncrDoclist</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">21</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">11</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>,<argument><expr><literal type="string">"mergecount="</literal></expr></argument>,<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zVal</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>v</name><operator>&gt;=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>v</name><operator>&lt;=</operator><name>FTS3_MERGE_COUNT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMergeCount</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_FTS4_DEFERRED</name></cpp:ifndef>
<comment type="block">/*
** Delete all cached deferred doclists. Deferred doclists are cached
** (allocated) by the sqlite3Fts3CacheDeferredDoclists() function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3FreeDeferredDoclists</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pDef</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr>;</init> <condition><expr><name>pDef</name></expr>;</condition> <incr><expr><name>pDef</name><operator>=</operator><name><name>pDef</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fts3PendingListDelete</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all entries in the pCsr-&gt;pDeffered list. Entries are added to 
** this list using sqlite3Fts3DeferToken().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3FreeDeferredTokens</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pDef</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr>;</init> <condition><expr><name>pDef</name></expr>;</condition> <incr><expr><name>pDef</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pDef</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3PendingListDelete</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Generate deferred-doclists for all tokens in the pCsr-&gt;pDeferred list
** based on the row that pCsr currently points to.
**
** A deferred-doclist is like any other doclist with position information
** included, except that it only contains entries for a single row of the
** table, not for all rows.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3CacheDeferredDoclists</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through table columns */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>         <comment type="block">/* Docid of the row pCsr points to */</comment>
    <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>      <comment type="block">/* Used to iterate through deferred tokens */</comment>
  
    <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pT</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
   
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>abNotindexed</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pTC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name>pT</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>       <comment type="block">/* Buffer containing token */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in token */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>iDum1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iDum2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Dummy variables */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Position of token in zText */</comment>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pTC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDum1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>pDef</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr>;</init> <condition><expr><name>pDef</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pDef</name><operator>=</operator><name><name>pDef</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pPT</name> <init>= <expr><name><name>pDef</name><operator>-&gt;</operator><name>pToken</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>iCol</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>||</operator> <name><name>pDef</name><operator>-&gt;</operator><name>iCol</name></name><operator>==</operator><name>i</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPT</name><operator>-&gt;</operator><name>bFirst</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iPos</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPT</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><name>nToken</name> <operator>||</operator> <operator>(</operator><name><name>pPT</name><operator>-&gt;</operator><name>isPrefix</name></name> <operator>&amp;&amp;</operator> <name><name>pPT</name><operator>-&gt;</operator><name>n</name></name><operator>&lt;</operator><name>nToken</name><operator>)</operator><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>pPT</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pPT</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
              )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>fts3PendingListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>pTC</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pTC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for<control>(<init><expr><name>pDef</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr>;</init> <condition><expr><name>pDef</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pDef</name><operator>=</operator><name><name>pDef</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingListAppendVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pDef</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3Fts3DeferredTokenList</name><parameter_list>(
  <parameter><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSkip</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>dummy</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pList</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pRet</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nSkip</name> <operator>=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pList</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pList</name><operator>-&gt;</operator><name>nData</name></name> <operator>-</operator> <name>nSkip</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pList</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name>nSkip</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>pnData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an entry for token pToken to the pCsr-&gt;pDeferred list.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3DeferToken</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Fts3 table cursor */</comment>
  <parameter><decl><type><name>Fts3PhraseToken</name> <modifier>*</modifier></type><name>pToken</name></decl></parameter>,        <comment type="block">/* Token to defer */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                        <comment type="block">/* Column that token must appear in (or -1) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3DeferredToken</name> <modifier>*</modifier></type><name>pDeferred</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pDeferred</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pDeferred</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pDeferred</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDeferred</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pDeferred</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDeferred</name><operator>-&gt;</operator><name>pToken</name></name> <operator>=</operator> <name>pToken</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDeferred</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr>;</expr_stmt> 
  <expr_stmt><expr><name><name>pDeferred</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name> <operator>=</operator> <name>pDeferred</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pToken</name><operator>-&gt;</operator><name>pDeferred</name></name> <operator>=</operator> <name>pDeferred</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** SQLite value pRowid contains the rowid of a row that may or may not be
** present in the FTS3 table. If it is, delete it and adjust the contents
** of subsiduary data structures accordingly.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3DeleteByRowid</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnChng</name></decl></parameter>,                    <comment type="block">/* IN/OUT: Decrement if row is deleted */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzDel</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* True if *pRowid really is in the table */</comment>

  <expr_stmt><expr><call><name>fts3DeleteTerms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>, <argument><expr><name>aSzDel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bFound</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>isEmpty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Deleting *pRowid leaves the table empty */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3IsEmpty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>isEmpty</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Deleting this row means the whole table is empty. In this case
        ** delete the contents of all three tables and throw away any
        ** data in the pendingTerms hash table.  */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteAll</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnChng</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSzDel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pnChng</name> <operator>=</operator> <operator>*</operator><name>pnChng</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_CONTENT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fts3SqlExec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQL_DELETE_DOCSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work for the xUpdate method of FTS3 virtual
** tables. The schema of the virtual table being:
**
**     CREATE TABLE &lt;table name&gt;( 
**       &lt;user columns&gt;,
**       &lt;table name&gt; HIDDEN, 
**       docid HIDDEN, 
**       &lt;langid&gt; HIDDEN
**     );
**
** 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3UpdateMethod</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* FTS3 vtab object */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Size of argument array */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>,          <comment type="block">/* Array of arguments */</comment>
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>            <comment type="block">/* OUT: The affected (or effected) rowid */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzIns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Sizes of inserted documents */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aSzDel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Sizes of deleted documents */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChng</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Net change in number of documents */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInsertDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* At this point it must be known if the %_stat table exists or not.
  ** So bHasStat may not be 2.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bHasStat</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSegments</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( 
      <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal>                     <comment type="block">/* DELETE operations */</comment>
   <operator>||</operator> <name>nArg</name><operator>==</operator><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>  <comment type="block">/* INSERT or UPDATE operations */</comment>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for a "special" INSERT operation. One of the form:
  **
  **   INSERT INTO xyz(xyz) VALUES('command');
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> 
   <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name> 
   <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SpecialInsert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>update_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    <goto>goto <name>update_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Allocate space to hold the change in document sizes */</comment>
  <expr_stmt><expr><name>aSzDel</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSzDel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aSzDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>update_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>aSzIns</name> <operator>=</operator> <operator>&amp;</operator><name><name>aSzDel</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aSzDel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSzDel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3Writelock</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>update_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* If this is an INSERT operation, or an UPDATE that modifies the rowid
  ** value, then this operation requires constraint handling.
  **
  ** If the on-conflict mode is REPLACE, this means that the existing row
  ** should be deleted from the database before inserting the new row. Or,
  ** if the on-conflict mode is other than REPLACE, then this method must
  ** detect the conflict and return SQLITE_CONSTRAINT before beginning to
  ** modify the database file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Find the value object that holds the new rowid value. */</comment>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pNewRowid</name> <init>= <expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pNewRowid</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pNewRowid</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pNewRowid</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator> 
        <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name>
     <operator>||</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pNewRowid</name></expr></argument>)</argument_list></call>
    <operator>)</operator></expr>)</condition><block>{<block_content>
      <comment type="block">/* The new rowid is not NULL (in this case the rowid will be
      ** automatically assigned and there is no chance of a conflict), and 
      ** the statement is either an INSERT or an UPDATE that modifies the
      ** rowid column. So if the conflict mode is REPLACE, then delete any
      ** existing row with rowid=pNewRowid. 
      **
      ** Or, if the conflict mode is not REPLACE, insert the new record into 
      ** the %_content table. If we hit the duplicate rowid constraint (or any
      ** other error) while doing so, return immediately.
      **
      ** This branch may also run if pNewRowid contains a value that cannot
      ** be losslessly converted to an integer. In this case, the eventual 
      ** call to fts3InsertData() (either just below or further on in this
      ** function) will return SQLITE_MISMATCH. If fts3DeleteByRowid is 
      ** invoked, it will delete zero rows (since no row will have
      ** docid=$pNewRowid if $pNewRowid is not an integer value).
      */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_REPLACE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteByRowid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pNewRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nChng</name></expr></argument>, <argument><expr><name>aSzDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3InsertData</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bInsertDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <goto>goto <name>update_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is a DELETE or UPDATE operation, remove the old record. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DeleteByRowid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nChng</name></expr></argument>, <argument><expr><name>aSzDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* If this is an INSERT or UPDATE operation, insert the new record. */</comment>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iLangid</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>bInsertDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3InsertData</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3PendingTermsDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><operator>*</operator><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iPrevDocid</name></name><operator>==</operator><operator>*</operator><name>pRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3InsertTerms</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>apVal</name></expr></argument>, <argument><expr><name>aSzIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bHasDocsize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3InsertDocsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aSzIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nChng</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bFts4</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3UpdateDocTotals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>aSzIns</name></expr></argument>, <argument><expr><name>aSzDel</name></expr></argument>, <argument><expr><name>nChng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>update_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aSzDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Flush any data in the pending-terms hash table to disk. If successful,
** merge all segments in the database (including the new segment, if 
** there was any data to flush) into a single segment. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts3Optimize</name><parameter_list>(<parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT fts3"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3DoOptimize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"RELEASE fts3"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO fts3"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"RELEASE fts3"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
