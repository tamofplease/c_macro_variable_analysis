<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/fts3/fts3_snippet.c"><comment type="block">/*
** 2009 Oct 23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Characters that may appear in the second argument to matchinfo().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_NPHRASE</name></cpp:macro>   <cpp:value>'p'</cpp:value></cpp:define>        <comment type="block">/* 1 value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_NCOL</name></cpp:macro>      <cpp:value>'c'</cpp:value></cpp:define>        <comment type="block">/* 1 value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_NDOC</name></cpp:macro>      <cpp:value>'n'</cpp:value></cpp:define>        <comment type="block">/* 1 value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_AVGLENGTH</name></cpp:macro> <cpp:value>'a'</cpp:value></cpp:define>        <comment type="block">/* nCol values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_LENGTH</name></cpp:macro>    <cpp:value>'l'</cpp:value></cpp:define>        <comment type="block">/* nCol values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_LCS</name></cpp:macro>       <cpp:value>'s'</cpp:value></cpp:define>        <comment type="block">/* nCol values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_HITS</name></cpp:macro>      <cpp:value>'x'</cpp:value></cpp:define>        <comment type="block">/* 3*nCol*nPhrase values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_LHITS</name></cpp:macro>     <cpp:value>'y'</cpp:value></cpp:define>        <comment type="block">/* nCol*nPhrase values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_LHITS_BM</name></cpp:macro>  <cpp:value>'b'</cpp:value></cpp:define>        <comment type="block">/* nCol*nPhrase values */</comment>

<comment type="block">/*
** The default value for the second argument to matchinfo(). 
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS3_MATCHINFO_DEFAULT</name></cpp:macro>   <cpp:value>"pcx"</cpp:value></cpp:define>


<comment type="block">/*
** Used as an fts3ExprIterate() context when loading phrase doclists to
** Fts3Expr.aDoclist[]/nDoclist.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>LoadDoclistCtx</name></name></type> <name>LoadDoclistCtx</name>;</typedef>
<struct>struct <name>LoadDoclistCtx</name> <block>{
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* FTS3 Cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt>                    <comment type="block">/* Number of phrases seen so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                     <comment type="block">/* Number of tokens seen so far */</comment>
}</block>;</struct>

<comment type="block">/*
** The following types are used as part of the implementation of the 
** fts3BestSnippet() routine.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SnippetIter</name></name></type> <name>SnippetIter</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SnippetPhrase</name></name></type> <name>SnippetPhrase</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>SnippetFragment</name></name></type> <name>SnippetFragment</name>;</typedef>

<struct>struct <name>SnippetIter</name> <block>{
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>               <comment type="block">/* Cursor snippet is being generated from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Extract snippet from this column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSnippet</name></decl>;</decl_stmt>                   <comment type="block">/* Requested snippet length (in tokens) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt>                    <comment type="block">/* Number of phrases in query */</comment>
  <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>aPhrase</name></decl>;</decl_stmt>         <comment type="block">/* Array of size nPhrase */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name></decl>;</decl_stmt>                   <comment type="block">/* First token of current snippet */</comment>
}</block>;</struct>

<struct>struct <name>SnippetPhrase</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                     <comment type="block">/* Number of tokens in phrase */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to start of phrase position list */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHead</name></decl>;</decl_stmt>                      <comment type="block">/* Next value in position list */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pHead</name></decl>;</decl_stmt>                    <comment type="block">/* Position list data following iHead */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iTail</name></decl>;</decl_stmt>                      <comment type="block">/* Next value in trailing position list */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>                    <comment type="block">/* Position list data following iTail */</comment>
}</block>;</struct>

<struct>struct <name>SnippetFragment</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Column snippet is extracted from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>;</decl_stmt>                       <comment type="block">/* Index of first token in snippet */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>covered</name></decl>;</decl_stmt>                    <comment type="block">/* Mask of query phrases covered */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>hlmask</name></decl>;</decl_stmt>                     <comment type="block">/* Mask of snippet terms to highlight */</comment>
}</block>;</struct>

<comment type="block">/*
** This type is used as an fts3ExprIterate() context object while 
** accumulating the data returned by the matchinfo() function.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>MatchInfo</name></name></type> <name>MatchInfo</name>;</typedef>
<struct>struct <name>MatchInfo</name> <block>{
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>            <comment type="block">/* FTS3 Cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt>                    <comment type="block">/* Number of matchable phrases in query */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDoc</name></decl>;</decl_stmt>             <comment type="block">/* Number of docs in database */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>flag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aMatchinfo</name></decl>;</decl_stmt>                <comment type="block">/* Pre-allocated buffer */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of this structure is used to manage a pair of buffers, each
** (nElem * sizeof(u32)) bytes in size. See the MatchinfoBuffer code below
** for details.
*/</comment>
<struct>struct <name>MatchinfoBuffer</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aRef</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bGlobal</name></decl>;</decl_stmt>                    <comment type="block">/* Set if global data is loaded */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMatchinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** The snippet() and offsets() functions both return text values. An instance
** of the following structure is used to accumulate those values while the
** functions are running. See fts3StringAppend() for details.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>StrBuffer</name></name></type> <name>StrBuffer</name>;</typedef>
<struct>struct <name>StrBuffer</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                        <comment type="block">/* Pointer to buffer containing string */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Length of z in bytes (excl. nul-term) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                     <comment type="block">/* Allocated size of buffer z in bytes */</comment>
}</block>;</struct>


<comment type="block" format="doxygen">/*************************************************************************
** Start of MatchinfoBuffer code.
*/</comment>

<comment type="block">/*
** Allocate a two-slot MatchinfoBuffer object.
*/</comment>
<function><type><specifier>static</specifier> <name>MatchinfoBuffer</name> <modifier>*</modifier></type><name>fts3MIBufferNew</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>nElem</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMatchinfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MatchinfoBuffer</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nElem</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator>
                           <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MatchinfoBuffer</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nStr</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zMatchinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><name>nByte</name> <operator>+</operator> <name>nStr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>pRet</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>nElem</name></expr>]</index></name> <operator>=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
                                      <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>nElem</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nElem</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nElem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zMatchinfo</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pRet</name><operator>)</operator> <operator>+</operator> <name>nByte</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zMatchinfo</name></name></expr></argument>, <argument><expr><name>zMatchinfo</name></expr></argument>, <argument><expr><name>nStr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3MIBufferFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MatchinfoBuffer</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><operator>(</operator><name>MatchinfoBuffer</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index><operator>)</operator></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name><operator>==</operator><operator>&amp;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> 
       <operator>||</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name><operator>==</operator><operator>&amp;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name><name>pBuf</name><operator>-&gt;</operator><name>nElem</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument> 
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><name>p</name><operator>==</operator><operator>&amp;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pBuf</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pBuf</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pBuf</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*fts3MIBufferAlloc(MatchinfoBuffer *p, u32 **paOut)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><block>{
  <expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>xRet</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;
  <expr><name>u32</name> <operator>*</operator><name>aOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xRet</name> <operator>=</operator> <name>fts3MIBufferFree</name></expr>;</expr_stmt>
  <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
  <if_stmt><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nElem</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xRet</name> <operator>=</operator> <name>fts3MIBufferFree</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nElem</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>xRet</name> <operator>=</operator> <name>sqlite3_free</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bGlobal</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nElem</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>paOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
  <return>return <expr><name>xRet</name></expr>;</return>
}

static <function><type><name>void</name></type> <name>fts3MIBufferSetGlobal</name><parameter_list>(<parameter><decl><type><name>MatchinfoBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bGlobal</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nElem</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nElem</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a MatchinfoBuffer object allocated using fts3MIBufferNew()
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3MIBufferFree</name><parameter_list>(<parameter><decl><type><name>MatchinfoBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aRef</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** End of MatchinfoBuffer code.
*************************************************************************/</comment>


<comment type="block">/*
** This function is used to help iterate through a position-list. A position
** list is a list of unique integers, sorted from smallest to largest. Each
** element of the list is represented by an FTS3 varint that takes the value
** of the difference between the current element and the previous one plus
** two. For example, to store the position-list:
**
**     4 9 113
**
** the three varints:
**
**     6 7 106
**
** are encoded.
**
** When this function is called, *pp points to the start of an element of
** the list. *piPos contains the value of the previous entry in the list.
** After it returns, *piPos contains the value of the next element of the
** list and *pp is advanced to the following varint.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3GetDeltaPosition</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piPos</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iVal</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piPos</name> <operator>+=</operator> <operator>(</operator><name>iVal</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for fts3ExprIterate() (see below).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprIterate2</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expression to iterate phrases of */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPhrase</name></decl></parameter>,                  <comment type="block">/* Pointer to phrase counter */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>Fts3Expr</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,  <comment type="block">/* Callback function to invoke for phrases */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* Second argument to pass to callback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>eType</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Type of expression node pExpr */</comment>

  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><name>FTSQUERY_PHRASE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate2</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>piPhrase</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><name>FTSQUERY_NOT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate2</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>piPhrase</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>x</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>*</operator><name>piPhrase</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>piPhrase</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Iterate through all phrase nodes in an FTS3 query, except those that
** are part of a sub-tree that is the right-hand-side of a NOT operator.
** For each phrase node found, the supplied callback function is invoked.
**
** If the callback function returns anything other than SQLITE_OK, 
** the iteration is abandoned and the error code returned immediately.
** Otherwise, SQLITE_OK is returned after a callback has been made for
** all eligible phrase nodes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprIterate</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Expression to iterate phrases of */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>Fts3Expr</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,  <comment type="block">/* Callback function to invoke for phrases */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* Second argument to pass to callback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Variable used as the phrase counter */</comment>
  <return>return <expr><call><name>fts3ExprIterate2</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPhrase</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This is an fts3ExprIterate() callback used while loading the doclists
** for each phrase into Fts3Expr.aDoclist[]/nDoclist. See also
** fts3ExprLoadDoclists().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprLoadDoclistsCb</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LoadDoclistCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LoadDoclistCtx</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPhrase</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nToken</name></name> <operator>+=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load the doclists for each phrase in the query associated with FTS3 cursor
** pCsr. 
**
** If pnPhrase is not NULL, then *pnPhrase is set to the number of matchable 
** phrases in the expression (all phrases except those directly or 
** indirectly descended from the right-hand-side of a NOT operator). If 
** pnToken is not NULL, then it is set to the number of tokens in all
** matchable phrases of the expression.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprLoadDoclists</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Fts3 cursor for current query */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPhrase</name></decl></parameter>,                  <comment type="block">/* OUT: Number of phrases in query */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnToken</name></decl></parameter>                    <comment type="block">/* OUT: Number of tokens in query */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>LoadDoclistCtx</name></type> <name>sCtx</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* Context for fts3ExprIterate() */</comment>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>fts3ExprLoadDoclistsCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnPhrase</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnPhrase</name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>nPhrase</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnToken</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnToken</name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>nToken</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprPhraseCountCb</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExpr</name><operator>-&gt;</operator><name>iPhrase</name></name> <operator>=</operator> <name>iPhrase</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprPhraseCount</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>fts3ExprPhraseCountCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nPhrase</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the position list iterator specified by the first two 
** arguments so that it points to the first element with a value greater
** than or equal to parameter iNext.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SnippetAdvance</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIter</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piIter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iNext</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><operator>*</operator><name>ppIter</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pIter</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iIter</name> <init>= <expr><operator>*</operator><name>piIter</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>iIter</name><operator>&lt;</operator><name>iNext</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><operator>*</operator><name>pIter</name> <operator>&amp;</operator> <literal type="number">0xFE</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iIter</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pIter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fts3GetDeltaPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>piIter</name> <operator>=</operator> <name>iIter</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppIter</name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Advance the snippet iterator to the next candidate snippet.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SnippetNextCandidate</name><parameter_list>(<parameter><decl><type><name>SnippetIter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>iCurrent</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The SnippetIter object has just been initialized. The first snippet
    ** candidate always starts at offset 0 (even if this candidate has a
    ** score of 0.0).
    */</comment>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>iCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Advance the 'head' iterator of each phrase to the first offset that
    ** is greater than or equal to (iNext+nSnippet).
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>aPhrase</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3SnippetAdvance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>pHead</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>iHead</name></name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>nSnippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><literal type="number">0x7FFFFFFF</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>aPhrase</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pHead</name></name> <operator>&amp;&amp;</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iHead</name></name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iHead</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>==</operator><literal type="number">0x7FFFFFFF</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>iCurrent</name></name> <operator>=</operator> <name>iStart</name> <operator>=</operator> <name>iEnd</name> <operator>-</operator> <name><name>pIter</name><operator>-&gt;</operator><name>nSnippet</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>aPhrase</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3SnippetAdvance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>pHead</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>iHead</name></name></expr></argument>, <argument><expr><name>iEnd</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts3SnippetAdvance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>pTail</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>iTail</name></name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Retrieve information about the current candidate snippet of snippet 
** iterator pIter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3SnippetDetails</name><parameter_list>(
  <parameter><decl><type><name>SnippetIter</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>,             <comment type="block">/* Snippet iterator */</comment>
  <parameter><decl><type><name>u64</name></type> <name>mCovered</name></decl></parameter>,                   <comment type="block">/* Bitmask of phrases already covered */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piToken</name></decl></parameter>,                   <comment type="block">/* OUT: First token of proposed snippet */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piScore</name></decl></parameter>,                   <comment type="block">/* OUT: "Score" for this snippet */</comment>
  <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>pmCover</name></decl></parameter>,                   <comment type="block">/* OUT: Bitmask of phrases covered */</comment>
  <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>pmHighlight</name></decl></parameter>                <comment type="block">/* OUT: Bitmask of terms to highlight */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name> <init>= <expr><name><name>pIter</name><operator>-&gt;</operator><name>iCurrent</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* First token of snippet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iScore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Score of this snippet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>mCover</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Mask of phrases covered by this snippet */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>mHighlight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Mask of tokens to highlight in snippet */</comment>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIter</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><operator>&amp;</operator><name><name>pIter</name><operator>-&gt;</operator><name>aPhrase</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pTail</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pTail</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iCsr</name> <init>= <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iTail</name></name></expr></init></decl>;</decl_stmt>

      <while>while<condition>( <expr><name>iCsr</name><operator>&lt;</operator><operator>(</operator><name>iStart</name><operator>+</operator><name><name>pIter</name><operator>-&gt;</operator><name>nSnippet</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>iCsr</name><operator>&gt;=</operator><name>iStart</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u64</name></type> <name>mPhrase</name> <init>= <expr><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>%</operator><literal type="number">64</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u64</name></type> <name>mPos</name> <init>= <expr><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iCsr</name> <operator>-</operator> <name>iStart</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCsr</name><operator>&gt;=</operator><name>iStart</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iCsr</name> <operator>-</operator> <name>iStart</name><operator>)</operator><operator>&lt;=</operator><literal type="number">64</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mCover</name><operator>|</operator><name>mCovered</name><operator>)</operator><operator>&amp;</operator><name>mPhrase</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iScore</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iScore</name> <operator>+=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>mCover</name> <operator>|=</operator> <name>mPhrase</name></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>mHighlight</name> <operator>|=</operator> <operator>(</operator><name>mPos</name><operator>&gt;&gt;</operator><name>j</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><operator>*</operator><name>pCsr</name> <operator>&amp;</operator> <literal type="number">0x0FE</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fts3GetDeltaPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Set the output variables before returning. */</comment>
  <expr_stmt><expr><operator>*</operator><name>piToken</name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piScore</name> <operator>=</operator> <name>iScore</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pmCover</name> <operator>=</operator> <name>mCover</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pmHighlight</name> <operator>=</operator> <name>mHighlight</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is an fts3ExprIterate() callback used by fts3BestSnippet().
** Each invocation populates an element of the SnippetIter.aPhrase[] array.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SnippetFindPositions</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SnippetIter</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>SnippetIter</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnippetPhrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aPhrase</name><index>[<expr><name>iPhrase</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3EvalPhrasePoslist</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>||</operator> <name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iFirst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fts3GetDeltaPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFirst</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>pTail</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iHead</name></name> <operator>=</operator> <name>iFirst</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPhrase</name><operator>-&gt;</operator><name>iTail</name></name> <operator>=</operator> <name>iFirst</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>(</operator>
       <name><name>pPhrase</name><operator>-&gt;</operator><name>pList</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>pHead</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>pTail</name></name><operator>==</operator><literal type="number">0</literal> 
    <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Select the fragment of text consisting of nFragment contiguous tokens 
** from column iCol that represent the "best" snippet. The best snippet
** is the snippet with the highest score, where scores are calculated
** by adding:
**
**   (a) +1 point for each occurrence of a matchable phrase in the snippet.
**
**   (b) +1000 points for the first occurrence of each matchable phrase in 
**       the snippet for which the corresponding mCovered bit is not set.
**
** The selected snippet parameters are stored in structure *pFragment before
** returning. The score of the selected snippet is stored in *piScore
** before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3BestSnippet</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nSnippet</name></decl></parameter>,                   <comment type="block">/* Desired snippet length */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor to create snippet for */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Index of column to create snippet from */</comment>
  <parameter><decl><type><name>u64</name></type> <name>mCovered</name></decl></parameter>,                   <comment type="block">/* Mask of phrases already covered */</comment>
  <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>pmSeen</name></decl></parameter>,                    <comment type="block">/* IN/OUT: Mask of phrases seen */</comment>
  <parameter><decl><type><name>SnippetFragment</name> <modifier>*</modifier></type><name>pFragment</name></decl></parameter>,     <comment type="block">/* OUT: Best snippet found */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piScore</name></decl></parameter>                    <comment type="block">/* OUT: Score of snippet pFragment */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nList</name></decl>;</decl_stmt>                      <comment type="block">/* Number of phrases in expression */</comment>
  <decl_stmt><decl><type><name>SnippetIter</name></type> <name>sIter</name></decl>;</decl_stmt>              <comment type="block">/* Iterates through snippet candidates */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl>;</decl_stmt>            <comment type="block">/* Number of bytes of space to allocate */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBestScore</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Best snippet score found so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* Loop counter */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sIter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Iterate through the phrases in the expression to count them. The same
  ** callback makes sure the doclists are loaded for each phrase.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLoadDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now that it is known how many phrases there are, allocate and zero
  ** the required space using malloc().
  */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnippetPhrase</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>aPhrase</name></name> <operator>=</operator> <operator>(</operator><name>SnippetPhrase</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>sIter</name><operator>.</operator><name>aPhrase</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the contents of the SnippetIter object. Then iterate through
  ** the set of phrases in the expression to populate the aPhrase[] array.
  */</comment>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>nSnippet</name></name> <operator>=</operator> <name>nSnippet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>nPhrase</name></name> <operator>=</operator> <name>nList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sIter</name><operator>.</operator><name>iCurrent</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>fts3SnippetFindPositions</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Set the *pmSeen output variable. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nList</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>sIter</name><operator>.</operator><name>aPhrase</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pHead</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pmSeen</name> <operator>|=</operator> <operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>%</operator><literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Loop through all candidate snippets. Store the best snippet in 
     ** *pFragment. Store its associated 'score' in iBestScore.
     */</comment>
    <expr_stmt><expr><name><name>pFragment</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>!</operator><call><name>fts3SnippetNextCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iScore</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>mCover</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>mHighlite</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fts3SnippetDetails</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sIter</name></expr></argument>, <argument><expr><name>mCovered</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iScore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mCover</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>mHighlite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iScore</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iScore</name><operator>&gt;</operator><name>iBestScore</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFragment</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFragment</name><operator>-&gt;</operator><name>hlmask</name></name> <operator>=</operator> <name>mHighlite</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFragment</name><operator>-&gt;</operator><name>covered</name></name> <operator>=</operator> <name>mCover</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iBestScore</name> <operator>=</operator> <name>iScore</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>piScore</name> <operator>=</operator> <name>iBestScore</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sIter</name><operator>.</operator><name>aPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Append a string to the string-buffer passed as the first argument.
**
** If nAppend is negative, then the length of the string zAppend is
** determined using strlen().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3StringAppend</name><parameter_list>(
  <parameter><decl><type><name>StrBuffer</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,                <comment type="block">/* Buffer to append to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAppend</name></decl></parameter>,            <comment type="block">/* Pointer to data to append to buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nAppend</name></decl></parameter>                     <comment type="block">/* Size of zAppend in bytes (or -1) */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nAppend</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nAppend</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If there is insufficient space allocated at StrBuffer.z, use realloc()
  ** to grow the buffer until so that it is big enough to accomadate the
  ** appended data.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>nAppend</name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>pStr</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name> <init>= <expr><name><name>pStr</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>+</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nAppend</name><operator>+</operator><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zNew</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pStr</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&gt;=</operator> <name><name>pStr</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>nAppend</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append the data to the string buffer. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>, <argument><expr><name>nAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nAppend</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The fts3BestSnippet() function often selects snippets that end with a
** query term. That is, the final term of the snippet is always a term
** that requires highlighting. For example, if 'X' is a highlighted term
** and '.' is a non-highlighted term, BestSnippet() may select:
**
**     ........X.....X
**
** This function "shifts" the beginning of the snippet forward in the 
** document so that there are approximately the same number of 
** non-highlighted terms to the right of the final highlighted term as there
** are to the left of the first highlighted term. For example, to this:
**
**     ....X.....X....
**
** This is done as part of extracting the snippet text, not when selecting
** the snippet. Snippet selection is done based on doclists only, so there
** is no way for fts3BestSnippet() to know whether or not the document 
** actually contains terms that follow the final highlighted term. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SnippetShift</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                <comment type="block">/* FTS3 table snippet comes from */</comment>
  <parameter><decl><type><name>int</name></type> <name>iLangid</name></decl></parameter>,                    <comment type="block">/* Language id to use in tokenizing */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSnippet</name></decl></parameter>,                   <comment type="block">/* Number of tokens desired for snippet */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl></parameter>,               <comment type="block">/* Document text to extract snippet from */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoc</name></decl></parameter>,                       <comment type="block">/* Size of buffer zDoc in bytes */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPos</name></decl></parameter>,                     <comment type="block">/* IN/OUT: First token of snippet */</comment>
  <parameter><decl><type><name>u64</name> <modifier>*</modifier></type><name>pHlmask</name></decl></parameter>                    <comment type="block">/* IN/OUT: Mask of tokens to highlight */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>hlmask</name> <init>= <expr><operator>*</operator><name>pHlmask</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Local copy of initial highlight-mask */</comment>

  <if_stmt><if>if<condition>( <expr><name>hlmask</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nLeft</name></decl>;</decl_stmt>                    <comment type="block">/* Tokens to the left of first highlight */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRight</name></decl>;</decl_stmt>                   <comment type="block">/* Tokens to the right of last highlight */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nDesired</name></decl>;</decl_stmt>                 <comment type="block">/* Ideal number of tokens to shift forward */</comment>

    <for>for<control>(<init><expr><name>nLeft</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><operator>(</operator><name>hlmask</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>nLeft</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>nLeft</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <for>for<control>(<init><expr><name>nRight</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><operator>(</operator><name>hlmask</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nSnippet</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>nRight</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>nRight</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nSnippet</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>nRight</name><operator>)</operator><operator>&lt;=</operator><literal type="number">63</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nSnippet</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>nRight</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDesired</name> <operator>=</operator> <operator>(</operator><name>nLeft</name><operator>-</operator><name>nRight</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/* Ideally, the start of the snippet should be pushed forward in the
    ** document nDesired tokens. This block checks if there are actually
    ** nDesired tokens to the right of the snippet. If so, *piPos and
    ** *pHlMask are updated to shift the snippet nDesired tokens to the
    ** right. Otherwise, the snippet is shifted by the number of tokens
    ** available.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nDesired</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nShift</name></decl>;</decl_stmt>                 <comment type="block">/* Number of tokens to shift snippet by */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Token counter */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                     <comment type="block">/* Return Code */</comment>
      <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer_module</name> <operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>

      <comment type="block">/* Open a cursor on zDoc/nDoc. Check if there are (nSnippet+nDesired)
      ** or more tokens in zDoc/nDoc.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>iLangid</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCurrent</name><operator>&lt;</operator><operator>(</operator><name>nSnippet</name><operator>+</operator><name>nDesired</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ZDUMMY</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>DUMMY1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>DUMMY2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>DUMMY3</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DUMMY1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DUMMY2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DUMMY3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name><name>pMod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content> <return>return <expr><name>rc</name></expr>;</return> </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>nShift</name> <operator>=</operator> <operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name><operator>)</operator><operator>+</operator><name>iCurrent</name><operator>-</operator><name>nSnippet</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nShift</name><operator>&lt;=</operator><name>nDesired</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nShift</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>piPos</name> <operator>+=</operator> <name>nShift</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pHlmask</name> <operator>=</operator> <name>hlmask</name> <operator>&gt;&gt;</operator> <name>nShift</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extract the snippet text for fragment pFragment from cursor pCsr and
** append it to string buffer pOut.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3SnippetText</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS3 Cursor */</comment>
  <parameter><decl><type><name>SnippetFragment</name> <modifier>*</modifier></type><name>pFragment</name></decl></parameter>,     <comment type="block">/* Snippet to extract */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFragment</name></decl></parameter>,                  <comment type="block">/* Fragment number */</comment>
  <parameter><decl><type><name>int</name></type> <name>isLast</name></decl></parameter>,                     <comment type="block">/* True for final fragment in snippet */</comment>
  <parameter><decl><type><name>int</name></type> <name>nSnippet</name></decl></parameter>,                   <comment type="block">/* Number of tokens in extracted snippet */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpen</name></decl></parameter>,              <comment type="block">/* String inserted before highlighted term */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zClose</name></decl></parameter>,             <comment type="block">/* String inserted after highlighted term */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name></decl></parameter>,          <comment type="block">/* String inserted between snippets */</comment>
  <parameter><decl><type><name>StrBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>                 <comment type="block">/* Write output here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>               <comment type="block">/* Document text to extract snippet from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>                       <comment type="block">/* Size of zDoc in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Current token number of document */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Byte offset of end of current token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isShiftDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* True after snippet is shifted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPos</name> <init>= <expr><name><name>pFragment</name><operator>-&gt;</operator><name>iPos</name></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* First token of snippet */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>hlmask</name> <init>= <expr><name><name>pFragment</name><operator>-&gt;</operator><name>hlmask</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Highlight-mask for snippet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pFragment</name><operator>-&gt;</operator><name>iCol</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Query column to extract text from */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt> <comment type="block">/* Tokenizer module methods object */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt>   <comment type="block">/* Tokenizer cursor open on zDoc/nDoc */</comment>
  
  <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDoc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open a token cursor on the document. */</comment>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer_module</name> <operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>,<argument><expr><name>nDoc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ZDUMMY</name></decl>;</decl_stmt>           <comment type="block">/* Dummy argument used with tokenizer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>DUMMY1</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Dummy argument used with tokenizer */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iBegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Offset in zDoc of start of token */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iFin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Offset in zDoc of end of token */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isHighlight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* True for highlighted terms */</comment>

    <comment type="block">/* Variable DUMMY1 is initialized to a negative value above. Elsewhere
    ** in the FTS code the variable that the third argument to xNext points to
    ** is initialized to zero before the first (*but not necessarily
    ** subsequent*) call to xNext(). This is done for a particular application
    ** that needs to know whether or not the tokenizer is being used for
    ** snippet generation or for some other purpose.
    **
    ** Extreme care is required when writing code to depend on this
    ** initialization. It is not a documented part of the tokenizer interface.
    ** If a tokenizer is used directly by any code outside of FTS, this
    ** convention might not be respected.  */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DUMMY1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Special case - the last token of the snippet is also the last token
        ** of the column. Append any punctuation that occurred between the end
        ** of the previous token and the end of the document to the output. 
        ** Then break out of the loop. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iEnd</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCurrent</name><operator>&lt;</operator><name>iPos</name></expr> )</condition><block>{<block_content> <continue>continue;</continue> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isShiftDone</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>nDoc</name> <operator>-</operator> <name>iBegin</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SnippetShift</name><argument_list>(
          <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>, <argument><expr><name>nSnippet</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iBegin</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hlmask</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isShiftDone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* Now that the shift has been done, check if the initial "..." are
      ** required. They are required if (a) this is not the first fragment,
      ** or (b) this fragment does not begin at position 0 of its column. 
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPos</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iFragment</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iBegin</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>iBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>iCurrent</name><operator>&lt;</operator><name>iPos</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCurrent</name><operator>&gt;=</operator><operator>(</operator><name>iPos</name><operator>+</operator><name>nSnippet</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>isLast</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set isHighlight to true if this term should be highlighted. */</comment>
    <expr_stmt><expr><name>isHighlight</name> <operator>=</operator> <operator>(</operator><name>hlmask</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iCurrent</name><operator>-</operator><name>iPos</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCurrent</name><operator>&gt;</operator><name>iPos</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iEnd</name></expr>]</index></name></expr></argument>, <argument><expr><name>iBegin</name><operator>-</operator><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>isHighlight</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zOpen</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iBegin</name></expr>]</index></name></expr></argument>, <argument><expr><name>iFin</name><operator>-</operator><name>iBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>isHighlight</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zClose</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>iFin</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name><name>pMod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is used to count the entries in a column-list (a 
** delta-encoded list of term offsets within a single column of a single 
** row). When this function is called, *ppCollist should point to the
** beginning of the first varint in the column-list (the varint that
** contains the position of the first matching term in the column data).
** Before returning, *ppCollist is set to point to the first byte after
** the last varint in the column-list (either the 0x00 signifying the end
** of the position-list, or the 0x01 that precedes the column number of
** the next column in the position-list).
**
** The number of elements in the column-list is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ColumnlistCount</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCollist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>*</operator><name>ppCollist</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* A column-list is terminated by either a 0x01 or 0x00. */</comment>
  <while>while<condition>( <expr><literal type="number">0xFE</literal> <operator>&amp;</operator> <operator>(</operator><operator>*</operator><name>pEnd</name> <operator>|</operator> <name>c</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pEnd</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>ppCollist</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt>
  <return>return <expr><name>nEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function gathers 'y' or 'b' data for a single phrase.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprLHits</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase expression node */</comment>
  <parameter><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                    <comment type="block">/* Matchinfo context */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pCursor</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Phrase</name> <modifier>*</modifier></type><name>pPhrase</name> <init>= <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><name><name>pPhrase</name><operator>-&gt;</operator><name>doclist</name><operator>.</operator><name>pList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flag</name></name><operator>==</operator><name>FTS3_MATCHINFO_LHITS_BM</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>flag</name></name><operator>==</operator><name>FTS3_MATCHINFO_LHITS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flag</name></name><operator>==</operator><name>FTS3_MATCHINFO_LHITS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iPhrase</name></name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iPhrase</name></name> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pIter</name></expr> )</condition><block type="pseudo"><block_content> <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nHit</name> <init>= <expr><call><name>fts3ColumnlistCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>||</operator> <name><name>pPhrase</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>iCol</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flag</name></name><operator>==</operator><name>FTS3_MATCHINFO_LHITS</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iStart</name> <operator>+</operator> <name>iCol</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>nHit</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nHit</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iStart</name> <operator>+</operator> <operator>(</operator><name>iCol</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">32</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iCol</name><operator>&amp;</operator><literal type="number">0x1F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0x00</literal> <operator>||</operator> <operator>*</operator><name>pIter</name><operator>==</operator><literal type="number">0x01</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pIter</name><operator>!=</operator><literal type="number">0x01</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pIter</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIter</name> <operator>+=</operator> <call><name>fts3GetVarint32</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Gather the results for matchinfo directives 'y' and 'b'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprLHitGather</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,
  <parameter><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>p</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>bEof</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>iDocid</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pCursor</name><operator>-&gt;</operator><name>iPrevId</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLHitGather</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLHitGather</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLHits</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** fts3ExprIterate() callback used to collect the "global" matchinfo stats
** for a single query. 
**
** fts3ExprIterate() callback to load the 'global' elements of a
** FTS3_MATCHINFO_HITS matchinfo array. The global stats are those elements 
** of the matchinfo array that are constant for all rows returned by the 
** current query.
**
** Argument pCtx is actually a pointer to a struct of type MatchInfo. This
** function populates Matchinfo.aMatchinfo[] as follows:
**
**   for(iCol=0; iCol&lt;nCol; iCol++){
**     aMatchinfo[3*iPhrase*nCol + 3*iCol + 1] = X;
**     aMatchinfo[3*iPhrase*nCol + 3*iCol + 2] = Y;
**   }
**
** where X is the number of matches for phrase iPhrase is column iCol of all
** rows of the table. Y is the number of rows for which column iCol contains
** at least one instance of phrase iPhrase.
**
** If the phrase pExpr consists entirely of deferred tokens, then all X and
** Y values are set to nDoc, where nDoc is the number of documents in the 
** file system. This is done because the full-text index doclist is required
** to calculate these values properly, and the full-text index doclist is
** not available for deferred tokens.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprGlobalHitsCb</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase expression node */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>,                    <comment type="block">/* Phrase number (numbered from zero) */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* Pointer to MatchInfo structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MatchInfo</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sqlite3Fts3EvalPhraseStats</name><argument_list>(
      <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">3</literal><operator>*</operator><name>iPhrase</name><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name></expr>]</index></name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** fts3ExprIterate() callback used to collect the "local" part of the
** FTS3_MATCHINFO_HITS array. The local stats are those elements of the 
** array that are different for each row returned by the query.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprLocalHitsCb</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase expression node */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>,                    <comment type="block">/* Phrase number */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* Pointer to MatchInfo structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>MatchInfo</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name> <init>= <expr><name>iPhrase</name> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>*</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3EvalPhrasePoslist</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCursor</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iStart</name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>fts3ColumnlistCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iStart</name><operator>+</operator><name>i</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MatchinfoCheck</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><name>char</name></type> <name>cArg</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_NPHRASE</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_NCOL</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_NDOC</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bFts4</name></name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_AVGLENGTH</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bFts4</name></name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_LENGTH</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>bHasDocsize</name></name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_LCS</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_HITS</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_LHITS</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_LHITS_BM</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3ErrMsg</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized matchinfo request: %c"</literal></expr></argument>, <argument><expr><name>cArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>fts3MatchinfoSize</name><parameter_list>(<parameter><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>cArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nVal</name></decl>;</decl_stmt>                      <comment type="block">/* Number of integers output by cArg */</comment>

  <switch>switch<condition>( <expr><name>cArg</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>FTS3_MATCHINFO_NDOC</name></expr>:</case>
    <case>case <expr><name>FTS3_MATCHINFO_NPHRASE</name></expr>:</case> 
    <case>case <expr><name>FTS3_MATCHINFO_NCOL</name></expr>:</case> 
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FTS3_MATCHINFO_AVGLENGTH</name></expr>:</case>
    <case>case <expr><name>FTS3_MATCHINFO_LENGTH</name></expr>:</case>
    <case>case <expr><name>FTS3_MATCHINFO_LCS</name></expr>:</case>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FTS3_MATCHINFO_LHITS</name></expr>:</case>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name> <operator>*</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FTS3_MATCHINFO_LHITS_BM</name></expr>:</case>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cArg</name><operator>==</operator><name>FTS3_MATCHINFO_HITS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name> <operator>*</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>nVal</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MatchinfoSelectDoctotal</name><parameter_list>(
  <parameter><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pnDoc</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paLen</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEnd</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>


  <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>*</operator><name>ppStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3Fts3SelectDoctotal</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <operator>*</operator><name>ppStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_data_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>a</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintBounded</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nDoc</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>a</name><operator>&gt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>FTS_CORRUPT_VTAB</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnDoc</name> <operator>=</operator> <name>nDoc</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>paLen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>paLen</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>ppEnd</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ppEnd</name> <operator>=</operator> <name>pEnd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of the following structure is used to store state while 
** iterating through a multi-column position-list corresponding to the
** hits for a single phrase on a single row in order to calculate the
** values for a matchinfo() FTS3_MATCHINFO_LCS request.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>LcsIterator</name></name></type> <name>LcsIterator</name>;</typedef>
<struct>struct <name>LcsIterator</name> <block>{
  <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>                <comment type="block">/* Pointer to phrase expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPosOffset</name></decl>;</decl_stmt>                 <comment type="block">/* Tokens count up to end of this phrase */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRead</name></decl>;</decl_stmt>                    <comment type="block">/* Cursor used to iterate through aDoclist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>;</decl_stmt>                       <comment type="block">/* Current position */</comment>
}</block>;</struct>

<comment type="block">/* 
** If LcsIterator.iCol is set to the following value, the iterator has
** finished iterating through all offsets for all columns.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCS_ITERATOR_FINISHED</name></cpp:macro> <cpp:value>0x7FFFFFFF;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MatchinfoLcsCb</name><parameter_list>(
  <parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>,                <comment type="block">/* Phrase expression node */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>,                    <comment type="block">/* Phrase number (numbered from zero) */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* Pointer to MatchInfo structure */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>aIter</name> <init>= <expr><operator>(</operator><name>LcsIterator</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aIter</name><index>[<expr><name>iPhrase</name></expr>]</index></name><operator>.</operator><name>pExpr</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance the iterator passed as an argument to the next position. Return
** 1 if the iterator is at EOF or if it now points to the start of the
** position list for the next column.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3LcsIteratorAdvance</name><parameter_list>(<parameter><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>pIter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pIter</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pRead</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pRead</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRead</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>pRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRead</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iRead</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRead</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>iPos</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iRead</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>pRead</name></name> <operator>=</operator> <name>pRead</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
  
<comment type="block">/*
** This function implements the FTS3_MATCHINFO_LCS matchinfo() flag. 
**
** If the call is successful, the longest-common-substring lengths for each
** column are written into the first nCol elements of the pInfo-&gt;aMatchinfo[] 
** array before returning. SQLITE_OK is returned in this case.
**
** Otherwise, if an error occurs, an SQLite error code is returned and the
** data written to the first nCol elements of pInfo-&gt;aMatchinfo[] is 
** undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MatchinfoLcs</name><parameter_list>(<parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>aIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Allocate and populate the array of LcsIterator objects. The array
  ** contains one element for each matchable phrase in the query.
  **/</comment>
  <expr_stmt><expr><name>aIter</name> <operator>=</operator> <call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LcsIterator</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPhrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aIter</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>fts3MatchinfoLcsCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>aIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><operator>&amp;</operator><name><name>aIter</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nToken</name> <operator>-=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>iPosOffset</name></name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nLcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* LCS value for this column */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nLive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of iterators in aIter not at EOF */</comment>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>pIt</name> <init>= <expr><operator>&amp;</operator><name><name>aIter</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3EvalPhrasePoslist</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pIt</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIt</name><operator>-&gt;</operator><name>pRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>matchinfo_lcs_out</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIt</name><operator>-&gt;</operator><name>pRead</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIt</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <name><name>pIt</name><operator>-&gt;</operator><name>iPosOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fts3LcsIteratorAdvance</name><argument_list>(<argument><expr><name>pIt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIt</name><operator>-&gt;</operator><name>pRead</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
          <goto>goto <name>matchinfo_lcs_out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nLive</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <while>while<condition>( <expr><name>nLive</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>pAdv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* The iterator to advance by one position */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nThisLcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* LCS for the current iterator positions */</comment>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>LcsIterator</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><operator>&amp;</operator><name><name>aIter</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>pRead</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* This iterator is already at EOF for this column. */</comment>
          <expr_stmt><expr><name>nThisLcs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>pAdv</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>iPos</name></name><operator>&lt;</operator><name><name>pAdv</name><operator>-&gt;</operator><name>iPos</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>pAdv</name> <operator>=</operator> <name>pIter</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>nThisLcs</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIter</name><operator>-&gt;</operator><name>iPos</name></name><operator>==</operator><name><name>pIter</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPos</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nThisLcs</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>nThisLcs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>nThisLcs</name><operator>&gt;</operator><name>nLcs</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLcs</name> <operator>=</operator> <name>nThisLcs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><call><name>fts3LcsIteratorAdvance</name><argument_list>(<argument><expr><name>pAdv</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nLive</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <name>nLcs</name></expr>;</expr_stmt>
  </block_content>}</block></for>

 <label><name>matchinfo_lcs_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Populate the buffer pInfo-&gt;aMatchinfo[] with an array of integers to
** be returned by the matchinfo() function. Argument zArg contains the 
** format string passed as the second argument to matchinfo (or the
** default value "pcx" if no second argument was specified). The format
** string has already been validated and the pInfo-&gt;aMatchinfo[] array
** is guaranteed to be large enough for the output.
**
** If bGlobal is true, then populate all fields of the matchinfo() output.
** If it is false, then assume that those fields that do not change between
** rows (i.e. FTS3_MATCHINFO_NPHRASE, NCOL, NDOC, AVGLENGTH and part of HITS)
** have already been populated.
**
** Return SQLITE_OK if successful, or an SQLite error code if an error 
** occurs. If a value other than SQLITE_OK is returned, the state the
** pInfo-&gt;aMatchinfo[] buffer is left in is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3MatchinfoValues</name><parameter_list>(
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS3 cursor object */</comment>
  <parameter><decl><type><name>int</name></type> <name>bGlobal</name></decl></parameter>,                    <comment type="block">/* True to grab the global stats */</comment>
  <parameter><decl><type><name>MatchInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>,               <comment type="block">/* Matchinfo context object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>                <comment type="block">/* Matchinfo format string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>FTS3_MATCHINFO_NPHRASE</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>FTS3_MATCHINFO_NCOL</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
        
      <case>case <expr><name>FTS3_MATCHINFO_NDOC</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDoc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MatchinfoSelectDoctotal</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDoc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>nDoc</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>FTS3_MATCHINFO_AVGLENGTH</name></expr>:</case> 
        <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nDoc</name></decl>;</decl_stmt>     <comment type="block">/* Number of rows in table */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>          <comment type="block">/* Aggregate column length array */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name></decl>;</decl_stmt>       <comment type="block">/* First byte past end of length array */</comment>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MatchinfoSelectDoctotal</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <decl_stmt><decl><type><name>u32</name></type> <name>iVal</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nToken</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarint</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
                <break>break;</break>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>nToken</name><operator>&amp;</operator><literal type="number">0xffffffff</literal><operator>)</operator><operator>+</operator><name>nDoc</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><name>nDoc</name><operator>)</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>FTS3_MATCHINFO_LENGTH</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelectDocsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3SelectDocsize</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelectDocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pSelectDocsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><name>a</name> <operator>+</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pSelectDocsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nToken</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>a</name> <operator>+=</operator> <call><name>sqlite3Fts3GetVarintBounded</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>a</name><operator>&gt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT_VTAB</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>nToken</name></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelectDocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>FTS3_MATCHINFO_LCS</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLoadDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MatchinfoLcs</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>

      <case>case <expr><name>FTS3_MATCHINFO_LHITS_BM</name></expr>:</case>
      <case>case <expr><name>FTS3_MATCHINFO_LHITS</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nZero</name> <init>= <expr><call><name>fts3MatchinfoSize</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLHitGather</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>

      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>FTS3_MATCHINFO_HITS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLoadDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pDeferred</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MatchinfoSelectDoctotal</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nDoc</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>fts3ExprGlobalHitsCb</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3Fts3EvalTestDeferred</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>fts3ExprLocalHitsCb</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aMatchinfo</name></name> <operator>+=</operator> <call><name>fts3MatchinfoSize</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Populate pCsr-&gt;aMatchinfo[] with data for the current row. The 
** 'matchinfo' data is an array of 32-bit unsigned integers (C type u32).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fts3GetMatchinfo</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,        <comment type="block">/* Return results here */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS3 Cursor object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>                <comment type="block">/* Second argument to matchinfo() function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>MatchInfo</name></type> <name>sInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bGlobal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Collect 'global' stats as well as local */</comment>

  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroyOut</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatchInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInfo</name><operator>.</operator><name>pCursor</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sInfo</name><operator>.</operator><name>nCol</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>

  <comment type="block">/* If there is cached matchinfo() data, but the format string for the 
  ** cache does not match the format string for this request, discard 
  ** the cached data. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name><operator>-&gt;</operator><name>zMatchinfo</name></name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts3MIBufferFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Fts3Cursor.pMIBuffer is NULL, then this is the first time the
  ** matchinfo function has been called for this query. In this case 
  ** allocate the array used to accumulate the matchinfo data and
  ** initialize those elements that are constant for every row.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nMatchinfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Number of u32 elements in match-info */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through zArg */</comment>

    <comment type="block">/* Determine the number of phrases in the query */</comment>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nPhrase</name></name> <operator>=</operator> <call><name>fts3ExprPhraseCount</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sInfo</name><operator>.</operator><name>nPhrase</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</expr_stmt>

    <comment type="block">/* Determine the number of integers in the buffer returned by this call. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fts3MatchinfoCheck</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nMatchinfo</name> <operator>+=</operator> <call><name>fts3MatchinfoSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sInfo</name></expr></argument>, <argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Allocate space for Fts3Cursor.aMatchinfo[] and Fts3Cursor.zMatchinfo. */</comment>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name> <operator>=</operator> <call><name>fts3MIBufferNew</name><argument_list>(<argument><expr><name>nMatchinfo</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isMatchinfoNeeded</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bGlobal</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>xDestroyOut</name> <operator>=</operator> <call><name>fts3MIBufferAlloc</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>xDestroyOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sInfo</name><operator>.</operator><name>aMatchinfo</name></name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sInfo</name><operator>.</operator><name>nPhrase</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3MatchinfoValues</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>bGlobal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sInfo</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bGlobal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fts3MIBufferSetGlobal</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>xDestroyOut</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xDestroyOut</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pMIBuffer</name><operator>-&gt;</operator><name>nElem</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>xDestroyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of snippet() function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3Snippet</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl></parameter>,             <comment type="block">/* Snippet start text - "&lt;b&gt;" */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name></decl></parameter>,               <comment type="block">/* Snippet end text - "&lt;/b&gt;" */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name></decl></parameter>,          <comment type="block">/* Snippet ellipsis text - "&lt;b&gt;...&lt;/b&gt;" */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>,                       <comment type="block">/* Extract snippet from this column */</comment>
  <parameter><decl><type><name>int</name></type> <name>nToken</name></decl></parameter>                      <comment type="block">/* Approximate number of tokens in snippet */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrBuffer</name></type> <name>res</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The returned text includes up to four fragments of text extracted from
  ** the data in the current row. The first iteration of the for(...) loop
  ** below attempts to locate a single fragment of text nToken tokens in 
  ** size that contains at least one instance of all phrases in the query
  ** expression that appear in the current row. If such a fragment of text
  ** cannot be found, the second iteration of the loop attempts to locate
  ** a pair of fragments, and so on.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSnippet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of fragments in this snippet */</comment>
  <decl_stmt><decl><type><name>SnippetFragment</name></type> <name><name>aSnippet</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Maximum of 4 fragments per snippet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFToken</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of tokens in each fragment */</comment>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Limit the snippet length to 64 tokens. */</comment>
  <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&lt;</operator><operator>-</operator><literal type="number">64</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nToken</name> <operator>=</operator> <operator>-</operator><literal type="number">64</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&gt;</operator><operator>+</operator><literal type="number">64</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nToken</name> <operator>=</operator> <operator>+</operator><literal type="number">64</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>nSnippet</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">1</literal></expr>;</condition> <incr><expr><name>nSnippet</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

    <decl_stmt><decl><type><name>int</name></type> <name>iSnip</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter 0..nSnippet-1 */</comment>
    <decl_stmt><decl><type><name>u64</name></type> <name>mCovered</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Bitmask of phrases covered by snippet */</comment>
    <decl_stmt><decl><type><name>u64</name></type> <name>mSeen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Bitmask of phrases seen by BestSnippet() */</comment>

    <if_stmt><if>if<condition>( <expr><name>nToken</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nFToken</name> <operator>=</operator> <operator>(</operator><name>nToken</name><operator>+</operator><name>nSnippet</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>nSnippet</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nFToken</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name>nToken</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <for>for<control>(<init><expr><name>iSnip</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iSnip</name><operator>&lt;</operator><name>nSnippet</name></expr>;</condition> <incr><expr><name>iSnip</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iBestScore</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Best score of columns checked so far */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iRead</name></decl>;</decl_stmt>                  <comment type="block">/* Used to iterate through columns */</comment>
      <decl_stmt><decl><type><name>SnippetFragment</name> <modifier>*</modifier></type><name>pFragment</name> <init>= <expr><operator>&amp;</operator><name><name>aSnippet</name><index>[<expr><name>iSnip</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFragment</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pFragment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Loop through all columns of the table being considered for snippets.
      ** If the iCol argument to this function was negative, this means all
      ** columns of the FTS3 table. Otherwise, only column iCol is considered.
      */</comment>
      <for>for<control>(<init><expr><name>iRead</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRead</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iRead</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>SnippetFragment</name></type> <name>sF</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iRead</name><operator>!=</operator><name>iCol</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Find the best snippet of nFToken tokens in column iRead. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3BestSnippet</name><argument_list>(<argument><expr><name>nFToken</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>iRead</name></expr></argument>, <argument><expr><name>mCovered</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mSeen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <goto>goto <name>snippet_out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iS</name><operator>&gt;</operator><name>iBestScore</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pFragment</name> <operator>=</operator> <name>sF</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iBestScore</name> <operator>=</operator> <name>iS</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name>mCovered</name> <operator>|=</operator> <name><name>pFragment</name><operator>-&gt;</operator><name>covered</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If all query phrases seen by fts3BestSnippet() are present in at least
    ** one of the nSnippet snippet fragments, break out of the loop.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>mCovered</name><operator>&amp;</operator><name>mSeen</name><operator>)</operator><operator>==</operator><name>mCovered</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>mSeen</name><operator>==</operator><name>mCovered</name> <operator>||</operator> <name>nSnippet</name><operator>==</operator><call><name>SizeofArray</name><argument_list>(<argument><expr><name>aSnippet</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFToken</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nSnippet</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3SnippetText</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aSnippet</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, 
        <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name><operator>==</operator><name>nSnippet</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>nFToken</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

 <label><name>snippet_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>res</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<typedef>typedef <type><name><name>struct</name> <name>TermOffset</name></name></type> <name>TermOffset</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>TermOffsetCtx</name></name></type> <name>TermOffsetCtx</name>;</typedef>

<struct>struct <name>TermOffset</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>                    <comment type="block">/* Position-list */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPos</name></decl>;</decl_stmt>                       <comment type="block">/* Position just read from pList */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>                       <comment type="block">/* Offset of this term from read positions */</comment>
}</block>;</struct>

<struct>struct <name>TermOffsetCtx</name> <block>{
  <decl_stmt><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Column of table to populate aTerm for */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TermOffset</name> <modifier>*</modifier></type><name>aTerm</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** This function is an fts3ExprIterate() callback used by sqlite3Fts3Offsets().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fts3ExprTermOffsetInit</name><parameter_list>(<parameter><decl><type><name>Fts3Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPhrase</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TermOffsetCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>TermOffsetCtx</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                      <comment type="block">/* Number of tokens in phrase */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>                      <comment type="block">/* For looping through nTerm phrase terms */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>                    <comment type="block">/* Pointer to position list for phrase */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* First position in position-list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>iPhrase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3EvalPhrasePoslist</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCsr</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pPhrase</name><operator>-&gt;</operator><name>nToken</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pList</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts3GetDeltaPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>iPos</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>iTerm</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTerm</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>iTerm</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>TermOffset</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aTerm</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iTerm</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pT</name><operator>-&gt;</operator><name>iOff</name></name> <operator>=</operator> <name>nTerm</name><operator>-</operator><name>iTerm</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pT</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pT</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of offsets() function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3Offsets</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* SQLite function call context */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>                <comment type="block">/* Cursor object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                     <comment type="block">/* Number of tokens in query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Column currently being processed */</comment>
  <decl_stmt><decl><type><name>StrBuffer</name></type> <name>res</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>      <comment type="block">/* Result string */</comment>
  <decl_stmt><decl><type><name>TermOffsetCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>             <comment type="block">/* Context for fts3ExprTermOffsetInit() */</comment>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>isRequireSeek</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Count the number of terms in the query */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprLoadDoclists</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>offsets_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Allocate the array of TermOffset iterators. */</comment>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>aTerm</name></name> <operator>=</operator> <operator>(</operator><name>TermOffset</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts3MallocZero</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TermOffset</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>sCtx</name><operator>.</operator><name>aTerm</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>offsets_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iDocid</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPrevId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pCsr</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>

  <comment type="block">/* Loop through the table columns, appending offset information to 
  ** string-buffer res for each column.
  */</comment>
  <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pC</name></decl>;</decl_stmt> <comment type="block">/* Tokenizer cursor */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ZDUMMY</name></decl>;</decl_stmt>           <comment type="block">/* Dummy argument used with xNext() */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>NDUMMY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Dummy argument used with xNext() */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>

    <comment type="block">/* Initialize the contents of sCtx.aTerm[] for column iCol. This 
    ** operation may fail if the database contains corrupt records.
    */</comment>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>iTerm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3ExprIterate</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>fts3ExprTermOffsetInit</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>offsets_out</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Retreive the text stored in column iCol. If an SQL NULL is stored 
    ** in column iCol, jump immediately to the next iteration of the loop.
    ** If an OOM occurs while retrieving the data (this can happen if SQLite
    ** needs to transform the data from utf-16 to utf-8), return SQLITE_NOMEM 
    ** to the caller. 
    */</comment>
    <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDoc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>offsets_out</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize a tokenizer iterator to iterate through column iCol. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts3OpenTokenizer</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iLangid</name></name></expr></argument>,
        <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pC</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>offsets_out</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Used to loop through terms */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iMinPos</name> <init>= <expr><literal type="number">0x7FFFFFFF</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Position of next token */</comment>
      <decl_stmt><decl><type><name>TermOffset</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* TermOffset associated with next token */</comment>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>TermOffset</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><operator>&amp;</operator><name><name>sCtx</name><operator>.</operator><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pT</name><operator>-&gt;</operator><name>pList</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pT</name><operator>-&gt;</operator><name>iPos</name></name><operator>-</operator><name><name>pT</name><operator>-&gt;</operator><name>iOff</name></name><operator>)</operator><operator>&lt;</operator><name>iMinPos</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iMinPos</name> <operator>=</operator> <name><name>pT</name><operator>-&gt;</operator><name>iPos</name></name><operator>-</operator><name><name>pT</name><operator>-&gt;</operator><name>iOff</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTerm</name> <operator>=</operator> <name>pT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pTerm</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* All offsets for this column have been gathered. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert_fts3_nc</name><argument_list>( <argument><expr><name>iCurrent</name><operator>&lt;=</operator><name>iMinPos</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><literal type="number">0xFE</literal><operator>&amp;</operator><operator>*</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pList</name></name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTerm</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>fts3GetDeltaPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTerm</name><operator>-&gt;</operator><name>iPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iCurrent</name><operator>&lt;</operator><name>iMinPos</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ZDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NDUMMY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>aBuffer</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>, 
              <argument><expr><literal type="string">"%d %d %d %d "</literal></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>pTerm</name><operator>-</operator><name><name>sCtx</name><operator>.</operator><name>aTerm</name></name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>iEnd</name><operator>-</operator><name>iStart</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fts3StringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zContentTbl</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>FTS_CORRUPT_VTAB</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>pMod</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>offsets_out</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>

 <label><name>offsets_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>sCtx</name><operator>.</operator><name>aTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>,  <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>res</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>.</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of matchinfo() function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3Matchinfo</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,      <comment type="block">/* Function call context */</comment>
  <parameter><decl><type><name>Fts3Cursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* FTS3 table cursor */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>                <comment type="block">/* Second arg to matchinfo() function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Fts3Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>Fts3Table</name> <operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zArg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFormat</name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFormat</name> <operator>=</operator> <name>FTS3_MATCHINFO_DEFAULT</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pExpr</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Retrieve matchinfo() data. */</comment>
    <expr_stmt><expr><call><name>fts3GetMatchinfo</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts3SegmentsClose</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
