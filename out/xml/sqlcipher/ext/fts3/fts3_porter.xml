<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/fts3/fts3_porter.c"><comment type="block">/*
** 2006 September 30
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Implementation of the full-text-search tokenizer that implements
** a Porter stemmer.
*/</comment>

<comment type="block">/*
** The code in this file is only compiled if:
**
**     * The FTS3 module is being built as an extension
**       (in which case SQLITE_CORE is not defined), or
**
**     * The FTS3 module is being built into the core of
**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3Int.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS3</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3_tokenizer.h"</cpp:file></cpp:include>

<comment type="block">/*
** Class derived from sqlite3_tokenizer
*/</comment>
<typedef>typedef <type><struct>struct <name>porter_tokenizer</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name></type> <name>base</name></decl>;</decl_stmt>      <comment type="block">/* Base class */</comment>
}</block></struct></type> <name>porter_tokenizer</name>;</typedef>

<comment type="block">/*
** Class derived from sqlite3_tokenizer_cursor
*/</comment>
<typedef>typedef <type><struct>struct <name>porter_tokenizer_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl>;</decl_stmt>          <comment type="block">/* input we are tokenizing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInput</name></decl>;</decl_stmt>                  <comment type="block">/* size of the input */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>                 <comment type="block">/* current position in zInput */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iToken</name></decl>;</decl_stmt>                  <comment type="block">/* index of next token to be returned */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>                <comment type="block">/* storage for current token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAllocated</name></decl>;</decl_stmt>              <comment type="block">/* space allocated to zToken buffer */</comment>
}</block></struct></type> <name>porter_tokenizer_cursor</name>;</typedef>


<comment type="block">/*
** Create a new tokenizer instance.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>porterCreate</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTokenizer</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>porter_tokenizer</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>porter_tokenizer</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>t</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppTokenizer</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destroy a tokenizer
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>porterDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Prepare to begin tokenizing a particular string.  The input
** string to be tokenized is zInput[0..nInput-1].  A cursor
** used to incrementally tokenize this string is returned in 
** *ppCursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>porterOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,         <comment type="block">/* The tokenizer */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,        <comment type="block">/* String to be tokenized */</comment>
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>    <comment type="block">/* OUT: Tokenization cursor */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>porter_tokenizer_cursor</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>porter_tokenizer_cursor</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>zInput</name></name> <operator>=</operator> <name>zInput</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zInput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nInput</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name> <operator>=</operator> <name>nInput</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                 <comment type="block">/* start tokenizing at the beginning */</comment>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iToken</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>zToken</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>               <comment type="block">/* no space allocated, yet. */</comment>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>nAllocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a tokenization cursor previously opened by a call to
** porterOpen() above.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>porterClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>porter_tokenizer_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>porter_tokenizer_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Vowel or consonant
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>cType</name><index>[]</index></name> <init>= <expr><block>{
   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** isConsonant() and isVowel() determine if their first character in
** the string they point to is a consonant or a vowel, according
** to Porter ruls.  
**
** A consonate is any letter other than 'a', 'e', 'i', 'o', or 'u'.
** 'Y' is a consonant unless it follows another consonant,
** in which case it is a vowel.
**
** In these routine, the letters are in reverse order.  So the 'y' rule
** is that 'y' is a consonant unless it is followed by another
** consonent.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>isVowel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isConsonant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>x</name> <init>= <expr><operator>*</operator><name>z</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>x</name><operator>&lt;=</operator><literal type="char">'z'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>cType</name><index>[<expr><name>x</name><operator>-</operator><literal type="char">'a'</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>j</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>isVowel</name><argument_list>(<argument><expr><name>z</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isVowel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>x</name> <init>= <expr><operator>*</operator><name>z</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>x</name><operator>&lt;=</operator><literal type="char">'z'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>cType</name><index>[<expr><name>x</name><operator>-</operator><literal type="char">'a'</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal><operator>-</operator><name>j</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Let any sequence of one or more vowels be represented by V and let
** C be sequence of one or more consonants.  Then every word can be
** represented as:
**
**           [C] (VC){m} [V]
**
** In prose:  A word is an optional consonant followed by zero or
** vowel-consonant pairs followed by an optional vowel.  "m" is the
** number of vowel consonant pairs.  This routine computes the value
** of m for the first i bytes of a word.
**
** Return true if the m-value for z is 1 or more.  In other words,
** return true if z contains at least one vowel that is followed
** by a consonant.
**
** In this routine z[] is in reverse order.  So we are really looking
** for an instance of a consonant followed by a vowel.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>m_gt_0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>isVowel</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like mgt0 above except we are looking for a value of m which is
** exactly 1
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>m_eq_1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>isVowel</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isVowel</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like mgt0 above except we are looking for a value of m&gt;1 instead
** or m&gt;0
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>m_gt_1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>isVowel</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isVowel</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if there is a vowel anywhere within z[0..n-1]
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasVowel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the word ends in a double consonant.
**
** The text is reversed here. So we are really looking at
** the first two characters of z[].
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>doubleConsonant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the word ends with three letters which
** are consonant-vowel-consonent and where the final consonant
** is not 'w', 'x', or 'y'.
**
** The word is reversed here.  So we are really checking the
** first three letters and the first one cannot be in [wxy].
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>star_oh</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return
    <expr><call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
    <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'w'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'y'</literal> <operator>&amp;&amp;</operator>
    <call><name>isVowel</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
    <call><name>isConsonant</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the word ends with zFrom and xCond() is true for the stem
** of the word that preceeds the zFrom ending, then change the 
** ending to zTo.
**
** The input word *pz and zFrom are both in reverse order.  zTo
** is in normal order. 
**
** Return TRUE if zFrom matches.  Return FALSE if zFrom does not
** match.  Not that TRUE is returned even if xCond() fails and
** no substitution occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stem</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>,             <comment type="block">/* The word being stemmed (Reversed) */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>,     <comment type="block">/* If the ending matches this... (Reversed) */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name></decl></parameter>,       <comment type="block">/* ... change the ending to this (not reversed) */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCond</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>   <comment type="block">/* Condition that must be true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>*</operator><name>pz</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>zFrom</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zFrom</name><operator>==</operator><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>zFrom</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zFrom</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>xCond</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>xCond</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>zTo</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>z</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zTo</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pz</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the fallback stemmer used when the porter stemmer is
** inappropriate.  The input word is copied into the output with
** US-ASCII case folding.  If the input word is too long (more
** than 20 bytes if it contains no digits or more than 6 bytes if
** it contains digits) then word is truncated to 20 or 6 bytes
** by taking 10 or 3 bytes from the beginning and end.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_stemmer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasDigit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasDigit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>mx</name> <operator>=</operator> <ternary><condition><expr><name>hasDigit</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&gt;</operator><name>mx</name><operator>*</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>mx</name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><name>nIn</name><operator>-</operator><name>mx</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Stem the input word zIn[0..nIn-1].  Store the output in zOut.
** zOut is at least big enough to hold nIn bytes.  Write the actual
** size of the output word (exclusive of the '\0' terminator) into *pnOut.
**
** Any upper-case characters in the US-ASCII character set ([A-Z])
** are converted to lower case.  Upper-case UTF characters are
** unchanged.
**
** Words that are longer than about 20 bytes are stemmed by retaining
** a few bytes from the beginning and the end of the word.  If the
** word contains digits, 3 bytes are taken from the beginning and
** 3 bytes from the end.  For long words without digits, 10 bytes
** are taken from each end.  US-ASCII case folding still applies.
** 
** If the input word contains not digits but does characters not 
** in [a-zA-Z] then no stemming is attempted and this routine just 
** copies the input into the input into the output with US-ASCII
** case folding.
**
** Stemming never increases the length of the word.  So there is
** no chance of overflowing the zOut buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>porter_stemmer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zReverse</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&lt;</operator><literal type="number">3</literal> <operator>||</operator> <name>nIn</name><operator>&gt;=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zReverse</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The word is too big or too small for the porter stemmer.
    ** Fallback to the copy stemmer */</comment>
    <expr_stmt><expr><call><name>copy_stemmer</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zReverse</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">6</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zReverse</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>c</name> <operator>+</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zReverse</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* The use of a character not in [a-zA-Z] means that we fallback
      ** to the copy stemmer */</comment>
      <expr_stmt><expr><call><name>copy_stemmer</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>pnOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zReverse</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>zReverse</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>&amp;</operator><name><name>zReverse</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>


  <comment type="block">/* Step 1a */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'s'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>(
     <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"sess"</literal></expr></argument>, <argument><expr><literal type="string">"ss"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
     <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"sei"</literal></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>  <operator>&amp;&amp;</operator>
     <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ss"</literal></expr></argument>, <argument><expr><literal type="string">"ss"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 1b */</comment>  
  <expr_stmt><expr><name>z2</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"dee"</literal></expr></argument>, <argument><expr><literal type="string">"ee"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Do nothing.  The work was all in the test */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( 
     <expr><operator>(</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"gni"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>hasVowel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"de"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>hasVowel</name></expr></argument>)</argument_list></call><operator>)</operator>
      <operator>&amp;&amp;</operator> <name>z</name><operator>!=</operator><name>z2</name></expr>
  )</condition><block>{<block_content>
     <if_stmt><if>if<condition>( <expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ta"</literal></expr></argument>, <argument><expr><literal type="string">"ate"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"lb"</literal></expr></argument>, <argument><expr><literal type="string">"ble"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"zi"</literal></expr></argument>, <argument><expr><literal type="string">"ize"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <comment type="block">/* Do nothing.  The work was all in the test */</comment>
     </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>doubleConsonant</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'z'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
     </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>m_eq_1</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>star_oh</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>z</name><operator>)</operator> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 1c */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'y'</literal> <operator>&amp;&amp;</operator> <call><name>hasVowel</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 2 */</comment>
  <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
   <case>case <expr><literal type="char">'a'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"lanoita"</literal></expr></argument>, <argument><expr><literal type="string">"ate"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"lanoit"</literal></expr></argument>, <argument><expr><literal type="string">"tion"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'c'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"icne"</literal></expr></argument>, <argument><expr><literal type="string">"ence"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"icna"</literal></expr></argument>, <argument><expr><literal type="string">"ance"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'e'</literal></expr>:</case>
     <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"rezi"</literal></expr></argument>, <argument><expr><literal type="string">"ize"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'g'</literal></expr>:</case>
     <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"igol"</literal></expr></argument>, <argument><expr><literal type="string">"log"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'l'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ilb"</literal></expr></argument>, <argument><expr><literal type="string">"ble"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call> 
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"illa"</literal></expr></argument>, <argument><expr><literal type="string">"al"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"iltne"</literal></expr></argument>, <argument><expr><literal type="string">"ent"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ile"</literal></expr></argument>, <argument><expr><literal type="string">"e"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>
     )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ilsuo"</literal></expr></argument>, <argument><expr><literal type="string">"ous"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'o'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"noitazi"</literal></expr></argument>, <argument><expr><literal type="string">"ize"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"noita"</literal></expr></argument>, <argument><expr><literal type="string">"ate"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>
     )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"rota"</literal></expr></argument>, <argument><expr><literal type="string">"ate"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'s'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"msila"</literal></expr></argument>, <argument><expr><literal type="string">"al"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ssenevi"</literal></expr></argument>, <argument><expr><literal type="string">"ive"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ssenluf"</literal></expr></argument>, <argument><expr><literal type="string">"ful"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>
     )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ssensuo"</literal></expr></argument>, <argument><expr><literal type="string">"ous"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'t'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"itila"</literal></expr></argument>, <argument><expr><literal type="string">"al"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"itivi"</literal></expr></argument>, <argument><expr><literal type="string">"ive"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>
     )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"itilib"</literal></expr></argument>, <argument><expr><literal type="string">"ble"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Step 3 */</comment>
  <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
   <case>case <expr><literal type="char">'e'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"etaci"</literal></expr></argument>, <argument><expr><literal type="string">"ic"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"evita"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>
     )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ezila"</literal></expr></argument>, <argument><expr><literal type="string">"al"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'i'</literal></expr>:</case>
     <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"itici"</literal></expr></argument>, <argument><expr><literal type="string">"ic"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'l'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"laci"</literal></expr></argument>, <argument><expr><literal type="string">"ic"</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"luf"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'s'</literal></expr>:</case>
     <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"ssen"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Step 4 */</comment>
  <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
   <case>case <expr><literal type="char">'a'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'c'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'a'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal><operator>)</operator>  <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>  )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'e'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'i'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'l'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'a'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'i'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'n'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'a'</literal></expr> )</condition><block>{<block_content>
         <if_stmt><if>if<condition>( <expr><call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
           <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
       </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal></expr> )</condition><block>{<block_content>
         <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"tneme"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call>
          <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"tnem"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call></expr>
         )</condition><block>{<block_content>
           <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"tne"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
       </block_content>}</block></if></if_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'o'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'u'</literal></expr> )</condition><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
         <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
       </block_content>}</block></if></if_stmt>
     </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'s'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"noi"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'s'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'t'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"eta"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>stem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="string">"iti"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>m_gt_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'u'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'o'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
   <case>case <expr><literal type="char">'v'</literal></expr>:</case>
   <case>case <expr><literal type="char">'z'</literal></expr>:</case>
     <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
       <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Step 5a */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'e'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>m_eq_1</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>star_oh</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Step 5b */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>m_gt_1</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'l'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* z[] is now the stemmed word in reverse order.  Flip it back
  ** around into forward order and return.
  */</comment>
  <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>zOut</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Characters that can be part of a token.  We assume any character
** whose value is greater than 0x80 (any UTF character) can be
** part of a token.  In other words, delimiters all must have
** values of 0x7f or lower.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>porterIdChar</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 3x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 4x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 5x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 6x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 7x */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isDelim</name><parameter_list>(<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((ch=C)&amp;0x80)==0 &amp;&amp; (ch&lt;0x30 || !porterIdChar[ch-0x30]))</cpp:value></cpp:define>

<comment type="block">/*
** Extract the next token from a tokenization cursor.  The cursor must
** have been opened by a prior call to porterOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>porterNext</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,  <comment type="block">/* Cursor returned by porterOpen */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzToken</name></decl></parameter>,               <comment type="block">/* OUT: *pzToken is the token text */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBytes</name></decl></parameter>,                       <comment type="block">/* OUT: Number of bytes in token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piStartOffset</name></decl></parameter>,                 <comment type="block">/* OUT: Starting offset of token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piEndOffset</name></decl></parameter>,                   <comment type="block">/* OUT: Ending offset of token */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPosition</name></decl></parameter>                     <comment type="block">/* OUT: Position integer of token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>porter_tokenizer_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>porter_tokenizer_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>zInput</name></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&lt;</operator><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iStartOffset</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

    <comment type="block">/* Scan past delimiter characters */</comment>
    <while>while<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&lt;</operator><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name> <operator>&amp;&amp;</operator> <call><name>isDelim</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Count non-delimiter characters. */</comment>
    <expr_stmt><expr><name>iStartOffset</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&lt;</operator><name><name>c</name><operator>-&gt;</operator><name>nInput</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isDelim</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&gt;</operator><name>iStartOffset</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name><operator>-</operator><name>iStartOffset</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>c</name><operator>-&gt;</operator><name>nAllocated</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>nAllocated</name></name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">20</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>zToken</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>nAllocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>zToken</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>porter_stemmer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>iStartOffset</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>zToken</name></name></expr></argument>, <argument><expr><name>pnBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzToken</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>zToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piStartOffset</name> <operator>=</operator> <name>iStartOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piEndOffset</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>iOffset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>piPosition</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>iToken</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The set of routines that implement the porter-stemmer tokenizer
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_tokenizer_module</name></type> <name>porterTokenizerModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,
  <expr><name>porterCreate</name></expr>,
  <expr><name>porterDestroy</name></expr>,
  <expr><name>porterOpen</name></expr>,
  <expr><name>porterClose</name></expr>,
  <expr><name>porterNext</name></expr>,
  <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Allocate a new porter tokenizer.  Return a pointer to the new
** tokenizer in *ppModule
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Fts3PorterTokenizerModule</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>ppModule</name> <operator>=</operator> <operator>&amp;</operator><name>porterTokenizerModule</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */</comment>
</unit>
