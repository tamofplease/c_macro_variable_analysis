<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/lsm1/lsm-test/lsmtest_main.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sqlite3.h&gt;</cpp:file></cpp:include>

<function><type><name>void</name></type> <name>test_failed</name><parameter_list>()</parameter_list><block>{<block_content> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return;</return> 
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testSetError</name><parameter_list>(<parameter><type><name>rc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>testSetErrorFunc(rc, pRc, __FILE__, __LINE__)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>testSetErrorFunc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLine</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"FAILED (%s:%d) rc=%d "</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>iLine</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_failed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsm_memcmp</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A test utility function.
*/</comment>
<function><type><name>void</name></type> <name>testFetch</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to query database for */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,           <comment type="block">/* Expected value */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDbVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDbVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDbVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nVal</name><operator>!=</operator><name>nDbVal</name> <operator>||</operator> <operator>(</operator><name>nVal</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>lsm_memcmp</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>pDbVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testWrite</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to query database for */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,           <comment type="block">/* Value to write */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_write</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>testDelete</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,           <comment type="block">/* Key to query database for */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>tdb_delete</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>testDeleteRange</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>tdb_delete_range</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testBegin</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTrans</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_begin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>testCommit</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTrans</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_commit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* unused */</comment>
static void testRollback(TestDb *pDb, int iTrans, int *pRc){
  if( *pRc==0 ){
    int rc;
    rc = tdb_rollback(pDb, iTrans);
    testSetError(rc);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>testWriteStr</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>,               <comment type="block">/* Key to query database for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl></parameter>,               <comment type="block">/* Value to write */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>zVal</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testWrite</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zKey</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* unused */</comment>
static void testDeleteStr(TestDb *pDb, const char *zKey, int *pRc){
  testDelete(pDb, (void *)zKey, strlen(zKey), pRc);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>testFetchStr</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>,               <comment type="block">/* Key to query database for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl></parameter>,               <comment type="block">/* Value to write */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>zVal</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testFetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zKey</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testFetchCompare</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pControl</name></decl></parameter>, 
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDbVal1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDbVal2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDbVal1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDbVal2</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pControl</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbVal1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDbVal1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDbVal2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDbVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal> 
   <operator>&amp;&amp;</operator> <operator>(</operator><name>nDbVal1</name><operator>!=</operator><name>nDbVal2</name> <operator>||</operator> <operator>(</operator><name>nDbVal1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pDbVal1</name></expr></argument>, <argument><expr><name>pDbVal2</name></expr></argument>, <argument><expr><name>nDbVal1</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>ScanResult</name></name></type> <name>ScanResult</name>;</typedef>
<struct>struct <name>ScanResult</name> <block>{
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey2</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>bReverse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrevKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aPrevKey</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>keyCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>nKey1</name> <operator>-</operator> <name>nKey2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type> <name>test_scan_debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>scanCompareCb</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ScanResult</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ScanResult</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aKey</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aVal</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>test_scan_debug</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d: %.*s\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  if( test_scan_debug ) printf("%.20s\n", (char *)pVal);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Check tdb_fetch() matches */</comment>
  int rc = 0;
  testFetch(p-&gt;pDb, pKey, nKey, pVal, nVal, &amp;rc);
  assert( rc==0 );
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Update the checksum data */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name><operator>++</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nKey</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cksum1</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>aKey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cksum2</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>cksum1</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cksum1</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>aVal</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cksum2</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>cksum1</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Check that the delivered row is not out of order. */</comment>
  <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aPrevKey</name></name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nPrevKey</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>keyCompare</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aPrevKey</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPrevKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>res</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bReverse</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>res</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bReverse</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Returned key out of order at %s:%d\n"</literal></expr></argument>, 
            <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nPrevKey</name></name> <operator>=</operator> <name>nKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aPrevKey</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nPrevKey</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that the delivered row is within range. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKey1</name></name> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pKey1</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nKey1</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pKey1</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nKey1</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nKey1</name></name><operator>&gt;</operator><name>nKey</name><operator>)</operator>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Returned key too small at %s:%d\n"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pKey2</name></name> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pKey2</name></name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nKey2</name></name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nKey2</name></name><operator>&lt;</operator><name>nKey</name><operator>)</operator>
  <operator>)</operator></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Returned key too large at %s:%d\n"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
** Scan the contents of the two databases. Check that they match.
*/</comment>
<function><type><name>void</name></type> <name>testScanCompare</name><parameter_list>(
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb1</name></decl></parameter>,                   <comment type="block">/* Control (trusted) database */</comment>
  <parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb2</name></decl></parameter>,                   <comment type="block">/* Database being tested */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ScanResult</name></type> <name>res1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanResult</name></type> <name>res2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRes1</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRes2</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res2</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>pDb</name></name> <operator>=</operator> <name>pDb1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>nKey1</name></name> <operator>=</operator> <name>nKey1</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>pKey1</name></name> <operator>=</operator> <name>pKey1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>nKey2</name></name> <operator>=</operator> <name>nKey2</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>pKey2</name></name> <operator>=</operator> <name>pKey2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res1</name><operator>.</operator><name>bReverse</name></name> <operator>=</operator> <name>bReverse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>pDb</name></name> <operator>=</operator> <name>pDb2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>nKey1</name></name> <operator>=</operator> <name>nKey1</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>pKey1</name></name> <operator>=</operator> <name>pKey1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>nKey2</name></name> <operator>=</operator> <name>nKey2</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>pKey2</name></name> <operator>=</operator> <name>pKey2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res2</name><operator>.</operator><name>bReverse</name></name> <operator>=</operator> <name>bReverse</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tdb_scan</name><argument_list>(<argument><expr><name>pDb1</name></expr></argument>, <argument><expr><name>pRes1</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>scanCompareCb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>( <expr><name>test_scan_debug</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>tdb_scan</name><argument_list>(<argument><expr><name>pDb2</name></expr></argument>, <argument><expr><name>pRes2</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>, <argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>scanCompareCb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>( <expr><name>test_scan_debug</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>res1</name><operator>.</operator><name>nRow</name></name><operator>!=</operator><name><name>res2</name><operator>.</operator><name>nRow</name></name> 
     <operator>||</operator> <name><name>res1</name><operator>.</operator><name>cksum1</name></name><operator>!=</operator><name><name>res2</name><operator>.</operator><name>cksum1</name></name> 
     <operator>||</operator> <name><name>res1</name><operator>.</operator><name>cksum2</name></name><operator>!=</operator><name><name>res2</name><operator>.</operator><name>cksum2</name></name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"expected: %d %X %X\n"</literal></expr></argument>, <argument><expr><name><name>res1</name><operator>.</operator><name>nRow</name></name></expr></argument>, <argument><expr><name><name>res1</name><operator>.</operator><name>cksum1</name></name></expr></argument>, <argument><expr><name><name>res1</name><operator>.</operator><name>cksum2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"got:      %d %X %X\n"</literal></expr></argument>, <argument><expr><name><name>res2</name><operator>.</operator><name>nRow</name></name></expr></argument>, <argument><expr><name><name>res2</name><operator>.</operator><name>cksum1</name></name></expr></argument>, <argument><expr><name><name>res2</name><operator>.</operator><name>cksum2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testClose</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TestDb</name> <modifier>*</modifier></type><name>testOpen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSystem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bClear</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>zSystem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bClear</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testSetError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pDb</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>testReopen</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLib</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zLib</name> <operator>=</operator> <call><name>tdb_library_name</name><argument_list>(<argument><expr><operator>*</operator><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>zLib</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* unused */</comment>
static void testSystemSelect(const char *zSys, int *piSel, int *pRc){
  if( *pRc==0 ){
    struct SysName { const char *zName; } *aName;
    int nSys;
    int i;

    for(nSys=0; tdb_system_name(nSys); nSys++);
    aName = malloc(sizeof(struct SysName) * (nSys+1));
    for(i=0; i&lt;=nSys; i++){
      aName[i].zName = tdb_system_name(i);
    }

    *pRc = testArgSelect(aName, "db", zSys, piSel);
    free(aName);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name> <modifier>*</modifier></type><name>testMallocVPrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>copy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zRet</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>testMalloc</name><argument_list>(<argument><expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>testMallocPrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>testMallocVPrintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** A wrapper around malloc(3).
**
** This function should be used for all allocations made by test procedures.
** It has the following properties:
**
**   * Test code may assume that allocations may not fail.
**   * Returned memory is always zeroed.
**
** Allocations made using testMalloc() should be freed using testFree().
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>testMalloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>testMallocCopy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCopy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><call><name>testMalloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>testRealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>ptr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nOrig</name> <init>=  <expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOrig</name><operator>&lt;</operator><name>n</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">8</literal><operator>+</operator><name>nOrig</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>nOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>testMalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an allocation made by an earlier call to testMalloc().
*/</comment>
<function><type><name>void</name></type> <name>testFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>ptr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0x55</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** String zPattern contains a glob pattern. Return true if zStr matches 
** the pattern, or false if it does not.
*/</comment>
<function><type><name>int</name></type> <name>testGlobMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name><name>zPattern</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>p</name> <init>= <expr><name><name>zPattern</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="char">'*'</literal> <operator>||</operator> <name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <do>do <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>testGlobMatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zPattern</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block>while<condition>( <expr><name><name>zStr</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr> )</condition>;</do>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>p</name><operator>!=</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name>p</name><operator>!=</operator><name><name>zStr</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* Match failed. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><operator>(</operator><name><name>zPattern</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zStr</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** End of test utilities 
**************************************************************************/</comment>

<function><type><name>int</name></type> <name>do_test</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Usage: test ?PATTERN?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>test_data_1</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_data_2</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_data_3</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_data_4</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_rollback</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_mc</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>test_mt</name><argument_list>(<argument><expr><call><name>tdb_system_name</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>test_oom</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>test_api</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_crash_test</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_writer_crash_test</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFail</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><operator>(</operator><name>nFail</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>lsm_db</name> <modifier>*</modifier></type><name>configure_lsm_db</name><parameter_list>(<parameter><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pLsm</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pLsm</name> <operator>=</operator> <call><name>tdb_lsm</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pLsm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>tdb_lsm_config_str</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="string">"mmap=1 autowork=1 automerge=4 worker_automerge=4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pLsm</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>WriteHookEvent</name></name></type> <name>WriteHookEvent</name>;</typedef>
<struct>struct <name>WriteHookEvent</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUs</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>WriteHookEvent</name></type> <name>prev</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flushPrev</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>prev</name><operator>.</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"w %s %lld %d %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>, <argument><expr><name><name>prev</name><operator>.</operator><name>iOff</name></name></expr></argument>, <argument><expr><name><name>prev</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name><name>prev</name><operator>.</operator><name>nUs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>prev</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* unused */</comment>
static void do_speed_write_hook2(
  void *pCtx,
  int bLog,
  i64 iOff,
  int nData,
  int nUs
){
  FILE *pOut = (FILE *)pCtx;
  if( bLog ) return;

  if( prev.nData &amp;&amp; nData &amp;&amp; iOff==prev.iOff+prev.nData ){
    prev.nData += nData;
    prev.nUs += nUs;
  }else{
    flushPrev(pOut);
    if( nData==0 ){
      fprintf(pOut, "s %s 0 0 %d\n", (bLog ? "l" : "d"), nUs);
    }else{
      prev.iOff = iOff;
      prev.nData = nData;
      prev.nUs = nUs;
    }
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_REPEAT</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_WRITE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_PAUSE</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_FETCH</name></cpp:macro>   <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_SCAN</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_NSCAN</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_KEYSIZE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_VALSIZE</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_TRANS</name></cpp:macro>   <cpp:value>8</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>print_speed_test_help</name><parameter_list>()</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"\n"</literal>
<literal type="string">"Repeat the following $repeat times:\n"</literal>
<literal type="string">"  1. Insert $write key-value pairs. One transaction for each write op.\n"</literal>
<literal type="string">"  2. Pause for $pause ms.\n"</literal>
<literal type="string">"  3. Perform $fetch queries on the database.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"  Keys are $keysize bytes in size. Values are $valsize bytes in size\n"</literal>
<literal type="string">"  Both keys and values are pseudo-randomly generated\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"Options are:\n"</literal>
<literal type="string">"  -repeat  $repeat                 (default value 10)\n"</literal>
<literal type="string">"  -write   $write                  (default value 10000)\n"</literal>
<literal type="string">"  -pause   $pause                  (default value 0)\n"</literal>
<literal type="string">"  -fetch   $fetch                  (default value 0)\n"</literal>
<literal type="string">"  -keysize $keysize                (default value 12)\n"</literal>
<literal type="string">"  -valsize $valsize                (default value 100)\n"</literal>
<literal type="string">"  -system  $system                 (default value \"lsm\")\n"</literal>
<literal type="string">"  -trans   $trans                  (default value 0)\n"</literal>
<literal type="string">"\n"</literal></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>do_speed_test2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct>struct <name>Option</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDefault</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aOpt</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"-repeat"</literal></expr>,  <expr><name>ST_REPEAT</name></expr>,    <expr><literal type="number">10</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-write"</literal></expr>,   <expr><name>ST_WRITE</name></expr>,  <expr><literal type="number">10000</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-pause"</literal></expr>,   <expr><name>ST_PAUSE</name></expr>,      <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-fetch"</literal></expr>,   <expr><name>ST_FETCH</name></expr>,      <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-scan"</literal></expr>,    <expr><name>ST_SCAN</name></expr>,       <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-nscan"</literal></expr>,   <expr><name>ST_NSCAN</name></expr>,      <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-keysize"</literal></expr>, <expr><name>ST_KEYSIZE</name></expr>,   <expr><literal type="number">12</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-valsize"</literal></expr>, <expr><name>ST_VALSIZE</name></expr>,  <expr><literal type="number">100</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-trans"</literal></expr>,   <expr><name>ST_TRANS</name></expr>,      <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"-system"</literal></expr>,  <expr><operator>-</operator><literal type="number">1</literal></expr>,            <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="string">"help"</literal></expr>,     <expr><operator>-</operator><literal type="number">2</literal></expr>,            <expr><literal type="number">0</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aParam</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bReadonly</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nContent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DatasourceDefn</name></type> <name>defn</name> <init>= <expr><block>{ <expr><name>TEST_DATASOURCE_RANDOM</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSystem</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bLsm</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pLog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NDEBUG</name></cpp:ifdef>
  <comment type="block">/* If NDEBUG is defined, disable the dynamic memory related checks in
  ** lsmtest_mem.c. They slow things down.  */</comment>
  <expr_stmt><expr><call><name>testMallocUninstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Initialize aParam[] with default values. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aOpt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zOpt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aParam</name><index>[<expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eVal</name></expr>]</index></name> <operator>=</operator> <name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iDefault</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Process the command line switches. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSel</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aOpt</name></expr></argument>, <argument><expr><literal type="string">"switch"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>eVal</name><operator>==</operator><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>print_speed_test_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>nArg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"option %s requires an argument\n"</literal></expr></argument>, <argument><expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>zOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>eVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aParam</name><index>[<expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>eVal</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSystem</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bLsm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      for(j=0; zSystem[j]; j++){
        if( zSystem[j]=='=' ) bLsm = 1;
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"#"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aOpt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zOpt</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s=%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>zOpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aParam</name><index>[<expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eVal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eVal</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s=\"%s\""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOpt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>zOpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zSystem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>defn</name><operator>.</operator><name>nMinKey</name></name> <operator>=</operator> <name><name>defn</name><operator>.</operator><name>nMaxKey</name></name> <operator>=</operator> <name><name>aParam</name><index>[<expr><name>ST_KEYSIZE</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>defn</name><operator>.</operator><name>nMinVal</name></name> <operator>=</operator> <name><name>defn</name><operator>.</operator><name>nMaxVal</name></name> <operator>=</operator> <name><name>aParam</name><index>[<expr><name>ST_VALSIZE</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>testDatasourceNew</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_WRITE</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bReadonly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bLsm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_lsm_open</name><argument_list>(<argument><expr><name>zSystem</name></expr></argument>, <argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><operator>!</operator><name>bReadonly</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pDb</name> <operator>=</operator> <call><name>testOpen</name><argument_list>(<argument><expr><name>zSystem</name></expr></argument>, <argument><expr><operator>!</operator><name>bReadonly</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bReadonly</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nContent</name> <operator>=</operator> <call><name>testCountDatabase</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  pLog = fopen("/tmp/speed.log", "w");
  tdb_lsm_write_hook(pDb, do_speed_write_hook2, (void *)pLog);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>aParam</name><index>[<expr><name>ST_REPEAT</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>msWrite</name></decl>, <decl><type ref="prev"/><name>msFetch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iFetch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><name><name>aParam</name><index>[<expr><name>ST_WRITE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>bReadonly</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>msWrite</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_TRANS</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>testWriteDatasourceRange</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>i</name><operator>*</operator><name>nWrite</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_TRANS</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>msWrite</name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nContent</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_PAUSE</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_PAUSE</name></expr>]</index></name><operator>/</operator><literal type="number">1000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name><name>aParam</name><index>[<expr><name>ST_PAUSE</name></expr>]</index></name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_PAUSE</name></expr>]</index></name><operator>%</operator><literal type="number">1000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal> <operator>*</operator> <operator>(</operator><name><name>aParam</name><index>[<expr><name>ST_PAUSE</name></expr>]</index></name><operator>%</operator><literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_FETCH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_TRANS</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>iFetch</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iFetch</name><operator>&lt;</operator><name><name>aParam</name><index>[<expr><name>ST_FETCH</name></expr>]</index></name></expr>;</condition> <incr><expr><name>iFetch</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iKey</name> <init>= <expr><call><name>testPrngValue</name><argument_list>(<argument><expr><name>i</name><operator>*</operator><name>nWrite</name><operator>+</operator><name>iFetch</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nContent</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <expr_stmt><expr><call><name>testDatasourceFetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>           <comment type="block">/* Database key to query for */</comment>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>           <comment type="block">/* Result of query */</comment>

        <expr_stmt><expr><call><name>testDatasourceEntry</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>aParam</name><index>[<expr><name>ST_TRANS</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>testCommit</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>msFetch</name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>msFetch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><operator>(</operator><name><name>aParam</name><index>[<expr><name>ST_REPEAT</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>msWrite</name> <operator>+=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d %d %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>msWrite</name></expr></argument>, <argument><expr><name>msFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>testClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testDatasourceFree</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pLog</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>flushPrev</name><argument_list>(<argument><expr><name>pLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>do_speed_tests</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>

  <struct>struct <name>DbSystem</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLibrary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColor</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aSys</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"sqlite3"</literal></expr>,      <expr><literal type="string">"black"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"leveldb"</literal></expr>,      <expr><literal type="string">"blue"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"lsm"</literal></expr>,          <expr><literal type="string">"red"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"lsm_mt2"</literal></expr>,      <expr><literal type="string">"orange"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"lsm_mt3"</literal></expr>,      <expr><literal type="string">"purple"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"kyotocabinet"</literal></expr>, <expr><literal type="string">"green"</literal></expr> }</block></expr>,
    <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
  }</block></expr></init></decl>;</struct>

  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* ms of rest allowed between INSERT tests */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Number of rows to insert into database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStep</name></decl>;</decl_stmt>                      <comment type="block">/* Measure INSERT time after this many rows */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSelStep</name></decl>;</decl_stmt>                   <comment type="block">/* Measure SELECT time after this many rows */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSelTest</name></decl>;</decl_stmt>                   <comment type="block">/* Number of SELECTs to run for timing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>doReadTest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>doWriteTest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aTime</name></decl>;</decl_stmt>                     <comment type="block">/* INSERT timing data */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aWrite</name></decl>;</decl_stmt>                    <comment type="block">/* Writes per nStep inserts */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aSelTime</name></decl>;</decl_stmt>                  <comment type="block">/* SELECT timing data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isFirst</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* File to write gnuplot script to. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><literal type="string">"lsmtest_speed.gnuplot"</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u32</name></type> <name>sys_mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>testMallocUninstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <struct>struct <name>Opt</name> <block>{ 
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt> 
      <decl_stmt><decl><type><name>int</name></type> <name>isSwitch</name></decl>;</decl_stmt>
    }</block> <decl><name><name>aOpt</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"sqlite3"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"leveldb"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"lsm"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"lsm_mt2"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"lsm_mt3"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"kyotocabinet"</literal></expr> , <expr><literal type="number">0</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"-rows"</literal></expr>     , <expr><literal type="number">1</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"-sleep"</literal></expr>    , <expr><literal type="number">2</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"-testmode"</literal></expr> , <expr><literal type="number">3</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"-out"</literal></expr>      , <expr><literal type="number">4</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>iSel</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aOpt</name></expr></argument>, <argument><expr><literal type="string">"argument"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>isSwitch</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"option %s requires an argument\n"</literal></expr></argument>, <argument><expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>zOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>isSwitch</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nRow</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>isSwitch</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nSleep</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>isSwitch</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <struct>struct <name>Mode</name> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMode</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>doReadTest</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>doWriteTest</name></decl>;</decl_stmt>
        }</block> <decl><name><name>aMode</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="string">"ro"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr> , <expr><block>{<expr><literal type="string">"rw"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="string">"wo"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</struct>
        <decl_stmt><decl><type><name>int</name></type> <name>iMode</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aMode</name></expr></argument>, <argument><expr><literal type="string">"option"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>doReadTest</name> <operator>=</operator> <name><name>aMode</name><index>[<expr><name>iMode</name></expr>]</index></name><operator>.</operator><name>doReadTest</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doWriteTest</name> <operator>=</operator> <name><name>aMode</name><index>[<expr><name>iMode</name></expr>]</index></name><operator>.</operator><name>doWriteTest</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aOpt</name><index>[<expr><name>iSel</name></expr>]</index></name><operator>.</operator><name>isSwitch</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* The "-out FILE" switch. This option is used to specify a file to
        ** write the gnuplot script to. */</comment>
        <expr_stmt><expr><name>zOut</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* A db name */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aOpt</name></expr></argument>, <argument><expr><literal type="string">"system"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>sys_mask</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iSel</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>sys_mask</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sys_mask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nRow</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>nRow</name></expr></argument>, <argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nStep</name> <operator>=</operator> <name>nRow</name><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSelStep</name> <operator>=</operator> <name>nRow</name><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSelTest</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nSelStep</name> <operator>&gt;</operator> <literal type="number">100000</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">100000</literal></expr> </then><else>: <expr><name>nSelStep</name></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name>aTime</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name>aSys</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>nRow</name><operator>/</operator><name>nStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aWrite</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nRow</name><operator>/</operator><name>nStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aSelTime</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name>aSys</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>nRow</name><operator>/</operator><name>nSelStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This loop collects the INSERT speed data. */</comment>
  <if_stmt><if>if<condition>( <expr><name>doWriteTest</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Writing output to file \"%s\".\n"</literal></expr></argument>,  <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pLog</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database being tested */</comment>
      <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pLsm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iDot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><name>sys_mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bSleep</name> <operator>&amp;&amp;</operator> <name>nSleep</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><name>nSleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>bSleep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>testCaseBegin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"speed.insert.%s"</literal></expr></argument>, <argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>pLsm</name> <operator>=</operator> <call><name>configure_lsm_db</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
      pLog = fopen("/tmp/speed.log", "w");
      tdb_lsm_write_hook(pDb, do_speed_write_hook2, (void *)pLog);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
      <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nStep</name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iStep</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nWrite1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nWrite2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>testCaseProgress</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nRow</name></expr></argument>, <argument><expr><call><name>testCaseNDot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pLsm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsm_info</name><argument_list>(<argument><expr><name>pLsm</name></expr></argument>, <argument><expr><name>LSM_INFO_NWRITE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>iStep</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iStep</name><operator>&lt;</operator><name>nStep</name></expr>;</condition> <incr><expr><name>iStep</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>u32</name></type> <name><name>aKey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 16-byte key */</comment>
          <decl_stmt><decl><type><name>u32</name></type> <name><name>aVal</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>                 <comment type="block">/* 100 byte value */</comment>
          <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><name>iStep</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><name>iStep</name></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_write</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>aTime</name><index>[<expr><operator>(</operator><name>j</name><operator>*</operator><name>nRow</name><operator>+</operator><name>i</name><operator>)</operator><operator>/</operator><name>nStep</name></expr>]</index></name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pLsm</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsm_info</name><argument_list>(<argument><expr><name>pLsm</name></expr></argument>, <argument><expr><name>LSM_INFO_NWRITE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>aWrite</name><index>[<expr><name>i</name><operator>/</operator><name>nStep</name></expr>]</index></name> <operator>=</operator> <name>nWrite2</name> <operator>-</operator> <name>nWrite1</name></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pLog</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>testCaseFinish</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* This loop collects the SELECT speed data. */</comment>
  <if_stmt><if>if<condition>( <expr><name>doReadTest</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database being tested */</comment>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><name>sys_mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bSleep</name> <operator>&amp;&amp;</operator> <name>nSleep</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><name>nSleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>bSleep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>testCaseBegin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"speed.select.%s"</literal></expr></argument>, <argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>doWriteTest</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>configure_lsm_db</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nSelStep</name></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iStep</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iSel</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>testCaseProgress</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nRow</name></expr></argument>, <argument><expr><call><name>testCaseNDot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>iStep</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iStep</name><operator>&lt;</operator><name>nSelStep</name></expr>;</condition> <incr><expr><name>iStep</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>u32</name></type> <name><name>aKey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 16-byte key */</comment>
            <decl_stmt><decl><type><name>u32</name></type> <name><name>aVal</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>                 <comment type="block">/* 100 byte value */</comment>
            <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><name>iStep</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><name>iStep</name></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_write</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
    
          <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <for>for<control>(<init><expr><name>iSel</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iSel</name><operator>&lt;</operator><name>nSelTest</name></expr>;</condition> <incr><expr><name>iSel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDummy</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nDummy</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>u32</name></type> <name><name>aKey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 16-byte key */</comment>
    
            <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>testPrngValue</name><argument_list>(<argument><expr><name>iSel</name></expr></argument>)</argument_list></call> <operator>%</operator> <operator>(</operator><name>i</name><operator>+</operator><name>nSelStep</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><name><name>aSelTime</name><index>[<expr><operator>(</operator><name>j</name><operator>*</operator><name>nRow</name><operator>+</operator><name>i</name><operator>)</operator><operator>/</operator><name>nSelStep</name></expr>]</index></name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iSel</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>configure_lsm_db</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>iSel</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>iSel</name><operator>&lt;</operator><name>nSelTest</name></expr>;</condition> <incr><expr><name>iSel</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pDummy</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nDummy</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u32</name></type> <name><name>aKey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 16-byte key */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
          <decl_stmt><decl><type><name>u32</name></type> <name><name>aVal</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>                 <comment type="block">/* 100 byte value */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

          <expr_stmt><expr><call><name>testCaseProgress</name><argument_list>(<argument><expr><name>iSel</name></expr></argument>, <argument><expr><name>nSelTest</name></expr></argument>, <argument><expr><call><name>testCaseNDot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <call><name>testPrngValue</name><argument_list>(<argument><expr><name>iSel</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nRow</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>aKey</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
          <expr_stmt><expr><call><name>testPrngArray</name><argument_list>(<argument><expr><name>iKey</name></expr></argument>, <argument><expr><name>aVal</name></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDummy</name><operator>==</operator><literal type="number">100</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>aVal</name></expr></argument>, <argument><expr><name>pDummy</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tdb_fetch</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: %d selects/second\n"</literal></expr></argument>, 
            <argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>nSelTest</name><operator>*</operator><literal type="number">1000.0</literal><operator>/</operator><name>t</name><operator>)</operator></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testCaseFinish</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>


  <if_stmt><if>if<condition>( <expr><name>doWriteTest</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"fopen(\"%s\", \"w\"): %s\n"</literal></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set xlabel \"Rows Inserted\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set ylabel \"Inserts per second\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>doReadTest</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set y2label \"Selects per second\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>sys_mask</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set y2label \"Page writes per insert\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set yrange [0:*]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set y2range [0:*]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set xrange [%d:*]\n"</literal></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>nStep</name></expr></argument>, <argument><expr><name>nRow</name><operator>/</operator><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set ytics nomirror\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set y2tics nomirror\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"set key box lw 0.01\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"plot "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><name>sys_mask</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLib</name> <init>= <expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%s\"-\" ti \"%s INSERT\" with lines lc rgb \"%s\" "</literal></expr></argument>, 
            <argument><expr><operator>(</operator><ternary><condition><expr><name>isFirst</name></expr>?</condition><then><expr><literal type="string">""</literal></expr></then><else>:<expr><literal type="string">", "</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zLib</name></expr></argument>, <argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zColor</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>doReadTest</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">", \"-\" ti \"%s SELECT\" "</literal>
                 <literal type="string">"axis x1y2 with points lw 3 lc rgb \"%s\""</literal></expr></argument>
              , <argument><expr><name>zLib</name></expr></argument>, <argument><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zColor</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>isFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>aSys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr></argument>, <argument><expr><literal type="string">"lsm"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>sys_mask</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>doReadTest</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">", \"-\" ti \"lsm pages written\" "</literal>
        <literal type="string">"axis x1y2 with boxes lw 1 lc rgb \"grey\""</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aSys</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>zLibrary</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>&amp;</operator><name>sys_mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"# Rows    Inserts per second\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nStep</name></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iTime</name> <init>= <expr><name><name>aTime</name><index>[<expr><operator>(</operator><name>j</name><operator>*</operator><name>nRow</name><operator>+</operator><name>i</name><operator>)</operator><operator>/</operator><name>nStep</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ips</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>i</name><operator>+</operator><name>nStep</name><operator>)</operator><operator>*</operator><literal type="number">1000.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>iTime</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%d %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>nStep</name></expr></argument>, <argument><expr><name>ips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
      <if_stmt><if>if<condition>( <expr><name>doReadTest</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"# Rows    Selects per second\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>nSelStep</name></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>sps</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nSelTest</name><operator>*</operator><literal type="number">1000.0</literal><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>aSelTime</name><index>[<expr><operator>(</operator><name>j</name><operator>*</operator><name>nRow</name><operator>+</operator><name>i</name><operator>)</operator><operator>/</operator><name>nSelStep</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%d %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>nSelStep</name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>sys_mask</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>nRow</name><operator>/</operator><name>nStep</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%d %f\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>*</operator><name>nStep</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>aWrite</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"pause -1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aSelTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testMallocInstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Usage: lsmtest random ?N?
**
** This command prints a sequence of zero or more numbers from the PRNG
** system to stdout. If the "N" argument is missing, values the first 10
** values (i=0, i=1, ... i=9) are printed. Otherwise, the first N.
**
** This was added to verify that the PRNG values do not change between
** runs of the lsmtest program.
*/</comment>
<function><type><name>int</name></type> <name>do_random_tests</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRand</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nRand</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nRand</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Usage: random ?N?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRand</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%x\n"</literal></expr></argument>, <argument><expr><call><name>testPrngValue</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>testFormatSize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><literal type="string">"%d byte"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nByte</name><operator>&lt;</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><literal type="string">"%dK"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nByte</name><operator>/</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">10</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><literal type="string">"%dM"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nByte</name><operator>/</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>i64</name></type> <name>testReadSize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMul</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'g'</literal></expr>:</case> <case>case <expr><literal type="char">'G'</literal></expr>:</case>
      <expr_stmt><expr><name>nMul</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">30</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'M'</literal></expr>:</case>
      <expr_stmt><expr><name>nMul</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><literal type="char">'k'</literal></expr>:</case> <case>case <expr><literal type="char">'K'</literal></expr>:</case>
      <expr_stmt><expr><name>nMul</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><name>nMul</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></switch>

  <return>return <expr><name>nMul</name> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function> 

<comment type="block">/*
** Usage: lsmtest writespeed FILESIZE BLOCKSIZE SYNCSIZE
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>do_writer_test</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ms</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aFilesize</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aBlockSize</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aOrder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSync</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>i64</name></type> <name>filesize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>blocksize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>syncsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* How long to sleep before running a trial (in ms). */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  const int nSleep = 10000;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nSleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintUsage</name><argument_list>(<argument><expr><literal type="string">"FILESIZE BLOCKSIZE SYNCSIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>testReadSize</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>blocksize</name> <operator>=</operator> <call><name>testReadSize</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>syncsize</name> <operator>=</operator> <call><name>testReadSize</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nBlock</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>filesize</name> <operator>/</operator> <name>blocksize</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>blocksize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nSync</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>syncsize</name> <operator>/</operator> <name>blocksize</name><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>aPage</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOrder</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>nBlock</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlock</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aOrder</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>nBlock</name><operator>*</operator><literal type="number">25</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>a</name> <init>= <expr><call><name>testPrngValue</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>b</name> <init>= <expr><call><name>testPrngValue</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name> <operator>%</operator> <name>nBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <name>b</name> <operator>%</operator> <name>nBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>aOrder</name><index>[<expr><name>a</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOrder</name><index>[<expr><name>a</name></expr>]</index></name> <operator>=</operator> <name><name>aOrder</name><index>[<expr><name>b</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aOrder</name><index>[<expr><name>b</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>testFormatSize</name><argument_list>(<argument><expr><name>aFilesize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aFilesize</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>nBlock</name> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testFormatSize</name><argument_list>(<argument><expr><name>aBlockSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aFilesize</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Testing writing a %s file using %s blocks. "</literal></expr></argument>, <argument><expr><name>aFilesize</name></expr></argument>, <argument><expr><name>aBlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSync</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Sync after each block.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Sync after each %d blocks.\n"</literal></expr></argument>, <argument><expr><name>nSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Preparing file... "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><literal type="string">"writer.out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"writer.out"</literal></expr></argument>, <argument><expr><name>O_RDWR</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>_O_BINARY</name></expr></argument>, <argument><expr><literal type="number">0664</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>fd</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"open(): %d - %s\n"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlock</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>i</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>iPg</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPg</name><operator>&lt;</operator><operator>(</operator><name>nSize</name><operator>/</operator><name>nPage</name><operator>)</operator></expr>;</condition> <incr><expr><name>iPg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ok (%d ms)\n"</literal></expr></argument>, <argument><expr><call><name>testTimeGet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><name>nSleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Now writing sequentially...  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nBlock</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>nSync</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>j</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iPg</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPg</name><operator>&lt;</operator><operator>(</operator><name>nSize</name><operator>/</operator><name>nPage</name><operator>)</operator></expr>;</condition> <incr><expr><name>iPg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ms</name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d ms\n"</literal></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><name>nSleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Now in an arbitrary order... "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testTimeInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nBlock</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>nSync</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>aOrder</name><index>[<expr><name>j</name></expr>]</index></name><operator>*</operator><name>nSize</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>j</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>iPg</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iPg</name><operator>&lt;</operator><operator>(</operator><name>nSize</name><operator>/</operator><name>nPage</name><operator>)</operator></expr>;</condition> <incr><expr><name>iPg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aPage</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ms</name> <operator>=</operator> <call><name>testTimeGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d ms\n"</literal></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_insert_work_hook</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsm_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_INFO_DB_STRUCTURE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsm_free</name><argument_list>(<argument><expr><call><name>lsm_get_env</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>unused_parameter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>InsertWriteHook</name></name></type> <name>InsertWriteHook</name>;</typedef>
<struct>struct <name>InsertWriteHook</name> <block>{
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bLog</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flushHook</name><parameter_list>(<parameter><decl><type><name>InsertWriteHook</name> <modifier>*</modifier></type><name>pHook</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pHook</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><literal type="string">"write %s %d %d\n"</literal></expr></argument>, 
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pHook</name><operator>-&gt;</operator><name>bLog</name></name></expr> ?</condition><then> <expr><literal type="string">"log"</literal></expr> </then><else>: <expr><literal type="string">"db"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pHook</name><operator>-&gt;</operator><name>iOff</name></name></expr></argument>, <argument><expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>pHook</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_insert_write_hook</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bLog</name></decl></parameter>,
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nUs</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InsertWriteHook</name> <modifier>*</modifier></type><name>pHook</name> <init>= <expr><operator>(</operator><name>InsertWriteHook</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>bLog</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>flushHook</name><argument_list>(<argument><expr><name>pHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>pHook</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><literal type="string">"sync %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bLog</name></expr> ?</condition><then> <expr><literal type="string">"log"</literal></expr> </then><else>: <expr><literal type="string">"db"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name> 
         <operator>&amp;&amp;</operator> <name>bLog</name><operator>==</operator><name><name>pHook</name><operator>-&gt;</operator><name>bLog</name></name> 
         <operator>&amp;&amp;</operator> <name>iOff</name><operator>==</operator><operator>(</operator><name><name>pHook</name><operator>-&gt;</operator><name>iOff</name></name><operator>+</operator><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name><operator>)</operator></expr> 
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>flushHook</name><argument_list>(<argument><expr><name>pHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHook</name><operator>-&gt;</operator><name>bLog</name></name> <operator>=</operator> <name>bLog</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHook</name><operator>-&gt;</operator><name>iOff</name></name> <operator>=</operator> <name>iOff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHook</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_replay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pClose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Usage: replay WRITELOG FILE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInput</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pClose</name> <operator>=</operator> <name>pInput</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEnv</name> <operator>=</operator> <call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <while>while<condition>( <expr><call><name>feof</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zLine</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fgets</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zLine</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"sync db"</literal></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nMatch</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"write db %d %d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nMatch</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>i</name><operator>&amp;</operator><literal type="number">0xFF</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pClose</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_insert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><literal type="string">"lsm"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TestDb</name> <modifier>*</modifier></type><name>pDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nRow</name> <init>= <expr><literal type="number">1</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DatasourceDefn</name></type> <name>defn</name> <init>= <expr><block>{ <expr><name>TEST_DATASOURCE_RANDOM</name></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">80</literal></expr>, <expr><literal type="number">150</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datasource</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Usage: insert ?DATABASE?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>testMallocUninstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zDb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'='</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zDb</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_lsm_open</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="string">"testdb.lsm"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Error opening db \"%s\": %d\n"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>InsertWriteHook</name></type> <name>hook</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hook</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hook</name><operator>.</operator><name>pOut</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"writelog.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>testDatasourceNew</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_lsm_config_work_hook</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>do_insert_work_hook</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_lsm_write_hook</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>do_insert_write_hook</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pKey</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>     <comment type="block">/* Database key to insert */</comment>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>     <comment type="block">/* Database value to insert */</comment>
        <expr_stmt><expr><call><name>testDatasourceEntry</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tdb_write</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>testDatasourceFree</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>flushHook</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>hook</name><operator>.</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>testMallocInstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>st_do_show</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>      <block>{<block_content> <return>return <expr><call><name>do_show</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>st_do_work</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>      <block>{<block_content> <return>return <expr><call><name>do_work</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>st_do_io</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>        <block>{<block_content> <return>return <expr><call><name>do_io</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>lsmtest_rusage_report</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"# getrusage: { ru_maxrss %d ru_oublock %d ru_inblock %d }\n"</literal></expr></argument>, 
      <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>r</name><operator>.</operator><name>ru_maxrss</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsmtest_rusage_report</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* no-op */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct>struct <name>TestFunc</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bRusageReport</name></decl>;</decl_stmt>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aTest</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"random"</literal></expr>,      <expr><literal type="number">1</literal></expr>, <expr><name>do_random_tests</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"writespeed"</literal></expr>,  <expr><literal type="number">1</literal></expr>, <expr><name>do_writer_test</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"io"</literal></expr>,          <expr><literal type="number">1</literal></expr>, <expr><name>st_do_io</name></expr>}</block></expr>,

    <expr><block>{<expr><literal type="string">"insert"</literal></expr>,      <expr><literal type="number">1</literal></expr>, <expr><name>do_insert</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"replay"</literal></expr>,      <expr><literal type="number">1</literal></expr>, <expr><name>do_replay</name></expr>}</block></expr>,

    <expr><block>{<expr><literal type="string">"speed"</literal></expr>,       <expr><literal type="number">1</literal></expr>, <expr><name>do_speed_tests</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"speed2"</literal></expr>,      <expr><literal type="number">1</literal></expr>, <expr><name>do_speed_test2</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"show"</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><name>st_do_show</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"work"</literal></expr>,        <expr><literal type="number">1</literal></expr>, <expr><name>st_do_work</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"test"</literal></expr>,        <expr><literal type="number">1</literal></expr>, <expr><name>do_test</name></expr>}</block></expr>,

    <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFunc</name></decl>;</decl_stmt>                      <comment type="block">/* Index into aTest[] */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nLeakAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Allocations leaked by lsm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLeakByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Bytes leaked by lsm */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_MEM</name></cpp:ifdef>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pReport</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* lsm malloc() report file */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zReport</name> <init>= <expr><literal type="string">"malloc.txt generated"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zReport</name> <init>= <expr><literal type="string">"malloc.txt NOT generated"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>testMallocInstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Usage: %s sub-command ?args...?\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize error reporting */</comment>
  <expr_stmt><expr><call><name>testErrorInit</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize PRNG system */</comment>
  <expr_stmt><expr><call><name>testPrngInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>testArgSelect</name><argument_list>(<argument><expr><name>aTest</name></expr></argument>, <argument><expr><literal type="string">"sub-command"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>aTest</name><index>[<expr><name>iFunc</name></expr>]</index></name><operator>.</operator><call><name>xFunc</name><argument_list>(<argument><expr><name>argc</name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG_MEM</name></cpp:ifdef>
  <expr_stmt><expr><name>pReport</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"malloc.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testMallocCheck</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLeakAlloc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLeakByte</name></expr></argument>, <argument><expr><name>pReport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pReport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>testMallocCheck</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLeakAlloc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLeakByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>nLeakAlloc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testPrintError</name><argument_list>(<argument><expr><literal type="string">"Leaked %d bytes in %d allocations (%s)\n"</literal></expr></argument>, 
        <argument><expr><name>nLeakByte</name></expr></argument>, <argument><expr><name>nLeakAlloc</name></expr></argument>, <argument><expr><name>zReport</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>testMallocUninstall</name><argument_list>(<argument><expr><call><name>tdb_lsm_env</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>aTest</name><index>[<expr><name>iFunc</name></expr>]</index></name><operator>.</operator><name>bRusageReport</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmtest_rusage_report</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
