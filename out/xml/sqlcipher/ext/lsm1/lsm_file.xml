<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/lsm1/lsm_file.c"><comment type="block">/*
** 2011-08-26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** 
** NORMAL DATABASE FILE FORMAT
**
** The following database file format concepts are used by the code in
** this file to read and write the database file.
**
** Pages:
**
**   A database file is divided into pages. The first 8KB of the file consists
**   of two 4KB meta-pages. The meta-page size is not configurable. The 
**   remainder of the file is made up of database pages. The default database
**   page size is 4KB. Database pages are aligned to page-size boundaries,
**   so if the database page size is larger than 8KB there is a gap between
**   the end of the meta pages and the start of the database pages.
**
**   Database pages are numbered based on their position in the file. Page N
**   begins at byte offset ((N-1)*pgsz). This means that page 1 does not 
**   exist - since it would always overlap with the meta pages. If the 
**   page-size is (say) 512 bytes, then the first usable page in the database
**   is page 33.
**
**   It is assumed that the first two meta pages and the data that follows
**   them are located on different disk sectors. So that if a power failure 
**   while writing to a meta page there is no risk of damage to the other
**   meta page or any other part of the database file. TODO: This may need
**   to be revisited.
**
** Blocks:
**
**   The database file is also divided into blocks. The default block size is
**   1MB. When writing to the database file, an attempt is made to write data
**   in contiguous block-sized chunks.
**
**   The first and last page on each block are special in that they are 4 
**   bytes smaller than all other pages. This is because the last four bytes 
**   of space on the first and last pages of each block are reserved for
**   pointers to other blocks (i.e. a 32-bit block number).
**
** Runs:
**
**   A run is a sequence of pages that the upper layer uses to store a 
**   sorted array of database keys (and accompanying data - values, FC 
**   pointers and so on). Given a page within a run, it is possible to
**   navigate to the next page in the run as follows:
**
**     a) if the current page is not the last in a block, the next page 
**        in the run is located immediately after the current page, OR
**
**     b) if the current page is the last page in a block, the next page 
**        in the run is the first page on the block identified by the
**        block pointer stored in the last 4 bytes of the current block.
**
**   It is possible to navigate to the previous page in a similar fashion,
**   using the block pointer embedded in the last 4 bytes of the first page
**   of each block as required.
**
**   The upper layer is responsible for identifying by page number the 
**   first and last page of any run that it needs to navigate - there are
**   no "end-of-run" markers stored or identified by this layer. This is
**   necessary as clients reading different database snapshots may access 
**   different subsets of a run.
**
** THE LOG FILE 
**
** This file opens and closes the log file. But it does not contain any
** logic related to the log file format. Instead, it exports the following
** functions that are used by the code in lsm_log.c to read and write the
** log file:
**
**     lsmFsOpenLog
**     lsmFsWriteLog
**     lsmFsSyncLog
**     lsmFsReadLog
**     lsmFsTruncateLog
**     lsmFsCloseAndDeleteLog
**
** COMPRESSED DATABASE FILE FORMAT
**
** The compressed database file format is very similar to the normal format.
** The file still begins with two 4KB meta-pages (which are never compressed).
** It is still divided into blocks.
**
** The first and last four bytes of each block are reserved for 32-bit 
** pointer values. Similar to the way four bytes are carved from the end of 
** the first and last page of each block in uncompressed databases. From
** the point of view of the upper layer, all pages are the same size - this
** is different from the uncompressed format where the first and last pages
** on each block are 4 bytes smaller than the others.
**
** Pages are stored in variable length compressed form, as follows:
**
**     * 3-byte size field containing the size of the compressed page image
**       in bytes. The most significant bit of each byte of the size field
**       is always set. The remaining 7 bits are used to store a 21-bit
**       integer value (in big-endian order - the first byte in the field
**       contains the most significant 7 bits). Since the maximum allowed 
**       size of a compressed page image is (2^17 - 1) bytes, there are
**       actually 4 unused bits in the size field.
**
**       In other words, if the size of the compressed page image is nSz,
**       the header can be serialized as follows:
**
**         u8 aHdr[3]
**         aHdr[0] = 0x80 | (u8)(nSz &gt;&gt; 14);
**         aHdr[1] = 0x80 | (u8)(nSz &gt;&gt;  7);
**         aHdr[2] = 0x80 | (u8)(nSz &gt;&gt;  0);
**
**     * Compressed page image.
**
**     * A second copy of the 3-byte record header.
**
** A page number is a byte offset into the database file. So the smallest
** possible page number is 8192 (immediately after the two meta-pages).
** The first and root page of a segment are identified by a page number
** corresponding to the byte offset of the first byte in the corresponding
** page record. The last page of a segment is identified by the byte offset
** of the last byte in its record.
**
** Unlike uncompressed pages, compressed page records may span blocks.
**
** Sometimes, in order to avoid touching sectors that contain synced data
** when writing, it is necessary to insert unused space between compressed
** page records. This can be done as follows:
**
**     * For less than 6 bytes of empty space, the first and last byte
**       of the free space contain the total number of free bytes. For
**       example:
**
**         Block of 4 free bytes: 0x04 0x?? 0x?? 0x04
**         Block of 2 free bytes: 0x02 0x02
**         A single free byte:    0x01
**
**     * For 6 or more bytes of empty space, a record similar to a 
**       compressed page record is added to the segment. A padding record
**       is distinguished from a compressed page record by the most 
**       significant bit of the second byte of the size field, which is
**       cleared instead of set. 
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** File-system object. Each database connection allocates a single instance
** of the following structure. It is used for all access to the database and
** log files.
**
** The database file may be accessed via two methods - using mmap() or using
** read() and write() calls. In the general case both methods are used - a
** prefix of the file is mapped into memory and the remainder accessed using
** read() and write(). This is helpful when accessing very large files (or
** files that may grow very large during the lifetime of a database
** connection) on systems with 32-bit address spaces. However, it also requires
** that this object manage two distinct types of Page objects simultaneously -
** those that carry pointers to the mapped file and those that carry arrays
** populated by read() calls.
**
** pFree:
**   The head of a singly-linked list that containing currently unused Page 
**   structures suitable for use as mmap-page handles. Connected by the
**   Page.pFreeNext pointers.
**
** pMapped:
**   The head of a singly-linked list that contains all pages that currently
**   carry pointers to the mapped region. This is used if the region is
**   every remapped - the pointers carried by existing pages can be adjusted
**   to account for the remapping. Connected by the Page.pMappedNext pointers.
**
** pWaiting:
**   When the upper layer wishes to append a new b-tree page to a segment,
**   it allocates a Page object that carries a malloc'd block of memory -
**   regardless of the mmap-related configuration. The page is not assigned
**   a page number at first. When the upper layer has finished constructing
**   the page contents, it calls lsmFsPagePersist() to assign a page number
**   to it. At this point it is likely that N pages have been written to the
**   segment, the (N+1)th page is still outstanding and the b-tree page is
**   assigned page number (N+2). To avoid writing page (N+2) before page 
**   (N+1), the recently completed b-tree page is held in the singly linked
**   list headed by pWaiting until page (N+1) has been written. 
**
**   Function lsmFsFlushWaiting() is responsible for eventually writing 
**   waiting pages to disk.
**
** apHash/nHash:
**   Hash table used to store all Page objects that carry malloc'd arrays,
**   except those b-tree pages that have not yet been assigned page numbers.
**   Once they have been assigned page numbers - they are added to this
**   hash table.
**
**   Hash table overflow chains are connected using the Page.pHashNext
**   pointers.
**
** pLruFirst, pLruLast:
**   The first and last entries in a doubly-linked list of pages. This
**   list contains all pages with malloc'd data that are present in the
**   hash table and have a ref-count of zero.
*/</comment>
<struct>struct <name>FileSystem</name> <block>{
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database handle that owns this object */</comment>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl>;</decl_stmt>                  <comment type="block">/* Environment pointer */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                      <comment type="block">/* Database file name */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLog</name></decl>;</decl_stmt>                     <comment type="block">/* Database file name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMetasize</name></decl>;</decl_stmt>                  <comment type="block">/* Size of meta pages in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMetaRwSize</name></decl>;</decl_stmt>                <comment type="block">/* Read/written size of meta pages in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPagesize</name></decl>;</decl_stmt>                  <comment type="block">/* Database page-size in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlocksize</name></decl>;</decl_stmt>                 <comment type="block">/* Database block-size in bytes */</comment>

  <comment type="block">/* r/w file descriptors for both files. */</comment>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pLsmFile</name></decl>;</decl_stmt>              <comment type="block">/* Used after lsm_close() to link into list */</comment>
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>fdDb</name></decl>;</decl_stmt>                 <comment type="block">/* Database file */</comment>
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>fdLog</name></decl>;</decl_stmt>                <comment type="block">/* Log file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szSector</name></decl>;</decl_stmt>                   <comment type="block">/* Database file sector size */</comment>

  <comment type="block">/* If this is a compressed database, a pointer to the compression methods.
  ** For an uncompressed database, a NULL pointer.  */</comment>
  <decl_stmt><decl><type><name>lsm_compress</name> <modifier>*</modifier></type><name>pCompress</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aIBuffer</name></decl>;</decl_stmt>                   <comment type="block">/* Buffer to compress to */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOBuffer</name></decl>;</decl_stmt>                   <comment type="block">/* Buffer to uncompress from */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffer</name></decl>;</decl_stmt>                    <comment type="block">/* Allocated size of above buffers in bytes */</comment>

  <comment type="block">/* mmap() page related things */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMapLimit</name></decl>;</decl_stmt>                  <comment type="block">/* Maximum bytes of file to map */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>                     <comment type="block">/* Current mapping of database file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMap</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes mapped at pMap */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pFree</name></decl>;</decl_stmt>                    <comment type="block">/* Unused Page structures */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pMapped</name></decl>;</decl_stmt>                  <comment type="block">/* List of Page structs that point to pMap */</comment>

  <comment type="block">/* Page cache parameters for non-mmap() pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCacheMax</name></decl>;</decl_stmt>                  <comment type="block">/* Configured cache size (in pages) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCacheAlloc</name></decl>;</decl_stmt>                <comment type="block">/* Current cache size (in pages) */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLruFirst</name></decl>;</decl_stmt>                <comment type="block">/* Head of the LRU list */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLruLast</name></decl>;</decl_stmt>                 <comment type="block">/* Tail of the LRU list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHash</name></decl>;</decl_stmt>                      <comment type="block">/* Number of hash slots in hash table */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>apHash</name></decl>;</decl_stmt>                  <comment type="block">/* nHash Hash slots */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pWaiting</name></decl>;</decl_stmt>                 <comment type="block">/* b-tree pages waiting to be written */</comment>

  <comment type="block">/* Statistics */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name></decl>;</decl_stmt>                       <comment type="block">/* Number of outstanding pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name></decl>;</decl_stmt>                     <comment type="block">/* Total number of pages written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Total number of pages read */</comment>
}</block>;</struct>

<comment type="block">/*
** Database page handle.
**
** pSeg:
**   When lsmFsSortedAppend() is called on a compressed database, the new
**   page is not assigned a page number or location in the database file
**   immediately. Instead, these are assigned by the lsmFsPagePersist() call
**   right before it writes the compressed page image to disk.
**
**   The lsmFsSortedAppend() function sets the pSeg pointer to point to the
**   segment that the new page will be a part of. It is unset by
**   lsmFsPagePersist() after the page is written to disk.
*/</comment>
<struct>struct <name>Page</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Buffer containing page data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes of usable data at aData[] */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl>;</decl_stmt>                    <comment type="block">/* Page number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of outstanding references */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                      <comment type="block">/* Combination of PAGE_XXX flags */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pHashNext</name></decl>;</decl_stmt>                <comment type="block">/* Next page in hash table slot */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLruNext</name></decl>;</decl_stmt>                 <comment type="block">/* Next page in LRU list */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLruPrev</name></decl>;</decl_stmt>                 <comment type="block">/* Previous page in LRU list */</comment>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl>;</decl_stmt>                <comment type="block">/* File system that owns this page */</comment>

  <comment type="block">/* Only used in compressed database mode: */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCompress</name></decl>;</decl_stmt>                  <comment type="block">/* Compressed size (or 0 for uncomp. db) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCompressPrev</name></decl>;</decl_stmt>              <comment type="block">/* Compressed size of prev page */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl>;</decl_stmt>                  <comment type="block">/* Segment this page will be written to */</comment>

  <comment type="block">/* Pointers for singly linked lists */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pWaitingNext</name></decl>;</decl_stmt>             <comment type="block">/* Next page in FileSystem.pWaiting list */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pFreeNext</name></decl>;</decl_stmt>                <comment type="block">/* Next page in FileSystem.pFree list */</comment>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pMappedNext</name></decl>;</decl_stmt>              <comment type="block">/* Next page in FileSystem.pMapped list */</comment>
}</block>;</struct>

<comment type="block">/*
** Meta-data page handle. There are two meta-data pages at the start of
** the database file, each FileSystem.nMetasize bytes in size.
*/</comment>
<struct>struct <name>MetaPage</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iPg</name></decl>;</decl_stmt>                        <comment type="block">/* Either 1 or 2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bWrite</name></decl>;</decl_stmt>                     <comment type="block">/* Write back to db file on release */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                      <comment type="block">/* Pointer to buffer */</comment>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl>;</decl_stmt>                <comment type="block">/* FileSystem that owns this page */</comment>
}</block>;</struct>

<comment type="block">/* 
** Values for LsmPage.flags 
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_DIRTY</name></cpp:macro>   <cpp:value>0x00000001</cpp:value></cpp:define>   <comment type="block">/* Set if page is dirty */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_FREE</name></cpp:macro>    <cpp:value>0x00000002</cpp:value></cpp:define>   <comment type="block">/* Set if Page.aData requires lsmFree() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_HASPREV</name></cpp:macro> <cpp:value>0x00000004</cpp:value></cpp:define>   <comment type="block">/* Set if page is first on uncomp. block */</comment>

<comment type="block">/*
** Number of pgsz byte pages omitted from the start of block 1. The start
** of block 1 contains two 4096 byte meta pages (8192 bytes in total).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK1_HDR_SIZE</name><parameter_list>(<parameter><type><name>pgsz</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>LSM_MAX(1, 8192/(pgsz))</cpp:value></cpp:define>

<comment type="block">/*
** If NDEBUG is not defined, set a breakpoint in function lsmIoerrBkpt()
** to catch IO errors (any error returned by a VFS method). 
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsmIoerrBkpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>nErr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>IOERR_WRAPPER</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmIoerrBkpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>IOERR_WRAPPER</name><parameter_list>(<parameter><type><name>rc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(rc)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NDEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assert_lists_are_ok</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type><name>fsPageFindInHash</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piHash</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>assert_lists_are_ok</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  Page *p;

  assert( pFS-&gt;nMapLimit&gt;=0 );

  <comment type="block">/* Check that all pages in the LRU list have nRef==0, pointers to buffers
  ** in heap memory, and corresponding entries in the hash table.  */</comment>
  for(p=pFS-&gt;pLruFirst; p; p=p-&gt;pLruNext){
    assert( p==pFS-&gt;pLruFirst || p-&gt;pLruPrev!=0 );
    assert( p==pFS-&gt;pLruLast || p-&gt;pLruNext!=0 );
    assert( p-&gt;pLruPrev==0 || p-&gt;pLruPrev-&gt;pLruNext==p );
    assert( p-&gt;pLruNext==0 || p-&gt;pLruNext-&gt;pLruPrev==p );
    assert( p-&gt;nRef==0 );
    assert( p-&gt;flags &amp; PAGE_FREE );
    assert( p==fsPageFindInHash(pFS, p-&gt;iPg, 0) );
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Wrappers around the VFS methods of the lsm_env object:
**
**     lsmEnvOpen()
**     lsmEnvRead()
**     lsmEnvWrite()
**     lsmEnvSync()
**     lsmEnvSectorSize()
**     lsmEnvClose()
**     lsmEnvTruncate()
**     lsmEnvUnlink()
**     lsmEnvRemap()
*/</comment>
<function><type><name>int</name></type> <name>lsmEnvOpen</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>ppNew</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvRead</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_i64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pRead</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nRead</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pRead</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvWrite</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_i64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pWrite</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nWrite</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pWrite</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvSync</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvSectorSize</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmEnvClose</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvTruncate</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>lsm_i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvUnlink</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>IOERR_WRAPPER</name><argument_list>( <argument><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xUnlink</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>zDel</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lsmEnvRemap</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>szMin</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppMap</name></decl></parameter>,
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pszMap</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xRemap</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>szMin</name></expr></argument>, <argument><expr><name>ppMap</name></expr></argument>, <argument><expr><name>pszMap</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmEnvLock</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmEnvTestLock</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nLock</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xTestLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>nLock</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmEnvShmMap</name><parameter_list>(
  <parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, 
  <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iChunk</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iChunk</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmEnvShmBarrier</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmEnvShmUnmap</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bDel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>bDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmEnvSleep</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nUs</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>pEnv</name><operator>-&gt;</operator><name>xSleep</name></name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>nUs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Write the contents of string buffer pStr into the log file, starting at
** offset iOff.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsWriteLog</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** fsync() the log file.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSyncLog</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lsmEnvSync</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read nRead bytes of data starting at offset iOff of the log file. Append
** the results to string buffer pStr.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsReadLog</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRead</name></decl></parameter>, <parameter><decl><type><name>LsmString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmStringExtend</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pStr</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nRead</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate the log file to nByte bytes in size.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsTruncateLog</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lsmEnvTruncate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate the db file to nByte bytes in size.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsTruncateDb</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lsmEnvTruncate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the log file. Then delete it from the file-system. This function
** is called during database shutdown only.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsCloseAndDeleteLog</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDel</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zDel</name> <operator>=</operator> <call><name>lsmMallocPrintf</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><literal type="string">"%s-log"</literal></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDel</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmEnvUnlink</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if page iReal of the database should be accessed using mmap.
** False otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsMmapPage</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iReal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>iReal</name><operator>*</operator><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>&lt;=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given that there are currently nHash slots in the hash table, return 
** the hash key for file iFile, page iPg.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsHashKey</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nHash</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>iPg</name> <operator>%</operator> <name>nHash</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a helper function for lsmFsOpen(). It opens a single file on
** disk (either the database or log file).
*/</comment>
<function><type><specifier>static</specifier> <name>lsm_file</name> <modifier>*</modifier></type><name>fsOpenFile</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File system object */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReadonly</name></decl></parameter>,                  <comment type="block">/* True to open this file read-only */</comment>
  <parameter><decl><type><name>int</name></type> <name>bLog</name></decl></parameter>,                       <comment type="block">/* True for log, false for db */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bReadonly</name></expr> ?</condition><then> <expr><name>LSM_OPEN_READONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bLog</name></expr> ?</condition><then> <expr><name><name>pFS</name><operator>-&gt;</operator><name>zLog</name></name></expr> </then><else>: <expr><name><name>pFS</name><operator>-&gt;</operator><name>zDb</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>lsmEnvOpen</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pFile</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If it is not already open, this function opens the log file. It returns
** LSM_OK if successful (or if the log file was already open) or an LSM
** error code otherwise.
**
** The log file must be opened before any of the following may be called:
**
**     lsmFsWriteLog
**     lsmFsSyncLog
**     lsmFsReadLog
*/</comment>
<function><type><name>int</name></type> <name>lsmFsOpenLog</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbOpen</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr> )</condition><block>{<block_content> 
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name> <operator>=</operator> <call><name>fsOpenFile</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>bReadonly</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_IOERR_NOENT</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>bReadonly</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pbOpen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbOpen</name> <operator>=</operator> <operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the log file, if it is open.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsCloseLog</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Open a connection to a database stored within the file-system.
**
** If parameter bReadonly is true, then open a read-only file-descriptor
** on the database file. It is possible that bReadonly will be false even
** if the user requested that pDb be opened read-only. This is because the
** file-descriptor may later on be recycled by a read-write connection.
** If the db file can be opened for read-write access, it always is. Parameter
** bReadonly is only ever true if it has already been determined that the
** db can only be opened for read-only access.
**
** Return LSM_OK if successful or an lsm error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsOpen</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database connection to open fd for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Full path to database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReadonly</name></decl></parameter>                   <comment type="block">/* True to open db file read-only */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FileSystem</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nDb</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <name>nDb</name><operator>+</operator><literal type="number">4</literal><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFS</name> <operator>=</operator> <operator>(</operator><name>FileSystem</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pLsmFile</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pFS</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>zLog</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>zDb</name><index>[<expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>=</operator> <name>LSM_DFLT_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>=</operator> <name>LSM_DFLT_BLOCK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name> <operator>=</operator> <name>LSM_META_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetaRwSize</name></name> <operator>=</operator> <name>LSM_META_RW_PAGE_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr>;</expr_stmt>

    <comment type="block">/* Make a copy of the database and log file names. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>zLog</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>zLog</name><index>[<expr><name>nDb</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-log"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate the hash-table here. At some point, it should be changed
    ** so that it can grow dynamicly. */</comment>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheMax</name></name> <operator>=</operator> <literal type="number">2048</literal><operator>*</operator><literal type="number">1024</literal> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open the database file */</comment>
    <expr_stmt><expr><name>pLsmFile</name> <operator>=</operator> <call><name>lsmDbRecycleFd</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pLsmFile</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLsmFile</name></name> <operator>=</operator> <name>pLsmFile</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name> <operator>=</operator> <name><name>pLsmFile</name><operator>-&gt;</operator><name>pFile</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pLsmFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLsmFile</name></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LsmFile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name> <operator>=</operator> <call><name>fsOpenFile</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>bReadonly</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFsClose</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFS</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name> <operator>=</operator> <call><name>lsmEnvSectorSize</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name>pFS</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure the file-system object according to the current values of
** the LSM_CONFIG_MMAP and LSM_CONFIG_SET_COMPRESSION options.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsConfigure</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pWaiting</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset any compression/decompression buffers already allocated */</comment>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Unmap the file, if it is currently mapped */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmEnvRemap</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free all allocated page structures */</comment>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFreeNext</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Zero pointers that point to deleted page objects */</comment>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Configure the FileSystem object */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>xCompress</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>compress</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>iMmap</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Unlimited */</comment>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">60</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* iMmap is a limit in KB. Set nMapLimit to the same value in bytes. */</comment>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>iMmap</name></name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close and destroy a FileSystem object.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsClose</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pFS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFreeNext</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdLog</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLsmFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when closing a database handle (i.e. lsm_close()) 
** if there exist other connections to the same database within this process.
** In that case the file-descriptor open on the database file is not closed
** when the FileSystem object is destroyed, as this would cause any POSIX
** locks held by the other connections to be silently dropped (see "man close"
** for details). Instead, the file-descriptor is stored in a list by the
** lsm_shared.c module until it is either closed or reused.
**
** This function returns a pointer to an object that can be linked into
** the list described above. The returned object now 'owns' the database
** file descriptr, so that when the FileSystem object is destroyed, it
** will not be closed. 
**
** This function may be called at most once in the life-time of a 
** FileSystem object. The results of any operations involving the database 
** file descriptor are undefined once this function has been called.
**
** None of this is necessary on non-POSIX systems. But we do it anyway in
** the name of using as similar code as possible on all platforms.
*/</comment>
<function><type><name>LsmFile</name> <modifier>*</modifier></type><name>lsmFsDeferClose</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pLsmFile</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLsmFile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a buffer and populate it with the output of the xFileid() 
** method of the database file handle. If successful, set *ppId to point 
** to the buffer and *pnId to the number of bytes in the buffer and return
** LSM_OK. Otherwise, set *ppId and *pnId to zero and return an LSM
** error code.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsFileid</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppId</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pId</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xFileid</name></name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pId</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pEnv</name><operator>-&gt;</operator><name>xFileid</name></name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>pId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>pId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppId</name> <operator>=</operator> <name>pId</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnId</name> <operator>=</operator> <name>nId</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the nominal page-size used by this file-system. Actual pages
** may be smaller or larger than this value.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsPageSize</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the block-size used by this file-system.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsBlockSize</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure the nominal page-size used by this file-system. Actual 
** pages may be smaller or larger than this value.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsSetPageSize</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPgsz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>=</operator> <name>nPgsz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheMax</name></name> <operator>=</operator> <literal type="number">2048</literal><operator>*</operator><literal type="number">1024</literal> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Configure the block-size used by this file-system. 
*/</comment>
<function><type><name>void</name></type> <name>lsmFsSetBlockSize</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlocksize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>=</operator> <name>nBlocksize</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the page number of the first page on block iBlock. Blocks are
** numbered starting from 1.
**
** For a compressed database, page numbers are byte offsets. The first
** page on each block is the byte offset immediately following the 4-byte
** "previous block" pointer at the start of each block.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>fsFirstPageOnBlock</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iBlock</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>*</operator> <operator>(</operator><name>LsmPgno</name><operator>)</operator><operator>(</operator><name>iBlock</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iBlock</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPg</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iPg</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>iBlock</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>nPagePerBlock</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>iPg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the page number of the last page on block iBlock. Blocks are
** numbered starting from 1.
**
** For a compressed database, page numbers are byte offsets. The first
** page on each block is the byte offset of the byte immediately before 
** the 4-byte "next block" pointer at the end of each block.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>fsLastPageOnBlock</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>*</operator> <operator>(</operator><name>LsmPgno</name><operator>)</operator><name>iBlock</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>iBlock</name> <operator>*</operator> <name>nPagePerBlock</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the block number of the block that page iPg is located on. 
** Blocks are numbered starting from 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsPageToBlock</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iPg</name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>iPg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if page iPg is the last page on its block.
**
** This function is only called in non-compressed database mode.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsIsLast</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator> <name>iPg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iPg</name> <operator>%</operator> <name>nPagePerBlock</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if page iPg is the first page on its block.
**
** This function is only called in non-compressed database mode.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsIsFirst</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator> <operator>(</operator><name>iPg</name> <operator>%</operator> <name>nPagePerBlock</name><operator>)</operator><operator>==</operator><literal type="number">1</literal>
        <operator>||</operator> <operator>(</operator><name>iPg</name><operator>&lt;</operator><name>nPagePerBlock</name> <operator>&amp;&amp;</operator> <name>iPg</name><operator>==</operator><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a page reference, return a pointer to the buffer containing the 
** pages contents. If parameter pnData is not NULL, set *pnData to the size
** of the buffer in bytes before returning.
*/</comment>
<function><type><name>u8</name> <modifier>*</modifier></type><name>lsmFsPageData</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pnData</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the page number of a page.
*/</comment>
<function><type><name>LsmPgno</name></type> <name>lsmFsPageNumber</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* assert( (pPage-&gt;flags &amp; PAGE_DIRTY)==0 ); */</comment>
  <return>return <expr><ternary><condition><expr><name>pPage</name></expr> ?</condition><then> <expr><name><name>pPage</name><operator>-&gt;</operator><name>iPg</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Page pPg is currently part of the LRU list belonging to pFS. Remove
** it from the list. pPg-&gt;pLruNext and pPg-&gt;pLruPrev are cleared by this
** operation.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsPageRemoveFromLru</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>||</operator> <name>pPg</name><operator>==</operator><name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>||</operator> <name>pPg</name><operator>==</operator><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Page pPg is not currently part of the LRU list belonging to pFS. Add it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsPageAddToLru</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruPrev</name><operator>-&gt;</operator><name>pLruNext</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Page pPg is currently stored in the apHash/nHash hash table. Remove it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsPageRemoveFromHash</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pPg</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free a Page object allocated by fsPageBuffer().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsPageBufferFree</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Purge the cache of all non-mmap pages with nRef==0.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsPurgeCache</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pLruNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fsPageRemoveFromHash</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fsPageBufferFree</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>&lt;=</operator><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name> <operator>&amp;&amp;</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Search the hash-table for page iPg. If an entry is round, return a pointer
** to it. Otherwise, return NULL.
**
** Either way, if argument piHash is not NULL set *piHash to the hash slot
** number that page iPg would be stored in before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>Page</name> <modifier>*</modifier></type><name>fsPageFindInHash</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                        <comment type="block">/* Return value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>piHash</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piHash</name> <operator>=</operator> <name>iHash</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><name>iPg</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a non-mmap Page object. If there are already 
** nCacheMax such Page objects outstanding, try to recycle an existing 
** Page instead.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsPageBuffer</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>&lt;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nCacheMax</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Allocate a new Page object */</comment>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <call><name>lsmMallocZero</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPage</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_NOMEM_BKPT</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>lsmMalloc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_NOMEM_BKPT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Reuse an existing Page object */</comment>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pPage</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pLruFirst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fsPageRemoveFromLru</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fsPageRemoveFromHash</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <name>aData</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pPage</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PAGE_FREE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Assuming *pRc is initially LSM_OK, attempt to ensure that the 
** memory-mapped region is at least iSz bytes in size. If it is not already,
** iSz bytes in size, extend it and update the pointers associated with any
** outstanding Page objects.
**
** If *pRc is not LSM_OK when this function is called, it is a no-op. 
** Otherwise, *pRc is set to an lsm error code if an error occurs, or
** left unmodified otherwise.
**
** This function is never called in compressed database mode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsGrowMapping</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File system object */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iSz</name></decl></parameter>,                        <comment type="block">/* Minimum size to extend mapping to */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGE_HASPREV</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>iSz</name><operator>&gt;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMap</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOld</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRemap</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>!=</operator><name>aOld</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pFix</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name> <operator>-</operator> <name>aOld</name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pFix</name><operator>=</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name></expr>;</init> <condition><expr><name>pFix</name></expr>;</condition> <incr><expr><name>pFix</name><operator>=</operator><name><name>pFix</name><operator>-&gt;</operator><name>pMappedNext</name></name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pFix</name><operator>-&gt;</operator><name>aData</name></name> <operator>+=</operator> <name>iOff</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>lsmSortedRemap</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If it is mapped, unmap the database file.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsUnmap</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRemap</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** fsync() the database file.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSyncDb</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmEnvSync</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If block iBlk has been redirected according to the redirections in the
** object passed as the first argument, return the destination block to
** which it is redirected. Otherwise, return a copy of iBlk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsRedirectBlock</name><parameter_list>(<parameter><decl><type><name>Redirect</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTo</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlk</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iBlk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If page iPg has been redirected according to the redirections in the
** object passed as the second argument, return the destination page to
** which it is redirected. Otherwise, return a copy of iPg.
*/</comment>
<function><type><name>LsmPgno</name></type> <name>lsmFsRedirectPage</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Redirect</name> <modifier>*</modifier></type><name>pRedir</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iReal</name> <init>= <expr><name>iPg</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pRedir</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator>
        <ternary><condition><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> ?</condition><then> <expr><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></else></ternary>
    <operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pRedir</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iFrom</name> <init>= <expr><name><name>pRedir</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iFrom</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>&gt;</operator><name>iBlk</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>==</operator><name>iBlk</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iTo</name> <init>= <expr><name><name>pRedir</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iTo</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>iReal</name> <operator>=</operator> <name>iPg</name> <operator>-</operator> <operator>(</operator><name>LsmPgno</name><operator>)</operator><operator>(</operator><name>iFrom</name> <operator>-</operator> <name>iTo</name><operator>)</operator> <operator>*</operator> <name>nPagePerBlock</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iTo</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iReal</name> <operator>+=</operator> <operator>(</operator><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iReal</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iReal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Required by the circular fsBlockNext&lt;-&gt;fsPageGet dependency. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fsPageGet</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Parameter iBlock is a database file block. This function reads the value 
** stored in the blocks "next block" pointer and stores it in *piNext.
** LSM_OK is returned if everything is successful, or an LSM error code
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsBlockNext</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system object handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Use this segment for block redirects */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBlock</name></decl></parameter>,                     <comment type="block">/* Read field from this block */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piNext</name></decl></parameter>                     <comment type="block">/* OUT: Next block in linked list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRead</name></decl>;</decl_stmt>                      <comment type="block">/* Read block from here */</comment>
  
  <if_stmt><if>if<condition>( <expr><name>pSeg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRead</name> <operator>=</operator> <call><name>fsRedirectBlock</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr></argument>, <argument><expr><name>iBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iRead</name> <operator>=</operator> <name>iBlock</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>                     <comment type="block">/* File offset to read data from */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name><name>aNext</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 4-byte pointer read from db file */</comment>

    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name>iRead</name> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aNext</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aNext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aNext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>lsmGetU32</name><argument_list>(<argument><expr><name>aNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iRead</name><operator>*</operator><name>nPagePerBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLast</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <call><name>lsmGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLast</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSeg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <call><name>fsRedirectBlock</name><argument_list>(<argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr></argument>, <argument><expr><operator>*</operator><name>piNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the page number of the last page on the same block as page iPg.
*/</comment>
<function><type><name>LsmPgno</name></type> <name>fsLastPageOnPagesBlock</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read nData bytes of data from offset iOff of the database file into
** buffer aData. If this means reading past the end of a block, follow
** the block pointer to the next block and continue reading.
**
** Offset iOff is an absolute offset - not subject to any block redirection.
** However any block pointer followed is. Use pSeg-&gt;pRedirect in this case.
**
** This function is only called in compressed database mode.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsReadData</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Block redirection */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* Read data from this offset */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,                      <comment type="block">/* Buffer to read data into */</comment>
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>                       <comment type="block">/* Number of bytes to read */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iEob</name></decl>;</decl_stmt>                       <comment type="block">/* End of block */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iEob</name> <operator>=</operator> <call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>LSM_MIN</name><argument_list>(<argument><expr><name>iEob</name> <operator>-</operator> <name>iOff</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRead</name><operator>!=</operator><name>nData</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iOff2</name> <init>= <expr><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>nRead</name></expr>]</index></name></expr></argument>, <argument><expr><name>nData</name><operator>-</operator><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parameter iBlock is a database file block. This function reads the value 
** stored in the blocks "previous block" pointer and stores it in *piPrev.
** LSM_OK is returned if everything is successful, or an LSM error code
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsBlockPrev</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system object handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Use this segment for block redirects */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBlock</name></decl></parameter>,                     <comment type="block">/* Read field from this block */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPrev</name></decl></parameter>                     <comment type="block">/* OUT: Previous block in linked list */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlock</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlock</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name><name>aPrev</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* 4-byte pointer read from db file */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aPrev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aPrev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Redirect</name> <modifier>*</modifier></type><name>pRedir</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>pSeg</name></expr> ?</condition><then> <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>piPrev</name> <operator>=</operator> <call><name>fsRedirectBlock</name><argument_list>(<argument><expr><name>pRedir</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lsmGetU32</name><argument_list>(<argument><expr><name>aPrev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Encode and decode routines for record size fields.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>putRecordSize</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nByte</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>nByte</name> <operator>&gt;&gt;</operator>  <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>bFree</name></expr> ?</condition><then> <expr><literal type="number">0x00</literal></expr> </then><else>: <expr><literal type="number">0x80</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nByte</name> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getRecordSize</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbFree</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nByte</name>  <operator>=</operator> <operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pbFree</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>nByte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Subtract iSub from database file offset iOff and set *piRes to the
** result. If doing so means passing the start of a block, follow the
** block pointer stored in the first 4 bytes of the block.
**
** Offset iOff is an absolute offset - not subject to any block redirection.
** However any block pointer followed is. Use pSeg-&gt;pRedirect in this case.
**
** Return LSM_OK if successful or an lsm error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsSubtractOffset</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iSub</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piRes</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>-</operator><name>iSub</name><operator>)</operator><operator>&gt;=</operator><name>iStart</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piRes</name> <operator>=</operator> <operator>(</operator><name>iOff</name><operator>-</operator><name>iSub</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockPrev</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRes</name> <operator>=</operator> <call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>iSub</name> <operator>+</operator> <operator>(</operator><name>iOff</name> <operator>-</operator> <name>iStart</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add iAdd to database file offset iOff and set *piRes to the
** result. If doing so means passing the end of a block, follow the
** block pointer stored in the last 4 bytes of the block.
**
** Offset iOff is an absolute offset - not subject to any block redirection.
** However any block pointer followed is. Use pSeg-&gt;pRedirect in this case.
**
** Return LSM_OK if successful or an lsm error code if an error occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsAddOffset</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAdd</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piRes</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>iEob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iEob</name> <operator>=</operator> <call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>+</operator><name>iAdd</name><operator>)</operator><operator>&lt;=</operator><name>iEob</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piRes</name> <operator>=</operator> <operator>(</operator><name>iOff</name><operator>+</operator><name>iAdd</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRes</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>iAdd</name> <operator>-</operator> <operator>(</operator><name>iEob</name> <operator>-</operator> <name>iOff</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If it is not already allocated, allocate either the FileSystem.aOBuffer (if
** bWrite is true) or the FileSystem.aIBuffer (if bWrite is false). Return
** LSM_OK if successful if the attempt to allocate memory fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsAllocateBuffer</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>                        <comment type="block">/* Pointer to either aIBuffer or aOBuffer */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If neither buffer has been allocated, figure out how large they
  ** should be. Store this value in FileSystem.nBuffer.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <call><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name><operator>-&gt;</operator><name>xBound</name></name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name><operator>&lt;</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name><operator>+</operator><literal type="number">6</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name><operator>+</operator><literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bWrite</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <call><name>lsmMalloc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><call><name>LSM_MAX</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called in compressed database mode. It reads and
** uncompresses the compressed data for page pPg from the database and
** populates the pPg-&gt;aData[] buffer and pPg-&gt;nCompress field.
**
** It is possible that instead of a page record, there is free space
** at offset pPg-&gt;iPgno. In this case no data is read from the file, but
** output variable *pnSpace is set to the total number of free bytes.
**
** LSM_OK is returned if successful, or an LSM error code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsReadPagedata</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* pPg is part of this segment */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>,                      <comment type="block">/* Page to read and uncompress data for */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnSpace</name></decl></parameter>                    <comment type="block">/* OUT: Total bytes of free space */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_compress</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aSz</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>fsAllocateBuffer</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsReadData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bFree</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aSz</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>getRecordSize</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>aSz</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>bFree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bFree</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pnSpace</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pnSpace</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsAddOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name><operator>&gt;</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsReadData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xUncompress</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, 
              <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, 
              <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>aIBuffer</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>n</name><operator>!=</operator><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_CORRUPT_BKPT</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a handle for a database page.
**
** If this file-system object is accessing a compressed database it may be
** that there is no page record at database file offset iPg. Instead, there
** may be a free space record. In this case, set *ppPg to NULL and *pnSpace
** to the total number of free bytes before returning.
**
** If no error occurs, LSM_OK is returned. Otherwise, an lsm error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsPageGet</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Block redirection to use (or NULL) */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>,                    <comment type="block">/* Page id */</comment>
  <parameter><decl><type><name>int</name></type> <name>noContent</name></decl></parameter>,                  <comment type="block">/* True to not load content from disk */</comment>
  <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPg</name></decl></parameter>,                    <comment type="block">/* OUT: New page handle */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnSpace</name></decl></parameter>                    <comment type="block">/* OUT: Bytes of free space */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* In most cases iReal is the same as iPg. Except, if pSeg-&gt;pRedirect is 
  ** not NULL, and the block containing iPg has been redirected, then iReal
  ** is the page number after redirection.  */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iReal</name> <init>= <expr><call><name>lsmFsRedirectPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>pSeg</name></expr> ?</condition><then> <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert_lists_are_ok</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>&gt;=</operator><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iReal</name><operator>&gt;=</operator><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Search the hash-table for the page */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fsPageFindInHash</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iReal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fsPageRemoveFromLru</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>

    <if_stmt><if>if<condition>( <expr><call><name>fsMmapPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iReal</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iEnd</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><name>iReal</name> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fsGrowMapping</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFreeNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name>pFS</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator><index>[<expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>*</operator> <operator>(</operator><name>iReal</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <name>iReal</name></expr>;</expr_stmt>

      <comment type="block">/* This page now carries a pointer to the mapping. Link it in to
      ** the FileSystem.pMapped list.  */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pMappedNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pMappedNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageBuffer</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <name>iReal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name>pFS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><literal type="number">0x56</literal></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLruNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pLruPrev</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>noContent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsReadPagedata</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>iReal</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nRead</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the xRead() call was successful (or not attempted), link the
        ** page into the page-cache hash-table. Otherwise, if it failed,
        ** free the buffer. */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nSpace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>fsPageBufferFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pnSpace</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnSpace</name> <operator>=</operator> <name>nSpace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>||</operator> <operator>(</operator><name>pnSpace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pnSpace</name><operator>)</operator><operator>)</operator><operator>)</operator>
         <operator>||</operator> <operator>(</operator><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>p</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> 
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iReal</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fsIsFirst</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iReal</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fsIsFirst</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iReal</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_HASPREV</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name> <operator>+=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read the 64-bit checkpoint id of the checkpoint currently stored on meta
** page iMeta of the database file. If no error occurs, store the id value
** in *piVal and return LSM_OK. Otherwise, return an LSM error code and leave
** *piVal unmodified.
**
** If a checkpointer connection is currently updating meta-page iMeta, or an
** earlier checkpointer crashed while doing so, the value read into *piVal
** may be garbage. It is the callers responsibility to deal with this.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsReadSyncedId</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iMeta</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iMeta</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iMeta</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsGrowMapping</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iMeta</name><operator>*</operator><name>LSM_META_PAGE_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>lsmGetU64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator><index>[<expr><operator>(</operator><name>iMeta</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>LSM_META_PAGE_SIZE</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>MetaPage</name> <modifier>*</modifier></type><name>pMeta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsMetaPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iMeta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piVal</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>lsmGetU64</name><argument_list>(<argument><expr><name><name>pMeta</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsMetaPageRelease</name><argument_list>(<argument><expr><name>pMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return true if the first or last page of segment pRun falls between iFirst
** and iLast, inclusive, and pRun is not equal to pIgnore.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsRunEndsBetween</name><parameter_list>(
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pIgnore</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iLast</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>pRun</name><operator>!=</operator><name>pIgnore</name> <operator>&amp;&amp;</operator> <operator>(</operator>
        <operator>(</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name><operator>&gt;=</operator><name>iFirst</name> <operator>&amp;&amp;</operator> <name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name><operator>&lt;=</operator><name>iLast</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>pRun</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>&gt;=</operator><name>iFirst</name> <operator>&amp;&amp;</operator> <name><name>pRun</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>&lt;=</operator><name>iLast</name><operator>)</operator>
  <operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if level pLevel contains a segment other than pIgnore for
** which the first or last page is between iFirst and iLast, inclusive.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsLevelEndsBetween</name><parameter_list>(
  <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pIgnore</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iLast</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>fsRunEndsBetween</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>pIgnore</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>fsRunEndsBetween</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pIgnore</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Block iBlk is no longer in use by segment pIgnore. If it is not in use
** by any other segment, move it to the free block list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsFreeBlock</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File system object */</comment>
  <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>,            <comment type="block">/* Worker snapshot */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pIgnore</name></decl></parameter>,               <comment type="block">/* Ignore this run when searching */</comment>
  <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>                        <comment type="block">/* Block number of block to free */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl>;</decl_stmt>                 <comment type="block">/* First page on block iBlk */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLast</name></decl>;</decl_stmt>                  <comment type="block">/* Last page on block iBlk */</comment>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>                  <comment type="block">/* Used to iterate through levels */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                        <comment type="block">/* Used to iterate through append points */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Used to output append points */</comment>
  <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aApp</name> <init>= <expr><name><name>pSnapshot</name><operator>-&gt;</operator><name>aiAppend</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iLast</name> <operator>=</operator> <call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if any other run in the snapshot has a start or end page 
  ** within this block. If there is such a run, return early. */</comment>
  <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pSnapshot</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>fsLevelEndsBetween</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pIgnore</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>LSM_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Remove any entries that lie on this block from the append-list. */</comment>
  <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>LSM_APPLIST_SZ</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aApp</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>&lt;</operator><name>iFirst</name> <operator>||</operator> <name><name>aApp</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>&gt;</operator><name>iLast</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aApp</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>aApp</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <while>while<condition>( <expr><name>iOut</name><operator>&lt;</operator><name>LSM_APPLIST_SZ</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aApp</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete or otherwise recycle the blocks currently occupied by run pDel.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSortedDelete</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bZero</name></decl></parameter>,                      <comment type="block">/* True to zero the Segment structure */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pDel</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDel</name><operator>-&gt;</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLastBlk</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pDel</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLastBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pDel</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark all blocks currently used by this sorted run as free */</comment>
    <while>while<condition>( <expr><name>iBlk</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>!=</operator><name>iLastBlk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bZero</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDel</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>!=</operator><call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iLastBlk</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsFreeBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name><name>pDel</name><operator>-&gt;</operator><name>pRedirect</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDel</name><operator>-&gt;</operator><name>pRedirect</name></name><operator>==</operator><operator>&amp;</operator><name><name>pSnapshot</name><operator>-&gt;</operator><name>redirect</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSnapshot</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bZero</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** aPgno is an array containing nPgno page numbers. Return the smallest page
** number from the array that falls on block iBlk. Or, if none of the pages
** in aPgno[] fall on block iBlk, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>firstOnBlock</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aPgno</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nPgno</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPgno</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name> <init>= <expr><name><name>aPgno</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call><operator>==</operator><name>iBlk</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iRet</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iPg</name><operator>&lt;</operator><name>iRet</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return true if page iPg, which is a part of segment p, lies on
** a redirected block. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsPageRedirects</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>iPg</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iPg</name><operator>!=</operator><call><name>lsmFsRedirectPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRedirect</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if the second argument is not NULL and any of the first
** last or root pages lie on a redirected block. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsSegmentRedirects</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator>
      <call><name>fsPageRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>fsPageRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>fsPageRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call>
  <operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Argument aPgno is an array of nPgno page numbers. All pages belong to
** the segment pRun. This function gobbles from the start of the run to the
** first page that appears in aPgno[] (i.e. so that the aPgno[] entry is
** the new first page of the run).
*/</comment>
<function><type><name>void</name></type> <name>lsmFsGobble</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aPgno</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nPgno</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRun</name><operator>-&gt;</operator><name>nSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>fsSegmentRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPgno</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>fsPageRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name><name>aPgno</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRun</name><operator>-&gt;</operator><name>nSize</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>-</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iFirst</name> <init>= <expr><call><name>firstOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><name>aPgno</name></expr></argument>, <argument><expr><name>nPgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFirst</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>=</operator> <name>iFirst</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsFreeBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSnapshot</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pRun</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator>
        <literal type="number">1</literal> <operator>+</operator> <call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call>
    <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name><name>pRun</name><operator>-&gt;</operator><name>nSize</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>-</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pRun</name><operator>-&gt;</operator><name>nSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is only used in compressed database mode.
**
** Argument iPg is the page number (byte offset) of a page within segment
** pSeg. The page record, including all headers, is nByte bytes in size.
** Before returning, set *piNext to the page number of the next page in
** the segment, or to zero if iPg is the last.
**
** In other words, do:
**
**   *piNext = iPg + nByte;
**
** But take block overflow and redirection into account.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsNextPageOffset</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File system object */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment to move within */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>,                    <comment type="block">/* Offset of current page */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>,                      <comment type="block">/* Size of current page including headers */</comment>
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piNext</name></decl></parameter>                 <comment type="block">/* OUT: Offset of next page. Or zero (EOF) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsAddOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>nByte</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pSeg</name> <operator>&amp;&amp;</operator> <name>iNext</name><operator>==</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsAddOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iNext</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only used in compressed database mode.
**
** Argument iPg is the page number of a pagethat appears in segment pSeg.
** This function determines the page number of the previous page in the
** same run. *piPrev is set to the previous page number before returning.
**
** LSM_OK is returned if no error occurs. Otherwise, an lsm error code.
** If any value other than LSM_OK is returned, then the final value of
** *piPrev is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsGetPageBefore</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPrev</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>aSz</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRead</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsSubtractOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsReadData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iRead</name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bFree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSz</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>aSz</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nSz</name> <operator>=</operator> <call><name>getRecordSize</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bFree</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nSz</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>aSz</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>bFree</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsSubtractOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>nSz</name></expr></argument>, <argument><expr><name>piPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The first argument to this function is a valid reference to a database
** file page that is part of a sorted run. If parameter eDir is -1, this 
** function attempts to locate and load the previous page in the same run. 
** Or, if eDir is +1, it attempts to find the next page in the same run.
** The results of passing an eDir value other than positive or negative one
** are undefined.
**
** If parameter pRun is not NULL then it must point to the run that page
** pPg belongs to. In this case, if pPg is the first or last page of the
** run, and the request is for the previous or next page, respectively,
** *ppNext is set to NULL before returning LSM_OK. If pRun is NULL, then it
** is assumed that the next or previous page, as requested, exists.
**
** If the previous/next page does exist and is successfully loaded, *ppNext
** is set to point to it and LSM_OK is returned. Otherwise, if an error 
** occurs, *ppNext is set to NULL and and lsm error code returned.
**
** Page references returned by this function should be released by the 
** caller using lsmFsPageRelease().
*/</comment>
<function><type><name>int</name></type> <name>lsmFsDbPageNext</name><parameter_list>(<parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eDir</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppNext</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>fsSegmentRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>eDir</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsNextPageOffset</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>nSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>==</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsGetPageBefore</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>nSpace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppNext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>ppNext</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>nSpace</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>while<condition>( <expr><name>nSpace</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition>;</do>

  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Redirect</name> <modifier>*</modifier></type><name>pRedir</name> <init>= <expr><ternary><condition><expr><name>pRun</name></expr> ?</condition><then> <expr><name><name>pRun</name><operator>-&gt;</operator><name>pRedirect</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDir</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eDir</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eDir</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pRun</name> <operator>&amp;&amp;</operator> <name>iPg</name><operator>==</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>ppNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>LSM_OK</name></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>fsIsFirst</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iPg</name> <operator>=</operator> <call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><call><name>lsmGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iPg</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pRun</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>==</operator><name><name>pRun</name><operator>-&gt;</operator><name>iLastPg</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>ppNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><name>LSM_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><call><name>fsRedirectBlock</name><argument_list>(
            <argument><expr><name>pRedir</name></expr></argument>, <argument><expr><call><name>lsmGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>iPg</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iPg</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pRun</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppNext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called when creating a new segment to determine if the
** first part of it can be written following an existing segment on an
** already allocated block. If it is possible, the page number of the first
** page to use for the new segment is returned. Otherwise zero.
**
** If argument pLvl is not NULL, then this function will not attempt to
** start the new segment immediately following any segment that is part
** of the right-hand-side of pLvl.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>findAppendPoint</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aiAppend</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>aiAppend</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>LSM_APPLIST_SZ</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iRet</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iRet</name> <operator>=</operator> <name><name>aiAppend</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pLvl</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iRet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iRet</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iLastPg</name></expr></argument>)</argument_list></call><operator>==</operator><name>iBlk</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aiAppend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a page to the left-hand-side of pLvl. Set the ref-count to 1 and
** return a pointer to it. The page is writable until either 
** lsmFsPagePersist() is called on it or the ref-count drops to zero.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSortedAppend</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>,
  <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bDefer</name></decl></parameter>,
  <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iApp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPrev</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRedirect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name> <operator>||</operator> <name>bDefer</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* In compressed database mode the page is not assigned a page number
    ** or location in the database file at this point. This will be done
    ** by the lsmFsPagePersist() call.  */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageBuffer</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name>pFS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_DIRTY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iApp</name> <operator>=</operator> <call><name>findAppendPoint</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pLvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNext2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iApp</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iNext2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iApp</name> <operator>=</operator> <name>iPrev</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If this is the first page allocated, or if the page allocated is the
    ** last in the block, also allocate the next block here.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>iApp</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iNew</name></decl>;</decl_stmt>                     <comment type="block">/* New block number */</comment>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockAllocate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iApp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iApp</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iNext</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Grab the new page. */</comment>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iApp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>||</operator> <name>pPg</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this is the first or last page of a block, fill in the pointer 
     ** value at the end of the new page. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nSize</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name> <operator>=</operator> <name>iApp</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>=</operator> <name>iApp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_DIRTY</name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>fsIsFirst</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Mark the segment passed as the second argument as finished. Once a segment
** is marked as finished it is not possible to append any further pages to 
** it.
**
** Return LSM_OK if successful or an lsm error code if an error occurs.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSortedFinish</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRedirect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the last page of this run happens to be the last of a block.
    ** If it is, then an extra block has already been allocated for this run.
    ** Shift this extra block back to the free-block list. 
    **
    ** Otherwise, add the first free page in the last block used by the run
    ** to the lAppend list.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>aiAppend</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>aiAppend</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LSM_APPLIST_SZ</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>aiAppend</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>aiAppend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLast</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lsmGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLast</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lsmBlockRefree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pLast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmBlockRefree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a reference to page number iPg.
**
** Return LSM_OK if successful, or an lsm error code if an error occurs.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsDbPageGet</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a reference to the last page in the segment passed as the 
** second argument.
**
** Return LSM_OK if successful, or an lsm error code if an error occurs.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsDbPageLast</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iPg</name><operator>++</operator></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>nSpace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsGetPageBefore</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nSpace</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition>;</do>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ppPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a reference to meta-page iPg. If successful, LSM_OK is returned
** and *ppPg populated with the new page reference. The reference should
** be released by the caller using lsmFsPageRelease().
**
** Otherwise, if an error occurs, *ppPg is set to NULL and an LSM error 
** code is returned.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsMetaPageGet</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system connection */</comment>
  <parameter><decl><type><name>int</name></type> <name>bWrite</name></decl></parameter>,                     <comment type="block">/* True for write access, false for read */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>,                        <comment type="block">/* Either 1 or 2 */</comment>
  <parameter><decl><type><name>MetaPage</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPg</name></decl></parameter>                 <comment type="block">/* OUT: Pointer to MetaPage object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MetaPage</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPg</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>iPg</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Page</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><operator>(</operator><name>iPg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fsGrowMapping</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator> <operator>+</operator> <name>iOff</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <call><name>lsmMallocRc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bWrite</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(
            <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetaRwSize</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <comment type="block">/* pPg-&gt;aData causes an uninitialized access via a downstreadm write().
         After discussion on this list, this memory should not, for performance
         reasons, be memset. However, tracking down "real" misuse is more
         difficult with this "false" positive, so it is set when NDEBUG.
      */</comment>
      <if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><literal type="number">0x77</literal></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>bWrite</name></name> <operator>=</operator> <name>bWrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name> <operator>=</operator> <name>pFS</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppPg</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a meta-page reference obtained via a call to lsmFsMetaPageGet().
*/</comment>
<function><type><name>int</name></type> <name>lsmFsMetaPageRelease</name><parameter_list>(<parameter><decl><type><name>MetaPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>bWrite</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetasize</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>nMetaRwSize</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to a buffer containing the data associated with the
** meta-page passed as the first argument. If parameter pnData is not NULL,
** set *pnData to the size of the meta-page in bytes before returning.
*/</comment>
<function><type><name>u8</name> <modifier>*</modifier></type><name>lsmFsMetaPageData</name><parameter_list>(<parameter><decl><type><name>MetaPage</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pnData</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>nMetaRwSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if page is currently writable. This is used in assert() 
** statements only.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>int</name></type> <name>lsmFsPageWritable</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DIRTY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This is called when block iFrom is being redirected to iTo. If page 
** number (*piPg) lies on block iFrom, then calculate the equivalent
** page on block iTo and set *piPg to this value before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsMovePage</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File system object */</comment>
  <parameter><decl><type><name>int</name></type> <name>iTo</name></decl></parameter>,                        <comment type="block">/* Destination block */</comment>
  <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>,                      <comment type="block">/* Source block */</comment>
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piPg</name></decl></parameter>                   <comment type="block">/* IN/OUT: Page number */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPg</name> <init>= <expr><operator>*</operator><name>piPg</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFrom</name><operator>==</operator><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator>
        <ternary><condition><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> ?</condition><then> <expr><name><name>pFS</name> <operator>-&gt;</operator><name>nBlocksize</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></else></ternary>
    <operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>piPg</name> <operator>=</operator> <name>iPg</name> <operator>-</operator> <operator>(</operator><name>LsmPgno</name><operator>)</operator><operator>(</operator><name>iFrom</name> <operator>-</operator> <name>iTo</name><operator>)</operator> <operator>*</operator> <name>nPagePerBlock</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Copy the contents of block iFrom to block iTo. 
**
** It is safe to assume that there are no outstanding references to pages 
** on block iTo. And that block iFrom is not currently being written. In
** other words, the data can be read and written directly.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsMoveBlock</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMap</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>i64</name></type> <name>iFromOff</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>iFrom</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iToOff</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name>iTo</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTo</name><operator>!=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFrom</name><operator>&gt;</operator><name>iTo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Grow the mapping as required. */</comment>
  <expr_stmt><expr><name>nMap</name> <operator>=</operator> <call><name>LSM_MIN</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>iFrom</name> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fsGrowMapping</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>nMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nPagePerBlock</name> <init>= <expr><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name> <operator>/</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSz</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nPagePerBlock</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name> <init>= <expr><name>iFromOff</name> <operator>+</operator> <name>i</name><operator>*</operator><name>nSz</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Set aData to point to a buffer containing the from page */</comment>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>+</operator><name>nSz</name><operator>)</operator><operator>&lt;=</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aMap</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <operator>&amp;</operator><name><name>aMap</name><index>[<expr><name>iOff</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocRc</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nSz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <name>aBuf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvRead</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Copy aData to the to page */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name>iToOff</name> <operator>+</operator> <name>i</name><operator>*</operator><name>nSz</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOff</name><operator>+</operator><name>nSz</name><operator>)</operator><operator>&lt;=</operator><name><name>pFS</name><operator>-&gt;</operator><name>nMapLimit</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aMap</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aMap</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPurgeCache</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update append-point list if necessary */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LSM_APPLIST_SZ</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>fsMovePage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aiAppend</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Update the Segment structure itself */</comment>
  <expr_stmt><expr><call><name>fsMovePage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fsMovePage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fsMovePage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append raw data to a segment. Return the database file offset that the
** data is written to (this may be used as the page number if the data
** being appended is a new page record).
**
** This function is only used in compressed database mode.
*/</comment>
<function><type><specifier>static</specifier> <name>LsmPgno</name></type> <name>fsAppendData</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>,                <comment type="block">/* File-system handle */</comment>
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,                  <comment type="block">/* Segment to append to */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,                <comment type="block">/* Buffer containing data to write */</comment>
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,                      <comment type="block">/* Size of buffer aData[] in bytes */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>                        <comment type="block">/* IN/OUT: Error code */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLastOnBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iApp</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If this is the first data written into the segment, find an append-point
    ** or allocate a new block.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>iApp</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>=</operator> <name>iApp</name> <operator>=</operator> <call><name>findAppendPoint</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iApp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockAllocate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>=</operator> <name>iApp</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iApp</name></expr>;</expr_stmt>

    <comment type="block">/* Write as much data as is possible at iApp (usually all of it). */</comment>
    <expr_stmt><expr><name>iLastOnBlock</name> <operator>=</operator> <call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nSpace</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iLastOnBlock</name> <operator>-</operator> <name>iApp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>LSM_MIN</name><argument_list>(<argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>=</operator> <name>nData</name> <operator>-</operator> <name>nWrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nWrite</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iApp</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If required, allocate a new block and write the rest of the data
    ** into it. Set the next and previous block pointers to link the new
    ** block to the old.  */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRem</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iApp</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>iLastOnBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iApp</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><name>iLastOnBlock</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aPtr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                 <comment type="block">/* Space to serialize a u32 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>                   <comment type="block">/* New block number */</comment>

      <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Allocate a new block. */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockAllocate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set the "next" pointer on the old block */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iApp</name><operator>==</operator><operator>(</operator><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call><operator>*</operator><name><name>pFS</name><operator>-&gt;</operator><name>nBlocksize</name></name><operator>)</operator><operator>-</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><name>aPtr</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>, <argument><expr><name>aPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set the "prev" pointer on the new block */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iWrite</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><name>aPtr</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iWrite</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iWrite</name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>aPtr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iApp</name> <operator>=</operator> <name>iWrite</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* The next block is already allocated. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iRet</name> <operator>=</operator> <name>iApp</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Write the remaining data into the new block */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iApp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>nWrite</name></expr>]</index></name></expr></argument>, <argument><expr><name>nRem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iApp</name> <operator>+=</operator> <name>nRem</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name> <operator>=</operator> <name>iApp</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>iRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is only called in compressed database mode. It 
** compresses the contents of page pPg and writes the result to the 
** buffer at pFS-&gt;aOBuffer. The size of the compressed data is stored in
** pPg-&gt;nCompress.
**
** If buffer pFS-&gt;aOBuffer[] has not been allocated then this function
** allocates it. If this fails, LSM_NOMEM is returned. Otherwise, LSM_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsCompressIntoBuffer</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_compress</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>fsAllocateBuffer</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nBuffer</name></name></expr>;</expr_stmt>
  <return>return <expr><call><name><name>p</name><operator>-&gt;</operator><name>xCompress</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, 
      <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr></argument>, 
      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append a new page to segment pSeg. Set output variable *piNew to the
** page number of the new page before returning.
**
** If the new page is the last on its block, then the 'next' block that
** will be used by the segment is allocated here too. In this case output
** variable *piNext is set to the block number of the next block.
**
** If the new page is the first on its block but not the first in the
** entire segment, set output variable *piPrev to the block number of
** the previous block in the segment.
**
** LSM_OK is returned if successful, or an lsm error code otherwise. If
** any value other than LSM_OK is returned, then the final value of all
** output variables is undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsAppendPage</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>LsmPgno</name> <modifier>*</modifier></type><name>piNew</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPrev</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piNext</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iPrev</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPrev</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>piPrev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Grab the first page on the next block (which has already be
    ** allocated). In this case set *piPrev to tell the caller to set
    ** the "previous block" pointer in the first 4 bytes of the page.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>piNew</name> <operator>=</operator> <call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piPrev</name> <operator>=</operator> <name>iBlk</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piNew</name> <operator>=</operator> <name>iPrev</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fsIsLast</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>*</operator><name>piNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* Allocate the next block here. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBlockAllocate</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pDb</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>piNext</name> <operator>=</operator> <name>iBlk</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name> <operator>=</operator> <operator>*</operator><name>piNew</name></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Flush all pages in the FileSystem.pWaiting list to disk.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsFlushWaiting</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pWaiting</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pWaiting</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pWaitingNext</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsPagePersist</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If there exists a hash-table entry associated with page iPg, remove it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsRemoveHashEntry</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iPg</name></name><operator>!=</operator><name>iPg</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fsPageRemoveFromHash</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If the page passed as an argument is dirty, update the database file
** (or mapping of the database file) with its current contents and mark
** the page as clean.
**
** Return LSM_OK if the operation is a success, or an LSM error code
** otherwise.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsPagePersist</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_DIRTY</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>                  <comment type="block">/* Hash key of assigned page number */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aSz</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* pPg-&gt;nCompress as a 24-bit big-endian */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name> <operator>&amp;&amp;</operator> <name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Compress the page image. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsCompressIntoBuffer</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Serialize the compressed size into buffer aSz[] */</comment>
      <expr_stmt><expr><call><name>putRecordSize</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Write the serialized page record into the database file. */</comment>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name> <operator>=</operator> <call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now that it has a page number, insert the page into the hash table */</comment>
      <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGE_DIRTY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nWrite</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>

      <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* No page number has been assigned yet. This occurs with pages used
        ** in the b-tree hierarchy. They were not assigned page numbers when
        ** they were created as doing so would cause this call to
        ** lsmFsPagePersist() to write an out-of-order page. Instead a page 
        ** number is assigned here so that the page data will be appended
        ** to the current segment.
        */</comment>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name><operator>-</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsAppendPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pSeg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPrev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>fsHashKey</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nHash</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fsRemoveHashEntry</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pHashNext</name><operator>-&gt;</operator><name>iPg</name></name><operator>!=</operator><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>iPrev</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iNext</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PAGE_HASPREV</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iNext</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPrev</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPg</name><operator>-&gt;</operator><name>aData</name><index>[<expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmSortedExpandBtreePage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>pWaiting</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pWaitingNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pWaitingNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>                   <comment type="block">/* Offset to write within database file */</comment>

        <expr_stmt><expr><name>iOff</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name> <operator>*</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>fsMmapPage</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>-</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvWrite</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>fdDb</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fsGrowMapping</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iOff</name> <operator>+</operator> <name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aTo</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMap</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>iOff</name></expr>]</index></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFrom</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>-</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aTo</name></expr></argument>, <argument><expr><name>aFrom</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>nPagesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>aFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nCacheAlloc</name></name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <name>aTo</name> <operator>+</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGE_FREE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fsPageRemoveFromHash</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pMappedNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>lsmFsFlushWaiting</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGE_DIRTY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nWrite</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** For non-compressed databases, this function is a no-op. For compressed
** databases, it adds a padding record to the segment passed as the third
** argument.
**
** The size of the padding records is selected so that the last byte 
** written is the last byte of a disk sector. This means that if a 
** snapshot is taken and checkpointed, subsequent worker processes will
** not write to any sector that contains checkpointed data.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSortedPadding</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>,
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name> <operator>&amp;&amp;</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLast2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iLast</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Current last page of segment */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPad</name></decl>;</decl_stmt>                       <comment type="block">/* Bytes of padding required */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name><name>aSz</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iLast2</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>iLast</name><operator>/</operator><name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name><operator>)</operator> <operator>*</operator> <name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iLast2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPad</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>iLast2</name> <operator>-</operator> <name>iLast</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iLast2</name><operator>&gt;</operator><call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iLast</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nPad</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPad</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>nPad</name><operator>&gt;=</operator><literal type="number">6</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name> <operator>+=</operator> <name>nPad</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPad</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>putRecordSize</name><argument_list>(<argument><expr><name>aSz</name></expr></argument>, <argument><expr><name>nPad</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pFS</name><operator>-&gt;</operator><name>aOBuffer</name></name></expr></argument>, <argument><expr><name>nPad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>aSz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nPad</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aBuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nPad</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aBuf</name><index>[<expr><name>nPad</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>nPad</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fsAppendData</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nPad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_OK</name> 
        <operator>||</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>==</operator><call><name>fsLastPageOnPagesBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call>
        <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Increment the reference count on the page object passed as the first
** argument.
*/</comment>
<function><type><name>void</name></type> <name>lsmFsPageRef</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release a page-reference obtained using fsPageGet().
*/</comment>
<function><type><name>int</name></type> <name>lsmFsPageRelease</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsPagePersist</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>nOut</name></name><operator>--</operator></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name> 
           <operator>||</operator> <call><name>fsIsFirst</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> 
           <operator>||</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>aData</name></name> <operator>-=</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_HASPREV</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PAGE_HASPREV</name></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PAGE_FREE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Removed from mapped list */</comment>
        <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pFS</name><operator>-&gt;</operator><name>pMapped</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pPg</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pMappedNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
        <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pPg</name><operator>-&gt;</operator><name>pMappedNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pMappedNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Add to free list */</comment>
        <expr_stmt><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFreeNext</name></name> <operator>=</operator> <name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pFS</name><operator>-&gt;</operator><name>pFree</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>fsPageAddToLru</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the total number of pages read from the database file.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsNRead</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>nRead</name></name></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** Return the total number of pages written to the database file.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsNWrite</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>nWrite</name></name></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** Return a copy of the environment pointer used by the file-system object.
*/</comment>
<function><type><name>lsm_env</name> <modifier>*</modifier></type><name>lsmFsEnv</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content> 
  <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Return a copy of the environment pointer used by the file-system object
** to which this page belongs.
*/</comment>
<function><type><name>lsm_env</name> <modifier>*</modifier></type><name>lsmPageEnv</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list> <block>{<block_content> 
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>pEnv</name></name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the file-system object associated with the Page
** passed as the only argument.
*/</comment>
<function><type><name>FileSystem</name> <modifier>*</modifier></type><name>lsmPageFS</name><parameter_list>(<parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the sector-size as reported by the log file handle.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsSectorSize</name><parameter_list>(<parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pFS</name><operator>-&gt;</operator><name>szSector</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Helper function for lsmInfoArrayStructure().
*/</comment>
<function><type><specifier>static</specifier> <name>Segment</name> <modifier>*</modifier></type><name>startsWith</name><parameter_list>(<parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pRun</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>iFirst</name><operator>==</operator><name><name>pRun</name><operator>-&gt;</operator><name>iFirst</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>pRun</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the segment that starts with page iFirst, if any. If no such segment
** can be found, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>Segment</name> <modifier>*</modifier></type><name>findSegment</name><parameter_list>(<parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>                    <comment type="block">/* Used to iterate through db levels */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Pointer to segment to return */</comment>

  <for>for<control>(<init><expr><name>pLvl</name><operator>=</operator><call><name>lsmDbSnapshotLevel</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pLvl</name> <operator>&amp;&amp;</operator> <name>pSeg</name><operator>==</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>pLvl</name><operator>=</operator><name><name>pLvl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>(</operator><name>pSeg</name> <operator>=</operator> <call><name>startsWith</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pSeg</name> <operator>=</operator> <call><name>startsWith</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLvl</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pSeg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function implements the lsm_info(LSM_INFO_ARRAY_STRUCTURE) request.
** If successful, *pzOut is set to point to a nul-terminated string 
** containing the array structure and LSM_OK is returned. The caller should
** eventually free the string using lsmFree().
**
** If an error occurs, *pzOut is set to NULL and an LSM error code returned.
*/</comment>
<function><type><name>int</name></type> <name>lsmInfoArrayStructure</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bBlock</name></decl></parameter>,                     <comment type="block">/* True for block numbers only */</comment>
  <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>              <comment type="block">/* Worker snapshot */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pArray</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Array to report on */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Obtain the worker snapshot */</comment>
  <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pWorker</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bUnlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Search for the array that starts on page iFirst */</comment>
  <expr_stmt><expr><name>pArray</name> <operator>=</operator> <call><name>findSegment</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pArray</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Could not find the requested array. This is an error. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLastBlk</name></decl>;</decl_stmt>
   
    <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLastBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bBlock</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iBlk</name><operator>!=</operator><name>iLastBlk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iBlk</name><operator>!=</operator><name>iLastBlk</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>pArray</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bUnlock</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rcwork</name> <init>= <expr><name>LSM_BUSY</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rcwork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmFsSegmentContainsPg</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, 
  <parameter><decl><type><name>LsmPgno</name></type> <name>iPg</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbRes</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Redirect</name> <modifier>*</modifier></type><name>pRedir</name> <init>= <expr><name><name>pSeg</name><operator>-&gt;</operator><name>pRedirect</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastBlk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPgBlock</name></decl>;</decl_stmt>                   <comment type="block">/* Block containing page iPg */</comment>

  <expr_stmt><expr><name>iPgBlock</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <call><name>fsRedirectBlock</name><argument_list>(<argument><expr><name>pRedir</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iLastBlk</name> <operator>=</operator> <call><name>fsRedirectBlock</name><argument_list>(<argument><expr><name>pRedir</name></expr></argument>, <argument><expr><call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>iBlk</name><operator>!=</operator><name>iLastBlk</name> <operator>&amp;&amp;</operator> <name>iBlk</name><operator>!=</operator><name>iPgBlock</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>pbRes</name> <operator>=</operator> <operator>(</operator><name>iBlk</name><operator>==</operator><name>iPgBlock</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function implements the lsm_info(LSM_INFO_ARRAY_PAGES) request.
** If successful, *pzOut is set to point to a nul-terminated string 
** containing the array structure and LSM_OK is returned. The caller should
** eventually free the string using lsmFree().
**
** If an error occurs, *pzOut is set to NULL and an LSM error code returned.
*/</comment>
<function><type><name>int</name></type> <name>lsmInfoArrayPages</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>LsmPgno</name></type> <name>iFirst</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name></decl>;</decl_stmt>              <comment type="block">/* Worker snapshot */</comment>
  <decl_stmt><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Array to report on */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bUnlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iFirst</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Obtain the worker snapshot */</comment>
  <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pWorker</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pWorker</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bUnlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Search for the array that starts on page iFirst */</comment>
  <expr_stmt><expr><name>pSeg</name> <operator>=</operator> <call><name>findSegment</name><argument_list>(<argument><expr><name>pWorker</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSeg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Could not find the requested array. This is an error. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LsmString</name></type> <name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lsmStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageGet</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Page</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lsmStringAppendf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %lld"</literal></expr></argument>, <argument><expr><call><name>lsmFsPageNumber</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsDbPageNext</name><argument_list>(<argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmFsPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPg</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>bUnlock</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rcwork</name> <init>= <expr><name>LSM_BUSY</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lsmFinishWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rcwork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following macros are used by the integrity-check code. Associated with
** each block in the database is an 8-bit bit mask (the entry in the aUsed[]
** array). As the integrity-check meanders through the database, it sets the
** following bits to indicate how each block is used.
**
** INTEGRITY_CHECK_FIRST_PG:
**   First page of block is in use by sorted run.
**
** INTEGRITY_CHECK_LAST_PG:
**   Last page of block is in use by sorted run.
**
** INTEGRITY_CHECK_USED:
**   At least one page of the block is in use by a sorted run.
**
** INTEGRITY_CHECK_FREE:
**   The free block list contains an entry corresponding to this block.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGRITY_CHECK_FIRST_PG</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGRITY_CHECK_LAST_PG</name></cpp:macro>  <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGRITY_CHECK_USED</name></cpp:macro>     <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGRITY_CHECK_FREE</name></cpp:macro>     <cpp:value>0x08</cpp:value></cpp:define>

<comment type="block">/*
** Helper function for lsmFsIntegrityCheck()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkBlocks</name><parameter_list>(
  <parameter><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name></decl></parameter>, 
  <parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bExtra</name></decl></parameter>,                     <comment type="block">/* If true, count the "next" block if any */</comment>
  <parameter><decl><type><name>int</name></type> <name>nUsed</name></decl></parameter>,
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aUsed</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pSeg</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pSeg</name> <operator>&amp;&amp;</operator> <name><name>pSeg</name><operator>-&gt;</operator><name>nSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name></decl>;</decl_stmt>                   <comment type="block">/* Current block (during iteration) */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iLastBlk</name></decl>;</decl_stmt>               <comment type="block">/* Last block of segment */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iFirstBlk</name></decl>;</decl_stmt>              <comment type="block">/* First block of segment */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>bLastIsLastOnBlock</name></decl>;</decl_stmt>     <comment type="block">/* True iLast is the last on its block */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>fsSegmentRedirects</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <name>iFirstBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLastBlk</name> <operator>=</operator> <call><name>fsPageToBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>bLastIsLastOnBlock</name> <operator>=</operator> <operator>(</operator><call><name>fsLastPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iLastBlk</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlk</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <do>do <block>{<block_content>
        <comment type="block">/* iBlk is a part of this sorted run. */</comment>
        <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_USED</name></expr>;</expr_stmt>

        <comment type="block">/* If the first page of this block is also part of the segment,
        ** set the flag to indicate that the first page of iBlk is in use.  
        */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>fsFirstPageOnBlock</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call><operator>==</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iFirst</name></name> <operator>||</operator> <name>iBlk</name><operator>!=</operator><name>iFirstBlk</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>INTEGRITY_CHECK_FIRST_PG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_FIRST_PG</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Unless the sorted run finishes before the last page on this block, 
        ** the last page of this block is also in use.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>!=</operator><name>iLastBlk</name> <operator>||</operator> <name>bLastIsLastOnBlock</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>INTEGRITY_CHECK_LAST_PG</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_LAST_PG</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Special case. The sorted run being scanned is the output run of
        ** a level currently undergoing an incremental merge. The sorted
        ** run ends on the last page of iBlk, but the next block has already
        ** been allocated. So mark it as in use as well.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>==</operator><name>iLastBlk</name> <operator>&amp;&amp;</operator> <name>bLastIsLastOnBlock</name> <operator>&amp;&amp;</operator> <name>bExtra</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iExtra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aUsed</name><index>[<expr><name>iExtra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iExtra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_USED</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iExtra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_FIRST_PG</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iExtra</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>INTEGRITY_CHECK_LAST_PG</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Move on to the next block in the sorted run. Or set iBlk to zero
        ** in order to break out of the loop if this was the last block in
        ** the run.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>==</operator><name>iLastBlk</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iBlk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsBlockNext</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block>while<condition>( <expr><name>iBlk</name></expr> )</condition>;</do>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>CheckFreelistCtx</name></name></type> <name>CheckFreelistCtx</name>;</typedef>
<struct>struct <name>CheckFreelistCtx</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkFreelistCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CheckFreelistCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>CheckFreelistCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlk</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlk</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aUsed</name><index>[<expr><name>iBlk</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>INTEGRITY_CHECK_FREE</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function checks that all blocks in the database file are accounted
** for. For each block, exactly one of the following must be true:
**
**   + the block is part of a sorted run, or
**   + the block is on the free-block list
**
** This function also checks that there are no references to blocks with
** out-of-range block numbers.
**
** If no errors are found, non-zero is returned. If an error is found, an
** assert() fails.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsIntegrityCheck</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CheckFreelistCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FileSystem</name> <modifier>*</modifier></type><name>pFS</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Freelist</name></type> <name>freelist</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pWorker</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name> <init>= <expr><name><name>pWorker</name><operator>-&gt;</operator><name>nBlock</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 
  static int nCall = 0;
  nCall++;
  printf("%d calls\n", nCall);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>aUsed</name> <operator>=</operator> <call><name>lsmMallocZero</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aUsed</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Malloc has failed. Since this function is only called within debug
    ** builds, this probably means the user is running an OOM injection test.
    ** Regardless, it will not be possible to run the integrity-check at this
    ** time, so assume the database is Ok and return non-zero. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>pLevel</name><operator>=</operator><name><name>pWorker</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</init> <condition><expr><name>pLevel</name></expr>;</condition> <incr><expr><name>pLevel</name><operator>=</operator><name><name>pLevel</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checkBlocks</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>, <argument><expr><name>aUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>nRight</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>checkBlocks</name><argument_list>(<argument><expr><name>pFS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLevel</name><operator>-&gt;</operator><name>aRhs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>, <argument><expr><name>aUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/* Mark all blocks in the free-list as used */</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>aUsed</name></name> <operator>=</operator> <name>aUsed</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nBlock</name></name> <operator>=</operator> <name>nBlock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>checkFreelistCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlock</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aUsed</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>aUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>freelist</name><operator>.</operator><name>aEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return true if pPg happens to be the last page in segment pSeg. Or false
** otherwise. This function is only invoked as part of assert() conditions.
*/</comment>
<function><type><name>int</name></type> <name>lsmFsDbPageIsLast</name><parameter_list>(<parameter><decl><type><name>Segment</name> <modifier>*</modifier></type><name>pSeg</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name><operator>-&gt;</operator><name>pCompress</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmPgno</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsNextPageOffset</name><argument_list>(<argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>pSeg</name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name></expr></argument>, <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>nCompress</name></name><operator>+</operator><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rc</name><operator>!=</operator><name>LSM_OK</name> <operator>||</operator> <name>iNext</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>iPg</name></name><operator>==</operator><name><name>pSeg</name><operator>-&gt;</operator><name>iLastPg</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
