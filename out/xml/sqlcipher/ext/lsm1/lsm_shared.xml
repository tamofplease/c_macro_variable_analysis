<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/lsm1/lsm_shared.c"><comment type="block">/*
** 2012-01-23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** Utilities used to help multiple LSM clients to coexist within the
** same process space.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lsmInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Global data. All global variables used by code in this file are grouped
** into the following structure instance.
**
** pDatabase:
**   Linked list of all Database objects allocated within this process.
**   This list may not be traversed without holding the global mutex (see
**   functions enterGlobalMutex() and leaveGlobalMutex()).
*/</comment>
<struct><specifier>static</specifier> struct <name>SharedData</name> <block>{
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>pDatabase</name></decl>;</decl_stmt>            <comment type="block">/* Linked list of all Database objects */</comment>
}</block> <decl><name>gShared</name></decl>;</struct>

<comment type="block">/*
** Database structure. There is one such structure for each distinct 
** database accessed by this process. They are stored in the singly linked 
** list starting at global variable gShared.pDatabase. Database objects are 
** reference counted. Once the number of connections to the associated
** database drops to zero, they are removed from the linked list and deleted.
**
** pFile:
**   In multi-process mode, this file descriptor is used to obtain locks 
**   and to access shared-memory. In single process mode, its only job is
**   to hold the exclusive lock on the file.
**   
*/</comment>
<struct>struct <name>Database</name> <block>{
  <comment type="block">/* Protected by the global mutex (enterGlobalMutex/leaveGlobalMutex): */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Canonical path to database file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                      <comment type="block">/* strlen(zName) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDbRef</name></decl>;</decl_stmt>                     <comment type="block">/* Number of associated lsm_db handles */</comment>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>pDbNext</name></decl>;</decl_stmt>              <comment type="block">/* Next Database structure in global list */</comment>

  <comment type="block">/* Protected by the local mutex (pClientMutex) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bReadonly</name></decl>;</decl_stmt>                  <comment type="block">/* True if Database.pFile is read-only */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bMultiProc</name></decl>;</decl_stmt>                 <comment type="block">/* True if running in multi-process mode */</comment>
  <decl_stmt><decl><type><name>lsm_file</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>                <comment type="block">/* Used for locks/shm in multi-proc mode */</comment>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pLsmFile</name></decl>;</decl_stmt>              <comment type="block">/* List of deferred closes */</comment>
  <decl_stmt><decl><type><name>lsm_mutex</name> <modifier>*</modifier></type><name>pClientMutex</name></decl>;</decl_stmt>        <comment type="block">/* Protects the apShmChunk[] and pConn */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nShmChunk</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in apShmChunk[] array */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>apShmChunk</name></decl>;</decl_stmt>              <comment type="block">/* Array of "shared" memory regions */</comment>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pConn</name></decl>;</decl_stmt>                  <comment type="block">/* List of connections to this db. */</comment>
}</block>;</struct>

<comment type="block">/*
** Functions to enter and leave the global mutex. This mutex is used
** to protect the global linked-list headed at gShared.pDatabase.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>enterGlobalMutex</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_mutex</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lsmMutexStatic</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>LSM_MUTEX_GLOBAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>leaveGlobalMutex</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_mutex</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmMutexStatic</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>LSM_MUTEX_GLOBAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>holdingGlobalMutex</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_mutex</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmMutexStatic</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>LSM_MUTEX_GLOBAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lsmMutexHeld</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void assertNotInFreelist(Freelist *p, int iBlk){
  int i; 
  for(i=0; i&lt;p-&gt;nEntry; i++){
    assert( p-&gt;aEntry[i].iBlk!=iBlk );
  }
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>assertNotInFreelist</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Append an entry to the free-list. If (iId==-1), this is a delete.
*/</comment>
<function><type><name>int</name></type> <name>freelistAppend</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Freelist</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> 

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iId</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>iId</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name><name>db</name><operator>-&gt;</operator><name>bUseFreelist</name></name></expr> ?</condition><then> <expr><name><name>db</name><operator>-&gt;</operator><name>pFreelist</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name></name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Extend the space allocated for the freelist, if required */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>FreelistEntry</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nNew</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FreelistEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><name>FreelistEntry</name> <operator>*</operator><operator>)</operator><call><name>lsmRealloc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aNew</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iBlk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>&gt;=</operator><name>iBlk</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name><operator>==</operator><name>iBlk</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Clobber an existing entry */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iId</name> <operator>=</operator> <name>iId</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Insert a new entry into the list */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreelistEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>-</operator><name>i</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBlk</name> <operator>=</operator> <name>iBlk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iId</name> <operator>=</operator> <name>iId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function frees all resources held by the Database structure passed
** as the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeDatabase</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>holdingGlobalMutex</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Free the mutexes */</comment>
    <expr_stmt><expr><call><name>lsmMutexDel</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free the array of shm pointers */</comment>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Free the memory allocated for the Database struct itself */</comment>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>DbTruncateCtx</name></name></type> <name>DbTruncateCtx</name>;</typedef>
<struct>struct <name>DbTruncateCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iInUse</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dbTruncateCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbTruncateCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DbTruncateCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBlk</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>nBlock</name></name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iInUse</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iSnapshot</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>iInUse</name></name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nBlock</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dbTruncate</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iInUse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  int i;
  DbTruncateCtx ctx;

  assert( pDb-&gt;pWorker );
  ctx.nBlock = pDb-&gt;pWorker-&gt;nBlock;
  ctx.iInUse = iInUse;

  rc = lsmWalkFreelist(pDb, 1, dbTruncateCb, (void *)&amp;ctx);
  for(i=ctx.nBlock+1; rc==LSM_OK &amp;&amp; i&lt;=pDb-&gt;pWorker-&gt;nBlock; i++){
    rc = freelistAppend(pDb, i, -1);
  }

  if( rc==LSM_OK ){
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
    if( ctx.nBlock!=pDb-&gt;pWorker-&gt;nBlock ){
      lsmLogMessage(pDb, 0, 
          "dbTruncate(): truncated db to %d blocks",ctx.nBlock
      );
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    pDb-&gt;pWorker-&gt;nBlock = ctx.nBlock;
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is called during database shutdown (when the number of
** connections drops from one to zero). It truncates the database file
** to as small a size as possible without truncating away any blocks that
** contain data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbTruncateFile</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmShmAssertLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoadWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DbTruncateCtx</name></type> <name>ctx</name></decl>;</decl_stmt>

    <comment type="block">/* Walk the database free-block-list in reverse order. Set ctx.nBlock
    ** to the block number of the last block in the database that actually
    ** contains data. */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nBlock</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>nBlock</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>iInUse</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dbTruncateCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the last block that contains data is not already the last block in
    ** the database file, truncate the database file so that it is. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsTruncateDb</name><argument_list>(
          <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name><name>ctx</name><operator>.</operator><name>nBlock</name></name><operator>*</operator><call><name>lsmFsBlockSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doDbDisconnect</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS3</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Block for an exclusive lock on DMS1. This lock serializes all calls
    ** to doDbConnect() and doDbDisconnect() across all processes.  */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>

      <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Try an exclusive lock on DMS2. If successful, this is the last
      ** connection to the database. In this case flush the contents of the
      ** in-memory tree to disk and write a checkpoint.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_CHECKPOINTER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bReadonly</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* True if there exist read-only conns. */</comment>

        <comment type="block">/* Flush the in-memory tree, if required. If there is data to flush,
        ** this will create a new client snapshot in Database.pClient. The
        ** checkpoint (serialization) of this snapshot may be written to disk
        ** by the following block.  
        **
        ** There is no need to take a WRITER lock here. That there are no 
        ** other locks on DMS2 guarantees that there are no other read-write
        ** connections at this time (and the lock on DMS1 guarantees that
        ** no new ones may appear).
        */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeLoadHeader</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>lsmTreeHasOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>lsmTreeSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFlushTreeToDisk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Now check if there are any read-only connections. If there are,
        ** then do not truncate the db file or unlink the shared-memory 
        ** region.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bReadonly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Write a checkpoint to disk. */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointWrite</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the checkpoint was written successfully, delete the log file
        ** and, if possible, truncate the database file.  */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>bRotrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>

          <comment type="block">/* The log file may only be deleted if there are no clients 
          ** read-only clients running rotrans transactions.  */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmDetectRoTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bRotrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bRotrans</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>lsmFsCloseAndDeleteLog</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* The database may only be truncated if there exist no read-only
          ** clients - either connected or running rotrans transactions. */</comment>
          <if_stmt><if>if<condition>( <expr><name>bReadonly</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bRotrans</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>lsmFsUnmap</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dbTruncateFile</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>lsmEnvShmUnmap</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iRwclient</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>iRwclient</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iRwclient</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>doDbConnect</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nUsMax</name> <init>= <expr><literal type="number">100000</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Max value for nUs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nUs</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* us to wait between DMS1 attempts */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Obtain a pointer to the shared-memory header */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Block for an exclusive lock on DMS1. This lock serializes all calls
  ** to doDbConnect() and doDbDisconnect() across all processes.  */</comment>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lsmEnvSleep</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>nUs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nUs</name> <operator>=</operator> <name>nUs</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nUs</name><operator>&gt;</operator><name>nUsMax</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nUs</name> <operator>=</operator> <name>nUsMax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <operator>(</operator><name>ShmHeader</name> <operator>*</operator><operator>)</operator><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Try an exclusive lock on DMS2/DMS3. If successful, this is the first 
  ** and only connection to the database. In this case initialize the 
  ** shared-memory and run log file recovery.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>LSM_LOCK_DMS3</name><operator>==</operator><literal type="number">1</literal><operator>+</operator><name>LSM_LOCK_DMS2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointRecover</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmLogRecover</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iLsmId</name> <operator>=</operator> <call><name>lsmCheckpointId</name><argument_list>(<argument><expr><name><name>pShm</name><operator>-&gt;</operator><name>aSnap1</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iTreeId</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Take a shared lock on DMS2. In multi-process mode this lock "cannot" 
  ** fail, as connections may only hold an exclusive lock on DMS2 if they 
  ** first hold an exclusive lock on DMS1. And this connection is currently 
  ** holding the exclusive lock on DSM1. 
  **
  ** However, if some other connection has the database open in single-process
  ** mode, this operation will fail. In this case, return the error to the
  ** caller - the attempt to connect to the db has failed.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If anything went wrong, unlock DMS2. Otherwise, try to take an exclusive
  ** lock on one of the LSM_LOCK_RWCLIENT() locks. Unlock DMS1 in any case. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LSM_LOCK_NRWCLIENT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>iRwclient</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dbOpenSharedFd</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bRoOk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvOpen</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_IOERR</name> <operator>&amp;&amp;</operator> <name>bRoOk</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvOpen</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>LSM_OPEN_READONLY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bReadonly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a reference to the shared Database handle for the database 
** identified by canonical path zName. If this is the first connection to
** the named database, a new Database object is allocated. Otherwise, a
** pointer to an existing object is returned.
**
** If successful, *ppDatabase is set to point to the shared Database 
** structure and LSM_OK returned. Otherwise, *ppDatabase is set to NULL
** and and LSM error code returned.
**
** Each successful call to this function should be (eventually) matched
** by a call to lsmDbDatabaseRelease().
*/</comment>
<function><type><name>int</name></type> <name>lsmDbDatabaseConnect</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>               <comment type="block">/* Full-path to db file */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Pointer returned via *ppDatabase */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>lsmStrlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>enterGlobalMutex</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>

    <comment type="block">/* Search the global list for an existing object. TODO: Need something
    ** better than the memcmp() below to figure out if a given Database
    ** object represents the requested file.  */</comment>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>gShared</name><operator>.</operator><name>pDatabase</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDbNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nName</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nName</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* If no suitable Database object was found, allocate a new one. */</comment>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Database</name> <operator>*</operator><operator>)</operator><call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Database</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the allocation was successful, fill in other fields and
      ** allocate the client mutex. */</comment> 
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bMultiProc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nName</name></name> <operator>=</operator> <name>nName</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmMutexNew</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If nothing has gone wrong so far, open the shared fd. And if that
      ** succeeds and this connection requested single-process mode, 
      ** attempt to take the exclusive lock on DMS2.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bReadonly</name> <init>= <expr><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bMultiProc</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbOpenSharedFd</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bReadonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Hold an exclusive lock DMS1 while grabbing DMS2. This ensures
        ** that any ongoing call to doDbDisconnect() (even one in another
        ** process) is finished before proceeding.  */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvLock</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvLock</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS2</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmEnvLock</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDbNext</name></name> <operator>=</operator> <name><name>gShared</name><operator>.</operator><name>pDatabase</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gShared</name><operator>.</operator><name>pDatabase</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>freeDatabase</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDbRef</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>leaveGlobalMutex</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pConn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pConn</name></name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsOpen</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bReadonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the db handle is read-write, then connect to the system now. Run
  ** recovery as necessary. Or, if this is a read-only database handle,
  ** defer attempting to connect to the system until a read-transaction
  ** is opened.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsConfigure</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>doDbConnect</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dbDeferClose</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pLsmFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLsmFile</name> <operator>=</operator> <call><name>lsmFsDeferClose</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLsmFile</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLsmFile</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLsmFile</name></name> <operator>=</operator> <name>pLsmFile</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>LsmFile</name> <modifier>*</modifier></type><name>lsmDbRecycleFd</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pRet</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pLsmFile</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLsmFile</name></name> <operator>=</operator> <name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release a reference to a Database object obtained from 
** lsmDbDatabaseConnect(). There should be exactly one call to this function 
** for each successful call to Find().
*/</comment>
<function><type><name>void</name></type> <name>lsmDbDatabaseRelease</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppDb</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>doDbDisconnect</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lsmFsUnmap</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ppDb</name><operator>=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pConn</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ppDb</name><operator>!=</operator><name>pDb</name></expr>;</condition> <incr><expr><name>ppDb</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>ppDb</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>ppDb</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dbDeferClose</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enterGlobalMutex</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDbRef</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nDbRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>LsmFile</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

      <comment type="block">/* Remove the Database structure from the linked list. */</comment>
      <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>gShared</name><operator>.</operator><name>pDatabase</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>p</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pDbNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDbNext</name></name></expr>;</expr_stmt>

      <comment type="block">/* If they were allocated from the heap, free the shared memory chunks */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nShmChunk</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Close any outstanding file descriptors */</comment>
      <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pLsmFile</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmEnvClose</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>freeDatabase</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>leaveGlobalMutex</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Level</name> <modifier>*</modifier></type><name>lsmDbSnapshotLevel</name><parameter_list>(<parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pSnapshot</name><operator>-&gt;</operator><name>pLevel</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmDbSnapshotSetLevel</name><parameter_list>(<parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>pSnap</name></decl></parameter>, <parameter><decl><type><name>Level</name> <modifier>*</modifier></type><name>pLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pSnap</name><operator>-&gt;</operator><name>pLevel</name></name> <operator>=</operator> <name>pLevel</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* TODO: Shuffle things around to get rid of this */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>firstSnapshotInUse</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* 
** Context object used by the lsmWalkFreelist() utility. 
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>WalkFreelistCtx</name></name></type> <name>WalkFreelistCtx</name>;</typedef>
<struct>struct <name>WalkFreelistCtx</name> <block>{
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bReverse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Freelist</name> <modifier>*</modifier></type><name>pFreelist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFree</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xUsr</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>i64</name></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* User callback function */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pUsrctx</name></decl>;</decl_stmt>                  <comment type="block">/* User callback context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDone</name></decl>;</decl_stmt>                      <comment type="block">/* Set to true after xUsr() returns true */</comment>
}</block>;</struct>

<comment type="block">/* 
** Callback used by lsmWalkFreelist().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>walkFreelistCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>WalkFreelistCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>WalkFreelistCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iDir</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bReverse</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Freelist</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pFreelist</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bDone</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlk</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFree</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iFree</name></name> <operator>&lt;</operator> <name><name>pFree</name><operator>-&gt;</operator><name>nEntry</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iFree</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>FreelistEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><operator>&amp;</operator><name><name>pFree</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iFree</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bReverse</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>iBlk</name></name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iBlk</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bReverse</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>iBlk</name></name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iBlk</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iFree</name></name> <operator>+=</operator> <name>iDir</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iId</name></name><operator>&gt;=</operator><literal type="number">0</literal> 
            <operator>&amp;&amp;</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xUsr</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUsrctx</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iBlk</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr> 
          )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iBlk</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iBlk</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name><name>p</name><operator>-&gt;</operator><name>xUsr</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUsrctx</name></name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><name>iSnapshot</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The database handle passed as the first argument must be the worker
** connection. This function iterates through the contents of the current
** free block list, invoking the supplied callback once for each list
** element.
**
** The difference between this function and lsmSortedWalkFreelist() is
** that lsmSortedWalkFreelist() only considers those free-list elements
** stored within the LSM. This function also merges in any in-memory 
** elements.
*/</comment>
<function><type><name>int</name></type> <name>lsmWalkFreelist</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>,                    <comment type="block">/* Database handle (must be worker) */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReverse</name></decl></parameter>,                   <comment type="block">/* True to iterate from largest to smallest */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>i64</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,     <comment type="block">/* Callback function */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>                      <comment type="block">/* First argument to pass to callback */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iDir</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bReverse</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCtx</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>WalkFreelistCtx</name></type> <name><name>ctx</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pDb</name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bReverse</name> <operator>=</operator> <name>bReverse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFreelist</name> <operator>=</operator> <operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>freelist</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pFreelist</name> <operator>&amp;&amp;</operator> <name>bReverse</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFree</name> <operator>=</operator> <name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>pFreelist</name><operator>-&gt;</operator><name>nEntry</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xUsr</name> <operator>=</operator> <name>walkFreelistCb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pUsrctx</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bDone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pDb</name> <operator>=</operator> <name>pDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bReverse</name> <operator>=</operator> <name>bReverse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFreelist</name> <operator>=</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pFreelist</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pFreelist</name> <operator>&amp;&amp;</operator> <name>bReverse</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iFree</name> <operator>=</operator> <name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>pFreelist</name><operator>-&gt;</operator><name>nEntry</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>xUsr</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pUsrctx</name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bDone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSortedWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bReverse</name></expr></argument>, <argument><expr><name>walkFreelistCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>ctx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>iCtx</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCtx</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>iCtx</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WalkFreelistCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><index>[<expr><name>iCtx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>iFree</name></name></expr>;</init> 
          <condition><expr><name><name>p</name><operator>-&gt;</operator><name>pFreelist</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>pFreelist</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition>
          <incr><expr><name>i</name> <operator>+=</operator> <name>iDir</name></expr></incr>
         )</control><block>{<block_content>
        <decl_stmt><decl><type><name>FreelistEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pFreelist</name><operator>-&gt;</operator><name>aEntry</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>iId</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xUsr</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pUsrctx</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iBlk</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <return>return <expr><name>LSM_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><name><name>struct</name> <name>FindFreeblockCtx</name></name></type> <name>FindFreeblockCtx</name>;</typedef>
<struct>struct <name>FindFreeblockCtx</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>iInUse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bNotOne</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>findFreeblockCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iSnapshot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FindFreeblockCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>FindFreeblockCtx</name> <operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSnapshot</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>iInUse</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iBlk</name><operator>!=</operator><literal type="number">1</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bNotOne</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRet</name></name> <operator>=</operator> <name>iBlk</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>findFreeblock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iInUse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bNotOne</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piRet</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>FindFreeblockCtx</name></type> <name>ctx</name></decl>;</decl_stmt>           <comment type="block">/* Context object */</comment>

  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>iInUse</name></name> <operator>=</operator> <name>iInUse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>iRet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>bNotOne</name></name> <operator>=</operator> <name>bNotOne</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmWalkFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>findFreeblockCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRet</name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>iRet</name></name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new database file block to write data to, either by extending
** the database file or by recycling a free-list entry. The worker snapshot 
** must be held in order to call this function.
**
** If successful, *piBlk is set to the block number allocated and LSM_OK is
** returned. Otherwise, *piBlk is zeroed and an lsm error code returned.
*/</comment>
<function><type><name>int</name></type> <name>lsmBlockAllocate</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBefore</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piBlk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Block number of allocated block */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iInUse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Snapshot id still in use */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iSynced</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Snapshot id synced to disk */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmInfoFreelist</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"lsmBlockAllocate(): %d freelist: %s"</literal></expr></argument>, <argument><expr><name>nCall</name></expr></argument>, <argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Set iInUse to the smallest snapshot id that is either:
  **
  **   * Currently in use by a database client,
  **   * May be used by a database client in the future, or
  **   * Is the most recently checkpointed snapshot (i.e. the one that will
  **     be used following recovery if a failure occurs at this point).
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointSynced</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSynced</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>iSynced</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iSynced</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iInUse</name> <operator>=</operator> <name>iSynced</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iInUse</name> <operator>=</operator> <call><name>LSM_MIN</name><argument_list>(<argument><expr><name>iInUse</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>firstSnapshotInUse</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iInUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
  <block>{<block_content>
    <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"lsmBlockAllocate(): "</literal>
        <literal type="string">"snapshot-in-use: %lld (iSynced=%lld) (client-id=%lld)"</literal></expr></argument>, 
        <argument><expr><name>iInUse</name></expr></argument>, <argument><expr><name>iSynced</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iId</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* Unless there exists a read-only transaction (which prevents us from
  ** recycling any blocks regardless, query the free block list for a 
  ** suitable block to reuse. 
  **
  ** It might seem more natural to check for a read-only transaction at
  ** the start of this function. However, it is better do wait until after
  ** the call to lsmCheckpointSynced() to do so.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bRotrans</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmDetectRoTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bRotrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bRotrans</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>findFreeblock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iInUse</name></expr></argument>, <argument><expr><operator>(</operator><name>iBefore</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iBefore</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iRet</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>iRet</name><operator>&gt;=</operator><name>iBefore</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If a block was found in the free block list, use it and remove it from 
    ** the list. Otherwise, if no suitable block was found, allocate one from
    ** the end of the file.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>iRet</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
      <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
          <argument><expr><literal type="string">"reusing block %d (snapshot-in-use=%lld)"</literal></expr></argument>, <argument><expr><name>iRet</name></expr></argument>, <argument><expr><name>iInUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>freelistAppend</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iRet</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbTruncate</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iInUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iRet</name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nBlock</name></name><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
      <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"extending file to %d blocks"</literal></expr></argument>, <argument><expr><name>iRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBefore</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iRet</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>LSM_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piBlk</name> <operator>=</operator> <name>iRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a database block. The worker snapshot must be held in order to call 
** this function.
**
** If successful, LSM_OK is returned. Otherwise, an lsm error code (e.g. 
** LSM_NOMEM).
*/</comment>
<function><type><name>int</name></type> <name>lsmBlockFree</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmShmAssertWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
  <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"lsmBlockFree(): Free block %d"</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><call><name>freelistAppend</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Refree a database block. The worker snapshot must be held in order to call 
** this function.
**
** Refreeing is required when a block is allocated using lsmBlockAllocate()
** but then not used. This function is used to push the block back onto
** the freelist. Refreeing a block is different from freeing is, as a refreed
** block may be reused immediately. Whereas a freed block can not be reused 
** until (at least) after the next checkpoint.
*/</comment>
<function><type><name>int</name></type> <name>lsmBlockRefree</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBlk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_FREELIST</name></cpp:ifdef>
  <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_OK</name></expr></argument>, <argument><expr><literal type="string">"lsmBlockRefree(): Refree block %d"</literal></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>freelistAppend</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iBlk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If required, copy a database checkpoint from shared memory into the
** database itself.
**
** The WORKER lock must not be held when this is called. This is because
** this function may indirectly call fsync(). And the WORKER lock should
** not be held that long (in case it is required by a client flushing an
** in-memory tree to disk).
*/</comment>
<function><type><name>int</name></type> <name>lsmCheckpointWrite</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pnWrite</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">1</literal> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>lsmShmAssertLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WORKER</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_CHECKPOINTER</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoad</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name> <init>= <expr><call><name>lsmCheckpointNBlock</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True if checkpoint is already stored */</comment>

    <comment type="block">/* Check if this checkpoint has already been written to the database
    ** file. If so, set variable bDone to true.  */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pShm</name><operator>-&gt;</operator><name>iMetaPage</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>MetaPage</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>              <comment type="block">/* Meta page */</comment>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                  <comment type="block">/* Meta-page data buffer */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                  <comment type="block">/* Size of aData[] in bytes */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>iCkpt</name></decl>;</decl_stmt>                  <comment type="block">/* Id of checkpoint just loaded */</comment>
      <decl_stmt><decl><type><name>i64</name></type> <name>iDisk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Id of checkpoint already stored in db */</comment>
      <expr_stmt><expr><name>iCkpt</name> <operator>=</operator> <call><name>lsmCheckpointId</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsMetaPageGet</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pShm</name><operator>-&gt;</operator><name>iMetaPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>lsmFsMetaPageData</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iDisk</name> <operator>=</operator> <call><name>lsmCheckpointId</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>lsmCheckpointNWrite</name><argument_list>(<argument><expr><operator>(</operator><name>u32</name> <operator>*</operator><operator>)</operator><name>aData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFsMetaPageRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bDone</name> <operator>=</operator> <operator>(</operator><name>iDisk</name><operator>&gt;=</operator><name>iCkpt</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bDone</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name> <init>= <expr><operator>(</operator><name><name>pShm</name><operator>-&gt;</operator><name>iMetaPage</name></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name><operator>!=</operator><name>LSM_SAFETY_OFF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSyncDb</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><name>nBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointStore</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>eSafety</name></name><operator>!=</operator><name>LSM_SAFETY_OFF</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmFsSyncDb</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>iMetaPage</name></name> <operator>=</operator> <name>iMeta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>lsmCheckpointNWrite</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>nWrite</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_LOG_WORK</name></cpp:ifdef>
      <expr_stmt><expr><call><name>lsmLogMessage</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"finish checkpoint %d"</literal></expr></argument>, 
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lsmCheckpointId</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_CHECKPOINTER</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnWrite</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnWrite</name> <operator>=</operator> <name>nWrite</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmBeginWork</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Attempt to take the WORKER lock */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WORKER</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Deserialize the current worker snapshot */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoadWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lsmFreeSnapshot</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>lsmSortedFreeLevel</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>freelist</name><operator>.</operator><name>aEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>redirect</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to populate one of the read-lock slots to contain lock values
** iLsm/iShm. Or, if such a slot exists already, this function is a no-op.
**
** It is not an error if no slot can be populated because the write-lock
** cannot be obtained. If any other error occurs, return an LSM error code.
** Otherwise, LSM_OK.
**
** This function is called at various points to try to ensure that there
** always exists at least one read-lock slot that can be used by a read-only
** client. And so that, in the usual case, there is an "exact match" available
** whenever a read transaction is opened by any client. At present this
** function is called when:
**
**    * A write transaction that called lsmTreeDiscardOld() is committed, and
**    * Whenever the working snapshot is updated (i.e. lsmFinishWork()).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbSetReadLock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLsm</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Check if there is already a slot containing the required values. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>==</operator><name>iLsm</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name><operator>==</operator><name>iShm</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_OK</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Iterate through all read-lock slots, attempting to take a write-lock
  ** on each of them. If a write-lock succeeds, populate the locked slot
  ** with the required values and break out of the loop.  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name> <operator>=</operator> <name>iLsm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name> <operator>=</operator> <name>iShm</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release the read-lock currently held by connection db.
*/</comment>
<function><type><name>int</name></type> <name>dbReleaseReadlock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bRoTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Argument bFlush is true if the contents of the in-memory tree has just
** been flushed to disk. The significance of this is that once the snapshot
** created to hold the updated state of the database is synced to disk, log
** file space can be recycled.
*/</comment>
<function><type><name>void</name></type> <name>lsmFinishWork</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bFlush</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>*</operator><name>pRc</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If no error has occurred, serialize the worker snapshot and write
    ** it to shared memory.  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSaveWorker</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Assuming no error has occurred, update a read lock slot with the
    ** new snapshot id (see comments above function dbSetReadLock()).  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeLoadHeader</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbSetReadLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Free the snapshot object. */</comment>
    <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WORKER</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Called when recovery is finished.
*/</comment>
<function><type><name>int</name></type> <name>lsmFinishRecovery</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmTreeEndTransaction</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check if the currently configured compression functions
** (LSM_CONFIG_SET_COMPRESSION) are compatible with a database that has its
** compression id set to iReq. Compression routines are compatible if iReq
** is zero (indicating the database is empty), or if it is equal to the 
** compression id of the configured compression routines.
**
** If the check shows that the current compression are incompatible and there
** is a compression factory registered, give it a chance to install new
** compression routines.
**
** If, after any registered factory is invoked, the compression functions
** are still incompatible, return LSM_MISMATCH. Otherwise, LSM_OK.
*/</comment>
<function><type><name>int</name></type> <name>lsmCheckCompressionId</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iReq</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iReq</name><operator>!=</operator><name>LSM_COMPRESSION_EMPTY</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>iId</name></name><operator>!=</operator><name>iReq</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFactory</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bInFactory</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>xFactory</name></name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>factory</name><operator>.</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bInFactory</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>compress</name><operator>.</operator><name>iId</name></name><operator>!=</operator><name>iReq</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Incompatible */</comment>
      <return>return <expr><name>LSM_MISMATCH</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Compatible */</comment>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Begin a read transaction. This function is a no-op if the connection
** passed as the only argument already has an open read transaction.
*/</comment>
<function><type><name>int</name></type> <name>lsmBeginReadTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>MAX_READLOCK_ATTEMPTS</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMaxAttempt</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pDb</name><operator>-&gt;</operator><name>bRoTrans</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>MAX_READLOCK_ATTEMPTS</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iAttempt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iAttempt</name><operator>++</operator><operator>)</operator><operator>&lt;</operator><name>nMaxAttempt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iTreehdr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iSnap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the in-memory tree header. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeLoadHeader</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iTreehdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the database snapshot */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>lsmCheckpointClientCacheOk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>lsmFreeSnapshot</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmMCursorFreeCache</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lsmFsPurgeCache</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointLoad</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iSnap</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Take a read-lock on the tree and snapshot just loaded. Then check
    ** that the shared-memory still contains the same values. If so, proceed.
    ** Otherwise, relinquish the read-lock and retry the whole procedure
    ** (starting with loading the in-memory tree header).  */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iShmMax</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>iShmMin</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iNextShmid</name></name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>LSM_MAX_SHMCHUNKS</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmReadlock</name><argument_list>(
          <argument><expr><name>pDb</name></expr></argument>, <argument><expr><call><name>lsmCheckpointId</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iShmMin</name></expr></argument>, <argument><expr><name>iShmMax</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>lsmTreeLoadHeaderOk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iTreehdr</name></expr></argument>)</argument_list></call>
         <operator>&amp;&amp;</operator> <call><name>lsmCheckpointLoadOk</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>iSnap</name></expr></argument>)</argument_list></call></expr>
        )</condition><block>{<block_content>
          <comment type="block">/* Read lock has been successfully obtained. Deserialize the 
          ** checkpoint just loaded. TODO: This will be removed after 
          ** lsm_sorted.c is changed to work directly from the serialized
          ** version of the snapshot.  */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointDeserialize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>aSnapshot</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>==</operator><name>LSM_OK</name><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Check that the client has the right compression hooks loaded.
          ** If not, set rc to LSM_MISMATCH.  */</comment>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckCompressionId</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iCmpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbReleaseReadlock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if( rc==LSM_OK &amp;&amp; pDb-&gt;pClient ){
  fprintf(stderr, 
      "reading %p: snapshot:%d used-shmid:%d trans-id:%d iOldShmid=%d\n",
      (void *)pDb,
      (int)pDb-&gt;pClient-&gt;iId, (int)pDb-&gt;treehdr.iUsedShmid, 
      (int)pDb-&gt;treehdr.root.iTransId,
      (int)pDb-&gt;treehdr.iOldShmid
  );
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>nChunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dbReleaseReadlock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used by a read-write connection to determine if there
** are currently one or more read-only transactions open on the database
** (in this context a read-only transaction is one opened by a read-only
** connection on a non-live database).
**
** If no error occurs, LSM_OK is returned and *pbExists is set to true if
** some other connection has a read-only transaction open, or false 
** otherwise. If an error occurs an LSM error code is returned and the final
** value of *pbExist is undefined.
*/</comment>
<function><type><name>int</name></type> <name>lsmDetectRoTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbExist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Only a read-write connection may use this function. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_ROTRANS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbExist</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbExist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** db is a read-only database handle in the disconnected state. This function
** attempts to open a read-transaction on the database. This may involve
** connecting to the database system (opening shared memory etc.).
*/</comment>
<function><type><name>int</name></type> <name>lsmBeginRoTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>bReadonly</name></name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>bRoTrans</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>

    <comment type="block">/* Attempt a shared-lock on DMS1. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmTestLock</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_NREADER</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* System is not live. Take a SHARED lock on the ROTRANS byte and
      ** release DMS1. Locking ROTRANS tells all read-write clients that they
      ** may not recycle any disk space from within the database or log files,
      ** as a read-only client may be using it.  */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_ROTRANS</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>bRoTrans</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <operator>(</operator><name>ShmHeader</name> <operator>*</operator><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointRecover</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmLogRecover</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* System is live! */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS3</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_DMS1</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmCacheChunks</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <operator>(</operator><name>ShmHeader</name> <operator>*</operator><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginReadTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close the currently open read transaction.
*/</comment>
<function><type><name>void</name></type> <name>lsmFinishReadTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>

  <comment type="block">/* Worker connections should not be closing read transactions. And
  ** read transactions should only be closed after all cursors and write
  ** transactions have been closed. Finally pClient should be non-NULL
  ** only iff pDb-&gt;iReader&gt;=0.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorker</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>bRoTrans</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nShm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>lsmFree</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>apShm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>nShm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_ROTRANS</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>dbReleaseReadlock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Open a write transaction.
*/</comment>
<function><type><name>int</name></type> <name>lsmBeginWriteTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDb</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Shared memory header */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>nTransOpen</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bDiscardOld</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is no read-transaction open, open one now. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmBeginReadTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Attempt to take the WRITER lock */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WRITER</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the previous writer failed mid-transaction, run emergency rollback. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>pShm</name><operator>-&gt;</operator><name>bWriter</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmTreeRepair</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that this connection is currently reading from the most recent
  ** version of the database. If not, return LSM_BUSY.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>hdr1</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TreeHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmLogBegin</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If everything was successful, set the "transaction-in-progress" flag
  ** and return LSM_OK. Otherwise, if some error occurred, relinquish the 
  ** WRITER lock and return an error code.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>TreeHeader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pShm</name><operator>-&gt;</operator><name>bWriter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>iTransId</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>lsmTreeHasOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iOldLog</name></name><operator>==</operator><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iLogOff</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>lsmTreeDiscardOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bDiscardOld</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WRITER</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pDb</name><operator>-&gt;</operator><name>pCsr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lsmFinishReadTrans</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** End the current write transaction. The connection is left with an open
** read transaction. It is an error to call this if there is no open write 
** transaction.
**
** If the transaction was committed, then a commit record has already been
** written into the log file when this function is called. Or, if the
** transaction was rolled back, both the log file and in-memory tree 
** structure have already been restored. In either case, this function 
** merely releases locks and other resources held by the write-transaction.
**
** LSM_OK is returned if successful, or an LSM error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>lsmFinishWriteTrans</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bCommit</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFlush</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>lsmLogEnd</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>bCommit</name> <operator>&amp;&amp;</operator> <call><name>lsmTreeSize</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name><name>pDb</name><operator>-&gt;</operator><name>nTreeLimit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bFlush</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lsmTreeMakeOld</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lsmTreeEndTransaction</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>bCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>bFlush</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmSortedAutoWork</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bCommit</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bDiscardOld</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbSetReadLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pDb</name><operator>-&gt;</operator><name>bDiscardOld</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>LSM_LOCK_WRITER</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>bFlush</name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>bAutowork</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pDb</name><operator>-&gt;</operator><name>xWork</name></name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pWorkCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return non-zero if the caller is holding the client mutex.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>
<function><type><name>int</name></type> <name>lsmHoldingClientMutex</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmMutexHeld</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>slotIsUsable</name><parameter_list>(<parameter><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLsm</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmMin</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return<expr><operator>(</operator> 
      <name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>&lt;=</operator><name>iLsm</name> 
      <operator>&amp;&amp;</operator> <call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name>iShmMax</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name></expr></argument>, <argument><expr><name>iShmMin</name></expr></argument>)</argument_list></call>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Obtain a read-lock on database version identified by the combination
** of snapshot iLsm and tree iTree. Return LSM_OK if successful, or
** an LSM error code otherwise.
*/</comment>
<function><type><name>int</name></type> <name>lsmReadlock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLsm</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmMin</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmMax</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name>iShmMax</name></expr></argument>, <argument><expr><name>iShmMin</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This is a no-op if the read-only transaction flag is set. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>bRoTrans</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Search for an exact match. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>==</operator><name>iLsm</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name><operator>==</operator><name>iShmMax</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>==</operator><name>iLsm</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name><operator>==</operator><name>iShmMax</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Try to obtain a write-lock on each slot, in order. If successful, set
  ** the slot values to iLsm/iTree.  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name> <operator>=</operator> <name>iLsm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name> <operator>=</operator> <name>iShmMax</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>LSM_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Search for any usable slot */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>slotIsUsable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLsm</name></expr></argument>, <argument><expr><name>iShmMin</name></expr></argument>, <argument><expr><name>iShmMax</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <call><name>slotIsUsable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLsm</name></expr></argument>, <argument><expr><name>iShmMin</name></expr></argument>, <argument><expr><name>iShmMax</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>iReader</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>iReader</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is used to check if there exists a read-lock locking a particular
** version of either the in-memory tree or database file. 
**
** If iLsmId is non-zero, then it is a snapshot id. If there exists a 
** read-lock using this snapshot or newer, set *pbInUse to true. Or,
** if there is no such read-lock, set it to false.
**
** Or, if iLsmId is zero, then iShmid is a shared-memory sequence id.
** Search for a read-lock using this sequence id or newer. etc.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isInUse</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLsmId</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbInUse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iLsmId</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iLsmId</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name><operator>)</operator> 
       <operator>||</operator> <operator>(</operator><name>iLsmId</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>shm_sequence_ge</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>iTreeId</name></name></expr></argument>, <argument><expr><name>iShmid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbInUse</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pbInUse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called by worker connections to determine the smallest
** snapshot id that is currently in use by a database client. The worker
** connection uses this result to determine whether or not it is safe to
** recycle a database block.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>firstSnapshotInUse</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                     <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piInUse</name></decl></parameter>                    <comment type="block">/* IN/OUT: Smallest snapshot id in use */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShmHeader</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pShmhdr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iInUse</name> <init>= <expr><operator>*</operator><name>piInUse</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iInUse</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>LSM_LOCK_NREADER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ShmReader</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pShm</name><operator>-&gt;</operator><name>aReader</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iThis</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iThis</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iInUse</name><operator>&gt;</operator><name>iThis</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iLsmId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lsmShmLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_BUSY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iInUse</name> <operator>=</operator> <name>iThis</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Some error other than LSM_BUSY. Return the error code to
          ** the caller in this case.  */</comment>
          <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>piInUse</name> <operator>=</operator> <name>iInUse</name></expr>;</expr_stmt>
  <return>return <expr><name>LSM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmTreeInUse</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iShmid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbInUse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>treehdr</name><operator>.</operator><name>iUsedShmid</name></name><operator>==</operator><name>iShmid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbInUse</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>isInUse</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iShmid</name></expr></argument>, <argument><expr><name>pbInUse</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmLsmInUse</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iLsmId</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbInUse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>pClient</name></name> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>pClient</name><operator>-&gt;</operator><name>iId</name></name><operator>&lt;=</operator><name>iLsmId</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pbInUse</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>LSM_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>isInUse</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iLsmId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pbInUse</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function may only be called after a successful call to
** lsmDbDatabaseConnect(). It returns true if the connection is in
** multi-process mode, or false otherwise.
*/</comment>
<function><type><name>int</name></type> <name>lsmDbMultiProc</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name></name> <operator>&amp;&amp;</operator> <name><name>pDb</name><operator>-&gt;</operator><name>pDatabase</name><operator>-&gt;</operator><name>bMultiProc</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************************************
**************************************************************************
**************************************************************************
**************************************************************************
**************************************************************************
*************************************************************************/</comment>

<comment type="block">/*
** Ensure that database connection db has cached pointers to at least the 
** first nChunk chunks of shared memory.
*/</comment>
<function><type><name>int</name></type> <name>lsmShmCacheChunks</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nChunk</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nChunk</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NINCR</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure that the db-&gt;apShm[] array is large enough. If an attempt to
    ** allocate memory fails, return LSM_NOMEM immediately. The apShm[] array
    ** is always extended in multiples of 16 entries - so the actual allocated
    ** size can be inferred from nShm.  */</comment> 
    <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name> <operator>+</operator> <name>NINCR</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>NINCR</name><operator>)</operator> <operator>*</operator> <name>NINCR</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>nChunk</name><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>apShm</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <name>NINCR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>apShm</name> <operator>=</operator> <call><name>lsmRealloc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>apShm</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apShm</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_NOMEM_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>apShm</name></name> <operator>=</operator> <name>apShm</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>bRoTrans</name></name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nChunk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>LSM_SHM_CHUNK_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

    </block_content>}</block></if><else>else<block>{<block_content>

      <comment type="block">/* Enter the client mutex */</comment>
      <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Extend the Database objects apShmChunk[] array if necessary. Using the
       ** same pattern as for the lsm_db.apShm[] array above.  */</comment>
      <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nShmChunk</name></name> <operator>+</operator> <name>NINCR</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>NINCR</name><operator>)</operator> <operator>*</operator> <name>NINCR</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>nChunk</name><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>apShm</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator>  <name>NINCR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>apShm</name> <operator>=</operator> <call><name>lsmRealloc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apShm</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_NOMEM_BKPT</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name></name> <operator>=</operator> <name>apShm</name></expr>;</expr_stmt>
      </block_content>}</block></while>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nChunk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nShmChunk</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <comment type="block">/* Single process mode */</comment>
            <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <call><name>lsmMallocZeroRc</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name>LSM_SHM_CHUNK_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* Multi-process mode */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvShmMap</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>LSM_SHM_CHUNK_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pChunk</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nShmChunk</name></name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>apShm</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>apShmChunk</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nShm</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <comment type="block">/* Release the client mutex */</comment>
      <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lockSharedFile</name><parameter_list>(<parameter><decl><type><name>lsm_env</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>, <parameter><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvLock</name><argument_list>(<argument><expr><name>pEnv</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Test if it would be possible for connection db to obtain a lock of type
** eType on the nLock locks starting at iLock. If so, return LSM_OK. If it
** would not be possible to obtain the lock due to a lock held by another
** connection, return LSM_BUSY. If an IO or other error occurs (i.e. in the 
** lsm_env.xTestLock function), return some other LSM error code.
**
** Note that this function never actually locks the database - it merely
** queries the system to see if there exists a lock that would prevent
** it from doing so.
*/</comment>
<function><type><name>int</name></type> <name>lsmShmTestLock</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nLock</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iLock</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>iLock</name><operator>+</operator><name>nLock</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>mask</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>LSM_LOCK_EXCL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mask</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>+</operator><literal type="number">32</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pConn</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>!=</operator><name>db</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIter</name><operator>!=</operator><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>pIter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bMultiProc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmEnvTestLock</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>nLock</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to obtain the lock identified by the iLock and bExcl parameters.
** If successful, return LSM_OK. If the lock cannot be obtained because 
** there exists some other conflicting lock, return LSM_BUSY. If some other
** error occurs, return an LSM error code.
**
** Parameter iLock must be one of LSM_LOCK_WRITER, WORKER or CHECKPOINTER,
** or else a value returned by the LSM_LOCK_READER macro.
*/</comment>
<function><type><name>int</name></type> <name>lsmShmLock</name><parameter_list>(
  <parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>,                        <comment type="block">/* One of LSM_LOCK_UNLOCK, SHARED or EXCL */</comment>
  <parameter><decl><type><name>int</name></type> <name>bBlock</name></decl></parameter>                      <comment type="block">/* True for a blocking lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u64</name></type> <name>me</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u64</name></type> <name>ms</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>+</operator><literal type="number">32</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>LSM_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Database</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pDatabase</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>!=</operator><name>LSM_LOCK_EXCL</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bReadonly</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLock</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iLock</name><operator>&lt;=</operator><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name>LSM_LOCK_NRWCLIENT</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>LSM_LOCK_RWCLIENT</name><argument_list>(<argument><expr><name>LSM_LOCK_NRWCLIENT</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>LSM_LOCK_UNLOCK</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>LSM_LOCK_SHARED</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>LSM_LOCK_EXCL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for a no-op. Proceed only if this is not one of those. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>eOp</name><operator>==</operator><name>LSM_LOCK_UNLOCK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <operator>(</operator><name>me</name><operator>|</operator><name>ms</name><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>eOp</name><operator>==</operator><name>LSM_LOCK_SHARED</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <operator>(</operator><name>me</name><operator>|</operator><name>ms</name><operator>)</operator><operator>)</operator><operator>!=</operator><name>ms</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>eOp</name><operator>==</operator><name>LSM_LOCK_EXCL</name>   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>me</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nExcl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of connections holding EXCLUSIVE */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nShared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Number of connections holding SHARED */</comment>
    <expr_stmt><expr><call><name>lsmMutexEnter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out the locks currently held by this process on iLock, not
    ** including any held by connection db.  */</comment>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pConn</name></name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>me</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pIter</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>ms</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>!=</operator><name>db</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>me</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nExcl</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>ms</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>nShared</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExcl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nExcl</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExcl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nShared</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExcl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <operator>(</operator><name>me</name><operator>|</operator><name>ms</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>( <expr><name>eOp</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>LSM_LOCK_UNLOCK</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>nShared</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>lockSharedFile</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>LSM_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>me</name><operator>|</operator><name>ms</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>LSM_LOCK_SHARED</name></expr>:</case>
        <if_stmt><if>if<condition>( <expr><name>nExcl</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nShared</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lockSharedFile</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>LSM_LOCK_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>|=</operator> <name>ms</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;=</operator> <operator>~</operator><name>me</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>LSM_LOCK_EXCL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nExcl</name> <operator>||</operator> <name>nShared</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>LSM_BUSY</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lockSharedFile</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>|=</operator> <operator>(</operator><name>me</name><operator>|</operator><name>ms</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>lsmMutexLeave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pClientMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LSM_DEBUG</name></cpp:ifdef>

<function><type><name>int</name></type> <name>shmLockType</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u64</name></type> <name>me</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u64</name></type> <name>ms</name> <init>= <expr><operator>(</operator><operator>(</operator><name>u64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>iLock</name><operator>+</operator><literal type="number">32</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>me</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_LOCK_EXCL</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mLock</name></name> <operator>&amp;</operator> <name>ms</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>LSM_LOCK_SHARED</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>LSM_LOCK_UNLOCK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The arguments passed to this function are similar to those passed to
** the lsmShmLock() function. However, instead of obtaining a new lock 
** this function returns true if the specified connection already holds 
** (or does not hold) such a lock, depending on the value of eOp. As
** follows:
**
**   (eOp==LSM_LOCK_UNLOCK) -&gt; true if db has no lock on iLock
**   (eOp==LSM_LOCK_SHARED) -&gt; true if db has at least a SHARED lock on iLock.
**   (eOp==LSM_LOCK_EXCL)   -&gt; true if db has an EXCLUSIVE lock on iLock.
*/</comment>
<function><type><name>int</name></type> <name>lsmShmAssertLock</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eHave</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLock</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iLock</name><operator>&lt;=</operator><call><name>LSM_LOCK_READER</name><argument_list>(<argument><expr><name>LSM_LOCK_NREADER</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLock</name><operator>&lt;=</operator><literal type="number">16</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eOp</name><operator>==</operator><name>LSM_LOCK_UNLOCK</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>LSM_LOCK_SHARED</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>LSM_LOCK_EXCL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>eHave</name> <operator>=</operator> <call><name>shmLockType</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>eOp</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>LSM_LOCK_UNLOCK</name></expr>:</case>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>eHave</name><operator>==</operator><name>LSM_LOCK_UNLOCK</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LSM_LOCK_SHARED</name></expr>:</case>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>eHave</name><operator>!=</operator><name>LSM_LOCK_UNLOCK</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LSM_LOCK_EXCL</name></expr>:</case>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>eHave</name><operator>==</operator><name>LSM_LOCK_EXCL</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><literal type="string">"bad eOp value passed to lsmShmAssertLock()"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsmShmAssertWorker</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>lsmShmAssertLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>LSM_LOCK_WORKER</name></expr></argument>, <argument><expr><name>LSM_LOCK_EXCL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>pWorker</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does not contribute to library functionality, and is not
** included in release builds. It is intended to be called from within
** an interactive debugger.
**
** When called, this function prints a single line of human readable output
** to stdout describing the locks currently held by the connection. For 
** example:
**
**     (gdb) call print_db_locks(pDb)
**     (shared on dms2) (exclusive on writer) 
*/</comment>
<function><type><name>void</name></type> <name>print_db_locks</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLock</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iLock</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iLock</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><name>iLock</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bOne</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azLock</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="string">"shared"</literal></expr>, <expr><literal type="string">"exclusive"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azName</name><index>[]</index></name> <init>= <expr><block>{
      <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"dms1"</literal></expr>, <expr><literal type="string">"dms2"</literal></expr>, <expr><literal type="string">"writer"</literal></expr>, <expr><literal type="string">"worker"</literal></expr>, <expr><literal type="string">"checkpointer"</literal></expr>,
      <expr><literal type="string">"reader0"</literal></expr>, <expr><literal type="string">"reader1"</literal></expr>, <expr><literal type="string">"reader2"</literal></expr>, <expr><literal type="string">"reader3"</literal></expr>, <expr><literal type="string">"reader4"</literal></expr>, <expr><literal type="string">"reader5"</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eHave</name> <init>= <expr><call><name>shmLockType</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>azLock</name><index>[<expr><name>eHave</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s(%s on %s)"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>bOne</name></expr>?</condition><then><expr><literal type="string">" "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>azLock</name><index>[<expr><name>eHave</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azName</name><index>[<expr><name>iLock</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bOne</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>print_all_db_locks</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>pDatabase</name><operator>-&gt;</operator><name>pConn</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s connection %p "</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>p</name><operator>==</operator><name>db</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"*"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_db_locks</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>lsmShmBarrier</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>lsmEnvShmBarrier</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>lsm_checkpoint</name><parameter_list>(<parameter><decl><type><name>lsm_db</name> <modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnKB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of pages checkpointed */</comment>

  <comment type="block">/* Attempt the checkpoint. If successful, nWrite is set to the number of
  ** pages written between this and the previous checkpoint.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lsmCheckpointWrite</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If required, calculate the output variable (KB of data checkpointed). 
  ** Set it to zero if an error occured.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pnKB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nKB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>LSM_OK</name> <operator>&amp;&amp;</operator> <name>nWrite</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nKB</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nWrite</name> <operator>*</operator> <call><name>lsmFsPageSize</name><argument_list>(<argument><expr><name><name>pDb</name><operator>-&gt;</operator><name>pFS</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnKB</name> <operator>=</operator> <name>nKB</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
