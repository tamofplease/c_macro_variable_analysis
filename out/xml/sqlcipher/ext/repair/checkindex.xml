<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/repair/checkindex.c"><comment type="block">/*
** 2017 October 27
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>

<comment type="block">/*
** Stuff that is available inside the amalgamation, but which we need to
** declare ourselves if this module is compiled separately.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>u16</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get4byte</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(        \
    ((u32)((x)[0])&lt;&lt;24) +    \
    ((u32)((x)[1])&lt;&lt;16) +    \
    ((u32)((x)[2])&lt;&lt;8) +     \
    ((u32)((x)[3]))          \
)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>CidxTable</name></name></type> <name>CidxTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>CidxCursor</name></name></type> <name>CidxCursor</name>;</typedef>

<struct>struct <name>CidxTable</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>CidxCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>       <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>           <comment type="block">/* Row number of the output */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdxName</name></decl>;</decl_stmt>                 <comment type="block">/* Copy of the index_name parameter */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAfterKey</name></decl>;</decl_stmt>                <comment type="block">/* Copy of the after_key parameter */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>            <comment type="block">/* SQL statement that generates the output */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>CidxColumn</name></name></type> <name>CidxColumn</name>;</typedef>
<struct>struct <name>CidxColumn</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpr</name></decl>;</decl_stmt>                    <comment type="block">/* Text for indexed expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDesc</name></decl>;</decl_stmt>                      <comment type="block">/* True for DESC columns, otherwise false */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bKey</name></decl>;</decl_stmt>                       <comment type="block">/* Part of index, not PK */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>CidxIndex</name></name></type> <name>CidxIndex</name>;</typedef>
<struct>struct <name>CidxIndex</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl>;</decl_stmt>                   <comment type="block">/* WHERE clause, if any */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Elements in aCol[] array */</comment>
  <decl_stmt><decl><type><name>CidxColumn</name></type> <name><name>aCol</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Array of indexed columns */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>cidxMalloc</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cidxCursorError</name><parameter_list>(<parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Connect to the incremental_index_check virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CidxTable</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IIC_ERRMSG</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IIC_CURRENT_KEY</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IIC_INDEX_NAME</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IIC_AFTER_KEY</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IIC_SCANNER_SQL</name></cpp:macro>   <cpp:value>4</cpp:value></cpp:define>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
      <argument><expr><literal type="string">"CREATE TABLE xyz("</literal>
      <literal type="string">" errmsg TEXT,"</literal>            <comment type="block">/* Error message or NULL if everything is ok */</comment>
      <literal type="string">" current_key TEXT,"</literal>       <comment type="block">/* SQLite quote() text of key values */</comment>
      <literal type="string">" index_name HIDDEN,"</literal>      <comment type="block">/* IN: name of the index being scanned */</comment>
      <literal type="string">" after_key HIDDEN,"</literal>       <comment type="block">/* IN: Start scanning after this key */</comment>
      <literal type="string">" scanner_sql HIDDEN"</literal>      <comment type="block">/* debuggingn info: SQL used for scanner */</comment>
      <literal type="string">")"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>cidxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CidxTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Disconnect from or destroy an incremental_index_check virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>CidxTable</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** idxNum and idxStr are not used.  There are only three possible plans,
** which are all distinguished by the number of parameters.
**
**   No parameters:         A degenerate plan.  The result is zero rows.
**   1 Parameter:           Scan all of the index starting with first entry
**   2 parameters:          Scan the index starting after the "after_key".    
**
** Provide successively smaller costs for each of these plans to encourage
** the query planner to select the one with the most parameters.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdxName</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iAfterKey</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>IIC_INDEX_NAME</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iIdxName</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>IIC_AFTER_KEY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iAfterKey</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>iIdxName</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000000000.0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iIdxName</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iIdxName</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iAfterKey</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iAfterKey</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iAfterKey</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new btreeinfo cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>cidxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CidxCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name><operator>*</operator><operator>)</operator><name>pRet</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a btreeinfo cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Move a btreeinfo cursor to the next entry in the file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CidxTable</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>db</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cidxCursorError</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"Cursor error: %s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We have reached EOF if previous sqlite3_step() returned
** anything other than SQLITE_ROW;
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cidxMprintf</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>cidxPrepare</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>                     <comment type="block">/* ... printf arguments */</comment>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CidxTable</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>-&gt;</operator><name>db</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>cidxCursorError</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"SQL error: %s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cidxFinalize</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>cidxStrdup</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cidxFreeIndex</name><parameter_list>(<parameter><decl><type><name>CidxIndex</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pIdx</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cidx_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cidx_isident</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal> 
    <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator> 
    <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'_'</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_PARSE_EOF</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_PARSE_COMMA</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/*  "," */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_PARSE_OPEN</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/*  "(" */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_PARSE_CLOSE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>      <comment type="block">/*  ")" */</comment>

<comment type="block">/*
** Argument zIn points into the start, middle or end of a CREATE INDEX
** statement. If argument pbDoNotTrim is non-NULL, then this function
** scans the input until it finds EOF, a comma (",") or an open or
** close parenthesis character. It then sets (*pzOut) to point to said
** character and returns a CIDX_PARSE_XXX constant as appropriate. The
** parser is smart enough that special characters inside SQL strings
** or comments are not returned for.
**
** Or, if argument pbDoNotTrim is NULL, then this function sets *pzOut
** to point to the first character of the string that is not whitespace
** or part of an SQL comment and returns CIDX_PARSE_EOF.
**
** Additionally, if pbDoNotTrim is not NULL and the element immediately
** before (*pzOut) is an SQL comment of the form "-- comment", then
** (*pbDoNotTrim) is set before returning. In all other cases it is
** cleared.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxFindNext</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzOut</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pbDoNotTrim</name></decl></parameter>                <comment type="block">/* OUT: True if prev is -- comment */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>CIDX_PARSE_EOF</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><name>pbDoNotTrim</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pbDoNotTrim</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'*'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>CIDX_PARSE_EOF</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzOut</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pbDoNotTrim</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>CIDX_PARSE_EOF</name></expr>;</return></block_content></block></if></if_stmt>
      <switch>switch<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="char">'\0'</literal></expr>:</case>
          <return>return <expr><name>CIDX_PARSE_EOF</name></expr>;</return>
        <case>case <expr><literal type="char">'('</literal></expr>:</case>
          <return>return <expr><name>CIDX_PARSE_OPEN</name></expr>;</return>
        <case>case <expr><literal type="char">')'</literal></expr>:</case>
          <return>return <expr><name>CIDX_PARSE_CLOSE</name></expr>;</return>
        <case>case <expr><literal type="char">','</literal></expr>:</case>
          <return>return <expr><name>CIDX_PARSE_COMMA</name></expr>;</return>
  
        <case>case <expr><literal type="char">'"'</literal></expr>:</case> 
        <case>case <expr><literal type="char">'\''</literal></expr>:</case> 
        <case>case <expr><literal type="char">'`'</literal></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><operator>*</operator><name>z</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><name>q</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>!=</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <break>break;</break>
        </block_content>}</block>
  
        <case>case <expr><literal type="char">'['</literal></expr>:</case>
          <while>while<condition>( <expr><operator>*</operator><name>z</name><operator>++</operator><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
          <break>break;</break>
  
        <default>default:</default>
          <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
      <expr_stmt><expr><operator>*</operator><name>pbDoNotTrim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxParseSQL</name><parameter_list>(<parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><name>CidxIndex</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zSql</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nParen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bDoNotTrim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CidxColumn</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>cidxFindNext</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bDoNotTrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>!=</operator><name>CIDX_PARSE_OPEN</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z1</name> <operator>=</operator> <name>z</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nParen</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>cidxFindNext</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bDoNotTrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><name>CIDX_PARSE_EOF</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>e</name><operator>==</operator><name>CIDX_PARSE_COMMA</name> <operator>||</operator> <name>e</name><operator>==</operator><name>CIDX_PARSE_CLOSE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nParen</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>zExpr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>bDoNotTrim</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"asc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>cidx_isident</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></if><if type="elseif">else
          if<condition>( <expr><operator>!</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"desc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>cidx_isident</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>z</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
          </block_content>}</block></if></if_stmt>
        <while>while<condition>( <expr><call><name>cidx_isspace</name><argument_list>(<argument><expr><name><name>z1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>zExpr</name></name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>z</name><operator>-</operator><name>z1</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCol</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name>z1</name> <operator>=</operator> <name>z2</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><name>CIDX_PARSE_OPEN</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nParen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><name>CIDX_PARSE_CLOSE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nParen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Search for a WHERE clause */</comment>
  <expr_stmt><expr><call><name>cidxFindNext</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"where"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal></expr> )</condition><block>{<block_content>
    <goto>goto <name>parse_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>

 <label><name>parse_error</name>:</label>
  <expr_stmt><expr><call><name>cidxCursorError</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"Parse error in: %s"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxLookupIndex</name><parameter_list>(
  <parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,               <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl></parameter>,               <comment type="block">/* Name of index to look up */</comment>
  <parameter><decl><type><name>CidxIndex</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppIdx</name></decl></parameter>,              <comment type="block">/* OUT: Description of columns */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTab</name></decl></parameter>                    <comment type="block">/* OUT: Table name */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CidxIndex</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFindTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
  <comment type="block">/* Find the table for this index. */</comment>
  <expr_stmt><expr><name>pFindTab</name> <operator>=</operator> <call><name>cidxPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, 
      <argument><expr><literal type="string">"SELECT tbl_name, sql FROM sqlite_schema WHERE name=%Q AND type='index'"</literal></expr></argument>,
      <argument><expr><name>zIdx</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pFindTab</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pFindTab</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zTab</name> <operator>=</operator> <call><name>cidxStrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pFindTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <call><name>cidxPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_xinfo(%Q)"</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CidxColumn</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zName</name> <operator>=</operator> <literal type="string">"rowid"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>CidxIndex</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CidxColumn</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nAlloc</name><operator>+</operator><literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pIdx</name> <operator>=</operator> <operator>(</operator><name>CidxIndex</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bDesc</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bKey</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>bKey</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zExpr</name></name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"\"%w\" COLLATE %s"</literal></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zExpr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>cidxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>cidxParseSQL</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>cidxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pFindTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cidxFreeIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzTab</name> <operator>=</operator> <name>zTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppIdx</name> <operator>=</operator> <name>pIdx</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxDecodeAfter</name><parameter_list>(
  <parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nCol</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAfterKey</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>pazAfter</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azAfter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAfterKey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zAfterKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>azAfter</name> <operator>=</operator> <call><name>cidxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCol</name> <operator>+</operator> <name>nAfterKey</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azAfter</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>zCopy</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name>zAfterKey</name></expr></argument>, <argument><expr><name>nAfterKey</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <while>while<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

      <comment type="block">/* Check NULL values */</comment>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'N'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if>

      <comment type="block">/* Check strings and blob literals */</comment>
      <if type="elseif">else if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'X'</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>azAfter</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'X'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'\''</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'\''</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if>

      <comment type="block">/* Check numbers */</comment>
      <else>else<block>{<block_content>
        <expr_stmt><expr><name><name>azAfter</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>p</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> 
            <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>p</name><operator>==</operator><literal type="char">'E'</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>

      <while>while<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>!=</operator><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><operator>(</operator><name>nCol</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'\0'</literal></expr> </then><else>: <expr><literal type="char">','</literal></expr></else></ternary><operator>)</operator></expr> )</condition><block>{<block_content>
        <goto>goto <name>parse_error</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pazAfter</name> <operator>=</operator> <name>azAfter</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

 <label><name>parse_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pazAfter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cidxCursorError</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"error parsing after value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cidxWhere</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>CidxColumn</name> <modifier>*</modifier></type><name>aCol</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azAfter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iGt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bLastIsNull</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iGt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s(%s) IS %s"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, 
        <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zExpr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>azAfter</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azAfter</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bLastIsNull</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s(%s) IS NULL"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if<condition>( <expr><name><name>azAfter</name><index>[<expr><name>iGt</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s(%s) %s %s"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, 
        <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>zExpr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>aCol</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>bDesc</name></expr> ?</condition><then> <expr><literal type="string">"&lt;"</literal></expr> </then><else>: <expr><literal type="string">"&gt;"</literal></expr></else></ternary><operator>)</operator></expr></argument>, 
        <argument><expr><name><name>azAfter</name><index>[<expr><name>iGt</name></expr>]</index></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s(%s) IS NOT NULL"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>,<argument><expr><name><name>aCol</name><index>[<expr><name>iGt</name></expr>]</index></name><operator>.</operator><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_CLIST_ALL</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_CLIST_ORDERBY</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_CLIST_CURRENT_KEY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_CLIST_SUBWHERE</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIDX_CLIST_SUBEXPR</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** This function returns various strings based on the contents of the
** CidxIndex structure and the eType parameter.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cidxColumnList</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl></parameter>,
  <parameter><decl><type><name>CidxIndex</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>,                <comment type="block">/* Indexed columns */</comment>
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>                       <comment type="block">/* True to include ASC/DESC */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>aDir</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">""</literal></expr>, <expr><literal type="string">" DESC"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>CidxColumn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bDesc</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bDesc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>

        <case>case <expr><name>CIDX_CLIST_ORDERBY</name></expr>:</case>
          <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s%d%s"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>aDir</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>bDesc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>CIDX_CLIST_CURRENT_KEY</name></expr>:</case>
          <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%squote(i%d)"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"||','||"</literal></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>CIDX_CLIST_SUBWHERE</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bKey</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s%s IS i.i%d"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, 
                <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zExpr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <case>case <expr><name>CIDX_CLIST_SUBEXPR</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bKey</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s%s IS i.i%d"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, 
                <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zExpr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <default>default:</default>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>CIDX_CLIST_ALL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><literal type="string">"%z%s(%s) AS i%d"</literal></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zExpr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate SQL (in memory obtained from sqlite3_malloc()) that will
** continue the index scan for zIdxName starting after zAfterKey.
*/</comment>
<function><type><name>int</name></type> <name>cidxGenerateScanSql</name><parameter_list>(
  <parameter><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,           <comment type="block">/* The cursor which needs the new statement */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdxName</name></decl></parameter>,       <comment type="block">/* index to be scanned */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAfterKey</name></decl></parameter>,      <comment type="block">/* start after this key, if not NULL */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzSqlOut</name></decl></parameter>             <comment type="block">/* OUT: Write the generated SQL here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCurrentKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrderBy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSubWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSubExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSrcList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azAfter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CidxIndex</name> <modifier>*</modifier></type><name>pIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pzSqlOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>cidxLookupIndex</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zOrderBy</name> <operator>=</operator> <call><name>cidxColumnList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>CIDX_CLIST_ORDERBY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCurrentKey</name> <operator>=</operator> <call><name>cidxColumnList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>CIDX_CLIST_CURRENT_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSubWhere</name> <operator>=</operator> <call><name>cidxColumnList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>CIDX_CLIST_SUBWHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSubExpr</name> <operator>=</operator> <call><name>cidxColumnList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>CIDX_CLIST_SUBEXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSrcList</name> <operator>=</operator> <call><name>cidxColumnList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>CIDX_CLIST_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zAfterKey</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>cidxDecodeAfter</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument>, <argument><expr><name>zAfterKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>azAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zAfterKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzSqlOut</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>,
          <argument><expr><literal type="string">"SELECT (SELECT %s FROM %Q AS t WHERE %s), %s "</literal>
          <literal type="string">"FROM (SELECT %s FROM %Q INDEXED BY %Q %s%sORDER BY %s) AS i"</literal></expr></argument>,
          <argument><expr><name>zSubExpr</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zSubWhere</name></expr></argument>, <argument><expr><name>zCurrentKey</name></expr></argument>, 
          <argument><expr><name>zSrcList</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, 
          <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> ?</condition><then> <expr><literal type="string">"WHERE "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
          <argument><expr><name>zOrderBy</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, 
          <argument><expr><literal type="string">"SELECT (SELECT %s FROM %Q WHERE %s), %s FROM ("</literal></expr></argument>,
          <argument><expr><name>zSubExpr</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zSubWhere</name></expr></argument>, <argument><expr><name>zCurrentKey</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nCol</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bDesc</name> <operator>&amp;&amp;</operator> <name><name>azAfter</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><call><name>cidxWhere</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name></name></expr></argument>, <argument><expr><name>azAfter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"%z"</literal>
              <literal type="string">"%sSELECT * FROM ("</literal>
                <literal type="string">"SELECT %s FROM %Q INDEXED BY %Q WHERE %s%s%z ORDER BY %s"</literal>
              <literal type="string">")"</literal></expr></argument>,
              <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zSrcList</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, 
              <argument><expr><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> ?</condition><then> <expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
              <argument><expr><ternary><condition><expr><name><name>pIdx</name><operator>-&gt;</operator><name>zWhere</name></name></expr> ?</condition><then> <expr><literal type="string">" AND "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
              <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>zOrderBy</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" UNION ALL "</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bDesc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>pzSqlOut</name> <operator>=</operator> <call><name>cidxMprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="string">"%z) AS i"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCurrentKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSubWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSubExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSrcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cidxFreeIndex</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** Position a cursor back to the beginning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdxName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAfterKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zIdxName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zAfterKey</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>zIdxName</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name> <operator>=</operator> <ternary><condition><expr><name>zAfterKey</name></expr> ?</condition><then> <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zAfterKey</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>cidxGenerateScanSql</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>zAfterKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <call><name>cidxPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"%z"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>cidxNext</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return a column value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><name>IIC_ERRMSG</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;=</operator><name>IIC_SCANNER_SQL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>iCol</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>IIC_ERRMSG</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="string">"row data mismatch"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zVal</name> <operator>=</operator> <literal type="string">"row missing"</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>IIC_CURRENT_KEY</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>IIC_INDEX_NAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>IIC_AFTER_KEY</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>IIC_SCANNER_SQL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cidxGenerateScanSql</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zIdxName</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>zAfterKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the ROWID for the sqlite_btreeinfo table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cidxRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CidxCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>CidxCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register the virtual table modules with the database handle passed
** as the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ciInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>cidx_module</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCreate */</comment>
    <expr><name>cidxConnect</name></expr>,                  <comment type="block">/* xConnect */</comment>
    <expr><name>cidxBestIndex</name></expr>,                <comment type="block">/* xBestIndex */</comment>
    <expr><name>cidxDisconnect</name></expr>,               <comment type="block">/* xDisconnect */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xDestroy */</comment>
    <expr><name>cidxOpen</name></expr>,                     <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>cidxClose</name></expr>,                    <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>cidxFilter</name></expr>,                   <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>cidxNext</name></expr>,                     <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>cidxEof</name></expr>,                      <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>cidxColumn</name></expr>,                   <comment type="block">/* xColumn - read data */</comment>
    <expr><name>cidxRowid</name></expr>,                    <comment type="block">/* xRowid - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xUpdate */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSync */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCommit */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollbackTo */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"incremental_index_check"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cidx_module</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extension load function.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_checkindex_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ciInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
