<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/expert/sqlite3expert.c"><comment type="block">/*
** 2017 April 09
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3expert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_AMALGAMATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_AMALGAMATION) */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef> 

<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>IdxColumn</name></name></type> <name>IdxColumn</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxConstraint</name></name></type> <name>IdxConstraint</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxScan</name></name></type> <name>IdxScan</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxStatement</name></name></type> <name>IdxStatement</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxTable</name></name></type> <name>IdxTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxWrite</name></name></type> <name>IdxWrite</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name></cpp:macro>  <cpp:value>(int)strlen</cpp:value></cpp:define>

<comment type="block">/*
** A temp table name that we assume no user database will actually use.
** If this assumption proves incorrect triggers on the table with the
** conflicting name will be ignored.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIQUE_TABLE_NAME</name></cpp:macro> <cpp:value>"t592690916721053953805701627921227776"</cpp:value></cpp:define>

<comment type="block">/*
** A single constraint. Equivalent to either "col = ?" or "col &lt; ?" (or
** any other type of single-ended range constraint on a column).
**
** pLink:
**   Used to temporarily link IdxConstraint objects into lists while
**   creating candidate indexes.
*/</comment>
<struct>struct <name>IdxConstraint</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>                    <comment type="block">/* Collation sequence */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRange</name></decl>;</decl_stmt>                     <comment type="block">/* True for range, false for eq */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Constrained table column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFlag</name></decl>;</decl_stmt>                      <comment type="block">/* Used by idxFindCompatible() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDesc</name></decl>;</decl_stmt>                      <comment type="block">/* True if ORDER BY &lt;expr&gt; DESC */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* Next constraint in pEq or pRange list */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pLink</name></decl>;</decl_stmt>           <comment type="block">/* See above */</comment>
}</block>;</struct>

<comment type="block">/*
** A single scan of a single table.
*/</comment>
<struct>struct <name>IdxScan</name> <block>{
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                 <comment type="block">/* Associated table object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                        <comment type="block">/* Database containing table zTable */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>covering</name></decl>;</decl_stmt>                   <comment type="block">/* Mask of columns required for cov. index */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pOrder</name></decl>;</decl_stmt>          <comment type="block">/* ORDER BY columns */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl>;</decl_stmt>             <comment type="block">/* List of == constraints */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pRange</name></decl>;</decl_stmt>          <comment type="block">/* List of &lt; constraints */</comment>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pNextScan</name></decl>;</decl_stmt>             <comment type="block">/* Next IdxScan object for same analysis */</comment>
}</block>;</struct>

<comment type="block">/*
** Information regarding a single database table. Extracted from 
** "PRAGMA table_info" by function idxGetTableInfo().
*/</comment>
<struct>struct <name>IdxColumn</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>IdxTable</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Table name */</comment>
  <decl_stmt><decl><type><name>IdxColumn</name> <modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                <comment type="block">/* Next table in linked list of all tables */</comment>
}</block>;</struct>

<comment type="block">/*
** An object of the following type is created for each unique table/write-op
** seen. The objects are stored in a singly-linked list beginning at
** sqlite3expert.pWrite.
*/</comment>
<struct>struct <name>IdxWrite</name> <block>{
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eOp</name></decl>;</decl_stmt>                        <comment type="block">/* SQLITE_UPDATE, DELETE or INSERT */</comment>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Each statement being analyzed is represented by an instance of this
** structure.
*/</comment>
<struct>struct <name>IdxStatement</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iId</name></decl>;</decl_stmt>                        <comment type="block">/* Statement number */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* SQL statement */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl>;</decl_stmt>                     <comment type="block">/* Indexes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEQP</name></decl>;</decl_stmt>                     <comment type="block">/* Plan */</comment>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** A hash table for storing strings. With space for a payload string
** with each entry. Methods are:
**
**   idxHashInit()
**   idxHashClear()
**   idxHashAdd()
**   idxHashSearch()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDX_HASH_SIZE</name></cpp:macro> <cpp:value>1023</cpp:value></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>IdxHashEntry</name></name></type> <name>IdxHashEntry</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxHash</name></name></type> <name>IdxHash</name>;</typedef>
<struct>struct <name>IdxHashEntry</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>                     <comment type="block">/* nul-terminated key */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>                     <comment type="block">/* nul-terminated value string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal2</name></decl>;</decl_stmt>                    <comment type="block">/* nul-terminated value string 2 */</comment>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pHashNext</name></decl>;</decl_stmt>        <comment type="block">/* Next entry in same hash bucket */</comment>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>            <comment type="block">/* Next entry in hash */</comment>
}</block>;</struct>
<struct>struct <name>IdxHash</name> <block>{
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name><name>aHash</name><index>[<expr><name>IDX_HASH_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** sqlite3expert object.
*/</comment>
<struct>struct <name>sqlite3expert</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iSample</name></decl>;</decl_stmt>                    <comment type="block">/* Percentage of tables to sample for stat1 */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* User database */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name></decl>;</decl_stmt>                   <comment type="block">/* In-memory db for this analysis */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbv</name></decl>;</decl_stmt>                   <comment type="block">/* Vtab schema for this analysis */</comment>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>               <comment type="block">/* List of all IdxTable objects */</comment>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl>;</decl_stmt>                 <comment type="block">/* List of scan objects */</comment>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>               <comment type="block">/* List of write objects */</comment>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStatement</name></decl>;</decl_stmt>       <comment type="block">/* List of IdxStatement objects */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRun</name></decl>;</decl_stmt>                       <comment type="block">/* True once analysis has run */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Error code from whereinfo hook */</comment>
  <decl_stmt><decl><type><name>IdxHash</name></type> <name>hIdx</name></decl>;</decl_stmt>                   <comment type="block">/* Hash containing all candidate indexes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCandidates</name></decl>;</decl_stmt>              <comment type="block">/* For EXPERT_REPORT_CANDIDATES */</comment>
}</block>;</struct>


<comment type="block">/*
** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc(). 
** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>idxMalloc</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize an IdxHash hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxHashInit</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset an IdxHash hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxHashClear</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>IDX_HASH_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the index of the hash bucket that the string specified by the
** arguments to this function belongs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxHashString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ret</name> <operator>%</operator> <name>IDX_HASH_SIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If zKey is already present in the hash table, return non-zero and do
** nothing. Otherwise, add an entry with key zKey and payload string zVal to
** the hash table passed as the second argument. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxHashAdd</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>idxHashString</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>zVal</name></expr> ?</condition><then> <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHash</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nKey</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHashEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nKey</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <name>nVal</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pEntry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name><index>[<expr><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If zKey/nKey is present in the hash table, return a pointer to the 
** hash-entry object.
*/</comment>
<function><type><specifier>static</specifier> <name>IdxHashEntry</name> <modifier>*</modifier></type><name>idxHashFind</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKey</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>idxHashString</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHash</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nKey</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>pEntry</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the hash table contains an entry with a key equal to the string
** passed as the final two arguments to this function, return a pointer
** to the payload string. Otherwise, if zKey/nKey is not present in the
** hash table, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxHashSearch</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>idxHashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
** variable to point to a copy of nul-terminated string zColl.
*/</comment>
<function><type><specifier>static</specifier> <name>IdxConstraint</name> <modifier>*</modifier></type><name>idxNewConstraint</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nColl</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>IdxConstraint</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxConstraint</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nColl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zColl</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>nColl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An error associated with database handle db has just occurred. Pass
** the error message to callback function xOut.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxDatabaseError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* Write error here */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pzErrmsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Prepare an SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPrepareStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle to compile against */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,          <comment type="block">/* OUT: Compiled SQL statement */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>,                <comment type="block">/* OUT: sqlite3_malloc()ed error message */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>                <comment type="block">/* SQL statement to compile */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Prepare an SQL statement using the results of a printf() formatting.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPrintfPrepareStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle to compile against */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,          <comment type="block">/* OUT: Compiled SQL statement */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>,                <comment type="block">/* OUT: sqlite3_malloc()ed error message */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>,               <comment type="block">/* printf() format of SQL statement */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                             <comment type="block">/* Trailing printf() arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************************************
** Beginning of virtual table implementation.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ExpertVtab</name></name></type> <name>ExpertVtab</name>;</typedef>
<struct>struct <name>ExpertVtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ExpertCsr</name></name></type> <name>ExpertCsr</name>;</typedef>
<struct>struct <name>ExpertCsr</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>expertDequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This function is the implementation of both the xConnect and xCreate
** methods of the r-tree virtual table.
**
**   argv[0]   -&gt; module name
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; column names...
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name> <init>= <expr><operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><name>pAux</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"internal error!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCreateTable</name> <init>= <expr><call><name>expertDequote</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCreateTable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCreateTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpertVtab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExpert</name></name> <operator>=</operator> <name>pExpert</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pExpert</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreateTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opmask</name> <init>= 
    <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name> <operator>|</operator> <name>SQLITE_INDEX_CONSTRAINT_GT</name> <operator>|</operator>
    <name>SQLITE_INDEX_CONSTRAINT_LT</name> <operator>|</operator> <name>SQLITE_INDEX_CONSTRAINT_GE</name> <operator>|</operator>
    <name>SQLITE_INDEX_CONSTRAINT_LE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pScan</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxScan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pScan</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Link the new scan object into the list */</comment>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pNextScan</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pExpert</name><operator>-&gt;</operator><name>pScan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExpert</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <name>pScan</name></expr>;</expr_stmt>

    <comment type="block">/* Add the constraints to the IdxScan object */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>usable</name></name> 
       <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>iPk</name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;</operator> <name>opmask</name><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><call><name>sqlite3_vtab_collation</name><argument_list>(<argument><expr><name>pIdxInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>idxNewConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bRange</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Add the ORDER BY to the IdxScan object */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>idxNewConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bDesc</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLink</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000000.0</literal> <operator>/</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>azData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>azData</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pRowid</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xOpen method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pVTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpertCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name><operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xClose method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Virtual table module xEof method.
**
** Return non-zero if the cursor does not currently point to a valid 
** record (i.e if the scan has finished), or zero otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xNext method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xRowid method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cur</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xColumn method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xFilter method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name> <init>= <expr><name><name>pVtab</name><operator>-&gt;</operator><name>pExpert</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>pExpert</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pVtab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>,
        <argument><expr><literal type="string">"SELECT * FROM main.%Q WHERE sample()"</literal></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expertNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxRegisterVtab</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>expertModule</name> <init>= <expr><block>{
    <expr><literal type="number">2</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><name>expertConnect</name></expr>,                <comment type="block">/* xCreate - create a table */</comment>
    <expr><name>expertConnect</name></expr>,                <comment type="block">/* xConnect - connect to an existing table */</comment>
    <expr><name>expertBestIndex</name></expr>,              <comment type="block">/* xBestIndex - Determine search strategy */</comment>
    <expr><name>expertDisconnect</name></expr>,             <comment type="block">/* xDisconnect - Disconnect from a table */</comment>
    <expr><name>expertDisconnect</name></expr>,             <comment type="block">/* xDestroy - Drop a table */</comment>
    <expr><name>expertOpen</name></expr>,                   <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>expertClose</name></expr>,                  <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>expertFilter</name></expr>,                 <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>expertNext</name></expr>,                   <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>expertEof</name></expr>,                    <comment type="block">/* xEof */</comment>
    <expr><name>expertColumn</name></expr>,                 <comment type="block">/* xColumn - read data */</comment>
    <expr><name>expertRowid</name></expr>,                  <comment type="block">/* xRowid - read data */</comment>
    <expr><name>expertUpdate</name></expr>,                 <comment type="block">/* xUpdate - write data */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xBegin - begin transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSync - sync transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCommit - commit transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollback - rollback transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xFindFunction - function overloading */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRename - rename the table */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><literal type="string">"expert"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expertModule</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** End of virtual table implementation.
*************************************************************************/</comment>
<comment type="block">/*
** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
** is called, set it to the return value of sqlite3_finalize() before
** returning. Otherwise, discard the sqlite3_finalize() return value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxFinalize</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to allocate an IdxTable structure corresponding to table zTab
** in the main database of connection db. If successful, set (*ppOut) to
** point to the new object and return SQLITE_OK. Otherwise, return an
** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
** set to point to an error string.
**
** It is the responsibility of the caller to eventually free either the
** IdxTable object or error message using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxGetTableInfo</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection to read details from */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>IdxTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>,               <comment type="block">/* OUT: New object (if successful) */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (if not) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nTab</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IdxTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nTab</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA table_xinfo=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zColSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zColSeq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColSeq</name> <operator>=</operator> <literal type="string">"binary"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zColSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPk</name> <operator>+=</operator> <operator>(</operator><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IdxColumn</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nCol</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>IdxColumn</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>iPk</name> <operator>=</operator> <operator>(</operator><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nPk</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zColSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zColSeq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColSeq</name> <operator>=</operator> <literal type="string">"binary"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zColSeq</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>zColl</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zColSeq</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pNew</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>nTab</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is set to anything other than 
** SQLITE_OK when it is called.
**
** If *pRc is initially set to SQLITE_OK, then the text specified by
** the printf() style arguments is appended to zIn and the result returned
** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
** zIn before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>idxAppendText</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAppend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><ternary><condition><expr><name>zIn</name></expr> ?</condition><then> <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAppend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zAppend</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zAppend</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAppend</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nIn</name> <operator>+</operator> <name>nAppend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zAppend</name> <operator>&amp;&amp;</operator> <name>zRet</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nIn</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zRet</name><index>[<expr><name>nIn</name></expr>]</index></name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>, <argument><expr><name>nAppend</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if zId must be quoted in order to use it as an SQL
** identifier, or false otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxIdentifierRequiresQuotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function appends an index column definition suitable for constraint
** pCons to the string passed as zIn and returns the result.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>idxAppendColDefn</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>,                      <comment type="block">/* Column defn accumulated so far */</comment>
  <parameter><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                 <comment type="block">/* Table index will be created on */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCons</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxColumn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCons</name><operator>-&gt;</operator><name>iCol</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"%Q"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %Q"</literal></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>bDesc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search database dbm for an index compatible with the one idxCreateFromCons()
** would create from arguments pScan, pEq and pTail. If no error occurs and 
** such an index is found, return non-zero. Or, if no such index is found,
** return zero.
**
** If an error occurs, set *pRc to an SQLite error code and return zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindCompatible</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* OUT: Error code */</comment>
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>dbm</name></decl></parameter>,                   <comment type="block">/* Database to search */</comment>
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,                 <comment type="block">/* Scan for table to search for index on */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl></parameter>,             <comment type="block">/* List of == constraints */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>            <comment type="block">/* List of range constraints */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIdxList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Number of elements in pEq */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Count the elements in list pEq */</comment>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nEq</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdxList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_list=%Q"</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bMatch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><name>pTail</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Zero the IdxConstraint.bFlag values in the pEq list */</comment>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_xInfo=%Q"</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>&lt;</operator><name>nEq</name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>iCol</name></name><operator>!=</operator><name>iCol</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pT</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pT</name><operator>-&gt;</operator><name>iCol</name></name><operator>!=</operator><name>iCol</name> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pT</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pT</name> <operator>=</operator> <name><name>pT</name><operator>-&gt;</operator><name>pLink</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bMatch</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Callback for sqlite3_exec() with query with leading count(*) column.
 * The first argument is expected to be an int*, referent to be incremented
 * if that leading column is not exactly '0'.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>countNonzeros</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nc</name></decl></parameter>,
                         <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>azResults</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>azColumns</name><index>[]</index></name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>azColumns</name></expr>;</expr_stmt>  <comment type="block">/* Suppress unused parameter warning */</comment>
  <if_stmt><if>if<condition>( <expr><name>nc</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>azResults</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'0'</literal> <operator>||</operator> <name><name>azResults</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pCount</name><operator>)</operator> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateFromCons</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl></parameter>, 
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pEq</name> <operator>||</operator> <name>pTail</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>idxFindCompatible</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>, <argument><expr><name>pTail</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCons</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>pCons</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pCons</name></expr>;</condition> <incr><expr><name>pCons</name><operator>=</operator><name><name>pCons</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendColDefn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>pCons</name><operator>=</operator><name>pTail</name></expr>;</init> <condition><expr><name>pCons</name></expr>;</condition> <incr><expr><name>pCons</name><operator>=</operator><name><name>pCons</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendColDefn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Hash the list of columns to come up with a name for the index */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>quoteTable</name> <init>= <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Index name */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>collisions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFind</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zCols</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>h</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>h</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name><name>zCols</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s_idx_%08x"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* Is is unique among table, view and index names? */</comment>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"SELECT count(*) FROM sqlite_schema WHERE name=%Q"</literal>
          <literal type="string">" AND type in ('index','table','view')"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zFind</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>zFind</name></expr></argument>, <argument><expr><name>countNonzeros</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>collisions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>collisions</name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>collisions</name><operator>&lt;</operator><literal type="number">50</literal> <operator>&amp;&amp;</operator> <name>zName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>collisions</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This return means "Gave up trying to find a unique index name." */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_TIMEOUT</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>quoteTable</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"CREATE INDEX \"%w\" ON \"%w\"(%s)"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"CREATE INDEX %s ON %s(%s)"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zIdx</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pzErrmsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_TIMEOUT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>idxHashAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if list pList (linked by IdxConstraint.pLink) contains
** a constraint compatible with *p. Otherwise return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindConstraint</name><parameter_list>(<parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCmp</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCmp</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>pCmp</name></expr>;</condition> <incr><expr><name>pCmp</name><operator>=</operator><name><name>pCmp</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name><operator>==</operator><name><name>pCmp</name><operator>-&gt;</operator><name>iCol</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateFromWhere</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,                 <comment type="block">/* Create indexes for this scan */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>            <comment type="block">/* range/ORDER BY constraints for inclusion */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCon</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Gather up all the == constraints. */</comment>
  <for>for<control>(<init><expr><name>pCon</name><operator>=</operator><name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name></expr>;</init> <condition><expr><name>pCon</name></expr>;</condition> <incr><expr><name>pCon</name><operator>=</operator><name><name>pCon</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>pTail</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCon</name><operator>-&gt;</operator><name>pLink</name></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>pCon</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Create an index using the == constraints collected above. And the
  ** range constraint/ORDER BY terms passed in by the caller, if any. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromCons</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no range/ORDER BY passed by the caller, create a version of the
  ** index for each range constraint.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pCon</name><operator>=</operator><name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pCon</name></expr>;</condition> <incr><expr><name>pCon</name><operator>=</operator><name><name>pCon</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCon</name><operator>-&gt;</operator><name>pLink</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>pTail</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromCons</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create candidate indexes in database [dbm] based on the data in 
** linked-list pScan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateCandidates</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr>;</init> <condition><expr><name>pIter</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNextScan</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromWhere</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pOrder</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromWhere</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting at pConstraint.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxConstraintFree</name><parameter_list>(<parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pConstraint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pConstraint</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting from pScan up until pLast
** (pLast is not freed).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxScanFree</name><parameter_list>(<parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>, <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pScan</name></expr>;</init> <condition><expr><name>p</name><operator>!=</operator><name>pLast</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextScan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting from pStatement up 
** until pLast (pLast is not freed).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxStatementFree</name><parameter_list>(<parameter><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStatement</name></decl></parameter>, <parameter><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pStatement</name></expr>;</init> <condition><expr><name>p</name><operator>!=</operator><name>pLast</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zEQP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free the linked list of IdxTable objects starting at pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxTableFree</name><parameter_list>(<parameter><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pTab</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free the linked list of IdxWrite objects starting at pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxWriteFree</name><parameter_list>(<parameter><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pTab</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block">/*
** This function is called after candidate indexes have been created. It
** runs all the queries to see which indexes they prefer, and populates
** IdxStatement.zIdx and IdxStatement.zEQP with the results.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindIndexes</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                         <comment type="block">/* OUT: Error message (sqlite3_malloc) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>IdxHash</name></type> <name>hIdx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>idxHashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pStmt</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pStmt</name></expr>;</condition> <incr><expr><name>pStmt</name><operator>=</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pExplain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExplain</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>,
        <argument><expr><literal type="string">"EXPLAIN QUERY PLAN %s"</literal></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* int iId = sqlite3_column_int(pExplain, 0); */</comment>
      <comment type="block">/* int iParent = sqlite3_column_int(pExplain, 1); */</comment>
      <comment type="block">/* int iNotUsed = sqlite3_column_int(pExplain, 2); */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDetail</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nDetail</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zDetail</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nDetail</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDetail</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">13</literal><operator>&lt;</operator><name>nDetail</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">" USING INDEX "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">13</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">22</literal><operator>&lt;</operator><name>nDetail</name> 
            <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">" USING COVERING INDEX "</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">22</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zIdx</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><name><name>zIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name><operator>!=</operator><literal type="char">' '</literal> <operator>||</operator> <name><name>zIdx</name><index>[<expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'('</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nIdx</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>idxHashSearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>idxHashAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>find_indexes_out</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name><name>zDetail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>hIdx</name><operator>.</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

 <label><name>find_indexes_out</name>:</label>
  <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxAuthCallback</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z3</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z4</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTrigger</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>z4</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>zTrigger</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pWrite</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</init> <condition><expr><name>pWrite</name></expr>;</condition> <incr><expr><name>pWrite</name><operator>=</operator><name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name>pTab</name> <operator>&amp;&amp;</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>eOp</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pWrite</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pWrite</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxWrite</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>eOp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name> <operator>=</operator> <name>pWrite</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxProcessOneTrigger</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInt</name> <init>= <expr><name>UNIQUE_TABLE_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDrop</name> <init>= <expr><literal type="string">"DROP TABLE "</literal> <name>UNIQUE_TABLE_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= 
    <expr><literal type="string">"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema "</literal>
    <literal type="string">"WHERE tbl_name = %Q AND type IN ('table', 'trigger') "</literal>
    <literal type="string">"ORDER BY type;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Create the table and its triggers in the temp schema */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCreate</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCreate</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Rename the table in the temp schema to zInt */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE temp.%Q RENAME TO %Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_INSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %Q VALUES("</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"%s?"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %Q SET "</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"%s%Q=?"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>, 
            <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"DELETE FROM %Q"</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zWrite</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zDrop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxProcessTriggers</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pFirst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pFirst</name><operator>!=</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pFirst</name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pIter</name><operator>!=</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxProcessOneTrigger</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>pFirst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateVtabSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>idxRegisterVtab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* For each table in the main db schema:
  **
  **   1) Add an entry to the p-&gt;pTable list, and
  **   2) Create the equivalent virtual table in dbv.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSchema</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>,
      <argument><expr><literal type="string">"SELECT type, name, sql, 1 FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%' "</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT type, name, sql, 2 FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type = 'trigger'"</literal>
      <literal type="string">"  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') "</literal>
      <literal type="string">"ORDER BY 4, 1"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zType</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'v'</literal> <operator>||</operator> <name><name>zType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxGetTableInfo</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTab</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zInner</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOuter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>

        <comment type="block">/* The statement the vtab will pass to sqlite3_declare_vtab() */</comment>
        <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>, <argument><expr><literal type="string">"%s%Q COLLATE %s"</literal></expr></argument>, 
              <argument><expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zColl</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The CVT statement to create the vtab */</comment>
        <expr_stmt><expr><name>zOuter</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
            <argument><expr><literal type="string">"CREATE VIRTUAL TABLE %Q USING expert(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zOuter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>IdxSampleCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iTarget</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>target</name></decl>;</decl_stmt>                  <comment type="block">/* Target nRet/nRow value */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRow</name></decl>;</decl_stmt>                    <comment type="block">/* Number of rows seen */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRet</name></decl>;</decl_stmt>                    <comment type="block">/* Number of rows returned */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>idxSampleFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxSampleCtx</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>IdxSampleCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name><operator>==</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bRet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>bRet</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nRet</name></name> <operator>/</operator> <name><name>p</name><operator>-&gt;</operator><name>nRow</name></name><operator>)</operator> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>rnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRet</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>rnd</name> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>iTarget</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>bRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRet</name></name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>bRet</name></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>IdxRemCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nSlot</name></decl>;</decl_stmt>
  <struct>struct <name>IdxRemSlot</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                    <comment type="block">/* SQLITE_NULL, INTEGER, REAL, TEXT, BLOB */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name></decl>;</decl_stmt>                     <comment type="block">/* SQLITE_INTEGER value */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>                  <comment type="block">/* SQLITE_FLOAT value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                    <comment type="block">/* Bytes of space allocated at z */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                        <comment type="block">/* Size of buffer z */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                      <comment type="block">/* SQLITE_TEXT/BLOB value */</comment>
  }</block> <decl><name><name>aSlot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</struct>
}</block>;</struct>

<comment type="block">/*
** Implementation of scalar function rem().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxRemFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemCtx</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>IdxRemCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemSlot</name></name> <modifier>*</modifier></type><name>pSlot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSlot</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iSlot</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSlot</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aSlot</name><index>[<expr><name>iSlot</name></expr>]</index></name></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>

    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>iVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>rVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>

    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>iVal</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>rVal</name></name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name><name>pSlot</name><operator>-&gt;</operator><name>nByte</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nByte</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pData</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxLargestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMax</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMax</name> <init>= 
    <expr><literal type="string">"SELECT max(i.seqno) FROM "</literal>
    <literal type="string">"  sqlite_schema AS s, "</literal>
    <literal type="string">"  pragma_index_list(s.name) AS l, "</literal>
    <literal type="string">"  pragma_index_info(l.name) AS i "</literal>
    <literal type="string">"WHERE s.type = 'table'"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMax</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pMax</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pMax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPopulateOneStat1</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIndexXInfo</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteStat</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrder</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aStat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Formulate the query text */</comment>
  <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zComma</name> <init>= <expr><ternary><condition><expr><name>zCols</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, 
        <argument><expr><literal type="string">"%sx.%Q IS rem(%d, x.%Q) COLLATE %s"</literal></expr></argument>, <argument><expr><name>zComma</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOrder</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>zComma</name></expr></argument>, <argument><expr><operator>++</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT %s FROM %Q x ORDER BY %s"</literal></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT %s FROM temp."</literal><name>UNIQUE_TABLE_NAME</name><literal type="string">" x ORDER BY %s"</literal></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Formulate the query text */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbrem</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>dbrem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aStat</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <for>for<control>(<comment type="block">/*no-op*/</comment><init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>aStat</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>s0</name> <init>= <expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zStat</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zStat</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zStat</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>s0</name><operator>+</operator><name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>zStat</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>idxHashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name> <operator>=</operator> <name>zStat</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxBuildSampleTable</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>,<argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal><name>UNIQUE_TABLE_NAME</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"CREATE TABLE temp."</literal> <name>UNIQUE_TABLE_NAME</name> <literal type="string">" AS SELECT * FROM %Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of sqlite3_expert_analyze(). Candidate
** indexes have already been created in database sqlite3expert.dbm, this
** function populates sqlite_stat1 table in the same database.
**
** The stat1 data is generated by querying the 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPopulateStat1</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name> <init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemCtx</name></name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxSampleCtx</name></name></type> <name>samplectx</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPrev</name> <init>= <expr><operator>-</operator><literal type="number">100000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIndexXInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAllIndex</name> <init>=
    <expr><literal type="string">"SELECT s.rowid, s.name, l.name FROM "</literal>
    <literal type="string">"  sqlite_schema AS s, "</literal>
    <literal type="string">"  pragma_index_list(s.name) AS l "</literal>
    <literal type="string">"WHERE s.type = 'table'"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIndexXInfo</name> <init>= 
    <expr><literal type="string">"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWrite</name> <init>= <expr><literal type="string">"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)"</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If iSample==0, no sqlite_stat1 data is required. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxLargestIndex</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMax</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMax</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE; PRAGMA writable_schema=1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>IdxRemCtx</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>IdxRemSlot</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nMax</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <operator>(</operator>struct <name>IdxRemCtx</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbrem</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(
        <argument><expr><name>dbrem</name></expr></argument>, <argument><expr><literal type="string">"rem"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>, <argument><expr><name>idxRemFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"sample"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>samplectx</name></expr></argument>, <argument><expr><name>idxSampleFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>nSlot</name></name> <operator>=</operator> <name>nMax</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAllIndex</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zAllIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIndexXInfo</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWrite</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&lt;</operator><literal type="number">100</literal> <operator>&amp;&amp;</operator> <name>iPrev</name><operator>!=</operator><name>iRowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>target</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>iTarget</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iSample</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>nRow</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>nRet</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxBuildSampleTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPopulateOneStat1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><name>pWrite</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iRowid</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&lt;</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, 
        <argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal> <name>UNIQUE_TABLE_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pAllIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>nSlot</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal><name>UNIQUE_TABLE_NAME</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new sqlite3expert object.
*/</comment>
<function><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>sqlite3_expert_new</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3expert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open two in-memory databases to work with. The "vtab database" (dbv)
  ** will contain a virtual table corresponding to each real table in
  ** the user database schema, and a copy of each view. It is used to
  ** collect information regarding the WHERE, ORDER BY and other clauses
  ** of the user's query.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSample</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  

  <comment type="block">/* Copy the entire schema of database [db] into [dbm]. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSql</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, 
        <argument><expr><literal type="string">"SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%'"</literal>
        <literal type="string">" AND sql NOT LIKE 'CREATE VIRTUAL %%'"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create the vtab schema */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateVtabSchema</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the auth callback with dbv */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>idxAuthCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an error has occurred, free the new object and reutrn NULL. Otherwise,
  ** return the new sqlite3expert handle.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_expert_destroy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure an sqlite3expert object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_config</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>EXPERT_CONFIG_SAMPLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an SQL statement to the analysis.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* From sqlite3_expert_new() */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL statement to add */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message (if any) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScanOrig</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmtOrig</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStmt</name> <init>= <expr><name>zSql</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zStmt</name> <operator>&amp;&amp;</operator> <name><name>zStmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>IdxStatement</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxStatement</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name><operator>-&gt;</operator><name>iId</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>idxScanFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><name>pScanOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxStatementFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></argument>, <argument><expr><name>pStmtOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <name>pScanOrig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name> <operator>=</operator> <name>pStmtOrig</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3_expert_analyze</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>

  <comment type="block">/* Do trigger processing to collect any extra IdxScan structures */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxProcessTriggers</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create candidate indexes within the in-memory database file */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateCandidates</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if <condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_TIMEOUT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pzErr</name></expr> )</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"Cannot find a unique index name to propose."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate the stat1 data */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPopulateStat1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Formulate the EXPERT_REPORT_CANDIDATES text */</comment>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name><operator>.</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr></argument>, 
        <argument><expr><literal type="string">"%s;%s%s\n"</literal></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr></argument>, 
        <argument><expr><ternary><condition><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr> ?</condition><then> <expr><literal type="string">" -- stat1: "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Figure out which of the candidate indexes are preferred by the query
  ** planner and report the results to the user.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxFindIndexes</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the total number of statements that have been added to this
** sqlite3expert using sqlite3_expert_sql().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_count</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRet</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name><operator>-&gt;</operator><name>iId</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a component of the report.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_expert_report</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eReport</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pStmt</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</init> <condition><expr><name>pStmt</name> <operator>&amp;&amp;</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>iId</name></name><operator>!=</operator><name>iStmt</name></expr>;</condition> <incr><expr><name>pStmt</name><operator>=</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <switch>switch<condition>( <expr><name>eReport</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>EXPERT_REPORT_SQL</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_INDEXES</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_PLAN</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_CANDIDATES</name></expr>:</case>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an sqlite3expert object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_expert_destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxScanFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxStatementFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxTableFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxWriteFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
