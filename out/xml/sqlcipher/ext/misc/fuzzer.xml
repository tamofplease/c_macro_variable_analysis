<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/fuzzer.c"><comment type="block">/*
** 2011 March 24
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** Code for a demonstration virtual table that generates variations
** on an input word at increasing edit distances from the original.
**
** A fuzzer virtual table is created like this:
**
**     CREATE VIRTUAL TABLE f USING fuzzer(&lt;fuzzer-data-table&gt;);
**
** When it is created, the new fuzzer table must be supplied with the
** name of a "fuzzer data table", which must reside in the same database
** file as the new fuzzer table. The fuzzer data table contains the various
** transformations and their costs that the fuzzer logic uses to generate
** variations.
**
** The fuzzer data table must contain exactly four columns (more precisely,
** the statement "SELECT * FROM &lt;fuzzer_data_table&gt;" must return records
** that consist of four columns). It does not matter what the columns are
** named. 
**
** Each row in the fuzzer data table represents a single character
** transformation. The left most column of the row (column 0) contains an
** integer value - the identifier of the ruleset to which the transformation
** rule belongs (see "MULTIPLE RULE SETS" below). The second column of the
** row (column 0) contains the input character or characters. The third 
** column contains the output character or characters. And the fourth column
** contains the integer cost of making the transformation. For example:
**
**    CREATE TABLE f_data(ruleset, cFrom, cTo, Cost);
**    INSERT INTO f_data(ruleset, cFrom, cTo, Cost) VALUES(0, '', 'a', 100);
**    INSERT INTO f_data(ruleset, cFrom, cTo, Cost) VALUES(0, 'b', '', 87);
**    INSERT INTO f_data(ruleset, cFrom, cTo, Cost) VALUES(0, 'o', 'oe', 38);
**    INSERT INTO f_data(ruleset, cFrom, cTo, Cost) VALUES(0, 'oe', 'o', 40);
**
** The first row inserted into the fuzzer data table by the SQL script
** above indicates that the cost of inserting a letter 'a' is 100.  (All 
** costs are integers.  We recommend that costs be scaled so that the 
** average cost is around 100.) The second INSERT statement creates a rule
** saying that the cost of deleting a single letter 'b' is 87.  The third
** and fourth INSERT statements mean that the cost of transforming a
** single letter "o" into the two-letter sequence "oe" is 38 and that the
** cost of transforming "oe" back into "o" is 40.
**
** The contents of the fuzzer data table are loaded into main memory when
** a fuzzer table is first created, and may be internally reloaded by the
** system at any subsequent time. Therefore, the fuzzer data table should be 
** populated before the fuzzer table is created and not modified thereafter.
** If you do need to modify the contents of the fuzzer data table, it is
** recommended that the associated fuzzer table be dropped, the fuzzer data
** table edited, and the fuzzer table recreated within a single transaction.
** Alternatively, the fuzzer data table can be edited then the database
** connection can be closed and reopened.
**
** Once it has been created, the fuzzer table can be queried as follows:
**
**    SELECT word, distance FROM f
**     WHERE word MATCH 'abcdefg'
**       AND distance&lt;200;
**
** This first query outputs the string "abcdefg" and all strings that
** can be derived from that string by appling the specified transformations.
** The strings are output together with their total transformation cost
** (called "distance") and appear in order of increasing cost.  No string
** is output more than once.  If there are multiple ways to transform the
** target string into the output string then the lowest cost transform is
** the one that is returned.  In the example, the search is limited to 
** strings with a total distance of less than 200.
**
** The fuzzer is a read-only table.  Any attempt to DELETE, INSERT, or
** UPDATE on a fuzzer table will throw an error.
**
** It is important to put some kind of a limit on the fuzzer output.  This
** can be either in the form of a LIMIT clause at the end of the query,
** or better, a "distance&lt;NNN" constraint where NNN is some number.  The
** running time and memory requirement is exponential in the value of NNN 
** so you want to make sure that NNN is not too big.  A value of NNN that
** is about twice the average transformation cost seems to give good results.
**
** The fuzzer table can be useful for tasks such as spelling correction.
** Suppose there is a second table vocabulary(w) where the w column contains
** all correctly spelled words.   Let $word be a word you want to look up.
**
**   SELECT vocabulary.w FROM f, vocabulary
**    WHERE f.word MATCH $word
**      AND f.distance&lt;=200
**      AND f.word=vocabulary.w
**    LIMIT 20
**
** The query above gives the 20 closest words to the $word being tested.
** (Note that for good performance, the vocubulary.w column should be
** indexed.)
**
** A similar query can be used to find all words in the dictionary that
** begin with some prefix $prefix:
**
**   SELECT vocabulary.w FROM f, vocabulary
**    WHERE f.word MATCH $prefix
**      AND f.distance&lt;=200
**      AND vocabulary.w BETWEEN f.word AND (f.word || x'F7BFBFBF')
**    LIMIT 50
**
** This last query will show up to 50 words out of the vocabulary that
** match or nearly match the $prefix.
**
** MULTIPLE RULE SETS
**
** Normally, the "ruleset" value associated with all character transformations
** in the fuzzer data table is zero. However, if required, the fuzzer table
** allows multiple rulesets to be defined. Each query uses only a single
** ruleset. This allows, for example, a single fuzzer table to support 
** multiple languages.
**
** By default, only the rules from ruleset 0 are used. To specify an 
** alternative ruleset, a "ruleset = ?" expression must be added to the
** WHERE clause of a SELECT, where ? is the identifier of the desired 
** ruleset. For example:
**
**   SELECT vocabulary.w FROM f, vocabulary
**    WHERE f.word MATCH $word
**      AND f.distance&lt;=200
**      AND f.word=vocabulary.w
**      AND f.ruleset=1  -- Specify the ruleset to use here
**    LIMIT 20
**
** If no "ruleset = ?" constraint is specified in the WHERE clause, ruleset 
** 0 is used.
**
** LIMITS
**
** The maximum ruleset number is 2147483647.  The maximum length of either
** of the strings in the second or third column of the fuzzer data table
** is 50 bytes.  The maximum cost on a rule is 1000.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>

<comment type="block">/* If SQLITE_DEBUG is not defined, disable assert statements. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NDEBUG</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Forward declaration of objects used by this implementation
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>fuzzer_vtab</name></name></type> <name>fuzzer_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>fuzzer_cursor</name></name></type> <name>fuzzer_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>fuzzer_rule</name></name></type> <name>fuzzer_rule</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>fuzzer_seen</name></name></type> <name>fuzzer_seen</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>fuzzer_stem</name></name></type> <name>fuzzer_stem</name>;</typedef>

<comment type="block">/*
** Various types.
**
** fuzzer_cost is the "cost" of an edit operation.
**
** fuzzer_len is the length of a matching string.  
**
** fuzzer_ruleid is an ruleset identifier.
*/</comment>
<typedef>typedef <type><name>int</name></type> <name>fuzzer_cost</name>;</typedef>
<typedef>typedef <type><name>signed</name> <name>char</name></type> <name>fuzzer_len</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>fuzzer_ruleid</name>;</typedef>

<comment type="block">/*
** Limits
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_MX_LENGTH</name></cpp:macro>           <cpp:value>50</cpp:value></cpp:define>   <comment type="block">/* Maximum length of a rule string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_MX_RULEID</name></cpp:macro>   <cpp:value>2147483647</cpp:value></cpp:define>   <comment type="block">/* Maximum rule ID */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_MX_COST</name></cpp:macro>           <cpp:value>1000</cpp:value></cpp:define>   <comment type="block">/* Maximum single-rule cost */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_MX_OUTPUT_LENGTH</name></cpp:macro>   <cpp:value>100</cpp:value></cpp:define>   <comment type="block">/* Maximum length of an output string */</comment>


<comment type="block">/*
** Each transformation rule is stored as an instance of this object.
** All rules are kept on a linked list sorted by rCost.
*/</comment>
<struct>struct <name>fuzzer_rule</name> <block>{
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>         <comment type="block">/* Next rule in order of increasing rCost */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl>;</decl_stmt>                <comment type="block">/* Transform from */</comment>
  <decl_stmt><decl><type><name>fuzzer_cost</name></type> <name>rCost</name></decl>;</decl_stmt>          <comment type="block">/* Cost of this transformation */</comment>
  <decl_stmt><decl><type><name>fuzzer_len</name></type> <name>nFrom</name></decl>, <decl><type ref="prev"/><name>nTo</name></decl>;</decl_stmt>      <comment type="block">/* Length of the zFrom and zTo strings */</comment>
  <decl_stmt><decl><type><name>fuzzer_ruleid</name></type> <name>iRuleset</name></decl>;</decl_stmt>     <comment type="block">/* The rule set to which this rule belongs */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTo</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Transform to (extra space appended) */</comment>
}</block>;</struct>

<comment type="block">/*
** A stem object is used to generate variants.  It is also used to record
** previously generated outputs.
**
** Every stem is added to a hash table as it is output.  Generation of
** duplicate stems is suppressed.
**
** Active stems (those that might generate new outputs) are kepts on a linked
** list sorted by increasing cost.  The cost is the sum of rBaseCost and
** pRule-&gt;rCost.
*/</comment>
<struct>struct <name>fuzzer_stem</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBasis</name></decl>;</decl_stmt>              <comment type="block">/* Word being fuzzed */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>  <comment type="block">/* Current rule to apply */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>        <comment type="block">/* Next stem in rCost order */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pHash</name></decl>;</decl_stmt>        <comment type="block">/* Next stem with same hash on zBasis */</comment>
  <decl_stmt><decl><type><name>fuzzer_cost</name></type> <name>rBaseCost</name></decl>;</decl_stmt>     <comment type="block">/* Base cost of getting to zBasis */</comment>
  <decl_stmt><decl><type><name>fuzzer_cost</name></type> <name>rCostX</name></decl>;</decl_stmt>        <comment type="block">/* Precomputed rBaseCost + pRule-&gt;rCost */</comment>
  <decl_stmt><decl><type><name>fuzzer_len</name></type> <name>nBasis</name></decl>;</decl_stmt>         <comment type="block">/* Length of the zBasis string */</comment>
  <decl_stmt><decl><type><name>fuzzer_len</name></type> <name>n</name></decl>;</decl_stmt>              <comment type="block">/* Apply pRule at this character offset */</comment>
}</block>;</struct>

<comment type="block">/* 
** A fuzzer virtual-table object 
*/</comment>
<struct>struct <name>fuzzer_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zClassName</name></decl>;</decl_stmt>          <comment type="block">/* Name of this class.  Default: "fuzzer" */</comment>
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>        <comment type="block">/* All active rules in this fuzzer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>               <comment type="block">/* Number of active cursors */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_HASH</name></cpp:macro>  <cpp:value>4001</cpp:value></cpp:define>    <comment type="block">/* Hash table size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUZZER_NQUEUE</name></cpp:macro>  <cpp:value>20</cpp:value></cpp:define>    <comment type="block">/* Number of slots on the stem queue */</comment>

<comment type="block">/* A fuzzer cursor object */</comment>
<struct>struct <name>fuzzer_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* The rowid of the current word */</comment>
  <decl_stmt><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>        <comment type="block">/* The virtual table this cursor belongs to */</comment>
  <decl_stmt><decl><type><name>fuzzer_cost</name></type> <name>rLimit</name></decl>;</decl_stmt>        <comment type="block">/* Maximum cost of any term */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl>;</decl_stmt>        <comment type="block">/* Stem with smallest rCostX */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pDone</name></decl>;</decl_stmt>        <comment type="block">/* Stems already processed to completion */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name><name>aQueue</name><index>[<expr><name>FUZZER_NQUEUE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Queue of stems with higher rCostX */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxQueue</name></decl>;</decl_stmt>               <comment type="block">/* Largest used index in aQueue[] */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>                <comment type="block">/* Temporary use buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>                  <comment type="block">/* Bytes allocated for zBuf */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStem</name></decl>;</decl_stmt>                 <comment type="block">/* Number of stems allocated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRuleset</name></decl>;</decl_stmt>              <comment type="block">/* Only process rules from this ruleset */</comment>
  <decl_stmt><decl><type><name>fuzzer_rule</name></type> <name>nullRule</name></decl>;</decl_stmt>      <comment type="block">/* Null rule used first */</comment>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name><name>apHash</name><index>[<expr><name>FUZZER_HASH</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Hash of previously generated terms */</comment>
}</block>;</struct>

<comment type="block">/*
** The two input rule lists are both sorted in order of increasing
** cost.  Merge them together into a single list, sorted by cost, and
** return a pointer to the head of that list.
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_rule</name> <modifier>*</modifier></type><name>fuzzerMergeRules</name><parameter_list>(<parameter><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_rule</name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTail</name> <operator>=</operator>  <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>rCost</name></name><operator>&lt;=</operator><name><name>pB</name><operator>-&gt;</operator><name>rCost</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pNext</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Statement pStmt currently points to a row in the fuzzer data table. This
** function allocates and populates a fuzzer_rule structure according to
** the content of the row.
**
** If successful, *ppRule is set to point to the new object and SQLITE_OK
** is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
** to an error message and an SQLite error code returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerLoadOneRule</name><parameter_list>(
  <parameter><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Fuzzer virtual table handle */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,            <comment type="block">/* Base rule on statements current row */</comment>
  <parameter><decl><type><name>fuzzer_rule</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRule</name></decl></parameter>,           <comment type="block">/* OUT: New rule object */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRuleset</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCost</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrom</name></decl>;</decl_stmt>                      <comment type="block">/* Size of string zFrom, in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTo</name></decl>;</decl_stmt>                        <comment type="block">/* Size of string zTo, in bytes */</comment>
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New rule object to return */</comment>

  <if_stmt><if>if<condition>( <expr><name>zFrom</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFrom</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zTo</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFrom</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Silently ignore null transformations */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zTo</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppRule</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nCost</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>nCost</name><operator>&gt;</operator><name>FUZZER_MX_COST</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: cost must be between 1 and %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>FUZZER_MX_COST</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name>nFrom</name><operator>&gt;</operator><name>FUZZER_MX_LENGTH</name> <operator>||</operator> <name>nTo</name><operator>&gt;</operator><name>FUZZER_MX_LENGTH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: maximum string length is %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>FUZZER_MX_LENGTH</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>    
  </block_content>}</block></if><if type="elseif">else
  if<condition>( <expr><name><name>iRuleset</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>iRuleset</name></expr></argument>&gt;</argument_list></name><name>FUZZER_MX_RULEID</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: ruleset must be between 0 and %d"</literal></expr></argument>, 
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>FUZZER_MX_RULEID</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>    
  </block_content>}</block></if><else>else<block>{<block_content>

    <expr_stmt><expr><name>pRule</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRule</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nFrom</name> <operator>+</operator> <name>nTo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRule</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name> <operator>=</operator> <name><name>pRule</name><operator>-&gt;</operator><name>zTo</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name> <operator>+=</operator> <name>nTo</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_len</name><operator>)</operator><name>nFrom</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>nTo</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_len</name><operator>)</operator><name>nTo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>rCost</name></name> <operator>=</operator> <name>nCost</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>iRuleset</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>iRuleset</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRule</name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load the content of the fuzzer data table into memory.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerLoadRules</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Virtual fuzzer table to configure */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,                <comment type="block">/* Database containing rules data */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name></decl></parameter>,              <comment type="block">/* Table containing rules data */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* SELECT used to read from rules table */</comment>
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pHead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM %Q.%Q"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>                      <comment type="block">/* finalize() return code */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s: %s has %d columns, expected 4"</literal></expr></argument>,
          <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzerLoadOneRule</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRule</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pRule</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pHead</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pHead</name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All rules are now in a singly linked list starting at pHead. This
  ** block sorts them by cost and then sets fuzzer_vtab.pRule to point to 
  ** point to the head of the sorted list.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <while>while<condition>( <expr><operator>(</operator><name>pX</name> <operator>=</operator> <name>pHead</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pHead</name> <operator>=</operator> <name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>fuzzerMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fuzzerMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>fuzzerMergeRules</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <call><name>fuzzerMergeRules</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* An error has occurred. Setting p-&gt;pRule to point to the head of the
    ** allocated list ensures that the list will be cleaned up in this case.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name>pHead</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function converts an SQL quoted string into an unquoted string
** and returns a pointer to a buffer allocated using sqlite3_malloc() 
** containing the result. The caller should eventually free this buffer
** using sqlite3_free.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fuzzerDequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nIn</name></decl>;</decl_stmt>              <comment type="block">/* Size of input string, in bytes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>                     <comment type="block">/* Output (dequoted) string */</comment>

  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nIn</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Quote character (if any ) */</comment>

    <if_stmt><if>if<condition>( <expr><name>q</name><operator>!=</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nIn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Index of next byte to write to output */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                    <comment type="block">/* Index of next byte to read from input */</comment>

      <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>nIn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xDisconnect/xDestroy method for the fuzzer module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>fuzzer_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xConnect/xCreate method for the fuzzer module. Arguments are:
**
**   argv[0]   -&gt; module name  ("fuzzer")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[3]   -&gt; fuzzer rule table name
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* New virtual table */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zModule</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"%s: wrong number of CREATE VIRTUAL TABLE arguments"</literal></expr></argument>, <argument><expr><name>zModule</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nModule</name></decl>;</decl_stmt>        <comment type="block">/* Length of zModule, in bytes */</comment>

    <expr_stmt><expr><name>nModule</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nModule</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>                 <comment type="block">/* Dequoted name of fuzzer data table */</comment>

      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zClassName</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zClassName</name></name></expr></argument>, <argument><expr><name>zModule</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nModule</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>zTab</name> <operator>=</operator> <call><name>fuzzerDequote</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzerLoadRules</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x(word,distance,ruleset)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fuzzerDisconnect</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name> <operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new fuzzer cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>fuzzer_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all stems in a list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzerClearStemList</name><parameter_list>(<parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>pStem</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pStem</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pStem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStem</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Free up all the memory allocated by a cursor.  Set it rLimit to 0
** to indicate that it is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fuzzerClearCursor</name><parameter_list>(<parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clearHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fuzzerClearStemList</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fuzzerClearStemList</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>FUZZER_NQUEUE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fuzzerClearStemList</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_cost</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>clearHash</name> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nStem</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>apHash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nStem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a fuzzer cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fuzzerClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nCursor</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute the current output term for a fuzzer_stem.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerRender</name><parameter_list>(
  <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>,   <comment type="block">/* The stem to be rendered */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzBuf</name></decl></parameter>,         <comment type="block">/* Write results into this buffer.  realloc if needed */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBuf</name></decl></parameter>            <comment type="block">/* Size of the buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name> <init>= <expr><name><name>pStem</name><operator>-&gt;</operator><name>pRule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Size of output term without nul-term */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                        <comment type="block">/* Buffer to assemble output term in */</comment>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name> <operator>+</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name> <operator>-</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pnBuf</name><operator>)</operator><operator>&lt;</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pzBuf</name><operator>)</operator> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pzBuf</name><operator>)</operator></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><name>pzBuf</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pnBuf</name><operator>)</operator> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">100</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pStem</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>*</operator><name>pzBuf</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pStem</name><operator>-&gt;</operator><name>zBasis</name></name></expr></argument>, <argument><expr><name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>pStem</name><operator>-&gt;</operator><name>zBasis</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zTo</name></name></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name><operator>+</operator><name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pStem</name><operator>-&gt;</operator><name>zBasis</name><index>[<expr><name>n</name><operator>+</operator><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr>]</index></name></expr></argument>, 
           <argument><expr><name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name><operator>-</operator><name>n</name><operator>-</operator><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>z</name><index>[<expr><name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name> <operator>+</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name> <operator>-</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a hash on zBasis.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>fuzzerHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">29</literal><operator>)</operator> <operator>^</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>h</name> <operator>%</operator> <name>FUZZER_HASH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Current cost of a stem
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_cost</name></type> <name>fuzzerCost</name><parameter_list>(<parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pStem</name><operator>-&gt;</operator><name>rCostX</name></name> <operator>=</operator> <name><name>pStem</name><operator>-&gt;</operator><name>rBaseCost</name></name> <operator>+</operator> <name><name>pStem</name><operator>-&gt;</operator><name>pRule</name><operator>-&gt;</operator><name>rCost</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Print a description of a fuzzer_stem on stderr.
*/</comment>
static void fuzzerStemPrint(
  const char *zPrefix,
  fuzzer_stem *pStem,
  const char *zSuffix
){
  if( pStem-&gt;n&lt;0 ){
    fprintf(stderr, "%s[%s](%d)--&gt;self%s",
       zPrefix,
       pStem-&gt;zBasis, pStem-&gt;rBaseCost,
       zSuffix
    );
  }else{
    char *zBuf = 0;
    int nBuf = 0;
    if( fuzzerRender(pStem, &amp;zBuf, &amp;nBuf)!=SQLITE_OK ) return;
    fprintf(stderr, "%s[%s](%d)--&gt;{%s}(%d)%s",
      zPrefix,
      pStem-&gt;zBasis, pStem-&gt;rBaseCost, zBuf, pStem-&gt;,
      zSuffix
    );
    sqlite3_free(zBuf);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return 1 if the string to which the cursor is point has already
** been emitted.  Return 0 if not.  Return -1 on a memory allocation
** failures.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerSeen</name><parameter_list>(<parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pLookup</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>fuzzerRender</name><argument_list>(<argument><expr><name>pStem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>fuzzerHash</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLookup</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pLookup</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pLookup</name><operator>-&gt;</operator><name>zBasis</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pLookup</name> <operator>=</operator> <name><name>pLookup</name><operator>-&gt;</operator><name>pHash</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pLookup</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If argument pRule is NULL, this function returns false.
**
** Otherwise, it returns true if rule pRule should be skipped. A rule 
** should be skipped if it does not belong to rule-set iRuleset, or if
** applying it to stem pStem would create a string longer than 
** FUZZER_MX_OUTPUT_LENGTH bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerSkipRule</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name></decl></parameter>,       <comment type="block">/* Determine whether or not to skip this */</comment>
  <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>,             <comment type="block">/* Stem rule may be applied to */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRuleset</name></decl></parameter>                    <comment type="block">/* Rule-set used by the current query */</comment>
)</parameter_list><block>{<block_content>
  <return>return <expr><name>pRule</name> <operator>&amp;&amp;</operator> <operator>(</operator>
      <operator>(</operator><name><name>pRule</name><operator>-&gt;</operator><name>iRuleset</name></name><operator>!=</operator><name>iRuleset</name><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name> <operator>+</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nTo</name></name> <operator>-</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name><operator>)</operator><operator>&gt;</operator><name>FUZZER_MX_OUTPUT_LENGTH</name>
  <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance a fuzzer_stem to its next value.   Return 0 if there are
** no more values that can be generated by this fuzzer_stem.  Return
** -1 on a memory allocation failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerAdvance</name><parameter_list>(<parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>pRule</name> <operator>=</operator> <name><name>pStem</name><operator>-&gt;</operator><name>pRule</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRule</name><operator>==</operator><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name></name> <operator>||</operator> <name><name>pRule</name><operator>-&gt;</operator><name>iRuleset</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>iRuleset</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name><name>pStem</name><operator>-&gt;</operator><name>n</name></name> <operator>&lt;</operator> <name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name> <operator>-</operator> <name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pStem</name><operator>-&gt;</operator><name>zBasis</name><index>[<expr><name><name>pStem</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>zFrom</name></name></expr></argument>, <argument><expr><name><name>pRule</name><operator>-&gt;</operator><name>nFrom</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* Found a rewrite case.  Make sure it is not a duplicate */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>fuzzerSeen</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pStem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fuzzerCost</name><argument_list>(<argument><expr><name>pStem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>pRule</name> <operator>=</operator> <name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><call><name>fuzzerSkipRule</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>, <argument><expr><name>pStem</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRuleset</name></name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
    <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRule</name> <operator>&amp;&amp;</operator> <call><name>fuzzerCost</name><argument_list>(<argument><expr><name>pStem</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The two input stem lists are both sorted in order of increasing
** rCostX.  Merge them together into a single list, sorted by rCostX, and
** return a pointer to the head of that new list.
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_stem</name> <modifier>*</modifier></type><name>fuzzerMergeStems</name><parameter_list>(<parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_stem</name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTail</name> <operator>=</operator>  <operator>&amp;</operator><name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>rCostX</name></name><operator>&lt;=</operator><name><name>pB</name><operator>-&gt;</operator><name>rCostX</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>head</name><operator>.</operator><name>pNext</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load pCur-&gt;pStem with the lowest-cost stem.  Return a pointer
** to the lowest-cost stem.
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_stem</name> <modifier>*</modifier></type><name>fuzzerLowestCostStem</name><parameter_list>(<parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pBest</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iBest</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBest</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pBest</name><operator>-&gt;</operator><name>rCostX</name></name><operator>&gt;</operator><name><name>pX</name><operator>-&gt;</operator><name>rCostX</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pBest</name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iBest</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for> 
    <if_stmt><if>if<condition>( <expr><name>pBest</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>iBest</name></expr>]</index></name> <operator>=</operator> <name><name>pBest</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <name>pBest</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Insert pNew into queue of pending stems.  Then find the stem
** with the lowest rCostX and move it into pCur-&gt;pStem.
** list.  The insert is done such the pNew is in the correct order
** according to fuzzer_stem.zBaseCost+fuzzer_stem.pRule-&gt;rCost.
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_stem</name> <modifier>*</modifier></type><name>fuzzerInsert</name><parameter_list>(<parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* If pCur-&gt;pStem exists and is greater than pNew, then make pNew
  ** the new pCur-&gt;pStem and insert the old pCur-&gt;pStem instead.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pX</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pX</name><operator>-&gt;</operator><name>rCostX</name></name><operator>&gt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>rCostX</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Insert the new value */</comment>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>fuzzerMergeStems</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>FUZZER_NQUEUE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxQueue</name></name><operator>==</operator><name>FUZZER_NQUEUE</name><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name> <operator>=</operator> <call><name>fuzzerMergeStems</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>FUZZER_NQUEUE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aQueue</name><index>[<expr><name>FUZZER_NQUEUE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pX</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>fuzzerLowestCostStem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new fuzzer_stem.  Add it to the hash table but do not
** link it into either the pCur-&gt;pStem or pCur-&gt;pDone lists.
*/</comment>
<function><type><specifier>static</specifier> <name>fuzzer_stem</name> <modifier>*</modifier></type><name>fuzzerNewStem</name><parameter_list>(
  <parameter><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWord</name></decl></parameter>,
  <parameter><decl><type><name>fuzzer_cost</name></type> <name>rBaseCost</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_rule</name> <modifier>*</modifier></type><name>pRule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zBasis</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nBasis</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_len</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zBasis</name></name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>nBasis</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRule</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pRule</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>fuzzerSkipRule</name><argument_list>(<argument><expr><name>pRule</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRuleset</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRule</name> <operator>=</operator> <name><name>pRule</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <name>pRule</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>rBaseCost</name></name> <operator>=</operator> <name><name>pNew</name><operator>-&gt;</operator><name>rCostX</name></name> <operator>=</operator> <name>rBaseCost</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>fuzzerHash</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zBasis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pHash</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nStem</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a cursor to its next row of output
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Use the element the cursor is currently point to to create
  ** a new stem and insert the new stem into the priority queue.
  */</comment>
  <expr_stmt><expr><name>pStem</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pStem</name><operator>-&gt;</operator><name>rCostX</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzerRender</name><argument_list>(<argument><expr><name>pStem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>fuzzerNewStem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>pStem</name><operator>-&gt;</operator><name>rCostX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>fuzzerAdvance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>fuzzerInsert</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call><operator>==</operator><name>pNew</name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Adjust the priority queue so that the first element of the
  ** stem list is the next lowest cost word.
  */</comment>
  <while>while<condition>( <expr><operator>(</operator><name>pStem</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>fuzzerAdvance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pStem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>res</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStem</name> <operator>=</operator> <call><name>fuzzerInsert</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pStem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>fuzzerSeen</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pStem</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>  <comment type="block">/* New word found */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pDone</name></name> <operator>=</operator> <name>pStem</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fuzzerLowestCostStem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fuzzerSeen</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Reach this point only if queue has been exhausted and there is
  ** nothing left to be output. */</comment>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_cost</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Called to "rewind" a cursor back to the beginning so that
** it starts its output over again.  Always called at least once
** prior to any fuzzerColumn, fuzzerRowid, or fuzzerEof call.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWord</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fuzzer_stem</name> <modifier>*</modifier></type><name>pStem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fuzzerClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <literal type="number">2147483647</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zWord</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_cost</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRuleset</name></name> <operator>=</operator> <operator>(</operator><name>fuzzer_cost</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name><operator>.</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pRule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name><operator>.</operator><name>rCost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name><operator>.</operator><name>nFrom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name><operator>.</operator><name>nTo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name><operator>.</operator><name>zFrom</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the query term is longer than FUZZER_MX_OUTPUT_LENGTH bytes, this
  ** query will return zero rows.  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zWord</name></expr></argument>)</argument_list></call><operator>&lt;</operator><name>FUZZER_MX_OUTPUT_LENGTH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name> <operator>=</operator> <name>pStem</name> <operator>=</operator> <call><name>fuzzerNewStem</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>zWord</name></expr></argument>, <argument><expr><operator>(</operator><name>fuzzer_cost</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStem</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>pRule</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nullRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pStem</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>pStem</name><operator>-&gt;</operator><name>nBasis</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only the word and distance columns have values.  All other columns
** return NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* the "word" column */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>fuzzerRender</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* the "distance" column */</comment>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStem</name><operator>-&gt;</operator><name>rCostX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* All other columns are NULL */</comment>
    <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The rowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When the fuzzer_cursor.rLimit value is 0 or less, that is a signal
** that the cursor has nothing more to output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fuzzer_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fuzzer_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>rLimit</name></name><operator>&lt;=</operator><operator>(</operator><name>fuzzer_cost</name><operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search for terms of these forms:
**
**   (A)    word MATCH $str
**   (B1)   distance &lt; $value
**   (B2)   distance &lt;= $value
**   (C)    ruleid == $ruleid
**
** The distance&lt; and distance&lt;= are both treated as distance&lt;=.
** The query plan number is a bit vector:
**
**   bit 1:   Term of the form (A) found
**   bit 2:   Term like (B1) or (B2) found
**   bit 3:   Term like (C) found
**
** If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
** then $value is in filter.argv[0] if bit-1 is clear and is in 
** filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
** in filter.argv[0] if bit-1 and bit-2 are both zero, is in
** filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
** filter.argv[2] if both bit-1 and bit-2 are set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fuzzerBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPlan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDistTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRulesetTerm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seenMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>rCost</name> <init>= <expr><literal type="number">1e12</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>seenMatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">1e6</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">1</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name>
           <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDistTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">4</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">2</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRulesetTerm</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iDistTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><operator>(</operator><name>iPlan</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iPlan</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iRulesetTerm</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>iPlan</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>seenMatch</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>iPlan</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rCost</name> <operator>=</operator> <literal type="number">1e99</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
   
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A virtual table module that implements the "fuzzer".
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>fuzzerModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* iVersion */</comment>
  <expr><name>fuzzerConnect</name></expr>,
  <expr><name>fuzzerConnect</name></expr>,
  <expr><name>fuzzerBestIndex</name></expr>,
  <expr><name>fuzzerDisconnect</name></expr>, 
  <expr><name>fuzzerDisconnect</name></expr>,
  <expr><name>fuzzerOpen</name></expr>,                  <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>fuzzerClose</name></expr>,                 <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>fuzzerFilter</name></expr>,                <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>fuzzerNext</name></expr>,                  <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>fuzzerEof</name></expr>,                   <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>fuzzerColumn</name></expr>,                <comment type="block">/* xColumn - read data */</comment>
  <expr><name>fuzzerRowid</name></expr>,                 <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                           <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fuzzer_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fuzzer"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fuzzerModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
