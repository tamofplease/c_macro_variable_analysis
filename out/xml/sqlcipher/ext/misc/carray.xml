<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/carray.c"><comment type="block">/*
** 2016-06-29
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file demonstrates how to create a table-valued-function that
** returns the values in a C-language array.
** Examples:
**
**      SELECT * FROM carray($ptr,5)
**
** The query above returns 5 integers contained in a C-language array
** at the address $ptr.  $ptr is a pointer to the array of integers.
** The pointer value must be assigned to $ptr using the
** sqlite3_bind_pointer() interface with a pointer type of "carray".
** For example:
**
**    static int aX[] = { 53, 9, 17, 2231, 4, 99 };
**    int i = sqlite3_bind_parameter_index(pStmt, "$ptr");
**    sqlite3_bind_pointer(pStmt, i, aX, "carray", 0);
**
** There is an optional third parameter to determine the datatype of
** the C-language array.  Allowed values of the third parameter are
** 'int32', 'int64', 'double', 'char*'.  Example:
**
**      SELECT * FROM carray($ptr,10,'char*');
**
** The default value of the third parameter is 'int32'.
**
** HOW IT WORKS
**
** The carray "function" is really a virtual table with the
** following schema:
**
**     CREATE TABLE carray(
**       value,
**       pointer HIDDEN,
**       count HIDDEN,
**       ctype TEXT HIDDEN
**     );
**
** If the hidden columns "pointer" and "count" are unconstrained, then 
** the virtual table has no rows.  Otherwise, the virtual table interprets
** the integer value of "pointer" as a pointer to the array and "count"
** as the number of elements in the array.  The virtual table steps through
** the array, element by element.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
 
<comment type="block">/* Allowed values for the mFlags parameter to sqlite3_carray_bind().
** Must exactly match the definitions in carray.h.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CARRAY_INT32</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_INT32</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>      <comment type="block">/* Data is 32-bit signed integers */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_INT64</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/* Data is 64-bit signed integers */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_DOUBLE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/* Data is doubles */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_TEXT</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>      <comment type="block">/* Data is char* */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_API</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_API</name></cpp:macro> <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_API</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Names of allowed datatypes
*/</comment>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azType</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"int32"</literal></expr>, <expr><literal type="string">"int64"</literal></expr>, <expr><literal type="string">"double"</literal></expr>, <expr><literal type="string">"char*"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Structure used to hold the sqlite3_carray_bind() information
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>carray_bind</name></name></type> <name>carray_bind</name>;</typedef>
<struct>struct <name>carray_bind</name> <block>{
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                <comment type="block">/* The data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                  <comment type="block">/* Number of elements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mFlags</name></decl>;</decl_stmt>                 <comment type="block">/* Control flags */</comment>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>        <comment type="block">/* Destructor for aData */</comment>
}</block>;</struct>


<comment type="block">/* carray_cursor is a subclass of sqlite3_vtab_cursor which will
** serve as the underlying representation of a cursor that scans
** over rows of the result
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>carray_cursor</name></name></type> <name>carray_cursor</name>;</typedef>
<struct>struct <name>carray_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* The rowid */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl>;</decl_stmt>                <comment type="block">/* Pointer to the array of values */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iCnt</name></decl>;</decl_stmt>        <comment type="block">/* Number of integers in the array */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eType</name></decl>;</decl_stmt>       <comment type="block">/* One of the CARRAY_type values */</comment>
}</block>;</struct>

<comment type="block">/*
** The carrayConnect() method is invoked to create a new
** carray_vtab that describes the carray virtual table.
**
** Think of this routine as the constructor for carray_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the carray_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against carray will look like.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<comment type="block">/* Column numbers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_COLUMN_VALUE</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_COLUMN_POINTER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_COLUMN_COUNT</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CARRAY_COLUMN_CTYPE</name></cpp:macro>   <cpp:value>3</cpp:value></cpp:define>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
     <argument><expr><literal type="string">"CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>*</operator><name>ppVtab</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for carray_cursor objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new carray_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a carray_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a carray_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>carray_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the carray_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>carray_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CARRAY_COLUMN_POINTER</name></expr>:</case>   <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    <case>case <expr><name>CARRAY_COLUMN_COUNT</name></expr>:</case>     <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iCnt</name></name></expr>;</expr_stmt>   <break>break;</break>
    <case>case <expr><name>CARRAY_COLUMN_CTYPE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>azType</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>eType</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <switch>switch<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>CARRAY_INT32</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CARRAY_INT64</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3_int64</name><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CARRAY_DOUBLE</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CARRAY_TEXT</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row.  In this implementation, the
** rowid is the same as the output value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>carray_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>carray_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>&gt;</operator><name><name>pCur</name><operator>-&gt;</operator><name>iCnt</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is called to "rewind" the carray_cursor object back
** to the first row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>carray_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iCnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>idxNum</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>carray_bind</name> <modifier>*</modifier></type><name>pBind</name> <init>= <expr><call><name>sqlite3_value_pointer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"carray-bind"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBind</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name> <operator>=</operator> <name><name>pBind</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iCnt</name></name> <operator>=</operator> <name><name>pBind</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pBind</name><operator>-&gt;</operator><name>mFlags</name></name> <operator>&amp;</operator> <literal type="number">0x03</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name> <operator>=</operator> <call><name>sqlite3_value_pointer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"carray"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iCnt</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>pPtr</name></name></expr> ?</condition><then> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>&lt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>CARRAY_INT32</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azType</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>azType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azType</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pVtabCursor</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
            <argument><expr><literal type="string">"unknown datatype: %Q"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the carray virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** idxNum is:
**
**    1    If only the pointer= constraint exists.  In this case, the
**         parameter must be bound using sqlite3_carray_bind().
**
**    2    if the pointer= and count= constraints exist.
**
**    3    if the ctype= constraint also exists.
**
** idxNum is 0 otherwise and carray becomes an empty table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carrayBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ptrIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Index of the pointer= constraint, or -1 if none */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cntIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Index of the count= constraint, or -1 if none */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ctypeIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Index of the ctype= constraint, or -1 if none */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>CARRAY_COLUMN_POINTER</name></expr>:</case>
        <expr_stmt><expr><name>ptrIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>CARRAY_COLUMN_COUNT</name></expr>:</case>
        <expr_stmt><expr><name>cntIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>CARRAY_COLUMN_CTYPE</name></expr>:</case>
        <expr_stmt><expr><name>ctypeIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>ptrIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ptrIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ptrIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>cntIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>cntIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>cntIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>ctypeIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ctypeIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>ctypeIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">2147483647</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">2147483647</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This following structure defines all the methods for the 
** carray virtual table.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>carrayModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>carrayConnect</name></expr>,             <comment type="block">/* xConnect */</comment>
  <expr><name>carrayBestIndex</name></expr>,           <comment type="block">/* xBestIndex */</comment>
  <expr><name>carrayDisconnect</name></expr>,          <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>carrayOpen</name></expr>,                <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>carrayClose</name></expr>,               <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>carrayFilter</name></expr>,              <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>carrayNext</name></expr>,                <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>carrayEof</name></expr>,                 <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>carrayColumn</name></expr>,              <comment type="block">/* xColumn - read data */</comment>
  <expr><name>carrayRowid</name></expr>,               <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Destructor for the carray_bind object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>carrayBindDel</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPtr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_bind</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>carray_bind</name><operator>*</operator><operator>)</operator><name>pPtr</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><operator>!=</operator><name>SQLITE_STATIC</name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xDel</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke this interface in order to bind to the single-argument
** version of CARRAY().
*/</comment>
<function><type><name>SQLITE_API</name> <name>int</name></type> <name>sqlite3_carray_bind</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>mFlags</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>carray_bind</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>xDestroy</name><operator>!=</operator><name>SQLITE_STATIC</name> <operator>&amp;&amp;</operator> <name>xDestroy</name><operator>!=</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mFlags</name></name> <operator>=</operator> <name>mFlags</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDestroy</name><operator>==</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><name>nData</name></expr></init></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><name>mFlags</name> <operator>&amp;</operator> <literal type="number">0x03</literal></expr> )</condition><block>{<block_content>
      <case>case <expr><name>CARRAY_INT32</name></expr>:</case>   <expr_stmt><expr><name>sz</name> <operator>*=</operator> <literal type="number">4</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>CARRAY_INT64</name></expr>:</case>   <expr_stmt><expr><name>sz</name> <operator>*=</operator> <literal type="number">8</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>CARRAY_DOUBLE</name></expr>:</case>  <expr_stmt><expr><name>sz</name> <operator>*=</operator> <literal type="number">8</literal></expr>;</expr_stmt>              <break>break;</break>
      <case>case <expr><name>CARRAY_TEXT</name></expr>:</case>    <expr_stmt><expr><name>sz</name> <operator>*=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>  <break>break;</break>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mFlags</name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator><operator>==</operator><name>CARRAY_TEXT</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>aData</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt> 
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>sz</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mFlags</name> <operator>&amp;</operator> <literal type="number">0x03</literal><operator>)</operator><operator>==</operator><name>CARRAY_TEXT</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>az</name><index>[<expr><name>nData</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zData</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>aData</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zData</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>sqlite3_free</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <name>aData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>xDel</name></name> <operator>=</operator> <name>xDestroy</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>sqlite3_bind_pointer</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="string">"carray-bind"</literal></expr></argument>, <argument><expr><name>carrayBindDel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** For testing purpose in the TCL test harness, we need a method for
** setting the pointer value.  The inttoptr(X) SQL function accomplishes
** this.  Tcl script will bind an integer to X and the inttoptr() SQL
** function will use sqlite3_result_pointer() to convert that integer into
** a pointer.
**
** This is for testing on TCL only.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>inttoptrFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i64</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i64</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i64</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i32</name> <init>= <expr><name>i64</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_pointer</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"carray"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<function><type><name>SQLITE_API</name> <name>int</name></type> <name>sqlite3_carray_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"carray"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carrayModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"inttoptr"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>inttoptrFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
