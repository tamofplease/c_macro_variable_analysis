<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/fileio.c"><comment type="block">/*
** 2014-06-13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements SQL functions readfile() and
** writefile(), and eponymous virtual type "fsdir".
**
** WRITEFILE(FILE, DATA [, MODE [, MTIME]]):
**
**   If neither of the optional arguments is present, then this UDF
**   function writes blob DATA to file FILE. If successful, the number
**   of bytes written is returned. If an error occurs, NULL is returned.
**
**   If the first option argument - MODE - is present, then it must
**   be passed an integer value that corresponds to a POSIX mode
**   value (file type + permissions, as returned in the stat.st_mode
**   field by the stat() system call). Three types of files may
**   be written/created:
**
**     regular files:  (mode &amp; 0170000)==0100000
**     symbolic links: (mode &amp; 0170000)==0120000
**     directories:    (mode &amp; 0170000)==0040000
**
**   For a directory, the DATA is ignored. For a symbolic link, it is
**   interpreted as text and used as the target of the link. For a
**   regular file, it is interpreted as a blob and written into the
**   named file. Regardless of the type of file, its permissions are
**   set to (mode &amp; 0777) before returning.
**
**   If the optional MTIME argument is present, then it is interpreted
**   as an integer - the number of seconds since the unix epoch. The
**   modification-time of the target file is set to this value before
**   returning.
**
**   If three or more arguments are passed to this function and an
**   error is encountered, an exception is raised.
**
** READFILE(FILE):
**
**   Read and return the contents of file FILE (type blob) from disk.
**
** FSDIR:
**
**   Used as follows:
**
**     SELECT * FROM fsdir($path [, $dir]);
**
**   Parameter $path is an absolute or relative pathname. If the file that it
**   refers to does not exist, it is an error. If the path refers to a regular
**   file or symbolic link, it returns a single row. Or, if the path refers
**   to a directory, it returns one row for the directory, and one row for each
**   file within the hierarchy rooted at $path.
**
**   Each row has the following columns:
**
**     name:  Path to file or directory (text value).
**     mode:  Value of stat.st_mode for directory entry (an integer).
**     mtime: Value of stat.st_mtime for directory entry (an integer).
**     data:  For a regular file, a blob containing the file data. For a
**            symlink, a text value containing the text of the link. For a
**            directory, NULL.
**
**   If a non-NULL value is specified for the optional $dir parameter and
**   $path is a relative path, then $path is interpreted relative to $dir. 
**   And the paths returned in the "name" column of the table are also 
**   relative to directory $dir.
**
** Notes on building this extension for Windows:
**   Unless linked statically with the SQLite library, a preprocessor
**   symbol, FILEIO_WIN32_DLL, must be #define'd to create a stand-alone
**   DLL form of this extension for WIN32. See its use below for details.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<function><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"test_windirent.h"</cpp:file></cpp:include>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>DIRENT</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>chmod</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>chmod</name></cpp:macro> <cpp:value>_chmod</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>stat</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>stat</name></cpp:macro> <cpp:value>_stat</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>mkdir</name><parameter_list>(<parameter><type><name>path</name></type></parameter>,<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_mkdir(path)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>path</name></type></parameter>,<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat(path,buf)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>


<comment type="block">/*
** Structure of the fsdir() table-valued function
*/</comment>
                 <comment type="block">/*    0    1    2     3    4           5             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_SCHEMA</name></cpp:macro> <cpp:value>"(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_NAME</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>     <comment type="block">/* Name of the file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_MODE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>     <comment type="block">/* Access mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_MTIME</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>     <comment type="block">/* Last modification time */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_DATA</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>     <comment type="block">/* File content */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_PATH</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>     <comment type="block">/* Path to top of search */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_DIR</name></cpp:macro>      <cpp:value>5</cpp:value></cpp:define>     <comment type="block">/* Path is relative to this directory */</comment>


<comment type="block">/*
** Set the result stored by context ctx to a blob containing the 
** contents of file zName.  Or, leave the result unchanged (NULL)
** if the file does not exist or is unreadable.
**
** If the file exceeds the SQLite blob size limit, through an
** SQLITE_TOOBIG error.
**
** Throw an SQLITE_IOERR if there are difficulties pulling the file
** off of disk.
*/</comment>
<specifier>static</specifier> <name>void</name></type> <name>readFileContents</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxBlob</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* File does not exist or is unreadable. Leave the result set to NULL. */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxBlob</name> <operator>=</operator> <call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_LENGTH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&gt;</operator><name>mxBlob</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><ternary><condition><expr><name>nIn</name></expr> ?</condition><then> <expr><name>nIn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>==</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nIn</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>SQLITE_IOERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the "readfile(X)" SQL function.  The entire content
** of the file named X is read and returned as a BLOB.  NULL is returned
** if the file does not exist or is unreadable.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>readfileFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argc</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>readFileContents</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ctxErrorMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This function is designed to convert a Win32 FILETIME structure into the
** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_uint64</name></type> <name>fileTimeToUnixTime</name><parameter_list>(
  <parameter><decl><type><name>LPFILETIME</name></type> <name>pFileTime</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>epochSystemTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>epochIntervals</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>epochFileTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>fileIntervals</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epochSystemTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SYSTEMTIME</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wYear</name></name> <operator>=</operator> <literal type="number">1970</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wMonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wDay</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epochSystemTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epochFileTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochIntervals</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>epochFileTime</name><operator>.</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochIntervals</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>epochFileTime</name><operator>.</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>fileIntervals</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>pFileTime</name><operator>-&gt;</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fileIntervals</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>pFileTime</name><operator>-&gt;</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>fileIntervals</name><operator>.</operator><name>QuadPart</name></name> <operator>-</operator> <name><name>epochIntervals</name><operator>.</operator><name>QuadPart</name></name><operator>)</operator> <operator>/</operator> <literal type="number">10000000</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILEIO_WIN32_DLL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:empty>#  <comment type="block">/* To allow a standalone DLL, use this next replacement function: */</comment></cpp:empty>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>sqlite3_win32_utf8_to_unicode</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_win32_utf8_to_unicode</name></cpp:macro> <cpp:value>utf8_to_utf16</cpp:value></cpp:define>
<cpp:empty>#</cpp:empty>
<function><type><name>LPWSTR</name></type> <name>utf8_to_utf16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nAllot</name> <init>= <expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>rv</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nAllot</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rv</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>nAllot</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
    <return>return <expr><name>rv</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function attempts to normalize the time values found in the stat()
** buffer to UTC.  This is necessary on Win32, where the runtime library
** appears to return these values as local times.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>statTimesToUtc</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zUnicodeName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>LPWSTR</name></type> <name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><name>zUnicodeName</name> <operator>=</operator> <call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zUnicodeName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WIN32_FIND_DATAW</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hFindFile</name> <operator>=</operator> <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>hFindFile</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_ctime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftCreationTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_atime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftLastAccessTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_mtime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftLastWriteTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is used in place of stat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls stat().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fileStat</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>statTimesToUtc</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This function is used in place of lstat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls lstat().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fileLinkStat</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lstat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>statTimesToUtc</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>lstat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Argument zFile is the name of a file that will be created and/or written
** by SQL function writefile(). This function ensures that the directory
** zFile will be written to exists, creating it if required. The permissions
** for any path components created by this function are set in accordance
** with the current umask.
**
** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
** SQLITE_OK is returned if the directory is successfully created, or
** SQLITE_ERROR otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>makeDirectory</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zCopy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

      <for>for<control>(<init>;</init> <condition><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nCopy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nCopy</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>fileStat</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><literal type="number">0777</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work for the writefile() UDF. Refer to 
** header comments at the top of this file for details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeFile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Context to return bytes written in */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>,              <comment type="block">/* File to write */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,           <comment type="block">/* Data to write */</comment>
  <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>,                    <comment type="block">/* MODE parameter passed to writefile() */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>mtime</name></decl></parameter>             <comment type="block">/* MTIME parameter (or -1 to not set time) */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTo</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>symlink</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* The mkdir() call to create the directory failed. This might not
        ** be an error though - if there is already a directory at the same
        ** path and either the permissions already match or can be changed
        ** to do so using chmod(), it is not an error.  */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>errno</name><operator>!=</operator><name>EEXIST</name>
         <operator>||</operator> <literal type="number">0</literal><operator>!=</operator><call><name>fileStat</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call>
         <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call>
         <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>sStat</name><operator>.</operator><name>st_mode</name></name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>mode</name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><call><name>chmod</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name><operator>&amp;</operator><literal type="number">0777</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><call><name>fwrite</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><name>n</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>&amp;&amp;</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name> <operator>&amp;</operator> <literal type="number">0777</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>mtime</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <comment type="block">/* Windows */</comment>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>lastAccess</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>lastWrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>currentTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LONGLONG</name></type> <name>intervals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zUnicodeName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>LPWSTR</name></type> <name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>intervals</name> <operator>=</operator> <call><name>Int32x32To64</name><argument_list>(<argument><expr><name>mtime</name></expr></argument>, <argument><expr><literal type="number">10000000</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">116444736000000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lastWrite</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>intervals</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lastWrite</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>=</operator> <name>intervals</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zUnicodeName</name> <operator>=</operator> <call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zUnicodeName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>hFile</name> <operator>=</operator> <call><name>CreateFileW</name><argument_list>(
      <argument><expr><name>zUnicodeName</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
      <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>hFile</name><operator>!=</operator><name>INVALID_HANDLE_VALUE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>bResult</name> <init>= <expr><call><name>SetFileTime</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastAccess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastWrite</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>!</operator><name>bResult</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal></expr></cpp:elif> <comment type="block">/* utimensat() is not universally available */</comment>
    <comment type="block">/* Recent unix */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name><name>times</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>=</operator> <name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>mtime</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>utimensat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>times</name></expr></argument>, <argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Legacy unix */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>times</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>mtime</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>utimes</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.  
** Refer to header comments at the top of this file for details.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>writefileFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mtime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>argc</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>argc</name></expr></argument>&gt;</argument_list></name><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, 
        <argument><expr><literal type="string">"wrong number of arguments to function writefile()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zFile</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>mode_t</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mtime</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>writeFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>makeDirectory</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>writeFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to create symlink: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to create directory: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to write file: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:   lsmode(MODE)
**
** Given a numberic st_mode from stat(), convert it into a human-readable
** text string in the style of "ls -l".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsModeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMode</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>iMode</name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>-</operator><name>i</name><operator>)</operator><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>i</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'r'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'w'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'x'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/* 
** Cursor type for recursively iterating through a directory structure.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>fsdir_cursor</name></name></type> <name>fsdir_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FsdirLevel</name></name></type> <name>FsdirLevel</name>;</typedef>

<struct>struct <name>FsdirLevel</name> <block>{
  <decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>pDir</name></decl>;</decl_stmt>                 <comment type="block">/* From opendir() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDir</name></decl>;</decl_stmt>                <comment type="block">/* Name of directory (nul-terminated) */</comment>
}</block>;</struct>

<struct>struct <name>fsdir_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nLvl</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in aLvl[] array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLvl</name></decl>;</decl_stmt>                  <comment type="block">/* Index of current entry */</comment>
  <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>aLvl</name></decl>;</decl_stmt>          <comment type="block">/* Hierarchy of directories being traversed */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBase</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>         <comment type="block">/* Current lstat() results */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>               <comment type="block">/* Path to current entry */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* Current rowid */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>fsdir_tab</name></name></type> <name>fsdir_tab</name>;</typedef>
<struct>struct <name>fsdir_tab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
}</block>;</struct>

<comment type="block">/*
** Construct a new fsdir virtual table object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_tab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x"</literal> <name>FSDIR_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>fsdir_tab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for fsdir vtab objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new fsdir_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset a cursor back to the state it was in when first returned
** by fsdirOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsdirResetCursor</name><parameter_list>(<parameter><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for an fsdir_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fsdirResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message for the virtual table associated with cursor
** pCur to the results of vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsdirSetErrmsg</name><parameter_list>(<parameter><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Advance an fsdir_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mode_t</name></type> <name>m</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Descend into this directory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iNew</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name>iNew</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>FsdirLevel</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>aNew</name> <init>= <expr><operator>(</operator><name>FsdirLevel</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FsdirLevel</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nNew</name><operator>-</operator><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLvl</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name>iNew</name></expr>]</index></name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot read directory: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
       <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fileLinkStat</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot stat file: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* EOF */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>FSDIR_COLUMN_NAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>FSDIR_COLUMN_MODE</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FSDIR_COLUMN_MTIME</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FSDIR_COLUMN_DATA</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>mode_t</name></type> <name>m</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>aStatic</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><name>aStatic</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nBuf</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><name>nBuf</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>!=</operator><name>aStatic</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <name>nBuf</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>!=</operator><name>aStatic</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>readFileContents</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <case>case <expr><name>FSDIR_COLUMN_PATH</name></expr>:</case>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
      ** always return their values as NULL */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row. In this implementation, the
** first row returned is assigned rowid value 1, and each subsequent
** row a value 1 more than that of the previous.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xFilter callback.
**
** idxNum==1   PATH parameter only
** idxNum==2   Both PATH and DIR supplied
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fsdirResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"table function fsdir requires an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><name>idxNum</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>argc</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>argc</name><operator>==</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDir</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"table function fsdir requires a non-NULL argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fileLinkStat</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot stat file: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the generate_series virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** The query plan is represented by values of idxNum:
**
**  (1)  The path value is supplied by argv[0]
**  (2)  Path is in argv[0] and dir is in argv[1]
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxPath</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Index in pIdxInfo-&gt;aConstraint of PATH= */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxDir</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Index in pIdxInfo-&gt;aConstraint of DIR= */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* True if an unusable PATH= constraint is seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* True if an unusable DIR= constraint is seen */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>tab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>FSDIR_COLUMN_PATH</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>idxPath</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>seenPath</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxPath</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>seenPath</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>FSDIR_COLUMN_DIR</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>idxDir</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>seenDir</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxDir</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>seenDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch> 
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>seenPath</name> <operator>||</operator> <name>seenDir</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If input parameters are unusable, disallow this plan */</comment>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxPath</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* The pIdxInfo-&gt;estimatedCost should have been initialized to a huge
    ** number.  Leave it unchanged. */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxPath</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxPath</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxDir</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxDir</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxDir</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register the "fsdir" virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirRegister</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>fsdirModule</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
    <expr><name>fsdirConnect</name></expr>,              <comment type="block">/* xConnect */</comment>
    <expr><name>fsdirBestIndex</name></expr>,            <comment type="block">/* xBestIndex */</comment>
    <expr><name>fsdirDisconnect</name></expr>,           <comment type="block">/* xDisconnect */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
    <expr><name>fsdirOpen</name></expr>,                 <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>fsdirClose</name></expr>,                <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>fsdirFilter</name></expr>,               <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>fsdirNext</name></expr>,                 <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>fsdirEof</name></expr>,                  <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>fsdirColumn</name></expr>,               <comment type="block">/* xColumn - read data */</comment>
    <expr><name>fsdirRowid</name></expr>,                <comment type="block">/* xRowid - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fsdir"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsdirModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>         <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>fsdirRegister</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fileio_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"readfile"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>readfileFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"writefile"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>writefileFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"lsmode"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>lsModeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsdirRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILEIO_WIN32_DLL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<comment type="block">/* To allow a standalone DLL, make test_windirent.c use the same
 * redefined SQLite API calls as the above extension code does.
 * Just pull in this .c to accomplish this. As a beneficial side
 * effect, this extension becomes a single translation unit. */</comment>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"test_windirent.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
