<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/closure.c"><comment type="block">/*
** 2013-04-16
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code for a virtual table that finds the transitive
** closure of a parent/child relationship in a real table.  The virtual 
** table is called "transitive_closure".
**
** A transitive_closure virtual table is created like this:
**
**     CREATE VIRTUAL TABLE x USING transitive_closure(
**        tablename=&lt;tablename&gt;,      -- T
**        idcolumn=&lt;columnname&gt;,      -- X
**        parentcolumn=&lt;columnname&gt;   -- P
**     );
**
** When it is created, the new transitive_closure table may be supplied 
** with default values for the name of a table T and columns T.X and T.P.
** The T.X and T.P columns must contain integers.  The ideal case is for 
** T.X to be the INTEGER PRIMARY KEY.  The T.P column should reference
** the T.X column. The row referenced by T.P is the parent of the current row.
**
** The tablename, idcolumn, and parentcolumn supplied by the CREATE VIRTUAL
** TABLE statement may be overridden in individual queries by including
** terms like tablename='newtable', idcolumn='id2', or 
** parentcolumn='parent3' in the WHERE clause of the query.
**
** For efficiency, it is essential that there be an index on the P column:
**
**    CREATE Tidx1 ON T(P)
**
** Suppose a specific instance of the closure table is as follows:
**
**    CREATE VIRTUAL TABLE ct1 USING transitive_closure(
**       tablename='group',
**       idcolumn='groupId',
**       parentcolumn='parentId'
**    );
**
** Such an instance of the transitive_closure virtual table would be
** appropriate for walking a tree defined using a table like this, for example:
**
**    CREATE TABLE group(
**      groupId INTEGER PRIMARY KEY,
**      parentId INTEGER REFERENCES group
**    );
**    CREATE INDEX group_idx1 ON group(parentId);
**
** The group table above would presumably have other application-specific
** fields.  The key point here is that rows of the group table form a
** tree.  The purpose of the ct1 virtual table is to easily extract
** branches of that tree.
**
** Once it has been created, the ct1 virtual table can be queried
** as follows:
**
**    SELECT * FROM element
**     WHERE element.groupId IN (SELECT id FROM ct1 WHERE root=?1);
**
** The above query will return all elements that are part of group ?1
** or children of group ?1 or grand-children of ?1 and so forth for all
** descendents of group ?1.  The same query can be formulated as a join:
**
**    SELECT element.* FROM element, ct1
**     WHERE element.groupid=ct1.id
**       AND ct1.root=?1;
**
** The depth of the transitive_closure (the number of generations of
** parent/child relations to follow) can be limited by setting "depth"
** column in the WHERE clause.  So, for example, the following query
** finds only children and grandchildren but no further descendents:
**
**    SELECT element.* FROM element, ct1
**     WHERE element.groupid=ct1.id
**       AND ct1.root=?1
**       AND ct1.depth&lt;=2;
**
** The "ct1.depth&lt;=2" term could be a strict equality "ct1.depth=2" in
** order to find only the grandchildren of ?1, not ?1 itself or the
** children of ?1.
** 
** The root=?1 term must be supplied in WHERE clause or else the query
** of the ct1 virtual table will return an empty set.  The tablename,
** idcolumn, and parentcolumn attributes can be overridden in the WHERE
** clause if desired.  So, for example, the ct1 table could be repurposed
** to find ancestors rather than descendents by inverting the roles of
** the idcolumn and parentcolumn:
**
**    SELECT element.* FROM element, ct1
**     WHERE element.groupid=ct1.id
**       AND ct1.root=?1
**       AND ct1.idcolumn='parentId'
**       AND ct1.parentcolumn='groupId';
**
** Multiple calls to ct1 could be combined.  For example, the following
** query finds all elements that "cousins" of groupId ?1.  That is to say
** elements where the groupId is a grandchild of the grandparent of ?1.
** (This definition of "cousins" also includes siblings and self.)
**
**    SELECT element.* FROM element, ct1
**     WHERE element.groupId=ct1.id
**       AND ct1.depth=2
**       AND ct1.root IN (SELECT id FROM ct1
**                         WHERE root=?1
**                           AND depth=2
**                           AND idcolumn='parentId'
**                           AND parentcolumn='groupId');
**
** In our example, the group.groupId column is unique and thus the
** subquery will return exactly one row.  For that reason, the IN
** operator could be replaced by "=" to get the same result.  But
** in the general case where the idcolumn is not unique, an IN operator
** would be required for this kind of query.
**
** Note that because the tablename, idcolumn, and parentcolumn can
** all be specified in the query, it is possible for an application
** to define a single transitive_closure virtual table for use on lots
** of different hierarchy tables.  One might say:
**
**     CREATE VIRTUAL TABLE temp.closure USING transitive_closure;
**
** As each database connection is being opened.  Then the application
** would always have a "closure" virtual table handy to use for querying.
**
**    SELECT element.* FROM element, closure
**     WHERE element.groupid=ct1.id
**       AND closure.root=?1
**       AND closure.tablename='group'
**       AND closure.idname='groupId'
**       AND closure.parentname='parentId';
**
** See the documentation at http://www.sqlite.org/loadext.html for information
** on how to compile and use loadable extensions such as this one.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Forward declaration of objects used by this implementation
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>closure_vtab</name></name></type> <name>closure_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>closure_cursor</name></name></type> <name>closure_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>closure_queue</name></name></type> <name>closure_queue</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>closure_avl</name></name></type> <name>closure_avl</name>;</typedef>

<comment type="block" format="doxygen">/*****************************************************************************
** AVL Tree implementation
*/</comment>
<comment type="block">/*
** Objects that want to be members of the AVL tree should embedded an
** instance of this structure.
*/</comment>
<struct>struct <name>closure_avl</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>id</name></decl>;</decl_stmt>     <comment type="block">/* Id of this entry in the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iGeneration</name></decl>;</decl_stmt>      <comment type="block">/* Which generation is this entry part of */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pList</name></decl>;</decl_stmt>   <comment type="block">/* A linked list of nodes */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pBefore</name></decl>;</decl_stmt> <comment type="block">/* Other elements less than id */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pAfter</name></decl>;</decl_stmt>  <comment type="block">/* Other elements greater than id */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>     <comment type="block">/* Parent element */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>height</name></decl>;</decl_stmt>     <comment type="block">/* Height of this node.  Leaf==1 */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>imbalance</name></decl>;</decl_stmt>  <comment type="block">/* Height difference between pBefore and pAfter */</comment>
}</block>;</struct>

<comment type="block">/* Recompute the closure_avl.height and closure_avl.imbalance fields for p.
** Assume that the children of p have correct heights.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closureAvlRecomputeHeight</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>hBefore</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name><operator>-&gt;</operator><name>height</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>hAfter</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name><operator>-&gt;</operator><name>height</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name> <operator>=</operator> <name>hBefore</name> <operator>-</operator> <name>hAfter</name></expr>;</expr_stmt>  <comment type="block">/* -: pAfter higher.  +: pBefore higher */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>hBefore</name><operator>&gt;</operator><name>hAfter</name></expr> ?</condition><then> <expr><name>hBefore</name></expr> </then><else>: <expr><name>hAfter</name></expr></else></ternary><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
**     P                B
**    / \              / \
**   B   Z    ==&gt;     X   P
**  / \                  / \
** X   Y                Y   Z
**
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlRotateBefore</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pP</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><name><name>pP</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pY</name> <init>= <expr><name><name>pB</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pY</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pY</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>closureAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closureAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pB</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
**     P                A
**    / \              / \
**   X   A    ==&gt;     P   Z
**      / \          / \
**     Y   Z        X   Y
**
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlRotateAfter</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pP</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><name><name>pP</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pY</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pP</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pY</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pY</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pY</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>pP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>closureAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closureAvlRecomputeHeight</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pA</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to the pBefore or pAfter pointer in the parent
** of p that points to p.  Or if p is the root node, return pp.
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>closureAvlFromPtr</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>closure_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pp</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>pAfter</name></name><operator>==</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>&amp;</operator><name><name>pUp</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>&amp;</operator><name><name>pUp</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rebalance all nodes starting with p and working up to the root.
** Return the new root.
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlBalance</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pTop</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>closureAvlRecomputeHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <call><name>closureAvlRotateAfter</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>closureAvlFromPtr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name> <operator>=</operator> <call><name>closureAvlRotateBefore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&lt;=</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>imbalance</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <call><name>closureAvlRotateBefore</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>closureAvlFromPtr</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name> <operator>=</operator> <call><name>closureAvlRotateAfter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pTop</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>pTop</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search the tree rooted at p for an entry with id.  Return a pointer
** to the entry or return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlSearch</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name>id</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>id</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>id</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>id</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the first node (the one with the smallest key).
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlFirst</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block type="pseudo"><block_content> <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the node with the next larger key after p.
*/</comment>
<function><type><name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlNext</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name><operator>==</operator><name>pPrev</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pPrev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pUp</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name>pPrev</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>closureAvlFirst</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new node pNew.  Return NULL on success.  If the key is not
** unique, then do not perform the insert but instead leave pNew unchanged
** and return a pointer to an existing node with the same key.
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>closureAvlInsert</name><parameter_list>(
  <parameter><decl><type><name>closure_avl</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppHead</name></decl></parameter>,  <comment type="block">/* Head of the tree */</comment>
  <parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>      <comment type="block">/* New node to be inserted */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ppHead</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>id</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>id</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>id</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>id</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUp</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>p</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pBefore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pAfter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>imbalance</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppHead</name> <operator>=</operator> <call><name>closureAvlBalance</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Walk the tree can call xDestroy on each node
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closureAvlDestroy</name><parameter_list>(<parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>closure_avl</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>closureAvlDestroy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pBefore</name></name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>closureAvlDestroy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pAfter</name></name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
** End of the AVL Tree implementation
******************************************************************************/</comment>

<comment type="block">/* 
** A closure virtual-table object 
*/</comment>
<struct>struct <name>closure_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                 <comment type="block">/* Name of database.  (ex: "main") */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSelf</name></decl>;</decl_stmt>               <comment type="block">/* Name of this virtual table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl>;</decl_stmt>          <comment type="block">/* Name of table holding parent/child relation */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdColumn</name></decl>;</decl_stmt>           <comment type="block">/* Name of ID column of zTableName */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zParentColumn</name></decl>;</decl_stmt>       <comment type="block">/* Name of PARENT column in zTableName */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>               <comment type="block">/* Number of pending cursors */</comment>
}</block>;</struct>

<comment type="block">/* A closure cursor object */</comment>
<struct>struct <name>closure_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>       <comment type="block">/* The virtual table this cursor belongs to */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl>;</decl_stmt>          <comment type="block">/* Name of table holding parent/child relation */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdColumn</name></decl>;</decl_stmt>           <comment type="block">/* Name of ID column of zTableName */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zParentColumn</name></decl>;</decl_stmt>       <comment type="block">/* Name of PARENT column in zTableName */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pCurrent</name></decl>;</decl_stmt>     <comment type="block">/* Current element of output */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pClosure</name></decl>;</decl_stmt>     <comment type="block">/* The complete closure tree */</comment>
}</block>;</struct>

<comment type="block">/* A queue of AVL nodes */</comment>
<struct>struct <name>closure_queue</name> <block>{
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>       <comment type="block">/* Oldest node on the queue */</comment>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>        <comment type="block">/* Youngest node on the queue */</comment>
}</block>;</struct>

<comment type="block">/*
** Add a node to the end of the queue
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>queuePush</name><parameter_list>(<parameter><decl><type><name>closure_queue</name> <modifier>*</modifier></type><name>pQueue</name></decl></parameter>, <parameter><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pQueue</name><operator>-&gt;</operator><name>pLast</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pQueue</name><operator>-&gt;</operator><name>pLast</name><operator>-&gt;</operator><name>pList</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pQueue</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pQueue</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Extract the oldest element (the front element) from the queue.
*/</comment>
<function><type><specifier>static</specifier> <name>closure_avl</name> <modifier>*</modifier></type><name>queuePull</name><parameter_list>(<parameter><decl><type><name>closure_queue</name> <modifier>*</modifier></type><name>pQueue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pQueue</name><operator>-&gt;</operator><name>pFirst</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pQueue</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pList</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pQueue</name><operator>-&gt;</operator><name>pFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pQueue</name><operator>-&gt;</operator><name>pLast</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function converts an SQL quoted string into an unquoted string
** and returns a pointer to a buffer allocated using sqlite3_malloc() 
** containing the result. The caller should eventually free this buffer
** using sqlite3_free.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>closureDequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nIn</name></decl>;</decl_stmt>              <comment type="block">/* Size of input string, in bytes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>                     <comment type="block">/* Output (dequoted) string */</comment>

  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nIn</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Quote character (if any ) */</comment>

    <if_stmt><if>if<condition>( <expr><name>q</name><operator>!=</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>q</name><operator>!=</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nIn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Index of next byte to write to output */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iIn</name></decl>;</decl_stmt>                    <comment type="block">/* Index of next byte to read from input */</comment>

      <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><name>nIn</name></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>nIn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate an closure_vtab object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closureFree</name><parameter_list>(<parameter><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSelf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xDisconnect/xDestroy method for the closure module.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>closure_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closureFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the argument is of the form:
**
**       KEY = VALUE
**
** If it is, return a pointer to the first character of VALUE.
** If not, return NULL.  Spaces around the = are ignored.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>closureValueOfKey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nStr</name><operator>&lt;</operator><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nKey</name></expr>;</init> <condition><expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'='</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>zStr</name><operator>+</operator><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xConnect/xCreate method for the closure module. Arguments are:
**
**   argv[0]    -&gt; module name  ("transitive_closure")
**   argv[1]    -&gt; database name
**   argv[2]    -&gt; table name
**   argv[3...] -&gt; arguments
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>              <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* New virtual table */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zDb</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>closureConnectError</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSelf</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zSelf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>closureConnectError</name>;</goto></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>closureValueOfKey</name><argument_list>(<argument><expr><literal type="string">"tablename"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zTableName</name></name> <operator>=</operator> <call><name>closureDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zTableName</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>closureConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>closureValueOfKey</name><argument_list>(<argument><expr><literal type="string">"idcolumn"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zIdColumn</name></name> <operator>=</operator> <call><name>closureDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zIdColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>closureConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <call><name>closureValueOfKey</name><argument_list>(<argument><expr><literal type="string">"parentcolumn"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zParentColumn</name></name> <operator>=</operator> <call><name>closureDequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>zParentColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>closureConnectError</name>;</goto></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unrecognized argument: [%s]\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>closureFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
         <argument><expr><literal type="string">"CREATE TABLE x(id,depth,root HIDDEN,tablename HIDDEN,"</literal>
                        <literal type="string">"idcolumn HIDDEN,parentcolumn HIDDEN)"</literal></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_ID</name></cpp:macro>              <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_DEPTH</name></cpp:macro>           <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_ROOT</name></cpp:macro>            <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_TABLENAME</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_IDCOLUMN</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSURE_COL_PARENTCOLUMN</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>closureFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

<label><name>closureConnectError</name>:</label>
  <expr_stmt><expr><call><name>closureFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new closure cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>closure_vtab</name><operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCursor</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free up all the memory allocated by a cursor.  Set it rLimit to 0
** to indicate that it is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closureClearCursor</name><parameter_list>(<parameter><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>closureAvlDestroy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pClosure</name></name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>closure_avl</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zTableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zTableName</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zIdColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zParentColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pClosure</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a closure cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name> <operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>closureClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nCursor</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance a cursor to its next row of output
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <call><name>closureAvlNext</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and insert a node
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureInsertNode</name><parameter_list>(
  <parameter><decl><type><name>closure_queue</name> <modifier>*</modifier></type><name>pQueue</name></decl></parameter>,  <comment type="block">/* Add new node to this queue */</comment>
  <parameter><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>,   <comment type="block">/* The cursor into which to add the node */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>id</name></decl></parameter>,       <comment type="block">/* The node ID */</comment>
  <parameter><decl><type><name>int</name></type> <name>iGeneration</name></decl></parameter>         <comment type="block">/* The generation number for this node */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iGeneration</name></name> <operator>=</operator> <name>iGeneration</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closureAvlInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pClosure</name></name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>queuePush</name><argument_list>(<argument><expr><name>pQueue</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Called to "rewind" a cursor back to the beginning so that
** it starts its output over again.  Always called at least once
** prior to any closureColumn, closureRowid, or closureEof call.
**
** This routine actually computes the closure.
**
** See the comment at the beginning of closureBestIndex() for a 
** description of the meaning of idxNum.  The idxStr parameter is
** not used.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxGen</name> <init>= <expr><literal type="number">999999999</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_avl</name> <modifier>*</modifier></type><name>pAvl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name> <init>= <expr><name><name>pVtab</name><operator>-&gt;</operator><name>zTableName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdColumn</name> <init>= <expr><name><name>pVtab</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParentColumn</name> <init>= <expr><name><name>pVtab</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_queue</name></type> <name>sQueue</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>    <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><call><name>closureClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQueue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sQueue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* No root=$root in the WHERE clause.  Return an empty set */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iRoot</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x000f0</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mxGen</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>(</operator><name>idxNum</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0f</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x00002</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxGen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x00f00</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zTableName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>(</operator><name>idxNum</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0f</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zTableName</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x0f000</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zIdColumn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>(</operator><name>idxNum</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0f</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zIdColumn</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zIdColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x0f0000</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zParentColumn</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>(</operator><name>idxNum</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0f</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zParentColumn</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zParentColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
       <argument><expr><literal type="string">"SELECT \"%w\".\"%w\" FROM \"%w\" WHERE \"%w\".\"%w\"=?1"</literal></expr></argument>,
       <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zIdColumn</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zParentColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVtab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>closureInsertNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQueue</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>pAvl</name> <operator>=</operator> <call><name>queuePull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQueue</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAvl</name><operator>-&gt;</operator><name>iGeneration</name></name><operator>&gt;=</operator><name>mxGen</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pAvl</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNew</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>closureAvlSearch</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pClosure</name></name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>closureInsertNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQueue</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>iNew</name></expr></argument>, <argument><expr><name><name>pAvl</name><operator>-&gt;</operator><name>iGeneration</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <call><name>closureAvlFirst</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pClosure</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Only the word and distance columns have values.  All other columns
** return NULL
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>CLOSURE_COL_ID</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSURE_COL_DEPTH</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>iGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSURE_COL_ROOT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSURE_COL_TABLENAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>zTableName</name></name></expr> ?</condition><then> <expr><name><name>pCur</name><operator>-&gt;</operator><name>zTableName</name></name></expr> </then><else>: <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zTableName</name></name></expr></else></ternary></expr></argument>,
         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSURE_COL_IDCOLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr> ?</condition><then> <expr><name><name>pCur</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr> </then><else>: <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zIdColumn</name></name></expr></else></ternary></expr></argument>,
         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSURE_COL_PARENTCOLUMN</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>pCur</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr> ?</condition><then> <expr><name><name>pCur</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr> </then><else>: <expr><name><name>pCur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zParentColumn</name></name></expr></else></ternary></expr></argument>,
         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The rowid.  For the closure table, this is the same as the "id" column.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** EOF indicator
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>closure_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>closure_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search for terms of these forms:
**
**   (A)    root = $root
**   (B1)   depth &lt; $depth
**   (B2)   depth &lt;= $depth
**   (B3)   depth = $depth
**   (C)    tablename = $tablename
**   (D)    idcolumn = $idcolumn
**   (E)    parentcolumn = $parentcolumn
**
** 
**
**   idxNum       meaning
**   ----------   ------------------------------------------------------
**   0x00000001   Term of the form (A) found
**   0x00000002   The term of bit-2 is like (B1)
**   0x000000f0   Index in filter.argv[] of $depth.  0 if not used.
**   0x00000f00   Index in filter.argv[] of $tablename.  0 if not used.
**   0x0000f000   Index in filter.argv[] of $idcolumn.  0 if not used
**   0x000f0000   Index in filter.argv[] of $parentcolumn.  0 if not used.
**
** There must be a term of type (A).  If there is not, then the index type
** is 0 and the query will return an empty set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>closureBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,             <comment type="block">/* The virtual table */</comment>
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>    <comment type="block">/* Information about the query */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPlan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>closure_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><operator>(</operator><name>closure_vtab</name><operator>*</operator><operator>)</operator><name>pTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>rCost</name> <init>= <expr><literal type="number">10000000.0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> 
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>CLOSURE_COL_ROOT</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x0000f0</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>CLOSURE_COL_DEPTH</name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name>
           <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LE</name>
           <operator>||</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>idx</name><operator>&lt;&lt;</operator><literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>idx</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <literal type="number">0x000002</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">5.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x000f00</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>CLOSURE_COL_TABLENAME</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>idx</name><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>idx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rCost</name> <operator>/=</operator> <literal type="number">5.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x00f000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>CLOSURE_COL_IDCOLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>idx</name><operator>&lt;&lt;</operator><literal type="number">12</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>idx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x0f0000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>CLOSURE_COL_PARENTCOLUMN</name>
     <operator>&amp;&amp;</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>iPlan</name> <operator>|=</operator> <name>idx</name><operator>&lt;&lt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>idx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pVtab</name><operator>-&gt;</operator><name>zTableName</name></name><operator>==</operator><literal type="number">0</literal>    <operator>&amp;&amp;</operator> <operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x000f00</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name><name>pVtab</name><operator>-&gt;</operator><name>zIdColumn</name></name><operator>==</operator><literal type="number">0</literal>     <operator>&amp;&amp;</operator> <operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x00f000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name><name>pVtab</name><operator>-&gt;</operator><name>zParentColumn</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iPlan</name> <operator>&amp;</operator> <literal type="number">0x0f0000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* All of tablename, idcolumn, and parentcolumn must be specified
    ** in either the CREATE VIRTUAL TABLE or in the WHERE clause constraints
    ** or else the result is an empty set. */</comment>
    <expr_stmt><expr><name>iPlan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iPlan</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there is no usable "root=?" term, then set the index-type to 0.
    ** Also clear any argvIndex variables already set. This is necessary
    ** to prevent the core from throwing an "xBestIndex malfunction error"
    ** error (because the argvIndex values are not contiguously assigned
    ** starting from 1).  */</comment>
    <expr_stmt><expr><name>rCost</name> <operator>*=</operator> <literal type="number">1e30</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>iPlan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>iPlan</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><name>CLOSURE_COL_ID</name>
   <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <name>rCost</name></expr>;</expr_stmt>
   
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A virtual table module that implements the "transitive_closure".
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>closureModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* iVersion */</comment>
  <expr><name>closureConnect</name></expr>,         <comment type="block">/* xCreate */</comment>
  <expr><name>closureConnect</name></expr>,         <comment type="block">/* xConnect */</comment>
  <expr><name>closureBestIndex</name></expr>,       <comment type="block">/* xBestIndex */</comment>
  <expr><name>closureDisconnect</name></expr>,      <comment type="block">/* xDisconnect */</comment>
  <expr><name>closureDisconnect</name></expr>,      <comment type="block">/* xDestroy */</comment>
  <expr><name>closureOpen</name></expr>,            <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>closureClose</name></expr>,           <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>closureFilter</name></expr>,          <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>closureNext</name></expr>,            <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>closureEof</name></expr>,             <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>closureColumn</name></expr>,          <comment type="block">/* xColumn - read data */</comment>
  <expr><name>closureRowid</name></expr>,           <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                      <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                       <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Register the closure virtual table
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_closure_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"transitive_closure"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>closureModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
