<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlcipher/ext/misc/fossildelta.c"><comment type="block">/*
** 2019-02-19
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements the delta functions used by the RBU
** extension. Three scalar functions and one table-valued function are
** implemented here:
**
**   delta_apply(X,D)     -- apply delta D to file X and return the result
**   delta_create(X,Y)    -- compute and return a delta that carries X into Y
**   delta_output_size(D) -- blob size in bytes output from applying delta D
**   delta_parse(D)       -- returns rows describing delta D
**
** The delta format is the Fossil delta format, described in a comment
** on the delete_create() function implementation below, and also at
**
**    https://www.fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki
**
** This delta format is used by the RBU extension, which is the main
** reason that these routines are included in the extension library.
** RBU does not use this extension directly.  Rather, this extension is
** provided as a convenience to developers who want to analyze RBU files 
** that contain deltas.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<comment type="block">/*
** The "u32" type must be an unsigned 32-bit integer.  Adjust this
*/</comment>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>

<comment type="block">/*
** Must be a 16-bit value
*/</comment>
<typedef>typedef <type><name>short</name> <name>int</name></type> <name>s16</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>u16</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_AMALGAMATION */</comment>


<comment type="block">/*
** The width of a hash window in bytes.  The algorithm only works if this
** is a power of 2.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NHASH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
** The current state of the rolling hash.
**
** z[] holds the values that have been hashed.  z[] is a circular buffer.
** z[i] is the first entry and z[(i+NHASH-1)%NHASH] is the last entry of
** the window.
**
** Hash.a is the sum of all elements of hash.z[].  Hash.b is a weighted
** sum.  Hash.b is z[i]*NHASH + z[i+1]*(NHASH-1) + ... + z[i+NHASH-1]*1.
** (Each index for z[] should be module NHASH, of course.  The %NHASH operator
** is omitted in the prior expression for brevity.)
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>hash</name></name></type> <name>hash</name>;</typedef>
<struct>struct <name>hash</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>         <comment type="block">/* Hash values */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>i</name></decl>;</decl_stmt>            <comment type="block">/* Start of the hash window */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><name>NHASH</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The values that have been hashed */</comment>
}</block>;</struct>

<comment type="block">/*
** Initialize the rolling hash using the first NHASH characters of z[]
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_init</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>NHASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>a</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Advance the rolling hash by a single character "c"
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_next</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>old</name> <init>= <expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>(</operator><name>NHASH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>-</operator> <name>old</name> <operator>+</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>-</operator> <name>NHASH</name><operator>*</operator><name>old</name> <operator>+</operator> <name><name>pHash</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit hash value
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>hash_32bit</name><parameter_list>(<parameter><decl><type><name>hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>a</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>pHash</name><operator>-&gt;</operator><name>b</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a hash on NHASH bytes.
**
** This routine is intended to be equivalent to:
**    hash h;
**    hash_init(&amp;h, zInput);
**    return hash_32bit(&amp;h);
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>hash_once</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u16</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <name>a</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>a</name> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name>b</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write an base-64 integer into the given buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>putInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zDigits</name><index>[]</index></name> <init>=
    <expr><literal type="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/*  123456789 123456789 123456789 123456789 123456789 123456789 123 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>v</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>v</name><operator>&gt;&gt;=</operator><literal type="number">6</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zDigits</name><index>[<expr><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>pz</name><operator>)</operator><operator>++</operator> <operator>=</operator> <name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Read bytes from *pz and convert them into a positive integer.  When
** finished, leave *pz pointing to the first character past the end of
** the integer.  The *pLen parameter holds the length of the string
** in *pz and is decremented once for each character in the integer.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>deltaGetInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pz</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pLen</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>signed</name> <name>char</name></type> <name><name>zValue</name><index>[]</index></name> <init>= <expr><block>{
    <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,   <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
    <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,   <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
    <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,   <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
     <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,    <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
    <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">16</literal></expr>,   <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">24</literal></expr>,
    <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">32</literal></expr>,   <expr><literal type="number">33</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">36</literal></expr>,
    <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>,   <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>, <expr><literal type="number">48</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>,
    <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">58</literal></expr>, <expr><literal type="number">59</literal></expr>,   <expr><literal type="number">60</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pz</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStart</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>zValue</name><index>[<expr><literal type="number">0x7f</literal><operator>&amp;</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>z</name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pLen</name> <operator>-=</operator> <name>z</name> <operator>-</operator> <name>zStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pz</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number digits in the base-64 representation of a positive integer
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>digit_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>x</name><operator>=</operator><literal type="number">64</literal></expr>;</init> <condition><expr><name>v</name><operator>&gt;=</operator><name>x</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">6</literal></expr></incr>)</control><block>{<block_content/>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>(__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Compute a 32-bit big-endian checksum on the N-byte buffer.  If the
** buffer is not a multiple of 4 bytes length, compute the sum that would
** have occurred if the buffer was padded with zeros to the next multiple
** of four bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>checksum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>byteOrderTest</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>N</name><operator>&amp;</operator><operator>~</operator><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>z</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>%</operator><literal type="number">4</literal><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Four-byte alignment */</comment>
  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>byteOrderTest</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This is a big-endian machine */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* A little-endian machine */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GCC_VERSION</name><operator>&gt;=</operator><literal type="number">4003000</literal></expr></cpp:if>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>__builtin_bswap32</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1300</literal></expr></cpp:elif>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>_byteswap_ulong</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>sum0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>sum1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>sum2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>N</name> <operator>&gt;=</operator> <literal type="number">16</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>sum0</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum1</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum2</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum</name>  <operator>+=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>+</operator> <name><name>z</name><index>[<expr><literal type="number">15</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>N</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>(<expr><name>N</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>sum0</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum1</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum2</name> <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sum</name>  <operator>+=</operator> <name><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>N</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name>sum2</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sum1</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sum0</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <switch>switch<condition>(<expr><name>N</name><operator>&amp;</operator><literal type="number">3</literal></expr>)</condition><block>{<block_content>
    <case>case <expr><literal type="number">3</literal></expr>:</case>   <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <case>case <expr><literal type="number">2</literal></expr>:</case>   <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
    <case>case <expr><literal type="number">1</literal></expr>:</case>   <expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
    <default>default:</default>  <empty_stmt>;</empty_stmt>
  </block_content>}</block></switch>
  <return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new delta.
**
** The delta is written into a preallocated buffer, zDelta, which
** should be at least 60 bytes longer than the target file, zOut.
** The delta string will be NUL-terminated, but it might also contain
** embedded NUL characters if either the zSrc or zOut files are
** binary.  This function returns the length of the delta string
** in bytes, excluding the final NUL terminator character.
**
** Output Format:
**
** The delta begins with a base64 number followed by a newline.  This
** number is the number of bytes in the TARGET file.  Thus, given a
** delta file z, a program can compute the size of the output file
** simply by reading the first line and decoding the base-64 number
** found there.  The delta_output_size() routine does exactly this.
**
** After the initial size number, the delta consists of a series of
** literal text segments and commands to copy from the SOURCE file.
** A copy command looks like this:
**
**     NNN@MMM,
**
** where NNN is the number of bytes to be copied and MMM is the offset
** into the source file of the first byte (both base-64).   If NNN is 0
** it means copy the rest of the input file.  Literal text is like this:
**
**     NNN:TTTTT
**
** where NNN is the number of bytes of text (base-64) and TTTTT is the text.
**
** The last term is of the form
**
**     NNN;
**
** In this case, NNN is a 32-bit bigendian checksum of the output file
** that can be used to verify that the delta applied correctly.  All
** numbers are in base-64.
**
** Pure text files generate a pure text delta.  Binary files generate a
** delta that may contain some binary data.
**
** Algorithm:
**
** The encoder first builds a hash table to help it find matching
** patterns in the source file.  16-byte chunks of the source file
** sampled at evenly spaced intervals are used to populate the hash
** table.
**
** Next we begin scanning the target file using a sliding 16-byte
** window.  The hash of the 16-byte window in the target is used to
** search for a matching section in the source file.  When a match
** is found, a copy command is added to the delta.  An effort is
** made to extend the matching section to regions that come before
** and after the 16-byte hash window.  A copy command is only issued
** if the result would use less space that just quoting the text
** literally. Literal text is added to the delta for sections that
** do not match or which can not be encoded efficiently using copy
** commands.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_create</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>,      <comment type="block">/* The source or pattern file */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>lenSrc</name></decl></parameter>,   <comment type="block">/* Length of the source file */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>,      <comment type="block">/* The target file */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>lenOut</name></decl></parameter>,   <comment type="block">/* Length of the target file */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zDelta</name></decl></parameter>           <comment type="block">/* Write the delta into this buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrigDelta</name> <init>= <expr><name>zDelta</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>hash</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHash</name></decl>;</decl_stmt>                 <comment type="block">/* Number of hash table entries */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>landmark</name></decl>;</decl_stmt>             <comment type="block">/* Primary hash table */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>collide</name></decl>;</decl_stmt>              <comment type="block">/* Collision chain */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lastRead</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Last byte of zSrc read by a COPY command */</comment>

  <comment type="block">/* Add the target file size to the beginning of the delta
  */</comment>
  <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

  <comment type="block">/* If the source file is very small, it means that we have no
  ** chance of ever doing a copy command.  Just output a single
  ** literal segment for the entire target and exit.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>lenSrc</name><operator>&lt;=</operator><name>NHASH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><call><name>checksum</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
    <return>return <expr><name>zDelta</name> <operator>-</operator> <name>zOrigDelta</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compute the hash table used to locate matching sections in the
  ** source file.
  */</comment>
  <expr_stmt><expr><name>nHash</name> <operator>=</operator> <name>lenSrc</name><operator>/</operator><name>NHASH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>collide</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nHash</name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>collide</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nHash</name><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>landmark</name> <operator>=</operator> <operator>&amp;</operator><name><name>collide</name><index>[<expr><name>nHash</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>lenSrc</name><operator>-</operator><name>NHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>NHASH</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>hv</name> <init>= <expr><call><name>hash_once</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nHash</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>collide</name><index>[<expr><name>i</name><operator>/</operator><name>NHASH</name></expr>]</index></name> <operator>=</operator> <name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name> <operator>=</operator> <name>i</name><operator>/</operator><name>NHASH</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Begin scanning the target file and generating copy commands and
  ** literal sections of the delta.
  */</comment>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* We have already generated everything before zOut[base] */</comment>
  <while>while<condition>( <expr><name>base</name><operator>+</operator><name>NHASH</name><operator>&lt;</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>, <decl><type ref="prev"/><name>iBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bestCnt</name></decl>, <decl><type ref="prev"/><name>bestOfst</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bestLitsz</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>     <comment type="block">/* Trying to match a landmark against zOut[base+i] */</comment>
    <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>hv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><literal type="number">250</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>hash_32bit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>nHash</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <name><name>landmark</name><index>[<expr><name>hv</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>iBlock</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/*
        ** The hash window has identified a potential match against
        ** landmark block iBlock.  But we need to investigate further.
        **
        ** Look for a region in zOut that matches zSrc. Anchor the search
        ** at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to
        ** zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].
        **
        ** Set cnt equal to the length of the match and set ofst so that
        ** zSrc[ofst] is the first element of the match.  litsz is the number
        ** of characters between zOut[base] and the beginning of the match.
        ** sz will be the overhead (in bytes) needed to encode the copy
        ** command.  Only generate copy command if the overhead of the
        ** copy command is less than the amount of literal text to be copied.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>ofst</name></decl>, <decl><type ref="prev"/><name>litsz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>limitX</name></decl>;</decl_stmt>

        <comment type="block">/* Beginning at iSrc, match forwards as far as we can.  j counts
        ** the number of characters that match */</comment>
        <expr_stmt><expr><name>iSrc</name> <operator>=</operator> <name>iBlock</name><operator>*</operator><name>NHASH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>y</name> <operator>=</operator> <name>base</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>limitX</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name>lenSrc</name><operator>-</operator><name>iSrc</name> <operator>&lt;=</operator> <name>lenOut</name><operator>-</operator><name>y</name> <operator>)</operator></expr> ?</condition><then> <expr><name>lenSrc</name></expr> </then><else>: <expr><name>iSrc</name> <operator>+</operator> <name>lenOut</name> <operator>-</operator> <name>y</name></expr></else></ternary></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>x</name><operator>=</operator><name>iSrc</name></expr>;</init> <condition><expr><name>x</name><operator>&lt;</operator><name>limitX</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr><operator>,</operator> <expr><name>y</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zSrc</name><index>[<expr><name>x</name></expr>]</index></name><operator>!=</operator><name><name>zOut</name><index>[<expr><name>y</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name> <operator>-</operator> <name>iSrc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* Beginning at iSrc-1, match backwards as far as we can.  k counts
        ** the number of characters that match */</comment>
        <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><name>iSrc</name> <operator>&amp;&amp;</operator> <name>k</name><operator>&lt;=</operator><name>i</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>zSrc</name><index>[<expr><name>iSrc</name><operator>-</operator><name>k</name></expr>]</index></name><operator>!=</operator><name><name>zOut</name><index>[<expr><name>base</name><operator>+</operator><name>i</name><operator>-</operator><name>k</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>

        <comment type="block">/* Compute the offset and size of the matching region */</comment>
        <expr_stmt><expr><name>ofst</name> <operator>=</operator> <name>iSrc</name><operator>-</operator><name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cnt</name> <operator>=</operator> <name>j</name><operator>+</operator><name>k</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>litsz</name> <operator>=</operator> <name>i</name><operator>-</operator><name>k</name></expr>;</expr_stmt>  <comment type="block">/* Number of bytes of literal text before the copy */</comment>
        <comment type="block">/* sz will hold the number of bytes needed to encode the "insert"
        ** command and the copy command, not counting the "insert" text */</comment>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>digit_count</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><name>k</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>digit_count</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>digit_count</name><argument_list>(<argument><expr><name>ofst</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;=</operator><name>sz</name> <operator>&amp;&amp;</operator> <name>cnt</name><operator>&gt;</operator><name>bestCnt</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Remember this match only if it is the best so far and it
          ** does not increase the file size */</comment>
          <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestOfst</name> <operator>=</operator> <name>iSrc</name><operator>-</operator><name>k</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestLitsz</name> <operator>=</operator> <name>litsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check the next matching block */</comment>
        <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <name><name>collide</name><index>[<expr><name>iBlock</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></while>

      <comment type="block">/* We have a copy command that does not cause the delta to be larger
      ** than a literal insert.  So add the copy command to the delta.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>bestCnt</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bestLitsz</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* Add an insert command before the copy */</comment>
          <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestLitsz</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>bestLitsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>bestLitsz</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base</name> <operator>+=</operator> <name>bestLitsz</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>base</name> <operator>+=</operator> <name>bestCnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestCnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>bestOfst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bestOfst</name> <operator>+</operator> <name>bestCnt</name> <operator>-</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>lastRead</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>lastRead</name> <operator>=</operator> <name>bestOfst</name> <operator>+</operator> <name>bestCnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bestCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* If we reach this point, it means no match is found so far */</comment>
      <if_stmt><if>if<condition>( <expr><name>base</name><operator>+</operator><name>i</name><operator>+</operator><name>NHASH</name><operator>&gt;=</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* We have reached the end of the file and have not found any
        ** matches.  Do an "insert" for everything that does not match */</comment>
        <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name><operator>-</operator><name>base</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>base</name> <operator>=</operator> <name>lenOut</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Advance the hash by one character.  Keep looking for a match */</comment>
      <expr_stmt><expr><call><name>hash_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><name><name>zOut</name><index>[<expr><name>base</name><operator>+</operator><name>i</name><operator>+</operator><name>NHASH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>
  <comment type="block">/* Output a final "insert" record to get all the text at the end of
  ** the file that does not match anything in the source file.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>base</name><operator>&lt;</operator><name>lenOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>, <argument><expr><name>lenOut</name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>lenOut</name><operator>-</operator><name>base</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Output the final checksum record. */</comment>
  <expr_stmt><expr><call><name>putInt</name><argument_list>(<argument><expr><call><name>checksum</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>lenOut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>zDelta</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>collide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zDelta</name> <operator>-</operator> <name>zOrigDelta</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the size (in bytes) of the output from applying
** a delta.
**
** This routine is provided so that an procedure that is able
** to call delta_apply() can learn how much space is required
** for the output and hence allocate nor more space that is really
** needed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_output_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDelta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenDelta</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zDelta</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* ERROR: size integer not terminated by "\n" */</comment>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Apply a delta.
**
** The output buffer should be big enough to hold the whole output
** file and a NUL terminator at the end.  The delta_output_size()
** routine will determine this size for you.
**
** The delta string should be null-terminated.  But the delta string
** may contain embedded NUL characters (if the input and output are
** binary files) so we also have to pass in the length of the delta in
** the lenDelta parameter.
**
** This function returns the size of the output file in bytes (excluding
** the final NUL terminator character).  Except, if the delta string is
** malformed or intended for use with a source file other than zSrc,
** then this routine returns -1.
**
** Refer to the delta_create() documentation above for a description
** of the delta file format.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_apply</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrc</name></decl></parameter>,      <comment type="block">/* The source or pattern file */</comment>
  <parameter><decl><type><name>int</name></type> <name>lenSrc</name></decl></parameter>,            <comment type="block">/* Length of the source file */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDelta</name></decl></parameter>,    <comment type="block">/* Delta to apply to the pattern */</comment>
  <parameter><decl><type><name>int</name></type> <name>lenDelta</name></decl></parameter>,          <comment type="block">/* Length of the delta */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>             <comment type="block">/* Write the output into this preallocated buffer */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>limit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FOSSIL_ENABLE_DELTA_CKSUM_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrigOut</name> <init>= <expr><name>zOut</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zDelta</name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* ERROR: size integer not terminated by "\n" */</comment>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zDelta</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lenDelta</name><operator>--</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>zDelta</name> <operator>&amp;&amp;</operator> <name>lenDelta</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>ofst</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>zDelta</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'@'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zDelta</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lenDelta</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ofst</name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zDelta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lenDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lenDelta</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zDelta</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">','</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR: copy command not terminated by ',' */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>zDelta</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lenDelta</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>total</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>total</name><operator>&gt;</operator><name>limit</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR: copy exceeds output file size */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>ofst</name><operator>+</operator><name>cnt</name> <operator>&gt;</operator> <name>lenSrc</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR: copy extends past end of input */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zSrc</name><index>[<expr><name>ofst</name></expr>]</index></name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zOut</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">':'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zDelta</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lenDelta</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>total</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>total</name><operator>&gt;</operator><name>limit</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR:  insert command gives an output larger than predicted */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>&gt;</operator><name>lenDelta</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR: insert count exceeds size of delta */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>zDelta</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zOut</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDelta</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lenDelta</name> <operator>-=</operator> <name>cnt</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">';'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zDelta</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lenDelta</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FOSSIL_ENABLE_DELTA_CKSUM_TEST</name></cpp:ifdef>
        <if_stmt><if>if<condition>( <expr><name>cnt</name><operator>!=</operator><call><name>checksum</name><argument_list>(<argument><expr><name>zOrigOut</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR:  bad checksum */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><name>total</name><operator>!=</operator><name>limit</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* ERROR: generated size does not match predicted size */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>total</name></expr>;</return>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <comment type="block">/* ERROR: unknown delta operator */</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <comment type="block">/* ERROR: unterminated delta */</comment>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL functions:  delta_create(X,Y)
**
** Return a delta for carrying X into Y.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>deltaCreateFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aOrig</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>nOrig</name></decl>;</decl_stmt>  <comment type="block">/* old blob */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name></decl>;</decl_stmt>   <comment type="block">/* new blob */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>        <decl_stmt><decl><type><name>int</name></type> <name>nOut</name></decl>;</decl_stmt>   <comment type="block">/* output delta */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nOrig</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOrig</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aNew</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nNew</name><operator>+</operator><literal type="number">70</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nOut</name> <operator>=</operator> <call><name>delta_create</name><argument_list>(<argument><expr><name>aOrig</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>, <argument><expr><name>aNew</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"cannot create fossil delta"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL functions:  delta_apply(X,D)
**
** Return the result of applying delta D to input X.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>deltaApplyFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aOrig</name></decl>;</decl_stmt>   <decl_stmt><decl><type><name>int</name></type> <name>nOrig</name></decl>;</decl_stmt>        <comment type="block">/* The X input */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDelta</name></decl>;</decl_stmt>  <decl_stmt><decl><type><name>int</name></type> <name>nDelta</name></decl>;</decl_stmt>       <comment type="block">/* The input delta (D) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>          <decl_stmt><decl><type><name>int</name></type> <name>nOut</name></decl>, <decl><type ref="prev"/><name>nOut2</name></decl>;</decl_stmt>  <comment type="block">/* The output */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nOrig</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOrig</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nDelta</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDelta</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out the size of the output */</comment>
  <expr_stmt><expr><name>nOut</name> <operator>=</operator> <call><name>delta_output_size</name><argument_list>(<argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>nDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"corrupt fossil delta"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>aOut</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nOut</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nOut2</name> <operator>=</operator> <call><name>delta_apply</name><argument_list>(<argument><expr><name>aOrig</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>, <argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>nDelta</name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nOut2</name><operator>!=</operator><name>nOut</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"corrupt fossil delta"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>aOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** SQL functions:  delta_output_size(D)
**
** Return the size of the output that results from applying delta D.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>deltaOutputSizeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aDelta</name></decl>;</decl_stmt>  <decl_stmt><decl><type><name>int</name></type> <name>nDelta</name></decl>;</decl_stmt>       <comment type="block">/* The input delta (D) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOut</name></decl>;</decl_stmt>                              <comment type="block">/* Size of output */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nDelta</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDelta</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out the size of the output */</comment>
  <expr_stmt><expr><name>nOut</name> <operator>=</operator> <call><name>delta_output_size</name><argument_list>(<argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>nDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"corrupt fossil delta"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
** Table-valued SQL function:   delta_parse(DELTA)
**
** Schema:
**
**     CREATE TABLE delta_parse(
**       op TEXT,
**       a1 INT,
**       a2 ANY,
**       delta HIDDEN BLOB
**     );
**
** Given an input DELTA, this function parses the delta and returns
** rows for each entry in the delta.  The op column has one of the
** values SIZE, COPY, INSERT, CHECKSUM, ERROR.
**
** Assuming no errors, the first row has op='SIZE'.  a1 is the size of
** the output in bytes and a2 is NULL.
**
** After the initial SIZE row, there are zero or more 'COPY' and/or 'INSERT'
** rows.  A COPY row means content is copied from the source into the
** output.  Column a1 is the number of bytes to copy and a2 is the offset
** into source from which to begin copying.  An INSERT row means to
** insert text into the output stream.  Column a1 is the number of bytes
** to insert and column is a BLOB that contains the text to be inserted.
**
** The last row of a well-formed delta will have an op value of 'CHECKSUM'.
** The a1 column will be the value of the checksum and a2 will be NULL.
**
** If the input delta is not well-formed, then a row with an op value
** of 'ERROR' is returned.  The a1 value of the ERROR row is the offset
** into the delta where the error was encountered and a2 is NULL.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>deltaparsevtab_vtab</name></name></type> <name>deltaparsevtab_vtab</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>deltaparsevtab_cursor</name></name></type> <name>deltaparsevtab_cursor</name>;</typedef>
<struct>struct <name>deltaparsevtab_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <comment type="block">/* No additional information needed */</comment>
}</block>;</struct>
<struct>struct <name>deltaparsevtab_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aDelta</name></decl>;</decl_stmt>              <comment type="block">/* The delta being parsed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDelta</name></decl>;</decl_stmt>                <comment type="block">/* Number of bytes in the delta */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCursor</name></decl>;</decl_stmt>               <comment type="block">/* Current cursor location */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eOp</name></decl>;</decl_stmt>                   <comment type="block">/* Name of current operator */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>       <comment type="block">/* Arguments to current operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iNext</name></decl>;</decl_stmt>                 <comment type="block">/* Next cursor value */</comment>
}</block>;</struct>

<comment type="block">/* Operator names:
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azOp</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"SIZE"</literal></expr>, <expr><literal type="string">"COPY"</literal></expr>, <expr><literal type="string">"INSERT"</literal></expr>, <expr><literal type="string">"CHECKSUM"</literal></expr>, <expr><literal type="string">"ERROR"</literal></expr>, <expr><literal type="string">"EOF"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_SIZE</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_COPY</name></cpp:macro>         <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_INSERT</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_CHECKSUM</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_ERROR</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSE_OP_EOF</name></cpp:macro>          <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
** The deltaparsevtabConnect() method is invoked to create a new
** deltaparse virtual table.
**
** Think of this routine as the constructor for deltaparsevtab_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the deltaparsevtab_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against the virtual table will look like.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
           <argument><expr><literal type="string">"CREATE TABLE x(op,a1,a2,delta HIDDEN)"</literal></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* For convenience, define symbolic names for the index to each column. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSEVTAB_OP</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSEVTAB_A1</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSEVTAB_A2</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELTAPARSEVTAB_DELTA</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for deltaparsevtab_vtab objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_vtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new deltaparsevtab_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a deltaparsevtab_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a deltaparsevtab_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iCursor</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name> <operator>+</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'@'</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a2</name></name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_COPY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">':'</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a2</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_INSERT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>z</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name></expr>]</index></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">';'</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_CHECKSUM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name><operator>==</operator><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_EOF</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the deltaparsevtab_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>DELTAPARSEVTAB_OP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>azOp</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>DELTAPARSEVTAB_A1</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>DELTAPARSEVTAB_A2</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>DELTAPARSE_OP_COPY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>DELTAPARSE_OP_INSERT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>+</operator><name><name>pCur</name><operator>-&gt;</operator><name>a2</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name></expr></argument>,
                            <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>DELTAPARSEVTAB_DELTA</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row.  In this implementation, the
** rowid is the same as the output value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iCursor</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>DELTAPARSE_OP_EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is called to "rewind" the deltaparsevtab_cursor object back
** to the first row of output.  This method is always called at least
** once prior to any call to deltaparsevtabColumn() or deltaparsevtabRowid() or 
** deltaparsevtabEof().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>deltaparsevtab_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>deltaparsevtab_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_ERROR</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name> <operator>=</operator> <call><name>deltaGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>DELTAPARSE_OP_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>a1</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>a2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nDelta</name></name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>a</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iNext</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>a</name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>aDelta</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deltaparsevtabBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name> <operator>!=</operator> <name>DELTAPARSEVTAB_DELTA</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This following structure defines all the methods for the 
** virtual table.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>deltaparsevtabModule</name> <init>= <expr><block>{
  <comment type="block">/* iVersion    */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xCreate     */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xConnect    */</comment> <expr><name>deltaparsevtabConnect</name></expr>,
  <comment type="block">/* xBestIndex  */</comment> <expr><name>deltaparsevtabBestIndex</name></expr>,
  <comment type="block">/* xDisconnect */</comment> <expr><name>deltaparsevtabDisconnect</name></expr>,
  <comment type="block">/* xDestroy    */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xOpen       */</comment> <expr><name>deltaparsevtabOpen</name></expr>,
  <comment type="block">/* xClose      */</comment> <expr><name>deltaparsevtabClose</name></expr>,
  <comment type="block">/* xFilter     */</comment> <expr><name>deltaparsevtabFilter</name></expr>,
  <comment type="block">/* xNext       */</comment> <expr><name>deltaparsevtabNext</name></expr>,
  <comment type="block">/* xEof        */</comment> <expr><name>deltaparsevtabEof</name></expr>,
  <comment type="block">/* xColumn     */</comment> <expr><name>deltaparsevtabColumn</name></expr>,
  <comment type="block">/* xRowid      */</comment> <expr><name>deltaparsevtabRowid</name></expr>,
  <comment type="block">/* xUpdate     */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xBegin      */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xSync       */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xCommit     */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xRollback   */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xFindMethod */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xRename     */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xSavepoint  */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xRelease    */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xRollbackTo */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xShadowName */</comment> <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fossildelta_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>enc</name> <init>= <expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"delta_create"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>deltaCreateFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"delta_apply"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>deltaApplyFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"delta_output_size"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>deltaOutputSizeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"delta_parse"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>deltaparsevtabModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
